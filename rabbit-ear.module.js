const e=typeof window!=="undefined"&&typeof window.document!=="undefined";const t=typeof process!=="undefined"&&process.versions!=null&&process.versions.node!=null;const n={planarize:"graph could not planarize",manifold:"valid manifold required",graphCycle:"cycle not allowed",planarBoundary:"planar boundary detection error, bad graph",circularEdge:"circular edges not allowed",replaceModifyParam:"replace() index < value. indices parameter modified",replaceUndefined:"replace() generated undefined",flatFoldAngles:"foldAngles cannot be determined from flat-folded faces without an assignment",noWebGL:"WebGl not Supported",convexFace:"only convex faces are supported",window:"window not set; if using node/deno include package @xmldom/xmldom and set ear.window = xmldom",nonConvexTriangulation:"non-convex triangulation requires vertices_coords",backendStylesheet:"svgToFold found <style> in <svg>. rendering will be incomplete unless run in a major browser.",noLayerSolution:"LayerSolver bad input. no solution possible"};const s={window:undefined};const r=e=>(new e.DOMParser).parseFromString("<!DOCTYPE html><title>.</title>","text/html");const o=e=>{if(!e.document){e.document=r(e)}s.window=e;return s.window};if(e){s.window=window}const c=()=>{if(s.window===undefined){throw new Error(n.window)}return s.window};const a=1e-6;const i=180/Math.PI;const f=Math.PI/180;const l=Math.PI*2;const d=Object.freeze({__proto__:null,D2R:f,EPSILON:a,R2D:i,TWO_PI:l});const u=(e,t)=>e+(t||0);const m=e=>Math.sqrt(e.map((e=>e*e)).reduce(u,0));const g=e=>Math.sqrt(e[0]*e[0]+e[1]*e[1]);const p=e=>Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);const _=e=>e.map((e=>e*e)).reduce(u,0);const h=e=>{const t=m(e);return t===0?e:e.map((e=>e/t))};const v=e=>{const t=g(e);return t===0?e:[e[0]/t,e[1]/t]};const b=e=>{const t=p(e);return t===0?e:[e[0]/t,e[1]/t,e[2]/t]};const y=(e,t)=>e.map((e=>e*t));const E=(e,t)=>[e[0]*t,e[1]*t];const A=(e,t)=>[e[0]*t,e[1]*t,e[2]*t];const x=(e,t)=>e.map(((e,n)=>e+(t[n]||0)));const M=(e,t)=>[e[0]+t[0],e[1]+t[1]];const k=(e,t)=>[e[0]+t[0],e[1]+t[1],e[2]+t[2]];const w=(e,t)=>e.map(((e,n)=>e-(t[n]||0)));const O=(e,t)=>[e[0]-t[0],e[1]-t[1]];const j=(e,t)=>[e[0]-t[0],e[1]-t[1],e[2]-t[2]];const F=(e,t)=>e.map(((n,s)=>e[s]*t[s])).reduce(u,0);const C=(e,t)=>e[0]*t[0]+e[1]*t[1];const S=(e,t)=>e[0]*t[0]+e[1]*t[1]+e[2]*t[2];const P=(e,t)=>e.map(((e,n)=>(e+t[n])/2));const N=(e,t)=>E(M(e,t),.5);const V=(e,t)=>A(k(e,t),.5);const z=function(){if(arguments.length===0){return[]}const e=arguments[0].length>0?arguments[0].length:0;const t=Array(e).fill(0);Array.from(arguments).forEach((e=>t.forEach(((n,s)=>{t[s]+=e[s]||0}))));return t.map((e=>e/arguments.length))};const $=(e,t,n)=>{const s=1-n;return e.map(((e,r)=>e*s+(t[r]||0)*n))};const T=(e,t)=>e[0]*t[1]-e[1]*t[0];const L=(e,t)=>[e[1]*t[2]-e[2]*t[1],e[2]*t[0]-e[0]*t[2],e[0]*t[1]-e[1]*t[0]];const B=(e,t)=>Math.sqrt(e.map(((n,s)=>(e[s]-t[s])**2)).reduce(u,0));const I=(e,t)=>{const n=e[0]-t[0];const s=e[1]-t[1];return Math.sqrt(n*n+s*s)};const R=(e,t)=>{const n=e[0]-t[0];const s=e[1]-t[1];const r=e[2]-t[2];return Math.sqrt(n*n+s*s+r*r)};const U=e=>e.map((e=>-e));const q=e=>[-e[1],e[0]];const D=e=>[e[1],-e[0]];const W=(e,t=a)=>e.map((e=>Math.abs(e))).reduce(u,0)<t;const G=(e,t,n=a)=>1-Math.abs(F(e,t))<n;const H=(e,t,n=a)=>G(h(e),h(t),n);const J=(e,t,n=a)=>Math.abs(T(e,t))<n;const Q=(e,t)=>t.length===e?t:Array(e).fill(0).map(((e,n)=>t[n]?t[n]:e));const Z=(e,t)=>[e,t].map((n=>Q(Math.max(e.length,t.length),n)));const Y=Object.freeze({__proto__:null,add:x,add2:M,add3:k,average:z,cross2:T,cross3:L,degenerate:W,distance:B,distance2:I,distance3:R,dot:F,dot2:C,dot3:S,flip:U,lerp:$,magSquared:_,magnitude:m,magnitude2:g,magnitude3:p,midpoint:P,midpoint2:N,midpoint3:V,normalize:h,normalize2:v,normalize3:b,parallel:H,parallel2:J,parallelNormalized:G,resize:Q,resizeUp:Z,rotate270:D,rotate90:q,scale:y,scale2:E,scale3:A,subtract:w,subtract2:O,subtract3:j});const X=[1,0,0,1];const K=X.concat(0,0);const ee=(e,t)=>[e[0]*t[0]+e[2]*t[1]+e[4],e[1]*t[0]+e[3]*t[1]+e[5]];const te=(e,t,n)=>({vector:[e[0]*t[0]+e[2]*t[1],e[1]*t[0]+e[3]*t[1]],origin:[e[0]*n[0]+e[2]*n[1]+e[4],e[1]*n[0]+e[3]*n[1]+e[5]]});const ne=(e,t)=>[e[0]*t[0]+e[2]*t[1],e[1]*t[0]+e[3]*t[1],e[0]*t[2]+e[2]*t[3],e[1]*t[2]+e[3]*t[3],e[0]*t[4]+e[2]*t[5]+e[4],e[1]*t[4]+e[3]*t[5]+e[5]];const se=e=>e[0]*e[3]-e[1]*e[2];const re=e=>{const t=se(e);if(Math.abs(t)<1e-6||Number.isNaN(t)||!Number.isFinite(e[4])||!Number.isFinite(e[5])){return undefined}return[e[3]/t,-e[1]/t,-e[2]/t,e[0]/t,(e[2]*e[5]-e[3]*e[4])/t,(e[1]*e[4]-e[0]*e[5])/t]};const oe=(e=0,t=0)=>X.concat(e,t);const ce=(e=[1,1],t=[0,0])=>[e[0],0,0,e[1],e[0]*-t[0]+t[0],e[1]*-t[1]+t[1]];const ae=(e=1,t=[0,0])=>ce([e,e],t);const ie=(e,t=[0,0])=>{const n=Math.cos(e);const s=Math.sin(e);return[n,s,-s,n,t[0],t[1]]};const fe=(e,t=[0,0])=>{const n=Math.atan2(e[1],e[0]);const s=Math.cos(n);const r=Math.sin(n);const o=Math.cos(-n);const c=Math.sin(-n);const a=s*o+r*c;const i=s*-c+r*o;const f=r*o+-s*c;const l=r*-c+-s*o;const d=t[0]+a*-t[0]+-t[1]*f;const u=t[1]+i*-t[0]+-t[1]*l;return[a,i,f,l,d,u]};const le=Object.freeze({__proto__:null,determinant2:se,identity2x2:X,identity2x3:K,invertMatrix2:re,makeMatrix2Reflect:fe,makeMatrix2Rotate:ie,makeMatrix2Scale:ce,makeMatrix2Translate:oe,makeMatrix2UniformScale:ae,multiplyMatrices2:ne,multiplyMatrix2Line2:te,multiplyMatrix2Vector2:ee});const de=Object.freeze([1,0,0,0,1,0,0,0,1]);const ue=Object.freeze(de.concat(0,0,0));const me=e=>ue.map(((t,n)=>Math.abs(t-e[n])<a)).reduce(((e,t)=>e&&t),true);const ge=(e,t)=>[e[0]*t[0]+e[3]*t[1]+e[6]*t[2]+e[9],e[1]*t[0]+e[4]*t[1]+e[7]*t[2]+e[10],e[2]*t[0]+e[5]*t[1]+e[8]*t[2]+e[11]];const pe=(e,t,n)=>({vector:[e[0]*t[0]+e[3]*t[1]+e[6]*t[2],e[1]*t[0]+e[4]*t[1]+e[7]*t[2],e[2]*t[0]+e[5]*t[1]+e[8]*t[2]],origin:[e[0]*n[0]+e[3]*n[1]+e[6]*n[2]+e[9],e[1]*n[0]+e[4]*n[1]+e[7]*n[2]+e[10],e[2]*n[0]+e[5]*n[1]+e[8]*n[2]+e[11]]});const _e=(e,t)=>[e[0]*t[0]+e[3]*t[1]+e[6]*t[2],e[1]*t[0]+e[4]*t[1]+e[7]*t[2],e[2]*t[0]+e[5]*t[1]+e[8]*t[2],e[0]*t[3]+e[3]*t[4]+e[6]*t[5],e[1]*t[3]+e[4]*t[4]+e[7]*t[5],e[2]*t[3]+e[5]*t[4]+e[8]*t[5],e[0]*t[6]+e[3]*t[7]+e[6]*t[8],e[1]*t[6]+e[4]*t[7]+e[7]*t[8],e[2]*t[6]+e[5]*t[7]+e[8]*t[8],e[0]*t[9]+e[3]*t[10]+e[6]*t[11]+e[9],e[1]*t[9]+e[4]*t[10]+e[7]*t[11]+e[10],e[2]*t[9]+e[5]*t[10]+e[8]*t[11]+e[11]];const he=e=>e[0]*e[4]*e[8]-e[0]*e[7]*e[5]-e[3]*e[1]*e[8]+e[3]*e[7]*e[2]+e[6]*e[1]*e[5]-e[6]*e[4]*e[2];const ve=e=>{const t=he(e);if(Math.abs(t)<1e-6||Number.isNaN(t)||!Number.isFinite(e[9])||!Number.isFinite(e[10])||!Number.isFinite(e[11])){return undefined}const n=[e[4]*e[8]-e[7]*e[5],-e[1]*e[8]+e[7]*e[2],e[1]*e[5]-e[4]*e[2],-e[3]*e[8]+e[6]*e[5],e[0]*e[8]-e[6]*e[2],-e[0]*e[5]+e[3]*e[2],e[3]*e[7]-e[6]*e[4],-e[0]*e[7]+e[6]*e[1],e[0]*e[4]-e[3]*e[1],-e[3]*e[7]*e[11]+e[3]*e[8]*e[10]+e[6]*e[4]*e[11]-e[6]*e[5]*e[10]-e[9]*e[4]*e[8]+e[9]*e[5]*e[7],e[0]*e[7]*e[11]-e[0]*e[8]*e[10]-e[6]*e[1]*e[11]+e[6]*e[2]*e[10]+e[9]*e[1]*e[8]-e[9]*e[2]*e[7],-e[0]*e[4]*e[11]+e[0]*e[5]*e[10]+e[3]*e[1]*e[11]-e[3]*e[2]*e[10]-e[9]*e[1]*e[5]+e[9]*e[2]*e[4]];const s=1/t;return n.map((e=>e*s))};const be=(e=0,t=0,n=0)=>de.concat(e,t,n);const ye=(e,t,n,s,r)=>{const o=de.concat([0,1,2].map((e=>t[e]||0)));const c=Math.cos(e);const a=Math.sin(e);o[n*3+n]=c;o[n*3+s]=(r?+1:-1)*a;o[s*3+n]=(r?-1:+1)*a;o[s*3+s]=c;return o};const Ee=(e,t=[0,0,0])=>ye(e,t,1,2,true);const Ae=(e,t=[0,0,0])=>ye(e,t,0,2,false);const xe=(e,t=[0,0,0])=>ye(e,t,0,1,true);const Me=(e,t=[0,0,1],n=[0,0,0])=>{const s=[0,1,2].map((e=>n[e]||0));const[r,o,c]=Q(3,h(t));const a=Math.cos(e);const i=Math.sin(e);const f=1-a;const l=de.concat(-s[0],-s[1],-s[2]);const d=de.concat(s[0],s[1],s[2]);return _e(d,_e([f*r*r+a,f*o*r+c*i,f*c*r-o*i,f*r*o-c*i,f*o*o+a,f*c*o+r*i,f*r*c+o*i,f*o*c-r*i,f*c*c+a,0,0,0],l))};const ke=(e=[1,1,1],t=[0,0,0])=>[e[0],0,0,0,e[1],0,0,0,e[2],e[0]*-t[0]+t[0],e[1]*-t[1]+t[1],e[2]*-t[2]+t[2]];const we=(e=1,t=[0,0,0])=>ke([e,e,e],t);const Oe=(e,t=[0,0])=>{const n=fe(e,t);return[n[0],n[1],0,n[2],n[3],0,0,0,1,n[4],n[5],0]};const je=Object.freeze({__proto__:null,determinant3:he,identity3x3:de,identity3x4:ue,invertMatrix3:ve,isIdentity3x4:me,makeMatrix3ReflectZ:Oe,makeMatrix3Rotate:Me,makeMatrix3RotateX:Ee,makeMatrix3RotateY:Ae,makeMatrix3RotateZ:xe,makeMatrix3Scale:ke,makeMatrix3Translate:be,makeMatrix3UniformScale:we,multiplyMatrices3:_e,multiplyMatrix3Line3:pe,multiplyMatrix3Vector3:ge});const Fe=e=>e!=null&&typeof e[Symbol.iterator]==="function";const Ce=function(){switch(arguments.length){case 0:return Array.from(arguments);case 1:return Fe(arguments[0])&&typeof arguments[0]!=="string"?Ce(...arguments[0]):[arguments[0]];default:return Array.from(arguments).map((e=>Fe(e)?[...Ce(e)]:e))}};const Se=function(){switch(arguments.length){case 0:return Array.from(arguments);case 1:return Fe(arguments[0])&&typeof arguments[0]!=="string"?Se(...arguments[0]):[arguments[0]];default:return Array.from(arguments).map((e=>Fe(e)?[...Se(e)]:e)).flat()}};const Pe=Object.freeze({__proto__:null,flattenArrays:Se,semiFlattenArrays:Ce});const Ne=function(){let e=Se(arguments);const t=e[0];if(typeof t==="object"&&t!==null&&!Number.isNaN(t.x)){e=["x","y","z"].map((e=>t[e])).filter((e=>e!==undefined))}return e.filter((e=>typeof e==="number"))};const Ve=function(){return Ce(arguments).map((e=>Ne(e)))};const ze=function(){const e=Ce(arguments);return e.length===4?[[0,1],[2,3]].map((t=>t.map((t=>e[t])))):e.map((e=>Ne(e)))};const $e=(e,t=[])=>({vector:e,origin:t});const Te=function(){const e=Ce(arguments);if(e.length===0||e[0]==null){return $e([],[])}if(e[0].constructor===Object&&e[0].vector!==undefined){return $e(e[0].vector,e[0].origin||[])}return typeof e[0]==="number"?$e(Ne(e)):$e(...e.map((e=>Ne(e))))};const Le=Object.freeze({__proto__:null,getArrayOfVectors:Ve,getLine:Te,getSegment:ze,getVector:Ne});const Be=e=>Array.from(Array(Math.floor(e))).map(((t,n)=>l*(n/e)));const Ie=(e,t)=>e.map((e=>[t*Math.cos(e),t*Math.sin(e)]));const Re=(e=3,t=1)=>Ie(Be(e),t);const Ue=(e=3,t=1)=>{const n=Math.PI/e;const s=Be(e).map((e=>e+n));return Ie(s,t)};const qe=(e=3,t=1)=>Re(e,t/Math.cos(Math.PI/e));const De=(e=3,t=1)=>Ue(e,t/Math.cos(Math.PI/e));const We=(e=3,t=1)=>Re(e,t/2/Math.sin(Math.PI/e));const Ge=(e=3,t=1)=>Ue(e,t/2/Math.sin(Math.PI/e));const He=(e,t=a)=>{const n=e.map(((e,t,n)=>[e,n[(t+1)%n.length]])).map((e=>w(e[1],e[0])));const s=n.map(((e,t,n)=>[e,n[(t+n.length-1)%n.length]])).map((e=>!H(e[1],e[0],t)));return e.filter(((e,t)=>s[t]))};const Je=(e,t,n)=>{const s=t[0]-e[0];const r=t[1]-e[1];const o=n[0]-e[0];const c=n[1]-e[1];const i=s*(e[0]+t[0])+r*(e[1]+t[1]);const f=o*(e[0]+n[0])+c*(e[1]+n[1]);const l=2*(s*(n[1]-t[1])-r*(n[0]-t[0]));if(Math.abs(l)<a){const s=Math.min(e[0],t[0],n[0]);const r=Math.min(e[1],t[1],n[1]);const o=(Math.max(e[0],t[0],n[0])-s)*.5;const c=(Math.max(e[1],t[1],n[1])-r)*.5;return{origin:[s+o,r+c],radius:Math.sqrt(o*o+c*c)}}const d=[(c*i-r*f)/l,(s*f-o*i)/l];const u=d[0]-e[0];const m=d[1]-e[1];return{origin:d,radius:Math.sqrt(u*u+m*m)}};const Qe=e=>.5*e.map(((e,t,n)=>[e,n[(t+1)%n.length]])).map((e=>T(...e))).reduce(((e,t)=>e+t),0);const Ze=e=>{const t=1/(6*Qe(e));return e.map(((e,t,n)=>[e,n[(t+1)%n.length]])).map((e=>E(M(...e),T(...e)))).reduce(((e,t)=>M(e,t)),[0,0]).map((e=>e*t))};const Ye=(e,t=0)=>{if(!e||!e.length){return undefined}const n=Array(e[0].length).fill(Infinity);const s=Array(e[0].length).fill(-Infinity);e.forEach((e=>e.forEach(((e,r)=>{if(e<n[r]){n[r]=e-t}if(e>s[r]){s[r]=e+t}}))));const r=s.map(((e,t)=>e-n[t]));return{min:n,max:s,span:r}};const Xe=Object.freeze({__proto__:null,boundingBox:Ye,centroid:Ze,circumcircle:Je,makePolygonCircumradius:Re,makePolygonCircumradiusSide:Ue,makePolygonInradius:qe,makePolygonInradiusSide:De,makePolygonNonCollinear:He,makePolygonSideLength:We,makePolygonSideLengthSide:Ge,signedArea:Qe});const Ke=(e,t,n=a)=>Math.abs(e-t)<n;const et=(e,t,n=a)=>Ke(e,t,n)?0:Math.sign(t-e);const tt=(e,t,n=a)=>{for(let s=0;s<Math.max(e.length,t.length);s+=1){if(!Ke(e[s]||0,t[s]||0,n)){return false}}return true};const nt=(e,t=a)=>e>-t;const st=(e,t=a)=>e>t;const rt=()=>true;const ot=()=>true;const ct=nt;const at=st;const it=(e,t=a)=>e>-t&&e<1+t;const ft=(e,t=a)=>e>t&&e<1-t;const lt=e=>e;const dt=e=>e<-a?0:e;const ut=e=>{if(e<-a){return 0}if(e>1+a){return 1}return e};const mt=Object.freeze({__proto__:null,clampLine:lt,clampRay:dt,clampSegment:ut,epsilonCompare:et,epsilonEqual:Ke,epsilonEqualVectors:tt,exclude:st,excludeL:ot,excludeR:at,excludeS:ft,include:nt,includeL:rt,includeR:ct,includeS:it});const gt={file:["file_spec","file_creator","file_author","file_title","file_description","file_classes","file_frames"],frame:["frame_author","frame_title","frame_description","frame_attributes","frame_classes","frame_unit","frame_parent","frame_inherit"],graph:["vertices_coords","vertices_vertices","vertices_faces","edges_vertices","edges_faces","edges_assignment","edges_foldAngle","edges_length","faces_vertices","faces_edges","vertices_edges","edges_edges","faces_faces"],orders:["edgeOrders","faceOrders"]};const pt=["singleModel","multiModel","animation","diagrams"];const _t=["creasePattern","foldedForm","graph","linkage"];const ht=["2D","3D","abstract","manifold","nonManifold","orientable","nonOrientable","selfTouching","nonSelfTouching","selfIntersecting","nonSelfIntersecting"];const vt=Object.freeze({__proto__:null,foldFileClasses:pt,foldFrameAttributes:ht,foldFrameClasses:_t,foldKeys:gt});const bt={vertices:"vertex",edges:"edge",faces:"face"};const yt={vertex:"vertices",edge:"edges",face:"faces"};const Et=Array.from("BbMmVvFfJjCcUu");const At={b:"boundary",m:"mountain",v:"valley",f:"flat",j:"join",c:"cut",u:"unassigned"};Object.keys(At).forEach((e=>{At[e.toUpperCase()]=At[e]}));const xt={B:0,b:0,M:-180,m:-180,V:180,v:180,F:0,f:0,J:0,j:0,C:0,c:0,U:0,u:0};const Mt={B:false,b:false,M:true,m:true,V:true,v:true,F:false,f:false,J:false,j:false,C:false,c:false,U:true,u:true};const kt=e=>xt[e]||0;const wt=e=>{if(e>a){return"V"}if(e<-a){return"M"}return"U"};const Ot=e=>Ke(0,e)||Ke(-180,e)||Ke(180,e);const jt=({edges_foldAngle:e})=>{if(!e){return true}for(let t=0;t<e.length;t+=1){if(!Ot(e[t])){return false}}return true};const Ft=(e,t)=>Object.keys(e).filter((e=>t(e)));const Ct=(e,t)=>Ft(e,(e=>e.substring(0,t.length+1)===`${t}_`));const St=(e,t)=>Ft(e,(e=>e.substring(e.length-t.length-1,e.length)===`_${t}`));const Pt=(e,t)=>{const n=Ct(e,t);if(n.length===0){return[]}const s=Math.max(...n.map((t=>e[t].length)));const r=Array.from(Array(s)).map((()=>({})));n.forEach((t=>r.forEach(((n,s)=>{r[s][t]=e[t][s]}))));return r};const Nt=(e,t,n)=>{const s=Ct(e,t);if(s.length===0){return undefined}const r={};s.forEach((t=>{r[t]=e[t][n]}));return r};const Vt=Object.freeze([].concat(gt.file).concat(gt.frame).concat(gt.graph).concat(gt.orders));const zt=(e={})=>Object.keys(e).length===0?0:Vt.filter((t=>e[t])).length/Object.keys(e).length;const $t=({frame_classes:e,file_classes:t})=>e&&e.includes("foldedForm")||t&&t.includes("foldedForm");const Tt=({edges_vertices:e,edges_foldAngle:t,edges_assignment:n})=>{if(n===undefined){return t===undefined?e.map((()=>true)):t.map((e=>e<-a||e>a))}return n.map((e=>Mt[e]))};const Lt=e=>{const t={M:"V",m:"v",V:"M",v:"m"};if(e.edges_assignment){e.edges_assignment=e.edges_assignment.map((e=>t[e]?t[e]:e))}if(e.edges_foldAngle){e.edges_foldAngle=e.edges_foldAngle.map((e=>-e))}return e};const Bt=Object.freeze({__proto__:null,assignmentCanBeFolded:Mt,assignmentFlatFoldAngle:xt,edgeAssignmentToFoldAngle:kt,edgeFoldAngleIsFlat:Ot,edgeFoldAngleToAssignment:wt,edgesAssignmentNames:At,edgesAssignmentValues:Et,edgesFoldAngleAreAllFlat:jt,filterKeysWithPrefix:Ct,filterKeysWithSuffix:St,invertAssignments:Lt,isFoldObject:zt,isFoldedForm:$t,makeEdgesIsFolded:Tt,pluralize:yt,singularize:bt,transposeGraphArrayAtIndex:Nt,transposeGraphArrays:Pt});const It=function(e,t){St(e,"coords").forEach((n=>{e[n]=e[n].map((e=>Q(3,e))).map((e=>ge(t,e)))}));St(e,"matrix").forEach((n=>{e[n]=e[n].map((e=>_e(e,t)))}));return e};const Rt=(e,...t)=>{const n=t.length===1?[t[0],t[0],t[0]]:[1,1,1].map(((e,n)=>t[n]===undefined?e:t[n]));const s=ke(n);return It(e,s)};const Ut=(e,...t)=>{const n=Ne(...t);const s=Q(3,n);const r=be(...s);return It(e,r)};const qt=(e,t,n,s)=>It(e,Me(t,n,s));const Dt=(e,t,...n)=>{const s=Ne(...n);const r=Q(3,s);const o=xe(t,...r);return It(e,o)};const Wt=function(e){if(!e.vertices_coords){return e}const t=Ye(e.vertices_coords);const n=Math.max(...t.span);const s=n===0?1:1/n;const r=t.min;e.vertices_coords=e.vertices_coords.map((e=>w(e,r))).map((e=>e.map((e=>e*s))));return e};const Gt=Object.freeze({__proto__:null,rotate:qt,rotateZ:Dt,scale:Rt,transform:It,translate:Ut,unitize:Wt});const Ht=({vertices_coords:e},t=a)=>{if(!e){return[]}const n=[];const s=[];const r=e.map(((e,t)=>({i:t,d:e[0]}))).sort(((e,t)=>e.d-t.d)).map((e=>e.i));let o=0;let c=[0,0];let i=[0,0];const f=t=>e[t][0]>i[0]&&e[t][0]<i[1]&&e[t][1]>c[0]&&e[t][1]<c[1];const l=n=>{const s=n[n.length-1];while(e[s]-e[n[o]]>t){o+=1}const r=n.slice(o,n.length).map((t=>e[t]));const a=r.map((e=>e[1]));c=[Math.min(...a)-t,Math.max(...a)+t];i=[r[0][0]-t,r[r.length-1][0]+t]};while(s.length!==e.length){const t=[];const c=r.shift();t.push(c);s.push(c);o=0;l(t);let a=0;while(a<r.length&&e[r[a]][0]<i[1]){if(f(r[a])){const e=r.splice(a,1).shift();t.push(e);s.push(e);l(t)}else{a+=1}}n.push(t)}return n};const Jt=Object.freeze({__proto__:null,getVerticesClusters:Ht});const Qt=(...e)=>Math.max(0,...e.filter((e=>e!==undefined)).map((e=>e.length)));const Zt=(e,t)=>Qt(...Ct(e,t).map((t=>e[t])));Zt.vertices=({vertices_coords:e,vertices_faces:t,vertices_vertices:n})=>Qt(e,t,n);Zt.edges=({edges_vertices:e,edges_edges:t,edges_faces:n})=>Qt(e,t,n);Zt.faces=({faces_vertices:e,faces_edges:t,faces_faces:n})=>Qt(e,t,n);const Yt=e=>Array.from(new Set(e));const Xt=e=>{const t={};e.forEach((e=>{if(t[e]===undefined){t[e]=0}t[e]+=1}));return e.filter((e=>t[e]>1))};const Kt=e=>{const t={};e.forEach((e=>{t[e]=true}));return Object.keys(t).map(parseFloat)};const en=(e,t)=>{t.sort(((e,t)=>e-t));return[e.slice(t[1]).concat(e.slice(0,t[0]+1)),e.slice(t[0],t[1]+1)]};const tn=e=>{const t=[];const n=[];e.forEach(((e,s)=>e.forEach((e=>{if(s<e){n.push([s,e])}if(s===e&&!t[s]){t[s]=true;n.push([s,e])}}))));return n};const nn=(e,t=a)=>{const n=e.map(((e,t)=>({v:e,i:t}))).sort(((e,t)=>e.v-t.v)).map((e=>e.i));const s=[[n[0]]];for(let r=1;r<n.length;r+=1){const o=n[r];const c=s.length-1;const a=s[c][s[c].length-1];if(Math.abs(e[a]-e[o])<t){s[c].push(o)}else{s.push([o])}}return s};const sn=(e,t=a)=>{const n=[[0]];for(let s=1;s<e.length;s+=1){let r=false;for(let o=0;o<n.length;o+=1){const c=n[o][0];if(H(e[s],e[c],t)){n[o].push(s);r=true;break}}if(!r){n.push([s])}}return n};const rn=e=>{const t=Array(e.length*(e.length-1)/2);let n=0;for(let s=0;s<e.length-1;s+=1){for(let r=s+1;r<e.length;r+=1,n+=1){t[n]=[e[s],e[r]]}}return t};const on=Object.freeze({__proto__:null,chooseTwoPairs:rn,clusterParallelVectors:sn,clusterScalars:nn,nonUniqueElements:Xt,selfRelationalUniqueIndexPairs:tn,splitCircularArray:en,uniqueElements:Yt,uniqueSortedNumbers:Kt});const cn=(e,t,s)=>{const r=Zt(e,t);let o=false;Object.entries(s).filter((([e,t])=>e<t)).forEach((([e,t])=>{o=true;delete s[e];s[t]=e}));if(o){console.warn(n.replaceModifyParam)}const c=Object.keys(s).map((e=>parseInt(e,10)));const a=Kt(c);const i=[];for(let e=0,t=0,o=0;e<r;e+=1,t+=1){while(e===a[o]){i[e]=i[s[a[o]]];if(i[e]===undefined){throw new Error(n.replaceUndefined)}e+=1;o+=1}if(e<r){i[e]=t}}St(e,t).forEach((t=>e[t].forEach(((n,s)=>e[t][s].forEach(((n,r)=>{e[t][s][r]=i[n]}))))));a.reverse();Ct(e,t).forEach((t=>a.forEach((n=>e[t].splice(n,1)))));return i};const an=(e,t)=>Ht(e,t).filter((e=>e.length>1));const fn=(e,t=a)=>{const n=[];const s=[];const r=Ht(e,t).filter((e=>e.length>1));r.forEach((e=>{if(Math.min(...e)!==e[0]){e.sort(((e,t)=>e-t))}for(let t=1;t<e.length;t+=1){n[e[t]]=e[0];s.push(e[t])}}));r.map((t=>t.map((t=>e.vertices_coords[t])))).map((e=>z(...e))).forEach(((t,n)=>{e.vertices_coords[r[n][0]]=t}));return{map:cn(e,"vertices",n),remove:s}};const ln=Object.freeze({__proto__:null,duplicateVertices:an,removeDuplicateVertices:fn});const dn=(e,t,n)=>{const s=Zt(e,t);const r=Kt(n);const o=[];for(let e=0,t=0,n=0;e<s;e+=1,t+=1){while(e===r[n]){o[e]=undefined;e+=1;n+=1}if(e<s){o[e]=t}}St(e,t).forEach((t=>e[t].forEach(((n,s)=>e[t][s].forEach(((n,r)=>{e[t][s][r]=o[n]}))))));r.reverse();Ct(e,t).forEach((t=>r.forEach((n=>e[t].splice(n,1)))));return o};const un=({vertices_coords:e,edges_vertices:t})=>{if(!e||!t){return[]}let n=e.length;const s=Array(n).fill(false);t.forEach((e=>{e.filter((e=>!s[e])).forEach((e=>{s[e]=true;n-=1}))}));return s.map(((e,t)=>e?undefined:t)).filter((e=>e!==undefined))};const mn=({vertices_coords:e,faces_vertices:t})=>{if(!e||!t){return[]}let n=e.length;const s=Array(n).fill(false);t.forEach((e=>{e.filter((e=>!s[e])).forEach((e=>{s[e]=true;n-=1}))}));return s.map(((e,t)=>e?undefined:t)).filter((e=>e!==undefined))};const gn=({vertices_coords:e,edges_vertices:t,faces_vertices:n})=>{if(!e){return[]}let s=e.length;const r=Array(s).fill(false);if(t){t.forEach((e=>{e.filter((e=>!r[e])).forEach((e=>{r[e]=true;s-=1}))}))}if(n){n.forEach((e=>{e.filter((e=>!r[e])).forEach((e=>{r[e]=true;s-=1}))}))}return r.map(((e,t)=>e?undefined:t)).filter((e=>e!==undefined))};const pn=(e,t)=>{if(!t){t=gn(e)}return{map:dn(e,"vertices",t),remove:t}};const _n=Object.freeze({__proto__:null,edgeIsolatedVertices:un,faceIsolatedVertices:mn,isolatedVertices:gn,removeIsolatedVertices:pn});const hn=e=>Math.atan2(e[1],e[0]);const vn=e=>[Math.cos(e),Math.sin(e)];const bn=(...e)=>{const t=Ve(...e);return{vector:w(t[1],t[0]),origin:t[0]}};const yn=({vector:e,origin:t})=>{const n=m(e);const s=q(e);const r=F(t,s)/n;return{normal:y(s,1/n),distance:r}};const En=({normal:e,distance:t})=>({vector:D(e),origin:y(e,t)});const An=Object.freeze({__proto__:null,angleToVector:vn,pointsToLine:bn,uniqueLineToVecLine:En,vecLineToUniqueLine:yn,vectorToAngle:hn});const xn=(e,t,n)=>{while(n<t){n+=l}while(e>t){e-=l}while(e<t){e+=l}return e<n};const Mn=(e,t)=>{while(e<0){e+=l}while(t<0){t+=l}while(e>l){e-=l}while(t>l){t-=l}const n=e-t;return n>=0?n:l-(t-e)};const kn=(e,t)=>{while(e<0){e+=l}while(t<0){t+=l}while(e>l){e-=l}while(t>l){t-=l}const n=t-e;return n>=0?n:l-(e-t)};const wn=(e,t)=>{const n=t[0]*e[0]+t[1]*e[1];const s=t[0]*e[1]-t[1]*e[0];let r=Math.atan2(s,n);if(r<0){r+=l}return r};const On=(e,t)=>{const n=e[0]*t[0]+e[1]*t[1];const s=e[0]*t[1]-e[1]*t[0];let r=Math.atan2(s,n);if(r<0){r+=l}return r};const jn=(e,t)=>vn(hn(e)-wn(e,t)/2);const Fn=(e,t)=>vn(hn(e)+On(e,t)/2);const Cn=(e,t,n)=>{const s=Mn(e,t)/n;return Array.from(Array(n-1)).map(((t,n)=>e+s*(n+1)))};const Sn=(e,t,n)=>{const s=kn(e,t)/n;return Array.from(Array(n-1)).map(((t,n)=>e+s*(n+1)))};const Pn=(e,t,n)=>{const s=Math.atan2(e[1],e[0]);const r=Math.atan2(t[1],t[0]);return Cn(s,r,n).map(vn)};const Nn=(e,t,n)=>{const s=Math.atan2(e[1],e[0]);const r=Math.atan2(t[1],t[0]);return Sn(s,r,n).map(vn)};const Vn=(...e)=>{const t=e.flat();const n=t.map(((e,t)=>t)).sort(((e,n)=>t[e]-t[n]));return n.slice(n.indexOf(0),n.length).concat(n.slice(0,n.indexOf(0)))};const zn=function(){return Vn(Ce(arguments).map(hn))};const $n=function(){const e=Array.from(arguments).flat();const t=Vn(e).map((t=>e[t]));return t.map(((e,t,n)=>[e,n[(t+1)%n.length]])).map((e=>kn(e[0],e[1])))};const Tn=function(){return $n(Ce(arguments).map(hn))};const Ln=(e,t,n,s=a)=>{const r=v(O(t,e));const o=v(O(n,e));const c=T(r,o);if(!Ke(c,0,s)){return Math.sign(c)}return Ke(I(e,t)+I(t,n),I(e,n))?0:undefined};const Bn=Object.freeze({__proto__:null,clockwiseAngle2:wn,clockwiseAngleRadians:Mn,clockwiseBisect2:jn,clockwiseSubsect2:Pn,clockwiseSubsectRadians:Cn,counterClockwiseAngle2:On,counterClockwiseAngleRadians:kn,counterClockwiseBisect2:Fn,counterClockwiseOrder2:zn,counterClockwiseOrderRadians:Vn,counterClockwiseSectors2:Tn,counterClockwiseSectorsRadians:$n,counterClockwiseSubsect2:Nn,counterClockwiseSubsectRadians:Sn,isCounterClockwiseBetween:xn,threePointTurnDirection:Ln});const In=e=>{let t=-1;e.filter((e=>e!==undefined)).forEach((e=>e.forEach((e=>e.forEach((e=>{if(e>t){t=e}}))))));return t};const Rn=e=>{let t=-1;e.forEach((e=>{if(e[0]>t){t=e[0]}if(e[1]>t){t=e[1]}}));return t};const Un={edges:"edgeOrders",faces:"faceOrders"};const qn=(e,t)=>Math.max(In(St(e,t).map((t=>e[t]))),e[Un[t]]?Rn(e[Un[t]]):-1)+1;qn.vertices=e=>qn(e,"vertices");qn.edges=e=>qn(e,"edges");qn.faces=e=>qn(e,"faces");const Dn=({vertices_vertices:e,vertices_sectors:t},n,s,r={})=>{const o={};const c={vertices:[n],edges:[],angles:[]};let a=n;let i=s;while(true){const n=e[i];const s=n.indexOf(a);const f=(s+n.length-1)%n.length;const l=n[f];const d=`${i} ${l}`;if(o[d]){Object.assign(r,o);c.vertices.pop();return c}o[d]=true;if(r[d]){return undefined}c.vertices.push(i);c.edges.push(d);if(t){c.angles.push(t[i][f])}a=i;i=l}};const Wn=({vertices_vertices:e,vertices_sectors:t})=>{const n={vertices_vertices:e,vertices_sectors:t};const s={};return e.map(((e,t)=>e.map((e=>Dn(n,t,e,s))).filter((e=>e!==undefined)))).flat()};const Gn=e=>e.filter((e=>e.angles.map((e=>Math.PI-e)).reduce(((e,t)=>e+t),0)>0));const Hn=Object.freeze({__proto__:null,counterClockwiseWalk:Dn,filterWalkedBoundaryFace:Gn,planarVertexWalk:Wn});const Jn=(e,t,n)=>{const s=e.map(((e,s)=>({i:s,d:n(t,e)})));let r;let o=Infinity;for(let e=0;e<s.length;e+=1){if(s[e].d<o){r=e;o=s[e].d}}return r};const Qn=(e,t,n,s)=>{let r=[0];for(let o=1;o<e.length;o+=1){switch(n(e[o][t],e[r[0]][t],s)){case 0:r.push(o);break;case 1:r=[o];break}}return r};const Zn=(e,t=a)=>{if(!e||!e.length){return undefined}const n=Qn(e,0,et,t);let s=0;for(let t=1;t<n.length;t+=1){if(e[n[t]][1]<e[n[s]][1]){s=t}}return n[s]};const Yn=Object.freeze({__proto__:null,minimum2DPointIndex:Zn,smallestComparisonSearch:Jn});const Xn=(e,t,n)=>e.map(((e,s)=>({i:s,n:n(e,t)}))).sort(((e,t)=>e.n-t.n)).map((e=>e.i));const Kn=(e,t)=>Xn(e,t,F);const es=(e,t=a)=>{const n=[[0]];let s=0;for(let r=1;r<e.length;r+=1){if(Ke(e[r],e[r-1],t)){n[s].push(r)}else{s=n.length;n.push([r])}}return n};const ts=(e,t=a)=>{const n=Zn(e,t);if(n===undefined){return[]}const s=e.map((t=>O(t,e[n]))).map((e=>v(e))).map((e=>C([0,1],e)));const r=s.map(((e,t)=>({a:e,i:t}))).sort(((e,t)=>e.a-t.a)).map((e=>e.i)).filter((e=>e!==n));return[[n]].concat(es(r.map((e=>s[e])),t).map((e=>e.map((e=>r[e])))).map((t=>t.length===1?t:t.map((t=>({i:t,len:I(e[t],e[n])}))).sort(((e,t)=>e.len-t.len)).map((e=>e.i)))))};const ns=Object.freeze({__proto__:null,clusterIndicesOfSortedNumbers:es,radialSortPointIndices2:ts,sortAgainstItem:Xn,sortPointsAlongVector:Kn});const ss=({vertices_coords:e},t,n)=>t.map((t=>e[t])).map((t=>w(t,e[n]))).map((e=>Math.atan2(e[1],e[0]))).map((e=>e>-a?e:e+Math.PI*2)).map(((e,t)=>({a:e,i:t}))).sort(((e,t)=>e.a-t.a)).map((e=>e.i)).map((e=>t[e]));const rs=({vertices_coords:e},t,n)=>Kn(t.map((t=>e[t])),n).map((e=>t[e]));const os=Object.freeze({__proto__:null,sortVerticesAlongVector:rs,sortVerticesCounterClockwise:ss});const cs=({vertices_coords:e,faces_vertices:t})=>t.map((t=>t.map((t=>e[t])))).map((e=>{const t=Q(3,w(e[1],e[0]));const n=Q(3,w(e[2],e[0]));return b(L(t,n))}));const as=({vertices_coords:e,faces_vertices:t,faces_normal:n})=>{const s=(e,t)=>{e[0]+=t[0];e[1]+=t[1];e[2]+=t[2]};if(!n){n=cs({vertices_coords:e,faces_vertices:t})}const r=e.map((()=>[0,0,0]));t.forEach(((e,t)=>e.forEach((e=>s(r[e],n[t])))));return r.map((e=>b(e)))};const is=Object.freeze({__proto__:null,makeFacesNormal:cs,makeVerticesNormal:as});const fs=({edges_vertices:e})=>{const t=[];e.forEach(((e,n)=>e.forEach((e=>{if(t[e]===undefined){t[e]=[]}t[e].push(n)}))));return t};const ls=({edges_vertices:e,vertices_vertices:t})=>{const n=hs({edges_vertices:e});return t.map(((e,t)=>e.map((e=>n[`${t} ${e}`]))))};const ds=({vertices_coords:e,vertices_edges:t,edges_vertices:n})=>{if(!t){t=fs({edges_vertices:n})}const s=t.map(((e,t)=>e.map((e=>n[e].filter((e=>e!==t)))).reduce(((e,t)=>e.concat(t)),[])));return e===undefined?s:s.map(((t,n)=>ss({vertices_coords:e},t,n)))};const us=({vertices_coords:e,vertices_faces:t,faces_vertices:n})=>{if(!t){t=ps({vertices_coords:e,faces_vertices:n})}const s=t.map((e=>e.map((e=>n[e]))));const r=s.map(((e,t)=>e.map((e=>e.indexOf(t)))));const o=s.map(((e,t)=>e.map(((e,n)=>[(r[t][n]+e.length-1)%e.length,r[t][n],(r[t][n]+1)%e.length]))));const c=o.map(((e,t)=>e.map(((e,n)=>e.map((e=>s[t][n][e]))))));const a=c.map((e=>{const t=e.map((e=>[[0,1],[1,2]].map((t=>t.map((t=>e[t])).join(" ")))));const n={};const s={};t.forEach(((e,t)=>{n[e[0]]=t;s[e[1]]=t}));return{facesVerts:t,to:s,from:n}}));return a.map((e=>{const t=Object.keys(e.to);const n=t.map((e=>e.split(" ").reverse().join(" ")));const s=t.filter(((t,s)=>!(n[s]in e.from)));if(s.length>2){console.warn("vertices_vertices found an unsolvable vertex");return[]}const r=s.length?s:[t[0]];const o=[];const c={};for(let t=0;t<r.length;t+=1){const n=r[t];const s=[n];c[n]=true;let a=false;do{const t=s[s.length-1];const n=e.to[t];if(!(n in e.facesVerts)){break}let r;if(e.facesVerts[n][0]===t){r=e.facesVerts[n][1]}if(e.facesVerts[n][1]===t){r=e.facesVerts[n][0]}if(r===undefined){return"not found"}const o=r.split(" ").reverse().join(" ");s.push(r);a=o in c;if(!a){s.push(o)}c[r]=true;c[o]=true}while(!a);const i=s.filter(((e,t)=>t%2===0)).map((e=>e.split(" ")[1])).map((e=>parseInt(e,10)));o.push(...i)}return o}))};const ms=e=>{if(!e.vertices_coords||!e.vertices_coords.length){return[]}switch(e.vertices_coords[0].length){case 3:return us(e);default:return ds(e)}};const gs=({vertices_edges:e,edges_vertices:t})=>{if(!e){e=fs({edges_vertices:t})}return e.map(((e,n)=>e.flatMap((e=>t[e].filter((e=>e!==n))))))};const ps=({vertices_coords:e,faces_vertices:t})=>{if(!t){return e.map((()=>[]))}const n=e!==undefined?e.map((()=>[])):Array.from(Array(qn.vertices({faces_vertices:t}))).map((()=>[]));t.forEach(((e,t)=>{const s=[];e.forEach((e=>{s[e]=t}));s.forEach(((e,t)=>n[t].push(e)))}));return n};const _s=({vertices_coords:e,vertices_vertices:t,faces_vertices:n})=>{if(!n){return e.map((()=>[]))}if(!t){return ps({vertices_coords:e,faces_vertices:n})}const s=bs({faces_vertices:n});return t.map(((e,t)=>e.map(((e,n,s)=>[s[(n+1)%s.length],t,e].join(" "))))).map((e=>e.map((e=>s[e]))))};const hs=({edges_vertices:e})=>{const t={};e.map((e=>e.join(" "))).forEach(((e,n)=>{t[e]=n}));e.map((e=>`${e[1]} ${e[0]}`)).forEach(((e,n)=>{t[e]=n}));return t};const vs=({edges_vertices:e})=>{const t={};e.map((e=>e.join(" "))).forEach(((e,n)=>{t[e]=n}));return t};const bs=({faces_vertices:e})=>{const t={};e.forEach(((e,n)=>e.map(((t,n)=>[0,1,2].map((t=>(n+t)%e.length)).map((t=>e[t])).join(" "))).forEach((e=>{t[e]=n}))));return t};const ys=({vertices_coords:e,vertices_vertices:t,edges_vertices:n,edges_vector:s})=>{if(!s){s=Ss({vertices_coords:e,edges_vertices:n})}const r=vs({edges_vertices:n});return t.map(((e,n)=>t[n].map((e=>{const t=r[`${n} ${e}`];const o=r[`${e} ${n}`];if(t!==undefined){return s[t]}if(o!==undefined){return U(s[o])}}))))};const Es=({vertices_coords:e,vertices_vertices:t,edges_vertices:n,edges_vector:s})=>ys({vertices_coords:e,vertices_vertices:t,edges_vertices:n,edges_vector:s}).map((e=>e.length===1?[l]:Tn(e)));const As=({edges_vertices:e,vertices_edges:t})=>e.map(((e,n)=>{const s=t[e[0]].filter((e=>e!==n));const r=t[e[1]].filter((e=>e!==n));return s.concat(r)}));const xs=({edges_vertices:e,faces_edges:t})=>{const n=e!==undefined?e.map((()=>[])):Array.from(Array(qn.edges({faces_edges:t}))).map((()=>[]));t.forEach(((e,t)=>{const s=[];e.forEach((e=>{s[e]=t}));s.forEach(((e,t)=>n[t].push(e)))}));return n};const Ms=({vertices_coords:e,edges_vertices:t,edges_vector:n,faces_vertices:s,faces_edges:r,faces_center:o})=>{if(!t||!s&&!r){return xs({faces_edges:r})}if(!s){s=zs({edges_vertices:t,faces_edges:r})}if(!r){r=$s({edges_vertices:t,faces_vertices:s})}if(!n){n=Ss({vertices_coords:e,edges_vertices:t})}const c=t.map((t=>e[t[0]]));if(!o){o=Rs({vertices_coords:e,faces_vertices:s})}const a=t.map((()=>[]));r.forEach(((e,t)=>{const n=[];e.forEach((e=>{n[e]=t}));n.forEach(((e,t)=>a[t].push(e)))}));a.forEach(((e,t)=>{const s=e.map((e=>o[e])).map((e=>O(e,c[t]))).map((e=>T(e,n[t])));e.sort(((e,t)=>s[e]-s[t]))}));return a};const ks={M:-180,m:-180,V:180,v:180};const ws=({edges_foldAngle:e})=>e.map((e=>{if(e===0){return"F"}return e<0?"M":"V"}));const Os=({edges_vertices:e,edges_foldAngle:t,edges_faces:n,faces_vertices:s,faces_edges:r})=>{if(!n){if(!r){r=$s({edges_vertices:e,faces_vertices:s})}n=xs({edges_vertices:e,faces_edges:r})}return t.map(((e,t)=>{if(n[t].length<2){return"B"}if(e===0){return"F"}return e<0?"M":"V"}))};const js=({edges_assignment:e})=>e.map((e=>ks[e]||0));const Fs=({vertices_coords:e,edges_vertices:t,edges_faces:s,edges_assignment:r,faces_vertices:o,faces_edges:c,faces_normal:a,faces_center:i})=>{if(!s){if(!c){c=$s({edges_vertices:t,faces_vertices:o})}s=xs({edges_vertices:t,faces_edges:c})}if(!a){a=cs({vertices_coords:e,faces_vertices:o})}if(!i){i=Rs({vertices_coords:e,faces_vertices:o})}return s.map(((e,t)=>{if(e.length>2){throw new Error(n.manifold)}if(e.length<2){return 0}const s=a[e[0]];const o=a[e[1]];const c=h(w(i[e[1]],i[e[0]]));let f=Math.sign(F(s,c));if(f===0){if(r&&r[t]){if(r[t]==="F"||r[t]==="F"){f=0}if(r[t]==="M"||r[t]==="m"){f=-1}if(r[t]==="V"||r[t]==="v"){f=1}}else{throw new Error(n.flatFoldAngles)}}return Math.acos(F(s,o))*(180/Math.PI)*f}))};const Cs=({vertices_coords:e,edges_vertices:t})=>t.map((t=>t.map((t=>e[t]))));const Ss=({vertices_coords:e,edges_vertices:t})=>Cs({vertices_coords:e,edges_vertices:t}).map((e=>w(e[1],e[0])));const Ps=({vertices_coords:e,edges_vertices:t})=>Ss({vertices_coords:e,edges_vertices:t}).map((e=>m(e)));const Ns=({vertices_coords:e,edges_vertices:t,edges_coords:n},s=0)=>{if(!n){n=Cs({vertices_coords:e,edges_vertices:t})}return n.map((e=>Ye(e,s)))};const Vs=({vertices_coords:e,vertices_vertices:t,vertices_edges:n,vertices_sectors:s,edges_vertices:r,edges_vector:o})=>{if(!t){t=ms({vertices_coords:e,edges_vertices:r,vertices_edges:n})}if(!s){s=Es({vertices_coords:e,vertices_vertices:t,edges_vertices:r,edges_vector:o})}const c=hs({edges_vertices:r});const a=Gn(Wn({vertices_vertices:t,vertices_sectors:s})).map((e=>({...e,edges:e.edges.map((e=>c[e]))})));return{faces_vertices:a.map((e=>e.vertices)),faces_edges:a.map((e=>e.edges)),faces_sectors:a.map((e=>e.angles))}};const zs=({edges_vertices:e,faces_edges:t})=>t.map((t=>t.map((t=>e[t])).map(((e,t,n)=>{const s=n[(t+1)%n.length];return e[0]===s[0]||e[0]===s[1]?e[1]:e[0]}))));const $s=({edges_vertices:e,faces_vertices:t})=>{const n=hs({edges_vertices:e});return t.map((e=>e.map(((e,t,n)=>[e,n[(t+1)%n.length]].join(" "))))).map((e=>e.map((e=>n[e]))))};const Ts=({faces_vertices:e})=>{const t=e.map((()=>[]));const n={};e.forEach(((e,t)=>e.forEach(((s,r,o)=>{let c=o[(r+1)%e.length];if(c<s){[s,c]=[c,s]}const a=`${s} ${c}`;if(n[a]===undefined){n[a]={}}n[a][t]=true}))));Object.values(n).map((e=>Object.keys(e))).filter((e=>e.length>1)).forEach((e=>{t[e[0]].push(parseInt(e[1],10));t[e[1]].push(parseInt(e[0],10))}));return t};const Ls=({vertices_coords:e,faces_vertices:t},n)=>t.map((t=>t.map((t=>e[t])))).map((e=>He(e,n)));const Bs=({vertices_coords:e,faces_vertices:t})=>t.map((t=>t.map((t=>e[t]))));const Is=({vertices_coords:e,faces_vertices:t})=>t.map((t=>t.map((t=>e[t])))).map((e=>Ze(e)));const Rs=({vertices_coords:e,faces_vertices:t})=>t.map((t=>t.map((t=>e[t])).reduce(((e,t)=>x(e,t)),Array(e[0].length).fill(0)).map((e=>e/t.length))));const Us=Object.freeze({__proto__:null,makeEdgesAssignment:Os,makeEdgesAssignmentSimple:ws,makeEdgesBoundingBox:Ns,makeEdgesCoords:Cs,makeEdgesEdges:As,makeEdgesFaces:Ms,makeEdgesFacesUnsorted:xs,makeEdgesFoldAngle:js,makeEdgesFoldAngleFromFaces:Fs,makeEdgesLength:Ps,makeEdgesVector:Ss,makeFacesCenter2D:Is,makeFacesConvexCenter:Rs,makeFacesEdgesFromVertices:$s,makeFacesFaces:Ts,makeFacesPolygon:Ls,makeFacesPolygonQuick:Bs,makeFacesVerticesFromEdges:zs,makePlanarFaces:Vs,makeVerticesEdges:ls,makeVerticesEdgesUnsorted:fs,makeVerticesFaces:_s,makeVerticesFacesUnsorted:ps,makeVerticesSectors:Es,makeVerticesToEdge:vs,makeVerticesToEdgeBidirectional:hs,makeVerticesToFace:bs,makeVerticesVertices:ms,makeVerticesVertices2D:ds,makeVerticesVerticesFromFaces:us,makeVerticesVerticesUnsorted:gs,makeVerticesVerticesVector:ys});const qs=({edges_vertices:e})=>{if(!e){return[]}const t=[];const n={};for(let s=0;s<e.length;s+=1){const r=`${e[s][0]} ${e[s][1]}`;const o=`${e[s][1]} ${e[s][0]}`;if(n[r]!==undefined){t[s]=n[r]}else{n[r]=s;n[o]=s}}return t};const Ds=(e,t)=>{if(!t){t=qs(e)}const n=Object.keys(t).map((e=>parseInt(e,10)));const s=cn(e,"edges",t);if(n.length){if(e.vertices_edges||e.vertices_vertices||e.vertices_faces){e.vertices_edges=fs(e);e.vertices_vertices=ms(e);e.vertices_edges=ls(e);e.vertices_faces=_s(e)}}return{map:s,remove:n}};const Ws=Object.freeze({__proto__:null,duplicateEdges:qs,removeDuplicateEdges:Ds});const Gs=({edges_vertices:e})=>{if(!e){return[]}const t=[];for(let n=0;n<e.length;n+=1){if(e[n][0]===e[n][1]){t.push(n)}}return t};const Hs=(e,t,n)=>{const s={};n.forEach((e=>{s[e]=true}));St(e,t).forEach((t=>e[t].forEach(((n,r)=>{for(let o=n.length-1;o>=0;o-=1){if(s[n[o]]===true){e[t][r].splice(o,1)}}}))))};const Js=(e,t)=>{if(!t){t=Gs(e)}if(t.length){Hs(e,"edges",t)}return{map:dn(e,"edges",t),remove:t}};const Qs=Object.freeze({__proto__:null,circularEdges:Gs,removeCircularEdges:Js});const Zs=(...e)=>{if(e.length===0){return[]}const t=e[0].map(((e,t)=>t));e.forEach((e=>t.forEach(((n,s)=>{t[s]=e[n]}))));return t};const Ys=(...e)=>{if(e.length===0){return[]}const t=e[0].map(((e,t)=>[t]));e.forEach((e=>{t.forEach(((n,s)=>n.forEach(((n,r)=>{t[s][r]=e[n]}))));t.forEach(((e,n)=>{t[n]=e.reduce(((e,t)=>e.concat(t)),[]).filter((e=>e!==undefined))}))}));return t};const Xs=(...e)=>{if(e.length===0){return[]}let t=e[0].map(((e,t)=>t));e.forEach((e=>{const n=e.map((e=>t[e]));t=n}));return t};const Ks=(...e)=>{if(e.length===0){return[]}let t=e[0].reduce(((e,t)=>e.concat(t)),[]).map(((e,t)=>[t]));e.forEach((e=>{const n=[];e.forEach(((e,s)=>{if(typeof e==="number"){n[s]=t[e]}else{n[s]=e.map((e=>t[e])).reduce(((e,t)=>e.concat(t)),[])}}));t=n}));return t};const er=e=>{const t=[];const n=(e,n)=>{if(t[e]!==undefined){if(typeof t[e]==="number"){t[e]=[t[e],n]}else{t[e].push(n)}}else{t[e]=n}};e.forEach(((e,t)=>{if(e==null){return}if(typeof e==="number"){n(e,t)}if(e.constructor===Array){e.forEach((e=>n(e,t)))}}));return t};const tr=e=>{const t=[];e.forEach(((e,n)=>{t[e]=n}));return t};const nr=Object.freeze({__proto__:null,invertMap:er,invertSimpleMap:tr,mergeBackmaps:Ks,mergeNextmaps:Ys,mergeSimpleBackmaps:Xs,mergeSimpleNextmaps:Zs});const sr=(e,t)=>{const n=fn(e,t);const s=Js(e);const r=Ds(e);const o=pn(e);const c=tr(n.map);const a=o.remove.map((e=>c[e]));const i=tr(s.map);const f=r.remove.map((e=>i[e]));return{vertices:{map:Zs(n.map,o.map),remove:n.remove.concat(a)},edges:{map:Zs(s.map,r.map),remove:s.remove.concat(f)}}};const rr=function(e){let t;let n;if(typeof e!=="object"){return e}if(!e){return e}if(Object.prototype.toString.apply(e)==="[object Array]"){t=[];for(n=0;n<e.length;n+=1){t[n]=rr(e[n])}return t}t={};for(n in e){if(e.hasOwnProperty(n)){t[n]=rr(e[n])}}return t};const or=e=>{if(!e.faces_vertices){return{}}const t=e.faces_edges?e.faces_edges:$s(e);const n=e.faces_vertices.flatMap((e=>e));const s=t.flatMap((e=>e));let r=0;let o=0;let c=0;e.faces_vertices=e.faces_vertices.map((e=>e.map((()=>r++))));e.faces_edges=e.faces_edges.map((e=>e.map((()=>o++))));e.edges_vertices=e.faces_edges.flatMap((e=>e.map(((e,t,n)=>{const s=t===n.length-1?[c,c+1-n.length]:[c,c+1];c+=1;return s}))));if(e.vertices_coords){e.vertices_coords=rr(n.map((t=>e.vertices_coords[t])))}if(e.edges_assignment){e.edges_assignment=rr(s.map((t=>e.edges_assignment[t])))}if(e.edges_foldAngle){e.edges_foldAngle=rr(s.map((t=>e.edges_foldAngle[t])))}if(e.vertices_vertices){delete e.vertices_vertices}if(e.vertices_edges){delete e.vertices_edges}if(e.vertices_faces){delete e.vertices_faces}if(e.edges_edges){delete e.edges_edges}if(e.edges_faces){delete e.edges_faces}if(e.faces_faces){delete e.faces_faces}return{vertices:{map:n},edges:{map:s}}};const cr=e=>{const t=e.faces_vertices.flatMap((t=>t.map((t=>e.vertices_coords[t]))));let n=0;const s=e.faces_vertices.map((e=>e.map((()=>n++))));return{vertices_coords:JSON.parse(JSON.stringify(t)),faces_vertices:s}};const ar=e=>{const t=e.edges_vertices.flatMap((t=>t.map((t=>e.vertices_coords[t]))));let n=0;const s=e.edges_vertices.map((e=>e.map((()=>n++))));return{vertices_coords:JSON.parse(JSON.stringify(t)),edges_vertices:s}};const ir=Object.freeze({__proto__:null,explode:or,explodeEdges:ar,explodeFaces:cr});const fr=(e,t)=>{const n=Jn(e,t,I);return n===undefined?undefined:e[n]};const lr=(e,t)=>{const n=Jn(e,t,B);return n===undefined?undefined:e[n]};const dr=({vector:e,origin:t},n,s=lt,r=a)=>{t=Q(e.length,t);n=Q(e.length,n);const o=_(e);const c=w(n,t);const i=F(e,c);const f=i/o;const l=s(f,r);return x(t,y(e,l))};const ur=(e,t)=>e.map(((e,t,n)=>w(n[(t+1)%n.length],e))).map(((t,n)=>({vector:t,origin:e[n]}))).map((e=>dr(e,t,ut))).map(((e,n)=>({point:e,edge:n,distance:B(e,t)}))).sort(((e,t)=>e.distance-t.distance)).shift();const mr=({radius:e,origin:t},n)=>x(t,y(h(w(n,t)),e));const gr=Object.freeze({__proto__:null,nearestPoint:lr,nearestPoint2:fr,nearestPointOnCircle:mr,nearestPointOnLine:dr,nearestPointOnPolygon:ur});const pr=({vector:e,origin:t},n,s=rt,r=a)=>{const o=O(n,t);const c=_(e);const i=Math.sqrt(c);if(i<r){return false}const f=T(o,e.map((e=>e/i)));const l=C(o,e)/c;return Math.abs(f)<r&&s(l,r/i)};const _r=(e,t,n=rt,s=rt,r=a)=>{const o=T(e.vector,t.vector);const c=-o;const i=O(t.origin,e.origin);const f=[-i[0],-i[1]];if(Math.abs(o)<r){if(Math.abs(T(i,e.vector))>r){return false}const o=f;const c=M(o,e.vector);const a=N(o,c);const l=i;const d=M(l,t.vector);const u=N(l,d);const m=C(e.vector,e.vector);const g=C(t.vector,t.vector);const p=C(o,t.vector)/g;const _=C(c,t.vector)/g;const h=C(a,t.vector)/g;const v=C(l,e.vector)/m;const b=C(d,e.vector)/m;const y=C(u,e.vector)/m;return n(v,r)||n(b,r)||s(p,r)||s(_,r)||n(y,r)||s(h,r)}const l=T(i,t.vector)/o;const d=T(f,e.vector)/c;return n(l,r/g(e.vector))&&s(d,r/g(t.vector))};const hr=({radius:e,origin:t},n,s=st,r=a)=>s(e-I(t,n),r);const vr=(e,t,n=st,s=a)=>e.map(((e,t,n)=>[e,n[(t+1)%n.length]])).map((e=>T(v(O(e[1],e[0])),O(t,e[0])))).map((e=>n(e,s))).map(((e,t,n)=>e===n[0])).reduce(((e,t)=>e&&t),true);const br=(e,t,n=a)=>{for(let s=0;s<2;s+=1){const r=s===0?e:t;const o=s===0?t:e;for(let e=0;e<r.length;e+=1){const t=r[e];const s=q(O(r[(e+1)%r.length],r[e]));const c=o.map((e=>O(e,t))).map((e=>C(s,e)));const a=r[(e+2)%r.length];const i=C(s,O(a,t));const f=i>0;const l=c.map((e=>f?e<n:e>-n)).reduce(((e,t)=>e&&t),true);if(l){return false}}}return true};const yr=(e,t,n=a)=>{const s=Math.min(e.min.length,t.min.length);for(let r=0;r<s;r+=1){if(e.min[r]>t.max[r]+n||e.max[r]<t.min[r]-n){return false}}return true};const Er=Object.freeze({__proto__:null,overlapBoundingBoxes:yr,overlapCirclePoint:hr,overlapConvexPolygonPoint:vr,overlapConvexPolygons:br,overlapLineLine:_r,overlapLinePoint:pr});const Ar=({vertices_coords:e},t)=>{if(!e){return undefined}const n=Q(e[0].length,t);const s=e.map(((e,t)=>({d:B(n,e),i:t}))).sort(((e,t)=>e.d-t.d)).shift();return s?s.i:undefined};const xr=({vertices_coords:e,edges_vertices:t},n)=>{if(!e||!t){return undefined}const s=t.map((t=>t.map((t=>e[t])))).map((e=>dr({vector:w(e[1],e[0]),origin:e[0]},n,ut)));return Jn(s,n,B)};const Mr=({vertices_coords:e,faces_vertices:t},n)=>{if(!e||!t){return undefined}const s=t.map(((t,n)=>({face:t.map((t=>e[t])),i:n}))).filter((e=>vr(e.face,n))).shift();return s===undefined?undefined:s.i};const kr=(e,t)=>{const n=Mr(e,t);if(n!==undefined){return n}if(e.edges_faces){const n=xr(e,t);const s=e.edges_faces[n];if(s.length===1){return s[0]}if(s.length>1){const n=Rs({vertices_coords:e.vertices_coords,faces_vertices:s.map((t=>e.faces_vertices[t]))});const r=n.map((e=>B(e,t)));let o=0;for(let e=0;e<r.length;e+=1){if(r[e]<r[o]){o=e}}return s[o]}}return undefined};const wr=(e,...t)=>{const n={vertices:Ar,edges:xr,faces:kr};const s=Ne(...t);const r=Object.create(null);["vertices","edges","faces"].forEach((t=>{Object.defineProperty(r,bt[t],{enumerable:true,get:()=>n[t](e,s)});Ct(e,t).forEach((n=>Object.defineProperty(r,n,{enumerable:true,get:()=>e[n][r[bt[t]]]})))}));return r};const Or=Object.freeze({__proto__:null,faceContainingPoint:Mr,nearest:wr,nearestEdge:xr,nearestFace:kr,nearestVertex:Ar});const jr=({vertices_coords:e,faces_vertices:t},n=0)=>t.map((t=>[t.reduce(((t,s)=>e[t][n]<e[s][n]?t:s)),t.reduce(((t,s)=>e[t][n]>e[s][n]?t:s))]));const Fr=({vertices_coords:e},t=0,n=a)=>nn(e.map((e=>e[t])),n).map((n=>({vertices:n,t:n.reduce(((n,s)=>n+e[s][t]),0)/n.length})));const Cr=(e,{edges_vertices:t,vertices_edges:n},s=a)=>{if(!n){n=fs({edges_vertices:t})}const r=t.map((t=>t.map((t=>e[t]))));const o=r.map((e=>Ke(...e,s)));const c=r.map((([e,t])=>Math.sign(e-t)));const i=t.map((([e,t],n)=>o[n]?{[e]:0,[t]:0}:{[e]:c[n],[t]:-c[n]}));return nn(e,s).map((e=>e.filter((e=>n[e])))).filter((e=>e.length)).map((t=>({vertices:t,t:t.reduce(((t,n)=>t+e[n]),0)/t.length,start:Yt(t.flatMap((e=>n[e].filter((t=>i[t][e]<=0))))),end:Yt(t.flatMap((e=>n[e].filter((t=>i[t][e]>=0)))))})))};const Sr=({vertices_coords:e,edges_vertices:t,vertices_edges:n},s=0,r=a)=>Cr(e.map((e=>e[s])),{edges_vertices:t,vertices_edges:n},r);const Pr=({vertices_coords:e,faces_vertices:t},n=0,s=a)=>Cr(e.map((e=>e[n])),{edges_vertices:jr({vertices_coords:e,faces_vertices:t},n)},s);const Nr=({vertices_coords:e,edges_vertices:t,faces_vertices:n},s=0,r=a)=>{const o=e.map((e=>e[s]));const c=jr({vertices_coords:e,faces_vertices:n},s);const i=fs({edges_vertices:t});const f=fs({edges_vertices:c});const l=t.map((e=>e.map((e=>o[e]))));const d=c.map((e=>e.map((e=>o[e]))));const u=l.map((e=>Ke(...e,r)));const m=d.map((e=>Ke(...e,r)));const g=l.map((([e,t])=>Math.sign(e-t)));const p=d.map((([e,t])=>Math.sign(e-t)));const _=t.map((([e,t],n)=>u[n]?{[e]:0,[t]:0}:{[e]:g[n],[t]:-g[n]}));const h=n.map((([e,t],n)=>m[n]?{[e]:0,[t]:0}:{[e]:p[n],[t]:-p[n]}));return nn(o,r).map((e=>({vertices:e,t:e.reduce(((e,t)=>e+o[t]),0)/e.length,edges:{start:Yt(e.filter((e=>i[e]!==undefined)).flatMap((e=>i[e].filter((t=>_[t][e]<=0))))),end:Yt(e.filter((e=>i[e]!==undefined)).flatMap((e=>i[e].filter((t=>_[t][e]>=0)))))},faces:{start:Yt(e.filter((e=>f[e]!==undefined)).flatMap((e=>f[e].filter((t=>h[t][e]<=0))))),end:Yt(e.filter((e=>f[e]!==undefined)).flatMap((e=>f[e].filter((t=>h[t][e]>=0)))))}})))};const Vr=Object.freeze({__proto__:null,sweep:Nr,sweepEdges:Sr,sweepFaces:Pr,sweepVertices:Fr});const zr=({vertices_coords:e,edges_vertices:t,vertices_edges:n,edges_vector:s},r=a)=>{if(!s){s=Ss({vertices_coords:e,edges_vertices:t})}const o=t.map(((n,r)=>({vector:s[r],origin:e[t[r][0]]})));const c=t.map((t=>t.map((t=>e[t][1])))).map((e=>e[0]<e[1]?e:[e[1],e[0]])).map((e=>[e[0]-r,e[1]+r]));const i=[];const f=[];Sr({vertices_coords:e,edges_vertices:t,vertices_edges:n},r).forEach((n=>{n.start.forEach((e=>{f[e]=true}));f.forEach(((s,a)=>n.vertices.forEach((n=>{if(t[a][0]===n||t[a][1]===n){return}const s=e[n][1];if(s<c[a][0]||s>c[a][1]){return}if(!i[a]){i[a]=[]}i[a][n]=pr(o[a],e[n],ft,r)}))));n.end.forEach((e=>delete f[e]))}));return i.map((e=>e.map(((e,t)=>e?t:undefined)).filter((e=>e!==undefined))))};const $r=Object.freeze({__proto__:null,getVerticesEdgesOverlap:zr});const Tr=(e,t,n=rt,s=rt,r=a)=>{const o=T(v(e.vector),v(t.vector));if(Math.abs(o)<r){return undefined}const c=T(e.vector,t.vector);const i=-c;const f=[t.origin[0]-e.origin[0],t.origin[1]-e.origin[1]];const l=[-f[0],-f[1]];const d=T(f,t.vector)/c;const u=T(l,e.vector)/i;if(n(d,r/g(e.vector))&&s(u,r/g(t.vector))){return M(e.origin,E(e.vector,d))}return undefined};const Lr=(e,t,n=nt,s=rt,r=a)=>{const o=t.vector[0]**2+t.vector[1]**2;const c=Math.sqrt(o);const i=c===0?t.vector:t.vector.map((e=>e/c));const f=q(i);const l=O(t.origin,e.origin);const d=T(l,i);if(Math.abs(d)>e.radius+r){return undefined}const u=Math.sqrt(e.radius**2-d**2);const m=(t,n)=>e.origin[n]-f[n]*d+i[n]*t;const g=Math.abs(e.radius-Math.abs(d))<r?[u].map((e=>[e,e].map(m))):[-u,u].map((e=>[e,e].map(m)));const p=g.map((e=>e.map(((e,n)=>e-t.origin[n])))).map((e=>e[0]*t.vector[0]+t.vector[1]*e[1])).map((e=>e/o));return g.filter(((e,t)=>s(p[t],r)))};const Br=e=>{if(e>=1)return 0;if(e<=-1)return Math.PI;return Math.acos(e)};const Ir=(e,t,n)=>{const s=t[0]-e[0];const r=t[1]-e[1];const o=s*Math.cos(n)+r*Math.sin(n);const c=r*Math.cos(n)-s*Math.sin(n);return[e[0]+o,e[1]+c]};const Rr=(e,t,n=nt,s=nt,r=a)=>{const o=e.radius<t.radius?e.radius:t.radius;const c=e.radius<t.radius?t.radius:e.radius;const i=e.radius<t.radius?e.origin:t.origin;const f=e.radius<t.radius?t.origin:e.origin;const l=[i[0]-f[0],i[1]-f[1]];const d=Math.sqrt(l[0]**2+l[1]**2);if(d<r){return undefined}const u=l.map(((e,t)=>e/d*c+f[t]));if(Math.abs(c+o-d)<r||Math.abs(c-(o+d))<r){return[u]}if(d+o<c||c+o<d){return undefined}const m=Br((o*o-d*d-c*c)/(-2*d*c));const g=Ir(f,u,+m);const p=Ir(f,u,-m);return[g,p]};const Ur=e=>{for(let t=1;t<e.length;t+=1){if(!tt(e[0],e[t])){return[e[0],e[t]]}}return undefined};const qr=(e,{vector:t,origin:n},s=it,r=rt,o=a)=>{const c=e.map(((e,t,n)=>[e,n[(t+1)%n.length]])).map((e=>Tr({vector:O(e[1],e[0]),origin:e[0]},{vector:t,origin:n},s,r,o))).filter((e=>e!==undefined));switch(c.length){case 0:return undefined;case 1:return[c];default:return Ur(c)||[c[0]]}};const Dr=(e,{vector:t,origin:n},s=it,r=ot,o=a)=>{const c=qr(e,{vector:t,origin:n},s,r,o);let i;switch(r){case at:i=ct;break;case ft:i=it;break;default:return c}const f=qr(e,{vector:t,origin:n},it,i,o);if(f===undefined){return undefined}const l=Ur(f);if(l===undefined){switch(r){case at:return vr(e,n,st,o)?f:undefined;case ft:return vr(e,M(n,t),st,o)||vr(e,n,st,o)?f:undefined;case ot:return undefined;default:return undefined}}return vr(e,N(...l),st,o)?l:c};const Wr=Object.freeze({__proto__:null,intersectCircleCircle:Rr,intersectCircleLine:Lr,intersectConvexPolygonLine:Dr,intersectLineLine:Tr});const Gr=({vertices_coords:e,edges_vertices:t,vertices_edges:n,edges_vector:s,edges_origin:r},o=a)=>{if(!s){s=Ss({vertices_coords:e,edges_vertices:t})}if(!r){r=t.map((t=>e[t[0]]))}const c=[];const i=[];Sr({vertices_coords:e,edges_vertices:t,vertices_edges:n},o).forEach((e=>{e.start.forEach((e=>{i[e]=true}));i.forEach(((t,n)=>e.start.forEach((e=>{if(n===e){return}const t=Tr({vector:s[n],origin:r[n]},{vector:s[e],origin:r[e]},ft,ft,o);if(t){if(!c[n]){c[n]=[]}if(!c[e]){c[e]=[]}c[n][e]=t;c[e][n]=t}}))));e.end.forEach((e=>delete i[e]))}));return c};const Hr=({vertices_coords:e,edges_vertices:t,edges_vector:n},s=a)=>{if(!n){n=Ss({vertices_coords:e,edges_vertices:t})}const r=n.map((e=>h(e)));const o=t.map((()=>[]));r.forEach(((e,t)=>{r.forEach(((e,n)=>{if(n>=t){return}if(1-Math.abs(F(r[t],r[n]))<s){o[t].push(n);o[n].push(t)}}))}));return o};const Jr=({vertices_coords:e,edges_vertices:t,edges_vector:n},s)=>{if(!n){n=Ss({vertices_coords:e,edges_vertices:t})}const r=t.map((t=>e[t[0]]));const o=n.map(((e,t)=>({vector:e,origin:r[t]})));return Hr({vertices_coords:e,edges_vertices:t,edges_vector:n},s).map(((e,t)=>e.filter((e=>_r(o[t],o[e],ft,ft,s)))))};const Qr=Object.freeze({__proto__:null,getEdgesEdgesIntersection:Gr,makeEdgesEdgesParallelOverlap:Jr});const Zr=(e,t=a)=>{const n=e.edges_vertices.map((t=>t.map((t=>e.vertices_coords[t]))));const s=n.map((e=>w(e[1],e[0])));const r=n.map((e=>e[0]));const o=fs(e);const c=Gr({vertices_coords:e.vertices_coords,vertices_edges:o,edges_vertices:e.edges_vertices,edges_vector:s,edges_origin:r},1e-6);const i=zr({vertices_coords:e.vertices_coords,vertices_edges:o,edges_vertices:e.edges_vertices,edges_vector:s},t);if(c.flat().filter((e=>e!==undefined)).length===0&&i.flat().filter((e=>e!==undefined)).length===0){return undefined}const f={vertices:e.vertices_coords.length};c.forEach((t=>t.filter((e=>e!==undefined)).filter((e=>e.length===2)).forEach((t=>{const n=e.vertices_coords.length;e.vertices_coords.push([...t]);t.splice(0,2);t.push(n)}))));c.forEach(((e,t)=>{e.forEach(((e,n)=>{if(e){c[t][n]=e[0]}}))}));const l=c.map((e=>e.filter((e=>e!==undefined))));e.edges_vertices.forEach(((e,t)=>{if(l[t]){e.push(...l[t])}if(i[t]){e.push(...i[t])}}));e.edges_vertices.forEach(((t,n)=>{e.edges_vertices[n]=rs({vertices_coords:e.vertices_coords},t,s[n])}));const d=e.edges_vertices.map(((e,t)=>Array(e.length-1).fill(t))).flat();e.edges_vertices=e.edges_vertices.map((e=>Array.from(Array(e.length-1)).map(((t,n,s)=>[e[n],e[n+1]])))).flat();if(e.edges_assignment&&e.edges_foldAngle&&e.edges_foldAngle.length>e.edges_assignment.length){for(let t=e.edges_assignment.length;t<e.edges_foldAngle.length;t+=1){e.edges_assignment[t]=wt(e.edges_foldAngle[t])}}if(e.edges_assignment){e.edges_assignment=d.map((t=>e.edges_assignment[t]||"U"))}if(e.edges_foldAngle){e.edges_foldAngle=d.map((t=>e.edges_foldAngle[t])).map(((t,n)=>t===undefined?kt(e.edges_assignment[n]):t))}return{vertices:{new:Array.from(Array(e.vertices_coords.length-f.vertices)).map(((e,t)=>f.vertices+t))},edges:{backmap:d}}};const Yr=["vertices_coords","edges_vertices","edges_assignment","edges_foldAngle"];const Xr=(e,t=a)=>{e.vertices_coords=e.vertices_coords.map((e=>e.slice(0,2)));["vertices","edges","faces"].map((t=>Ct(e,t))).flat().filter((e=>!Yr.includes(e))).forEach((t=>delete e[t]));const s={vertices:{},edges:{}};let r;for(r=0;r<20;r+=1){const n=fn(e,t/2);const r=Ds(e);const o=Js(e);const c=Zr(e,t);if(c===undefined){s.vertices.map=s.vertices.map===undefined?n.map:Ys(s.vertices.map,n.map);s.edges.map=s.edges.map===undefined?Ys(r.map,o.map):Ys(s.edges.map,r.map,o.map);break}const a=er(c.edges.backmap);const i=Ys(r.map,o.map,a);s.vertices.map=s.vertices.map===undefined?n.map:Ys(s.vertices.map,n.map);s.edges.map=s.edges.map===undefined?i:Ys(s.edges.map,i)}if(r===20){throw new Error(n.planarize)}return s};const Kr=e=>{const t=e.edges_vertices.length;if(!e.edges_assignment){e.edges_assignment=[]}if(!e.edges_foldAngle){e.edges_foldAngle=[]}if(e.edges_assignment.length>e.edges_foldAngle.length){for(let t=e.edges_foldAngle.length;t<e.edges_assignment.length;t+=1){e.edges_foldAngle[t]=kt(e.edges_assignment[t])}}if(e.edges_foldAngle.length>e.edges_assignment.length){for(let t=e.edges_assignment.length;t<e.edges_foldAngle.length;t+=1){e.edges_assignment[t]=wt(e.edges_foldAngle[t])}}for(let n=e.edges_assignment.length;n<t;n+=1){e.edges_assignment[n]="U";e.edges_foldAngle[n]=0}};const eo=(e,t)=>{if(t===undefined&&!e.faces_vertices&&!e.faces_edges){t=true}if(t&&e.vertices_coords){const t=Vs(e);e.faces_vertices=t.faces_vertices;e.faces_edges=t.faces_edges;return}if(e.faces_vertices&&e.faces_edges){return}if(e.faces_vertices&&!e.faces_edges){e.faces_edges=$s(e)}else if(e.faces_edges&&!e.faces_vertices){e.faces_vertices=zs(e)}else{e.faces_vertices=[];e.faces_edges=[]}};const to=(e,t)=>{if(typeof e!=="object"){return e}if(!e.edges_vertices){return e}e.vertices_edges=fs(e);e.vertices_vertices=ms(e);e.vertices_edges=ls(e);Kr(e);eo(e,t);e.vertices_faces=_s(e);e.edges_faces=xs(e);e.faces_faces=Ts(e);return e};const no=({vertices_faces:e,edges_vertices:t,edges_faces:n,faces_edges:s,faces_vertices:r},o)=>{if(n&&n[o]){return n[o]}const c=t[o];if(e!==undefined){const t=[];for(let n=0;n<e[c[0]].length;n+=1){for(let s=0;s<e[c[1]].length;s+=1){if(e[c[0]][n]===e[c[1]][s]){if(e[c[0]][n]===undefined){continue}t.push(e[c[0]][n])}}}return t}if(s){const e=[];for(let t=0;t<s.length;t+=1){for(let n=0;n<s[t].length;n+=1){if(s[t][n]===o){e.push(t)}}}return e}if(r){console.warn("todo: findAdjacentFacesToEdge")}};const so=({vertices_vertices:e},t,n)=>{if(!e){return}e[t]=[...n];n.forEach(((n,s,r)=>{const o=r[(s+1)%r.length];const c=e[n].indexOf(o);e[n][c]=t}))};const ro=({vertices_coords:e,vertices_vertices:t,vertices_sectors:n},s)=>{if(!n){return}n[s]=t[s].length===1?[l]:Tn(t[s].map((t=>O(e[t],e[s]))))};const oo=({vertices_edges:e},t,n,s,r)=>{if(!e){return}e[n]=[...r];s.map((n=>e[n].indexOf(t))).forEach(((t,n)=>{e[s[n]][t]=r[n]}))};const co=({vertices_faces:e},t,n)=>{if(!e){return}e[t]=[...n]};const ao=({edges_faces:e},t,n)=>{if(!e){return}t.forEach((t=>{e[t]=[...n]}))};const io=({faces_vertices:e},t,n,s)=>{if(!e){return}s.map((t=>e[t])).forEach((e=>e.map(((e,t,s)=>{const r=(t+1)%s.length;return e===n[0]&&s[r]===n[1]||e===n[1]&&s[r]===n[0]?r:undefined})).filter((e=>e!==undefined)).sort(((e,t)=>t-e)).forEach((n=>e.splice(n,0,t)))))};const fo=({edges_vertices:e,faces_vertices:t,faces_edges:n},s)=>{const r=hs({edges_vertices:e});s.map((e=>t[e].map(((e,t,n)=>[e,n[(t+1)%n.length]])).map((e=>r[e.join(" ")])))).forEach(((e,t)=>{n[s[t]]=e}))};const lo=(e,t,n)=>{const s=e.edges_vertices[t];const r=[{edges_vertices:[s[0],n]},{edges_vertices:[n,s[1]]}];r.forEach((n=>["edges_assignment","edges_foldAngle"].filter((n=>e[n]&&e[n][t]!==undefined)).forEach((s=>{n[s]=e[s][t]}))));return r};const uo=(e,t,n,s=a)=>{if(e.edges_vertices.length<t){return{}}const r=e.edges_vertices[t];if(!n){n=P(...r)}const o=r.map((t=>e.vertices_coords[t])).map((e=>B(e,n)<s));if(o[0]){return{vertex:r[0],edges:{}}}if(o[1]){return{vertex:r[1],edges:{}}}const c=e.vertices_coords.length;e.vertices_coords[c]=n;const i=[0,1].map((t=>t+e.edges_vertices.length));lo(e,t,c).forEach(((t,n)=>Object.keys(t).forEach((s=>{e[s][i[n]]=t[s]}))));so(e,c,r);ro(e,c);oo(e,t,c,r,i);const f=no(e,t);if(f){co(e,c,f);ao(e,i,f);io(e,c,r,f);fo(e,f)}const l=dn(e,"edges",[t]);i.forEach(((e,t)=>{i[t]=l[i[t]]}));l.splice(-2);l[t]=i;return{vertex:c,edges:{map:l,new:i,remove:t}}};const mo=({vertices_coords:e},t,n)=>{const s=t.map((t=>e[t])).reverse();return{edges_vertices:[...t],edges_foldAngle:0,edges_assignment:"U",edges_length:B(...s),edges_vector:w(...s),edges_faces:[n,n]}};const go=(e,t,n)=>{const s=e.edges_vertices.length;const r=mo(e,n,t);Object.keys(r).filter((t=>e[t]!==undefined)).forEach((t=>{e[t][s]=r[t]}));return s};const po=({edges_vertices:e,faces_vertices:t,faces_edges:n},s,r)=>{const o=r.map((e=>t[s].indexOf(e)));const c=en(t[s],o).map((e=>({faces_vertices:e})));if(n){const t=hs({edges_vertices:e});c.map((e=>e.faces_vertices.map(((e,t,n)=>`${e} ${n[(t+1)%n.length]}`)).map((e=>t[e])))).forEach(((e,t)=>{c[t].faces_edges=e}))}return c};const _o=(e,t,n)=>{const s=[0,1].map((t=>e.faces_vertices.length+t));po(e,t,n).forEach(((t,n)=>Object.keys(t).forEach((r=>{e[r][s[n]]=t[r]}))));return s};const ho=(e,{vertices:t,edges:n})=>{let s;const r=n.map((t=>{const n=uo(e,s?s[t.edge]:t.edge,t.coords);s=s?Ys(s,n.edges.map):n.edges.map;return n}));t.push(...r.map((e=>e.vertex)));let o;r.forEach((e=>{e.edges.remove=o?o[e.edges.remove]:e.edges.remove;const t=tr(e.edges.map);o=o?Ks(o,t):t}));return{vertices:t,edges:{map:s,remove:r.map((e=>e.edges.remove))}}};const vo=({vertices_coords:e,vertices_vertices:t,edges_vertices:n},s)=>{const r=n[s][0];const o=n[s][1];t[r]=ss({vertices_coords:e},t[r].concat(o),r);t[o]=ss({vertices_coords:e},t[o].concat(r),o)};const bo=({edges_vertices:e,vertices_edges:t,vertices_vertices:n},s)=>{if(!t||!n){return}const r=e[s];r.map((e=>n[e])).map(((e,t)=>e.indexOf(r[(t+1)%r.length]))).forEach(((e,n)=>t[r[n]].splice(e,0,s)))};const yo=(e,t,s)=>{const r={};s.forEach((t=>e.faces_vertices[t].forEach((e=>{if(!r[e]){r[e]=[]}r[e].push(t)}))));e.faces_vertices[t].forEach((s=>{const o=e.vertices_faces[s].indexOf(t);const c=r[s];if(o===-1||!c){throw new Error(n.convexFace)}e.vertices_faces[s].splice(o,1,...c)}))};const Eo=(e,t,s,r)=>{const o={};r.forEach((t=>e.faces_edges[t].forEach((e=>{if(!o[e]){o[e]=[]}o[e].push(t)}))));const c=[...e.faces_edges[t],s];c.forEach((s=>{const r=o[s];const c=[];for(let n=0;n<e.edges_faces[s].length;n+=1){if(e.edges_faces[s][n]===t){c.push(n)}}if(c.length===0||!r){throw new Error(n.convexFace)}c.reverse().forEach((t=>e.edges_faces[s].splice(t,1)));const a=c[c.length-1];e.edges_faces[s].splice(a,0,...r)}))};const Ao=({faces_vertices:e,faces_faces:t},n,s)=>{const r=t[n];const o=s.map((t=>e[t]));const c=r.map((t=>{const n=e[t];const r=[0,0];for(let e=0;e<o.length;e+=1){let t=0;for(let s=0;s<n.length;s+=1){if(o[e].indexOf(n[s])!==-1){t+=1}}r[e]=t}if(r[0]>=2){return s[0]}if(r[1]>=2){return s[1]}}));s.forEach(((e,n,r)=>{t[e]=[r[(n+1)%s.length]]}));r.forEach(((e,s)=>{for(let r=0;r<t[e].length;r+=1){if(t[e][r]===n){t[e][r]=c[s];t[c[s]].push(e)}}}))};const xo=()=>0;const Mo=(e,t)=>e<-t?-1:0;const ko=(e,t)=>e<-t?-1:e>1+t?1:0;const wo=({vertices_coords:e,faces_vertices:t},{vector:n,origin:s},r=xo,o=a)=>{const c=C(n,n);const i=v(n);const f=e.map((e=>O(e,s))).map((e=>v(e))).map((e=>T(i,e))).map((e=>Math.abs(e)<o?0:Math.sign(e)));const l=e.map((e=>O(e,s))).map((e=>C(e,n))).map((e=>e/c)).map((e=>r(e,o)));const d=t.map((e=>e.map((e=>f[e])).map(((e,t,n)=>e===n[0])).reduce(((e,t)=>e&&t),true))).map((e=>!e));const u=t.map((e=>e.map((e=>l[e])).map(((e,t,n)=>e===n[0])).reduce(((e,t)=>e&&t),true))).map((e=>!e)).map(((e,n)=>e||l[t[n][0]]===0));return t.map(((e,t)=>t)).filter((e=>d[e]&&u[e]))};const Oo=(e,{vector:t,origin:n},s=a)=>wo(e,{vector:t,origin:n},xo,s);const jo=(e,{vector:t,origin:n},s=a)=>wo(e,{vector:t,origin:n},Mo,s);const Fo=(e,t,n=a)=>{const s=O(t[1],t[0]);const r=t[0];return wo(e,{vector:s,origin:r},ko,n)};const Co=({vertices_coords:e,edges_vertices:t,faces_vertices:n,faces_edges:s},r,{vector:o,origin:c},i=a)=>{const f=n[r].map((t=>e[t])).map((e=>pr({vector:o,origin:c},e,(()=>true),i))).map(((e,t)=>e?t:undefined)).filter((e=>e!==undefined));const l=f.map((e=>n[r][e]));const d=f.concat(f.map((e=>e+n[r].length))).map(((e,t,n)=>n[t+1]-e===1)).reduce(((e,t)=>e||t),false);if(d){return undefined}if(l.length>1){return{vertices:l,edges:[]}}const u=s[r].map((n=>t[n].map((t=>e[t])))).map((e=>Tr({vector:o,origin:c},{vector:O(e[1],e[0]),origin:e[0]},rt,ft,i))).map(((e,t)=>({coords:e,edge:s[r][t]}))).filter((e=>e.coords!==undefined)).filter((e=>!l.map((n=>t[e.edge].includes(n))).reduce(((e,t)=>e||t),false)));return u.length+l.length===2?{vertices:l,edges:u}:undefined};const So=Object.freeze({__proto__:null,facesLineTypeOverlap:wo,getFacesLineOverlap:Oo,getFacesRayOverlap:jo,getFacesSegmentOverlap:Fo,intersectConvexFaceLine:Co});const Po=(e,t,n,s)=>{const r=Co(e,t,n,s);if(r===undefined){return undefined}const o=ho(e,r);o.edges.new=go(e,t,o.vertices);vo(e,o.edges.new);bo(e,o.edges.new);const c=_o(e,t,o.vertices);yo(e,t,c);Eo(e,t,o.edges.new,c);Ao(e,t,c);const a=dn(e,"faces",[t]);c.forEach(((e,t)=>{c[t]=a[c[t]]}));a.splice(-2);a[t]=c;o.faces={map:a,new:c,remove:t};return o};const No=(e,t)=>{const n={};t.forEach((e=>{n[e]=true}));const s=[];t.forEach((t=>{s[t]=e[t].filter((e=>n[e]))}));return s};const Vo=(e,t={})=>{if(!t.vertices){t.vertices=[]}if(!t.edges){t.edges=[]}if(!t.faces){t.faces=[]}const n=["faces","edges","vertices"];const s={};n.forEach((e=>{s[e]={}}));n.forEach((e=>t[e].forEach((t=>{s[e][t]=true}))));const r={};n.forEach((t=>{Ct(e,t).forEach((e=>{r[e]={}}));St(e,t).forEach((e=>{r[e]={}}))}));n.forEach((t=>{Ct(e,t).forEach((e=>{r[e].prefix=t}));St(e,t).forEach((e=>{r[e].suffix=t}))}));const o={...e};gt.graph.forEach((e=>delete o[e]));delete o.file_frames;Object.keys(r).forEach((e=>{o[e]=[]}));Object.keys(r).forEach((n=>{const{prefix:c,suffix:a}=r[n];if(c&&a){t[c].forEach((t=>{o[n][t]=e[n][t].filter((e=>s[a][e]))}))}else if(c){t[c].forEach((t=>{o[n][t]=e[n][t]}))}else if(a){o[n]=e[n].map((e=>e.filter((e=>s[a][e]))))}else{o[n]=e[n]}}));return o};const zo=(e,t)=>{let n=[];if(e.faces_vertices){n=Kt(t.flatMap((t=>e.faces_vertices[t])))}let s=[];if(e.faces_edges){s=Kt(t.flatMap((t=>e.faces_edges[t])))}else if(e.edges_vertices){const t={};n.forEach((e=>{t[e]=true}));s=e.edges_vertices.map(((e,n)=>t[e[0]]&&t[e[1]]?n:undefined)).filter((e=>e!==undefined))}return Vo(e,{faces:t,edges:s,vertices:n})};const $o=Object.freeze({__proto__:null,selfRelationalArraySubset:No,subgraph:Vo,subgraphWithFaces:zo});const To=e=>{const t={vertices:Zt.vertices(e),edges:Zt.edges(e),faces:Zt.faces(e)};const n={vertices:qn.vertices(e),edges:qn.edges(e),faces:qn.faces(e)};return{vertices:t.vertices>=n.vertices,edges:t.edges>=n.edges,faces:t.faces>=n.faces}};const Lo=(e,t)=>{const n=qs(e);const s=Gs(e);const r=gn(e);const o=an(e,t);const c=To(e);const a=n.length===0&&s.length===0&&r.length===0&&c.vertices&&c.edges&&c.faces;const i=a?"valid":"problematic";return{summary:i,vertices:{isolated:r,duplicate:o,references:c.vertices},edges:{circular:s,duplicate:n,references:c.edges},faces:{references:c.faces}}};const Bo=({vertices_coords:e},t)=>Ye(e,t);const Io=({edges_vertices:e,edges_assignment:t})=>Yt(e.filter(((e,n)=>t[n]==="B"||t[n]==="b")).flat());const Ro=()=>({vertices:[],edges:[],polygon:[]});const Uo=({vertices_coords:e,vertices_edges:t,edges_vertices:n,edges_assignment:s})=>{if(!s||!n){return Ro()}if(!t){t=fs({edges_vertices:n})}const r=s.map((e=>e==="B"||e==="b"));const o=[];const c=[];let a=-1;for(let e=0;e<r.length;e+=1){if(r[e]){a=e;break}}if(a===-1){return Ro()}r[a]=false;o.push(a);c.push(n[a][0]);let i=n[a][1];while(c[0]!==i){c.push(i);a=t[i].filter((e=>r[e])).shift();if(a===undefined){return Ro()}if(n[a][0]===i){[,i]=n[a]}else{[i]=n[a]}r[a]=false;o.push(a)}return{vertices:c,edges:o,polygon:e?c.map((t=>e[t])):[]}};const qo=({vertices_coords:e,vertices_edges:t,vertices_vertices:s,edges_vertices:r},o=true)=>{if(!s){s=ms({vertices_coords:e,vertices_edges:t,edges_vertices:r})}const c=hs({edges_vertices:r});const a=[];const i=[];const f={vertices:i,edges:a};let l=-Infinity;let d=-1;e.forEach(((e,t)=>{if(e[0]>l){l=e[0];d=t}}));if(d===-1){return f}i.push(d);const u=e[d];const m=s[d];if(!m){return f}const g=m.map((t=>e[t])).map((e=>[e[0]-u[0],e[1]-u[1]])).map((e=>Math.atan2(e[1],e[0]))).map((e=>e<0?e+Math.PI*2:e)).map(((e,t)=>({a:e,i:t}))).sort(((e,t)=>e.a-t.a)).shift().i;const p=m[g];const _=d<p?`${d} ${p}`:`${p} ${d}`;const h=c[_];a.push(h);let v=d;let b=p;const y=performance.now();const E=1e4;let A=0;while(true){const e=s[b];const t=e.indexOf(v);const r=(t+1)%e.length;const l=e[r];const d=b<l?`${b} ${l}`:`${l} ${b}`;const u=c[d];if(u===a[0]){return f}i.push(b);a.push(u);v=b;b=l;A+=1;if(o&&A%1e3===0&&performance.now()-y>E){throw new Error(n.planarBoundary)}}};const Do=Object.freeze({__proto__:null,boundary:Uo,boundaryVertices:Io,boundingBox:Bo,planarBoundary:qo});const Wo=(e,t)=>{const n={};t.forEach((e=>{n[e]=true}));const s=e.map((e=>!!n[e]));const r=[];const o=s.indexOf(false);const c={};for(let t=o+1;t<s.length;t+=1){if(s[t]&&!c[e[t]]){r.push(e[t]);c[e[t]]=true}}for(let t=0;t<o;t+=1){if(s[t]&&!c[e[t]]){r.push(e[t]);c[e[t]]=true}}return r};const Go=({faces_vertices:e,faces_faces:t},n=0)=>{if(!t){t=Ts({faces_vertices:e})}if(t.length===0){return[]}const s=[[{face:n}]];const r={};r[n]=true;do{const n=s[s.length-1].map((e=>t[e.face].map((t=>({face:t,parent:e.face}))))).reduce(((e,t)=>e.concat(t)),[]);const o={};n.forEach(((e,t)=>{if(r[e.face]){o[t]=true}r[e.face]=true}));const c=n.filter(((e,t)=>!o[t]));c.map((t=>Wo(e[t.face],e[t.parent]))).forEach(((e,t)=>{const n=e.slice(0,2);c[t].edge_vertices=n}));s[s.length]=c}while(s[s.length-1].length>0);if(s.length>0&&s[s.length-1].length===0){s.pop()}return s};const Ho=Object.freeze({__proto__:null,getFaceFaceSharedVertices:Wo,makeFaceSpanningTree:Go});const Jo=({vertices_coords:e,vertices_faces:t,faces_vertices:n},s)=>{if(!t){t=_s({faces_vertices:n})}const r=t.map((e=>e.filter((e=>e!=null)).shift())).map((e=>e===undefined?K:s[e]));return e.map(((e,t)=>ee(r[t],e)))};const Qo={U:true,u:true};const Zo=({vertices_coords:e,edges_vertices:t,edges_foldAngle:n,edges_assignment:s,faces_vertices:r,faces_faces:o},c=0)=>{if(!s&&n){s=ws({edges_foldAngle:n})}if(!n){if(s){n=js({edges_assignment:s})}else{n=Array(t.length).fill(0)}}const a=hs({edges_vertices:t});const i=r.map((()=>ue));Go({faces_vertices:r,faces_faces:o},c).slice(1).forEach((t=>t.forEach((t=>{const r=t.edge_vertices.map((t=>e[t]));const o=t.edge_vertices.join(" ");const c=a[o];const f=Qo[s[c]]?Math.PI:n[c]*Math.PI/180;const l=Me(f,w(...Z(r[1],r[0])),r[0]);i[t.face]=_e(i[t.parent],l)}))));return i};const Yo=({vertices_coords:e,edges_vertices:t,edges_foldAngle:n,edges_assignment:s,faces_vertices:r,faces_faces:o},c=0)=>{if(!n){if(s){n=js({edges_assignment:s})}else{n=Array(t.length).fill(0)}}const a=Tt({edges_vertices:t,edges_foldAngle:n,edges_assignment:s});const i=hs({edges_vertices:t});const f=r.map((()=>K));Go({faces_vertices:r,faces_faces:o},c).slice(1).forEach((t=>t.forEach((t=>{const n=t.edge_vertices.map((t=>e[t]));const s=t.edge_vertices.join(" ");const r=i[s];const o=O(n[1],n[0]);const c=n[0];const l=a[r]?fe(o,c):K;f[t.face]=ne(f[t.parent],l)}))));return f};const Xo=Object.freeze({__proto__:null,makeFacesMatrix:Zo,makeFacesMatrix2:Yo,multiplyVerticesFacesMatrix2:Jo});const Ko=({vertices_coords:e,vertices_faces:t,edges_vertices:n,edges_foldAngle:s,edges_assignment:r,faces_vertices:o,faces_faces:c,faces_matrix:a},i)=>{a=Zo({vertices_coords:e,edges_vertices:n,edges_foldAngle:s,edges_assignment:r,faces_vertices:o,faces_faces:c},i);if(!t){t=_s({faces_vertices:o})}const f=t.map((e=>e.filter((e=>e!=null)).shift())).map((e=>e===undefined?ue:a[e]));return e.map((e=>Q(3,e))).map(((e,t)=>ge(f[t],e)))};const ec=({vertices_coords:e,edges_vertices:t,edges_foldAngle:n,edges_assignment:s,faces_vertices:r,faces_faces:o},c=0)=>{const a=Tt({edges_vertices:t,edges_foldAngle:n,edges_assignment:s});const i=[];r[c].forEach((t=>{i[t]=[...e[t]]}));const f=[];f[c]=false;const l=hs({edges_vertices:t});Go({faces_vertices:r,faces_faces:o},c).slice(1).forEach((n=>n.forEach((n=>{const s=n.edge_vertices.join(" ");const o=l[s];const c=t[o].map((e=>i[e]));if(c[0]===undefined||c[1]===undefined){return}const d=t[o].map((t=>e[t]));const u=d[0];const m=v(O(d[1],d[0]));const g=q(m);f[n.face]=a[o]?!f[n.parent]:f[n.parent];const p=v(O(c[1],c[0]));const _=c[0];const h=f[n.face]?D(p):q(p);r[n.face].filter((e=>i[e]===undefined)).forEach((t=>{const n=O(e[t],u);const s=F(n,g);const r=F(n,m);const o=E(p,r);const c=E(h,s);const a=M(M(_,o),c);i[t]=a}))}))));return i};const tc=Object.freeze({__proto__:null,makeVerticesCoordsFlatFolded:ec,makeVerticesCoordsFolded:Ko});const nc="class";const sc="function";const rc="undefined";const oc="boolean";const cc="number";const ac="string";const ic="object";const fc="svg";const lc="path";const dc="id";const uc="style";const mc="viewBox";const gc="transform";const pc="points";const _c="stroke";const hc="fill";const vc="none";const bc="arrow";const yc="head";const Ec="tail";const Ac=typeof window!==rc&&typeof window.document!==rc;typeof process!==rc&&process.versions!=null&&process.versions.node!=null;const xc={window:"window not set; svg.window = @xmldom/xmldom"};const Mc={window:undefined};const kc=e=>(new e.DOMParser).parseFromString("<!DOCTYPE html><title>.</title>","text/html");const wc=e=>{if(!e.document){e.document=kc(e)}Mc.window=e;return Mc.window};if(Ac){Mc.window=window}const Oc=()=>{if(Mc.window===undefined){throw xc.window}return Mc.window};const jc="http://www.w3.org/2000/svg";const Fc={presentation:["color","color-interpolation","cursor","direction","display","fill","fill-opacity","fill-rule","font-family","font-size","font-size-adjust","font-stretch","font-style","font-variant","font-weight","image-rendering","letter-spacing","opacity","overflow","paint-order","pointer-events","preserveAspectRatio","shape-rendering","stroke","stroke-dasharray","stroke-dashoffset","stroke-linecap","stroke-linejoin","stroke-miterlimit","stroke-opacity","stroke-width","tabindex","transform-origin","user-select","vector-effect","visibility"],animation:["accumulate","additive","attributeName","begin","by","calcMode","dur","end","from","keyPoints","keySplines","keyTimes","max","min","repeatCount","repeatDur","restart","to","values"],effects:["azimuth","baseFrequency","bias","color-interpolation-filters","diffuseConstant","divisor","edgeMode","elevation","exponent","filter","filterRes","filterUnits","flood-color","flood-opacity","in","in2","intercept","k1","k2","k3","k4","kernelMatrix","lighting-color","limitingConeAngle","mode","numOctaves","operator","order","pointsAtX","pointsAtY","pointsAtZ","preserveAlpha","primitiveUnits","radius","result","seed","specularConstant","specularExponent","stdDeviation","stitchTiles","surfaceScale","targetX","targetY","type","xChannelSelector","yChannelSelector"],text:["dx","dy","alignment-baseline","baseline-shift","dominant-baseline","lengthAdjust","method","overline-position","overline-thickness","rotate","spacing","startOffset","strikethrough-position","strikethrough-thickness","text-anchor","text-decoration","text-rendering","textLength","underline-position","underline-thickness","word-spacing","writing-mode"],gradient:["gradientTransform","gradientUnits","spreadMethod"]};const Cc={svg:["svg"],defs:["defs"],header:["desc","filter","metadata","style","script","title","view"],cdata:["cdata"],group:["g"],visible:["circle","ellipse","line","path","polygon","polyline","rect","arc","arrow","curve","parabola","roundRect","wedge","origami"],text:["text"],invisible:["marker","symbol","clipPath","mask"],patterns:["linearGradient","radialGradient","pattern"],childrenOfText:["textPath","tspan"],gradients:["stop"],filter:["feBlend","feColorMatrix","feComponentTransfer","feComposite","feConvolveMatrix","feDiffuseLighting","feDisplacementMap","feDistantLight","feDropShadow","feFlood","feFuncA","feFuncB","feFuncG","feFuncR","feGaussianBlur","feImage","feMerge","feMergeNode","feMorphology","feOffset","fePointLight","feSpecularLighting","feSpotLight","feTile","feTurbulence"]};const Sc={svg:[mc],line:["x1","y1","x2","y2"],rect:["x","y","width","height"],circle:["cx","cy","r"],ellipse:["cx","cy","rx","ry"],polygon:[pc],polyline:[pc],path:["d"],text:["x","y"],mask:[dc],symbol:[dc],clipPath:[dc,"clip-rule"],marker:[dc,"markerHeight","markerUnits","markerWidth","orient","refX","refY"],linearGradient:["x1","x2","y1","y2"],radialGradient:["cx","cy","r","fr","fx","fy"],stop:["offset","stop-color","stop-opacity"],pattern:["patternContentUnits","patternTransform","patternUnits"]};const Pc=[{nodes:[fc,"defs","g"].concat(Cc.visible,Cc.text),attr:Fc.presentation},{nodes:["filter"],attr:Fc.effects},{nodes:Cc.childrenOfText.concat("text"),attr:Fc.text},{nodes:Cc.filter,attr:Fc.effects},{nodes:Cc.gradients,attr:Fc.gradient}];Pc.forEach((e=>e.nodes.forEach((t=>{if(!Sc[t]){Sc[t]=[]}Sc[t].push(...e.attr)}))));const Nc=[Cc.header,Cc.invisible,Cc.patterns].flat();const Vc=[Cc.group,Cc.visible,Cc.text].flat();const zc={svg:[["svg","defs"],Nc,Vc].flat(),defs:Nc,filter:Cc.filter,g:Vc,text:Cc.childrenOfText,marker:Vc,symbol:Vc,clipPath:Vc,mask:Vc,linearGradient:Cc.gradients,radialGradient:Cc.gradients};const $c=Object.values(Cc).flat();const Tc={black:"#000000",silver:"#c0c0c0",gray:"#808080",white:"#ffffff",maroon:"#800000",red:"#ff0000",purple:"#800080",fuchsia:"#ff00ff",green:"#008000",lime:"#00ff00",olive:"#808000",yellow:"#ffff00",navy:"#000080",blue:"#0000ff",teal:"#008080",aqua:"#00ffff",orange:"#ffa500",aliceblue:"#f0f8ff",antiquewhite:"#faebd7",aquamarine:"#7fffd4",azure:"#f0ffff",beige:"#f5f5dc",bisque:"#ffe4c4",blanchedalmond:"#ffebcd",blueviolet:"#8a2be2",brown:"#a52a2a",burlywood:"#deb887",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",cornflowerblue:"#6495ed",cornsilk:"#fff8dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",darkkhaki:"#bdb76b",darkmagenta:"#8b008b",darkolivegreen:"#556b2f",darkorange:"#ff8c00",darkorchid:"#9932cc",darkred:"#8b0000",darksalmon:"#e9967a",darkseagreen:"#8fbc8f",darkslateblue:"#483d8b",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",darkturquoise:"#00ced1",darkviolet:"#9400d3",deeppink:"#ff1493",deepskyblue:"#00bfff",dimgray:"#696969",dimgrey:"#696969",dodgerblue:"#1e90ff",firebrick:"#b22222",floralwhite:"#fffaf0",forestgreen:"#228b22",gainsboro:"#dcdcdc",ghostwhite:"#f8f8ff",gold:"#ffd700",goldenrod:"#daa520",greenyellow:"#adff2f",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",indianred:"#cd5c5c",indigo:"#4b0082",ivory:"#fffff0",khaki:"#f0e68c",lavender:"#e6e6fa",lavenderblush:"#fff0f5",lawngreen:"#7cfc00",lemonchiffon:"#fffacd",lightblue:"#add8e6",lightcoral:"#f08080",lightcyan:"#e0ffff",lightgoldenrodyellow:"#fafad2",lightgray:"#d3d3d3",lightgreen:"#90ee90",lightgrey:"#d3d3d3",lightpink:"#ffb6c1",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",lightskyblue:"#87cefa",lightslategray:"#778899",lightslategrey:"#778899",lightsteelblue:"#b0c4de",lightyellow:"#ffffe0",limegreen:"#32cd32",linen:"#faf0e6",magenta:"#ff00ff",mediumaquamarine:"#66cdaa",mediumblue:"#0000cd",mediumorchid:"#ba55d3",mediumpurple:"#9370db",mediumseagreen:"#3cb371",mediumslateblue:"#7b68ee",mediumspringgreen:"#00fa9a",mediumturquoise:"#48d1cc",mediumvioletred:"#c71585",midnightblue:"#191970",mintcream:"#f5fffa",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",navajowhite:"#ffdead",oldlace:"#fdf5e6",olivedrab:"#6b8e23",orangered:"#ff4500",orchid:"#da70d6",palegoldenrod:"#eee8aa",palegreen:"#98fb98",paleturquoise:"#afeeee",palevioletred:"#db7093",papayawhip:"#ffefd5",peachpuff:"#ffdab9",peru:"#cd853f",pink:"#ffc0cb",plum:"#dda0dd",powderblue:"#b0e0e6",rosybrown:"#bc8f8f",royalblue:"#4169e1",saddlebrown:"#8b4513",salmon:"#fa8072",sandybrown:"#f4a460",seagreen:"#2e8b57",seashell:"#fff5ee",sienna:"#a0522d",skyblue:"#87ceeb",slateblue:"#6a5acd",slategray:"#708090",slategrey:"#708090",snow:"#fffafa",springgreen:"#00ff7f",steelblue:"#4682b4",tan:"#d2b48c",thistle:"#d8bfd8",tomato:"#ff6347",turquoise:"#40e0d0",violet:"#ee82ee",wheat:"#f5deb3",whitesmoke:"#f5f5f5",yellowgreen:"#9acd32"};const Lc=(e,t,n)=>{const s=t/100;const r=n/100;const o=t=>(t+e/30)%12;const c=s*Math.min(r,1-r);const a=e=>r-c*Math.max(-1,Math.min(o(e)-3,Math.min(9-o(e),1)));return[a(0)*255,a(8)*255,a(4)*255]};const Bc=(e,t)=>{const n=Array.from(Array(t.length)).map(((t,n)=>e[n]||"0"));return e.length<=4?t.map((e=>n[e])).join(""):n.join("")};const Ic=e=>{const t=e.replace(/#(?=\S)/g,"");const n=t.length===4||t.length===8;const s=n?Bc(t,[0,0,1,1,2,2,3,3]):Bc(t,[0,0,1,1,2,2]);const r=parseInt(s,16);return n?[r>>24&255,r>>16&255,r>>8&255,r&255]:[r>>16&255,r>>8&255,r&255]};const Rc=(e,t,n,s)=>{const r=e=>`00${Math.max(0,Math.min(Math.round(e),255)).toString(16)}`.slice(-2);const o=`#${[e,t,n].map(r).join("")}`;return s===undefined?o:`${o}${r(s*255)}`};const Uc=Object.freeze({__proto__:null,hexToRgb:Ic,hslToRgb:Lc,rgbToHex:Rc});const qc=e=>{const t=e.match(/\(([^\)]+)\)/g);if(t==null||!t.length){return[]}return t[0].substring(1,t[0].length-1).split(/[\s,]+/).map(parseFloat)};const Dc=e=>{if(Tc[e]){return Ic(Tc[e])}if(e[0]==="#"){return Ic(e)}if(e.substring(0,4)==="rgba"||e.substring(0,3)==="rgb"){const t=qc(e);[0,1,2].filter((e=>t[e]===undefined)).forEach((e=>{t[e]=0}));return t}if(e.substring(0,4)==="hsla"||e.substring(0,3)==="hsl"){const t=qc(e);[0,1,2].filter((e=>t[e]===undefined)).forEach((e=>{t[e]=0}));const n=Lc(...t);if(t.length===4){n.push(t[3])}return n}return undefined};const Wc=e=>{if(Tc[e]){return Tc[e].toUpperCase()}if(e[0]==="#"){return Rc(...Ic(e))}if(e.substring(0,4)==="rgba"||e.substring(0,3)==="rgb"){return Rc(...qc(e))}if(e.substring(0,4)==="hsla"||e.substring(0,3)==="hsl"){const t=qc(e);[0,1,2].filter((e=>t[e]===undefined)).forEach((e=>{t[e]=0}));const n=Lc(...t);if(t.length===4){n.push(t[3])}[0,1,2].forEach((e=>{n[e]*=255}));Rc(...n)}return undefined};const Gc=Object.freeze({__proto__:null,parseColorToHex:Wc,parseColorToRgb:Dc});const Hc={cssColors:Tc,...Uc,...Gc};const Jc=(e,t)=>[e[0]+t[0],e[1]+t[1]];const Qc=(e,t)=>[e[0]-t[0],e[1]-t[1]];const Zc=(e,t)=>[e[0]*t,e[1]*t];const Yc=e=>e[0]**2+e[1]**2;const Xc=e=>Math.sqrt(Yc(e));const Kc=(e,t)=>Yc(Qc(e,t));const ea=(e,t)=>Math.sqrt(Kc(e,t));const ta=(e,t)=>[Math.cos(e)*t,Math.sin(e)*t];const na=(e,t)=>[e[0]*t[0]+e[2]*t[1],e[1]*t[0]+e[3]*t[1],e[0]*t[2]+e[2]*t[3],e[1]*t[2]+e[3]*t[3],e[0]*t[4]+e[2]*t[5]+e[4],e[1]*t[4]+e[3]*t[5]+e[5]];const sa=Object.freeze({__proto__:null,svg_add2:Jc,svg_distance2:ea,svg_distanceSq2:Kc,svg_magnitude2:Xc,svg_magnitudeSq2:Yc,svg_multiplyMatrices2:na,svg_polar_to_cart:ta,svg_scale2:Zc,svg_sub2:Qc});const ra=function(e){const t=e.match(/(\w+\((\-?\d+\.?\d*e?\-?\d*,?\s*)+\))+/g);if(!t){return[]}const n=t.map((e=>e.match(/[\w\.\-]+/g)));return n.map((e=>({transform:e.shift(),parameters:e.map((e=>parseFloat(e)))})))};const oa=function(e){switch(e.length){case 1:return[1,0,0,1,e[0],0];case 2:return[1,0,0,1,e[0],e[1]];default:console.warn(`improper translate, ${e}`)}return undefined};const ca=function(e){const t=Math.cos(e[0]/(180*Math.PI));const n=Math.sin(e[0]/(180*Math.PI));switch(e.length){case 1:return[t,n,-n,t,0,0];case 3:return[t,n,-n,t,-e[1]*t+e[2]*n+e[1],-e[1]*n-e[2]*t+e[2]];default:console.warn(`improper rotate, ${e}`)}return undefined};const aa=function(e){switch(e.length){case 1:return[e[0],0,0,e[0],0,0];case 2:return[e[0],0,0,e[1],0,0];default:console.warn(`improper scale, ${e}`)}return undefined};const ia=function(e){return[1,0,Math.tan(e[0]/(180*Math.PI)),1,0,0]};const fa=function(e){return[1,Math.tan(e[0]/(180*Math.PI)),0,1,0,0]};const la=function(e,t){switch(e){case"translate":return oa(t);case"rotate":return ca(t);case"scale":return aa(t);case"skewX":return ia(t);case"skewY":return fa(t);case"matrix":return t;default:console.warn(`unknown transform type ${e}`)}return undefined};const da=function(e){return ra(e).map((e=>la(e.transform,e.parameters))).filter((e=>e!==undefined)).reduce(((e,t)=>na(e,t)),[1,0,0,1,0,0])};const ua=Object.freeze({__proto__:null,transformStringToMatrix:da});const ma=(e,t="text/xml")=>{const n=(new(Oc().DOMParser)).parseFromString(e,t);return n?n.documentElement:null};const ga=e=>{let t=e;while(t.parentNode!=null){t=t.parentNode}return t};const pa=(e,t)=>{if((e.nodeName||"")===t){return e}return e.parentNode?pa(e.parentNode,t):undefined};const _a=(e,...t)=>{const n={};const s=e.getAttribute("class");const r=s?s.split(" "):[];r.push(...t);r.forEach((e=>{n[e]=true}));const o=Object.keys(n).join(" ");e.setAttribute("class",o)};const ha=(e,...t)=>{if(!e||!t.length){return undefined}return e.classList?e.classList.add(...t):_a(e,...t)};const va=e=>e.children==null||!e.children.length?[e]:Array.from(e.children).flatMap((e=>va(e)));const ba={svg:["viewBox","xmlns","version"],line:["x1","y1","x2","y2"],rect:["x","y","width","height"],circle:["cx","cy","r"],ellipse:["cx","cy","rx","ry"],polygon:["points"],polyline:["points"],path:["d"]};const ya=e=>{const t=Array.from(e.attributes);return ba[e.nodeName]?t.filter((t=>!ba[e.nodeName].includes(t.name))):t};const Ea=e=>{const t={};e.forEach((e=>{t[e.nodeName]=e.value}));return t};const Aa=(e,t)=>{const n=Ea(ya(t));if(!n.transform&&!e.transform){return{...e,...n}}const s=n.transform||"";const r=e.transform||"";const o=da(s);const c=da(r);const a=na(c,o);const i=`matrix(${a.join(", ")})`;return{...e,...n,transform:i}};const xa=(e,t={})=>e.children==null||!e.children.length?[{element:e,attributes:t}]:Array.from(e.children).flatMap((e=>xa(e,Aa(t,e))));const Ma=Object.freeze({__proto__:null,addClass:ha,findElementTypeInParents:pa,flattenDomTree:va,flattenDomTreeWithStyle:xa,getRootParent:ga,xmlStringToElement:ma});const ka=e=>(new(Oc().DOMParser)).parseFromString("<root></root>","text/xml").createCDATASection(e);const wa=/[MmLlSsQqLlHhVvCcSsQqTtAaZz]/g;const Oa=/-?[0-9]*\.?\d+/g;const ja={m:"move",l:"line",v:"vertical",h:"horizontal",a:"ellipse",c:"curve",s:"smoothCurve",q:"quadCurve",t:"smoothQuadCurve",z:"close"};Object.keys(ja).forEach((e=>{const t=ja[e];ja[e.toUpperCase()]=t.charAt(0).toUpperCase()+t.slice(1)}));const Fa=(e,t)=>[e[0]+(t[0]||0),e[1]+(t[1]||0)];const Ca=(e,t,n=[0,0])=>{const s=e.toUpperCase();let r=e===s?[0,0]:n;if(e==="V"){r=[n[0],0]}if(e==="H"){r=[0,n[1]]}switch(s){case"V":return Fa(r,[0,t[0]]);case"H":return Fa(r,[t[0],0]);case"M":case"L":case"T":return Fa(r,t);case"A":return Fa(r,[t[5],t[6]]);case"C":return Fa(r,[t[4],t[5]]);case"S":case"Q":return Fa(r,[t[2],t[3]]);case"Z":return undefined;default:return r}};const Sa=e=>{const t=[];let n;while((n=wa.exec(e))!==null){t.push(n)}return t.map(((t,n,s)=>[t[0],t.index,n===s.length-1?e.length-1:s[(n+1)%s.length].index-1])).map((t=>{const n=t[0];const s=e.substring(t[1]+1,t[2]+1);const r=s.match(Oa);const o=r?r.map(parseFloat):[];return{command:n,values:o}}))};const Pa=e=>{let t=[0,0];const n=Sa(e);if(!n.length){return n}n.forEach(((e,s)=>{n[s].end=Ca(e.command,e.values,t);n[s].start=s===0?t:n[s-1].end;t=n[s].end}));const s=n[n.length-1];const r=n.filter((e=>e.command.toUpperCase()!=="M"&&e.command.toUpperCase()!=="Z")).shift();if(s.command.toUpperCase()==="Z"){s.end=[...r.start]}return n};const Na=Object.freeze({__proto__:null,parsePathCommands:Sa,parsePathCommandsWithEndpoints:Pa,pathCommandNames:ja});const Va=(...e)=>e.filter((e=>typeof e===cc)).concat(e.filter((e=>typeof e===ic&&e!==null)).map((e=>{if(typeof e.x===cc){return[e.x,e.y]}if(typeof e[0]===cc){return[e[0],e[1]]}return undefined})).filter((e=>e!==undefined)).reduce(((e,t)=>e.concat(t)),[]));const za=function(e,t,n,s,r=0){const o=1;const c=n/o-n;const a=e-c-r;const i=t-c-r;const f=n+c*2+r*2;const l=s+c*2+r*2;return[a,i,f,l].join(" ")};const $a=(...e)=>{const t=Va(...e.flat());if(t.length===2){t.unshift(0,0)}return t.length===4?za(...t):undefined};const Ta=(e,...t)=>{const n=t.length===1&&typeof t[0]===ac?t[0]:$a(...t);if(n){e.setAttribute(mc,n)}return e};const La=function(e){const t=e.getAttribute(mc);return t==null?undefined:t.split(" ").map((e=>parseFloat(e)))};const Ba=function(e,t,n){const s=e.createSVGPoint();s.x=t;s.y=n;const r=s.matrixTransform(e.getScreenCTM().inverse());return[r.x,r.y]};const Ia=Object.freeze({__proto__:null,convertToViewBox:Ba,getViewBox:La,setViewBox:Ta});const Ra={...sa,...Ma,makeCDATASection:ka,...Na,...ua,...Ia};const Ua=function(e){const t=La(e);if(t!==undefined){return t}if(typeof e.getBoundingClientRect===sc){const t=e.getBoundingClientRect();return[t.x,t.y,t.width,t.height]}return[]};const qa="svg-background-rectangle";const Da=function(e,t){let n=Array.from(e.childNodes).filter((e=>e.getAttribute(nc)===qa)).shift();if(n==null){n=Oc().document.createElementNS(jc,"rect");Ua(e).forEach(((e,t)=>n.setAttribute(Sc.rect[t],e)));n.setAttribute(nc,qa);n.setAttribute(_c,vc);e.insertBefore(n,e.firstChild)}n.setAttribute(hc,t);return e};const Wa=e=>{const t=e.getAttribute(gc);return t==null||t===""?undefined:t};const Ga={clearTransform:e=>{e.removeAttribute(gc);return e}};["translate","rotate","scale","matrix"].forEach((e=>{Ga[e]=(t,...n)=>{t.setAttribute(gc,[Wa(t),`${e}(${n.join(" ")})`].filter((e=>e!==undefined)).join(" "));return t}}));const Ha=e=>e.replace(/([-_][a-z])/gi,(e=>e.toUpperCase().replace("-","").replace("_","")));const Ja=e=>e.replace(/([a-z0-9])([A-Z])/g,"$1-$2").replace(/([A-Z])([A-Z])(?=[a-z])/g,"$1-$2").toLowerCase();const Qa=e=>e.charAt(0).toUpperCase()+e.slice(1);const Za=e=>{while(e.lastChild){e.removeChild(e.lastChild)}return e};const Ya=(e,t)=>{if(t&&t.appendChild){t.appendChild(e)}return e};const Xa=(e,t)=>{Object.keys(t).forEach((n=>e.setAttribute(Ja(n),t[n])));return e};const Ka=Object.freeze({__proto__:null,appendTo:Ya,removeChildren:Za,setAttributes:Xa});const ei=function(e,t){const n=La(e);if(n!==undefined){Ta(e,...[-t,-t,t*2,t*2].map(((e,t)=>n[t]+e)))}return e};const ti=function(e,t){const n=e.getElementsByTagName(t);return n.length?n[0]:null};const ni=function(e,t){let n=ti(e,uc);if(n==null){n=Oc().document.createElementNS(jc,uc);n.setTextContent=e=>{n.textContent="";n.appendChild(ka(e));return n};e.insertBefore(n,e.firstChild)}n.textContent="";n.appendChild(ka(t));return n};const si=e=>{Array.from(e.attributes).filter((e=>e.name!=="xmlns"&&e.name!=="version")).forEach((t=>e.removeAttribute(t.name)));return Za(e)};const ri={clear:si,size:Ta,setViewBox:Ta,getViewBox:La,padding:ei,background:Da,getWidth:e=>Ua(e)[2],getHeight:e=>Ua(e)[3],stylesheet:function(e,t){return ni.call(this,e,t)},...Ga,...Ka};const oi={move:["mousemove","touchmove"],press:["mousedown","touchstart"],release:["mouseup","touchend"],leave:["mouseleave","touchcancel"]};const ci=(e,t)=>Object.values(oi).flat().forEach((n=>{t[n].forEach((t=>e.removeEventListener(n,t)));t[n]=[]}));const ai=(e,t,n)=>Object.defineProperty(e,t,{get:()=>n,enumerable:true,configurable:true});const ii=function(e){const t=[];Object.keys(oi).forEach((e=>{oi[e].forEach((e=>{t[e]=[]}))}));const n=n=>oi[n].forEach((n=>t[n].forEach((t=>e.removeEventListener(n,t)))));Object.keys(oi).forEach((s=>{Object.defineProperty(e,`on${Qa(s)}`,{set:r=>{if(!e.addEventListener){return}if(r==null){n(s);return}oi[s].forEach((n=>{const s=t=>{const n=t.touches!=null?t.touches[0]:t;if(n!==undefined){const{clientX:s,clientY:r}=n;const[o,c]=Ba(e,s,r);ai(t,"x",o);ai(t,"y",c)}r(t)};t[n].push(s);e.addEventListener(n,s)}))},enumerable:true})}));Object.defineProperty(e,"off",{value:()=>ci(e,t)})};const fi=()=>Math.random().toString(36).replace(/[^a-z]+/g,"").concat("aaaaa").substr(0,5);const li=function(e){let t;let n=0;let s;const r={};const o=()=>{if(Oc().cancelAnimationFrame){Oc().cancelAnimationFrame(s)}Object.keys(r).forEach((e=>delete r[e]))};const c=e=>{o();if(!e||!Oc().requestAnimationFrame){return}t=performance.now();n=0;const c=fi();r[c]=o=>{const a=(o-t)*.001;e({time:a,frame:n});n+=1;if(r[c]){s=Oc().requestAnimationFrame(r[c])}};s=Oc().requestAnimationFrame(r[c])};Object.defineProperty(e,"play",{set:c,enumerable:true});Object.defineProperty(e,"stop",{value:o,enumerable:true})};const di=e=>e&&e.parentNode?e.parentNode.removeChild(e):undefined;const ui=[["cx","cy"],["x","y"]];const mi=function(e,t={}){const n=[0,0];const s={selected:false,svg:undefined,updatePosition:e=>e};const r=()=>{if(!s.svg){return}if(!s.svg.parentNode){e.appendChild(s.svg)}ui.filter((e=>s.svg[e[0]]!=null)).forEach((e=>e.forEach(((e,t)=>{s.svg.setAttribute(e,n[t])}))))};const o=new Proxy(n,{set:(e,t,n)=>{e[t]=n;r();return true}});const c=function(...e){Va(...e.flat()).forEach(((e,t)=>{n[t]=e}));r();if(typeof n.delegate===sc){n.delegate.apply(n.pointsContainer,[o,n.pointsContainer])}};n.delegate=undefined;n.setPosition=c;n.onMouseMove=e=>s.selected?c(s.updatePosition(e)):undefined;n.onMouseUp=()=>{s.selected=false};n.distance=e=>Math.sqrt(Kc(e,n));["x","y"].forEach(((e,t)=>Object.defineProperty(n,e,{get:()=>n[t],set:e=>{n[t]=e}})));[fc,"updatePosition","selected"].forEach((e=>Object.defineProperty(n,e,{get:()=>s[e],set:t=>{s[e]=t}})));Object.defineProperty(n,"remove",{value:()=>{di(s.svg);n.delegate=undefined}});return o};const gi=function(e,t,n){let s;let r;const o=Array.from(Array(t)).map((()=>mi(e,n)));const c=e=>typeof r===sc?r.call(o,e,s,o):undefined;o.forEach((e=>{e.delegate=c;e.pointsContainer=o}));const a=function(e){if(!(o.length>0)){return}s=o.map(((t,n)=>({i:n,d:Kc(t,[e.x,e.y])}))).sort(((e,t)=>e.d-t.d)).shift().i;o[s].selected=true};const i=function(e){o.forEach((t=>t.onMouseMove(e)))};const f=function(){o.forEach((e=>e.onMouseUp()));s=undefined};e.onPress=a;e.onMove=i;e.onRelease=f;Object.defineProperty(o,"selectedIndex",{get:()=>s});Object.defineProperty(o,"selected",{get:()=>o[s]});Object.defineProperty(o,"add",{value:t=>{o.push(mi(e,t))}});o.removeAll=()=>{while(o.length>0){o.pop().remove()}};const l={onChange:(e,t)=>{r=e;if(t===true){const t=o.length-1;e.call(o,o[t],t,o)}},position:e=>o.forEach(((t,n)=>t.setPosition(e.call(o,t,n,o)))),svg:e=>o.forEach(((t,n)=>{t.svg=e.call(o,t,n,o)}))};Object.keys(l).forEach((e=>{o[e]=function(){if(typeof arguments[0]===sc){l[e](...arguments)}return o}}));o.parent=function(e){if(e!=null&&e.appendChild!=null){o.forEach((t=>{e.appendChild(t.svg)}))}return o};return o};const pi=e=>{e.controls=(...t)=>gi.call(e,e,...t)};const _i={svg:{args:(...e)=>[$a(Va(...e))].filter((e=>e!=null)),methods:ri,init:(...e)=>{const t=Oc().document.createElementNS(jc,"svg");t.setAttribute("version","1.1");t.setAttribute("xmlns",jc);e.filter((e=>e!=null)).filter((e=>e.appendChild)).forEach((e=>e.appendChild(t)));ii(t);li(t);pi(t);return t}}};const hi=function(e){if(e==null){return""}if(typeof e===ac){return e.slice(0,3)==="url"?e:`url(#${e})`}if(e.getAttribute!=null){const t=e.getAttribute(dc);return`url(#${t})`}return""};const vi={};["clip-path","mask","symbol","marker-end","marker-mid","marker-start"].forEach((e=>{vi[Ha(e)]=(t,n)=>{t.setAttribute(e,hi(n));return t}}));const bi={g:{methods:{...Ga,...vi,...Ka}}};const yi=(e,t)=>{e.setAttribute(Sc.circle[2],t);return e};const Ei=(e,t,n)=>{[...Va(...[t,n].flat()).slice(0,2)].forEach(((t,n)=>e.setAttribute(Sc.circle[n],t)));return e};const Ai=(e,t,n,s)=>[e,t,ea([e,t],[n,s])];const xi={circle:{args:(e,t,n,s)=>{const r=Va(...[e,t,n,s].flat());switch(r.length){case 0:case 1:return[,,...r];case 2:case 3:return r;default:return Ai(...r)}},methods:{radius:yi,setRadius:yi,origin:Ei,setOrigin:Ei,center:Ei,setCenter:Ei,position:Ei,setPosition:Ei,...Ga,...vi,...Ka}}};const Mi=(e,t,n)=>{[,,t,n].forEach(((t,n)=>e.setAttribute(Sc.ellipse[n],t)));return e};const ki=(e,t,n)=>{[...Va(...[t,n].flat()).slice(0,2)].forEach(((t,n)=>e.setAttribute(Sc.ellipse[n],t)));return e};const wi={ellipse:{args:(e,t,n,s)=>{const r=Va(...[e,t,n,s].flat()).slice(0,4);switch(r.length){case 0:case 1:case 2:return[,,...r];default:return r}},methods:{radius:Mi,setRadius:Mi,origin:ki,setOrigin:ki,center:ki,setCenter:ki,position:ki,setPosition:ki,...Ga,...vi,...Ka}}};const Oi=e=>e!=null&&typeof e[Symbol.iterator]===sc;const ji=function(){switch(arguments.length){case 0:return Array.from(arguments);case 1:return Oi(arguments[0])&&typeof arguments[0]!==ac?ji(...arguments[0]):[arguments[0]];default:return Array.from(arguments).map((e=>Oi(e)?[...ji(e)]:e))}};const Fi=(...e)=>Va(...ji(...e)).slice(0,4);const Ci=(e,...t)=>{Fi(...t).forEach(((t,n)=>e.setAttribute(Sc.line[n],t)));return e};const Si={line:{args:Fi,methods:{setPoints:Ci,...Ga,...vi,...Ka}}};const Pi=e=>{const t=e.getAttribute("d");return t==null?"":t};const Ni=e=>{e.removeAttribute("d");return e};const Vi=(e,t,...n)=>{e.setAttribute("d",`${Pi(e)}${t}${n.flat().join(" ")}`);return e};const zi=e=>Sa(Pi(e));const $i={addCommand:Vi,appendCommand:Vi,clear:Ni,getCommands:zi,get:zi,getD:e=>e.getAttribute("d"),...Ga,...vi,...Ka};Object.keys(ja).forEach((e=>{$i[ja[e]]=(t,...n)=>Vi(t,e,...n)}));const Ti={path:{methods:$i}};const Li=(e,t,n)=>{[,,t,n].forEach(((t,n)=>e.setAttribute(Sc.rect[n],t)));return e};const Bi=(e,t,n)=>{[...Va(...[t,n].flat()).slice(0,2)].forEach(((t,n)=>e.setAttribute(Sc.rect[n],t)));return e};const Ii=function(e){[0,1].forEach((t=>{if(e[2+t]<0){if(e[0+t]===undefined){e[0+t]=0}e[0+t]+=e[2+t];e[2+t]=-e[2+t]}}));return e};const Ri={rect:{args:(e,t,n,s)=>{const r=Va(...[e,t,n,s].flat()).slice(0,4);switch(r.length){case 0:case 1:case 2:case 3:return Ii([,,...r]);default:return Ii(r)}},methods:{origin:Bi,setOrigin:Bi,center:Bi,setCenter:Bi,size:Li,setSize:Li,...Ga,...vi,...Ka}}};const Ui={style:{init:e=>{const t=Oc().document.createElementNS(jc,"style");t.setAttribute("type","text/css");t.textContent="";t.appendChild(ka(e));return t},methods:{setTextContent:(e,t)=>{e.textContent="";e.appendChild(ka(t));return e}}}};const qi={text:{args:(e,t,n)=>Va(...[e,t,n].flat()).slice(0,2),init:(e,t,n,s)=>{const r=Oc().document.createElementNS(jc,"text");const o=[e,t,n,s].filter((e=>typeof e===ac)).shift();r.appendChild(Oc().document.createTextNode(o||""));return r},methods:{...Ga,...vi,appendTo:Ya,setAttributes:Xa}}};const Di=function(){return Array.from(arguments).filter((e=>typeof e===ac||e instanceof String)).shift()||fi()};const Wi=(...e)=>[Di(...e)];const Gi={mask:{args:Wi,methods:{...Ga,...vi,...Ka}},clipPath:{args:Wi,methods:{...Ga,...vi,...Ka}},symbol:{args:Wi,methods:{...Ga,...vi,...Ka}},marker:{args:Wi,methods:{size:Ta,setViewBox:Ta,...Ga,...vi,...Ka}}};const Hi=e=>{const t=e.getAttribute(pc);return t==null?"":t};const Ji=function(){return Array.from(Array(Math.floor(arguments.length/2))).map(((e,t)=>`${arguments[t*2+0]},${arguments[t*2+1]}`)).join(" ")};const Qi=(...e)=>[Ji(...Va(...ji(...e)))];const Zi=(e,...t)=>{e.setAttribute(pc,Qi(...t)[0]);return e};const Yi=(e,...t)=>{e.setAttribute(pc,[Hi(e),Qi(...t)[0]].filter((e=>e!=="")).join(" "));return e};const Xi=function(...e){return e.length===1&&typeof e[0]===ac?[e[0]]:Qi(...e)};const Ki={polyline:{args:Xi,methods:{setPoints:Zi,addPoint:Yi,...Ga,...vi,...Ka}},polygon:{args:Xi,methods:{setPoints:Zi,addPoint:Yi,...Ga,...vi,...Ka}}};const ef=(e,t,n,s,r,o=false)=>{if(r==null){return""}const c=ta(s,n);const a=ta(r,n);const i=[a[0]-c[0],a[1]-c[1]];const f=c[0]*a[1]-c[1]*a[0];const l=c[0]*a[0]+c[1]*a[1];const d=Math.atan2(f,l)>0?0:1;let u=o?`M ${e},${t} l ${c[0]},${c[1]} `:`M ${e+c[0]},${t+c[1]} `;u+=["a ",n,n,0,d,1,i[0],i[1]].join(" ");if(o){u+=" Z"}return u};const tf=(e,t,n,s,r)=>[ef(e,t,n,s,r,false)];const nf={arc:{nodeName:lc,attributes:["d"],args:tf,methods:{setArc:(e,...t)=>e.setAttribute("d",tf(...t)),...Ga}}};const sf=[Ec,yc];const rf=e=>e.join(",");const of=e=>"M"+e.map((e=>e.join(","))).join("L")+"Z";const cf=function(e){let t=[[0,1],[2,3]].map((t=>t.map((t=>e.points[t]||0))));let n=Qc(t[1],t[0]);let s=Jc(t[0],Zc(n,.5));const r=Xc(n);const o=sf.map((t=>e[t].visible?(1+e[t].padding)*e[t].height*2.5:0)).reduce(((e,t)=>e+t),0);if(r<o){const e=r===0?[o,0]:Zc(n,o/r);t=[Qc,Jc].map((t=>t(s,Zc(e,.5))));n=Qc(t[1],t[0])}let c=[n[1],-n[0]];let a=Jc(s,Zc(c,e.bend));const i=t.map((e=>Qc(a,e)));const f=i.map((e=>Xc(e)));const l=i.map(((e,t)=>f[t]===0?e:Zc(e,1/f[t])));const d=l.map((e=>Zc(e,-1)));const u=d.map((e=>[e[1],-e[0]]));const m=sf.map(((t,n)=>e[t].padding?e[t].padding:e.padding?e.padding:0));const g=sf.map(((t,n)=>e[t].height*(e[t].visible?1:0))).map(((e,t)=>e+m[t]));const p=t.map(((e,t)=>Jc(e,Zc(l[t],g[t]))));n=Qc(p[1],p[0]);c=[n[1],-n[0]];s=Jc(p[0],Zc(n,.5));a=Jc(s,Zc(c,e.bend));const _=p.map(((t,n)=>Jc(t,Zc(Qc(a,t),e.pinch))));const h=sf.map(((t,n)=>[Jc(p[n],Zc(d[n],e[t].height)),Jc(p[n],Zc(u[n],e[t].width/2)),Jc(p[n],Zc(u[n],-e[t].width/2))]));return{line:`M${rf(p[0])}C${rf(_[0])},${rf(_[1])},${rf(p[1])}`,tail:of(h[0]),head:of(h[1])}};const af=(e,t,n)=>{if(typeof t===oc){e.options[n].visible=t}else if(typeof t===ic){Object.assign(e.options[n],t);if(t.visible==null){e.options[n].visible=true}}else if(t==null){e.options[n].visible=true}};const ff=(e,t={},n=yc)=>{const s=e.getElementsByClassName(`${bc}-${n}`)[0];Object.keys(t).map((e=>({key:e,fn:s[Ha(e)]}))).filter((e=>typeof e.fn===sc&&e.key!=="class")).forEach((e=>e.fn(t[e.key])));Object.keys(t).filter((e=>e==="class")).forEach((e=>s.classList.add(t[e])))};const lf=e=>{const t=cf(e.options);Object.keys(t).map((t=>({path:t,element:e.getElementsByClassName(`${bc}-${t}`)[0]}))).filter((e=>e.element)).map((e=>{e.element.setAttribute("d",t[e.path]);return e})).filter((t=>e.options[t.path])).forEach((t=>t.element.setAttribute("visibility",e.options[t.path].visible?"visible":"hidden")));return e};const df=(e,...t)=>{e.options.points=Va(...ji(...t)).slice(0,4);return lf(e)};const uf=(e,t)=>{e.options.bend=t;return lf(e)};const mf=(e,t)=>{e.options.pinch=t;return lf(e)};const gf=(e,t)=>{e.options.padding=t;return lf(e)};const pf=(e,t)=>{af(e,t,yc);ff(e,t,yc);return lf(e)};const _f=(e,t)=>{af(e,t,Ec);ff(e,t,Ec);return lf(e)};const hf=e=>e.getElementsByClassName(`${bc}-line`)[0];const vf=e=>e.getElementsByClassName(`${bc}-${yc}`)[0];const bf=e=>e.getElementsByClassName(`${bc}-${Ec}`)[0];const yf={setPoints:df,points:df,bend:uf,pinch:mf,padding:gf,head:pf,tail:_f,getLine:hf,getHead:vf,getTail:bf,...Ga};const Ef=()=>({visible:false,width:8,height:10,padding:0});const Af=()=>({head:Ef(),tail:Ef(),bend:0,padding:0,pinch:.618,points:[]});const xf=Object.keys(Af());const Mf=(...e)=>{for(let t=0;t<e.length;t+=1){if(typeof e[t]!==ic){continue}const n=Object.keys(e[t]);for(let s=0;s<n.length;s+=1){if(xf.includes(n[s])){return e[t]}}}return undefined};const kf=function(e,...t){e.classList.add(bc);const n=["line",Ec,yc].map((t=>{const n=Oc().document.createElementNS(jc,lc);n.className=`${bc}-${t}`;e.appendChild(n);return n}));n[0].setAttribute(uc,"fill:none;");n[1].setAttribute(_c,vc);n[2].setAttribute(_c,vc);e.options=Af();yf.setPoints(e,...t);const s=Mf(...t);if(s){Object.keys(s).filter((e=>yf[e])).forEach((t=>yf[t](e,s[t])))}return e};const wf={arrow:{nodeName:"g",attributes:[],args:()=>[],methods:yf,init:kf}};const Of=(e=[],t=0,n=.5)=>{const s=[e[0]||0,e[1]||0];const r=[e[2]||0,e[3]||0];const o=Qc(r,s);const c=Jc(s,Zc(o,.5));const a=[o[1],-o[0]];const i=Jc(c,Zc(a,t));const f=Jc(s,Zc(Qc(i,s),n));const l=Jc(r,Zc(Qc(i,r),n));return`M${s[0]},${s[1]}C${f[0]},${f[1]} ${l[0]},${l[1]} ${r[0]},${r[1]}`};const jf=(...e)=>[Of(Va(...e.flat()))];const Ff=e=>e.slice(1).split(/[, ]+/).map((e=>parseFloat(e)));const Cf=e=>e.match(/[Cc][(0-9), .-]+/).map((e=>Ff(e)));const Sf=e=>e.match(/[Mm][(0-9), .-]+/).map((e=>Ff(e)));const Pf=e=>{const t=Sf(e).shift();const n=Cf(e).shift();const s=t?[t[t.length-2],t[t.length-1]]:[0,0];const r=n?[n[n.length-2],n[n.length-1]]:[0,0];return[...s,...r]};const Nf=(e,...t)=>{const n=Va(...t.flat()).slice(0,4);e.setAttribute("d",Of(n,e._bend,e._pinch));return e};const Vf=(e,t)=>{e._bend=t;return Nf(e,...Pf(e.getAttribute("d")))};const zf=(e,t)=>{e._pinch=t;return Nf(e,...Pf(e.getAttribute("d")))};const $f={setPoints:Nf,bend:Vf,pinch:zf,...Ga};const Tf={curve:{nodeName:lc,attributes:["d"],args:jf,methods:$f}};const Lf=(e,t,n,s,r)=>[ef(e,t,n,s,r,true)];const Bf={wedge:{nodeName:lc,args:Lf,attributes:["d"],methods:{setArc:(e,...t)=>e.setAttribute("d",Lf(...t)),...Ga}}};const If={};const Rf=(e,...t)=>{const n=Oc().document.createElementNS(jc,"g");If.ear.convert.foldToSvg.render(e,n,...t);return n};const Uf={...Ga,...vi,...Ka};const qf={origami:{nodeName:"g",init:Rf,args:()=>[],methods:Uf}};const Df={..._i,...bi,...xi,...wi,...Si,...Ti,...Ri,...Ui,...qi,...Gi,...Ki,...nf,...wf,...Tf,...Bf,...qf};const Wf=(...e)=>e;const Gf=(e,t,...n)=>{const s=Df[e]&&Df[e].nodeName?Df[e].nodeName:e;const{init:r,args:o,methods:c}=Df[e]||{};const a=Sc[s]||[];const i=zc[s]||[];const f=r?r(...n):Oc().document.createElementNS(jc,s);if(t){t.appendChild(f)}const l=o||Wf;l(...n).forEach(((e,t)=>{f.setAttribute(Sc[s][t],e)}));if(c){Object.keys(c).forEach((e=>Object.defineProperty(f,e,{value:function(){return c[e](f,...arguments)}})))}a.forEach((e=>{const t=Ha(e);if(f[t]){return}Object.defineProperty(f,t,{value:function(){f.setAttribute(e,...arguments);return f}})}));i.forEach((e=>{if(f[e]){return}const t=function(){return Gf(e,f,...arguments)};Object.defineProperty(f,e,{value:t})}));return f};const Hf=(...e)=>{const t=Gf(fc,null,...e);const n=()=>e.filter((e=>typeof e===sc)).forEach((e=>e.call(t,t)));if(Oc().document.readyState==="loading"){Oc().document.addEventListener("DOMContentLoaded",n)}else{n()}return t};Object.assign(Hf,{NS:jc,nodes_attributes:Sc,nodes_children:zc,extensions:Df,...Hc,...Ra});$c.forEach((e=>{Hf[e]=(...t)=>Gf(e,null,...t)}));Object.defineProperty(Hf,"window",{enumerable:false,set:wc});const Jf=e=>[e.min,e.span].flatMap((e=>[e[0],e[1]])).join(" ");const Qf=e=>{const t=Bo(e);return t===undefined?"":Jf(t)};const Zf=({vertices_coords:e,edges_vertices:t,edges_length:n},s=.1)=>{if(!e||!t){return undefined}if(!n){n=Ps({vertices_coords:e,edges_vertices:t})}const r=n.slice().sort(((e,t)=>e-t));const o=Math.max(0,Math.min(Math.floor(r.length*s),r.length-1));return r[o]};const Yf={min:[0,0],span:[1,1]};const Xf=1/100;const Kf=(e,{vmax:t}={})=>{if(!t){const n=Bo(e)||Yf;t=Math.max(...n.span)}const n=Zf(e,.1);return n?n*Xf*10:t*Xf};const el=(e,t={})=>{const n=Hf.g();if(!e||!e.vertices_coords){return n}e.vertices_coords.map((e=>Hf.circle(e[0],e[1],.01))).forEach((e=>n.appendChild(e)));n.setAttributeNS(null,"fill","none");Object.keys(t).forEach((e=>n.setAttributeNS(null,e,t[e])));return n};const tl={};const nl={stroke:"black"};const sl={};const rl={B:{stroke:"black"},b:{stroke:"black"},M:{stroke:"crimson"},m:{stroke:"crimson"},V:{stroke:"royalblue"},v:{stroke:"royalblue"},F:{stroke:"lightgray"},f:{stroke:"lightgray"},J:{stroke:"gold"},j:{stroke:"gold"},C:{stroke:"limegreen"},c:{stroke:"limegreen"},U:{stroke:"orchid"},u:{stroke:"orchid"}};const ol=(e,t,n)=>e.setAttribute(`data-${t}`,n);const cl=e=>{const t={u:[],c:[],j:[],f:[],v:[],m:[],b:[]};const n=e["edges_assignment"].map((e=>e.toLowerCase()));e["edges_vertices"].map(((e,t)=>n[t]||"u")).forEach(((e,n)=>t[e].push(n)));return t};const al=({vertices_coords:e,edges_vertices:t})=>{if(!e||!t){return[]}return t.map((t=>t.map((t=>e[t]))))};const il=e=>`M${e[0][0]} ${e[0][1]}L${e[1][0]} ${e[1][1]}`;const fl=e=>al(e).map((e=>il(e))).join("");const ll=({vertices_coords:e,edges_vertices:t,edges_assignment:n})=>{if(!e||!t){return{}}if(!n){return{u:fl({vertices_coords:e,edges_vertices:t})}}const s=cl({vertices_coords:e,edges_vertices:t,edges_assignment:n});Object.keys(s).forEach((n=>{s[n]=fl({vertices_coords:e,edges_vertices:s[n].map((e=>t[e]))})}));Object.keys(s).forEach((e=>{if(s[e]===""){delete s[e]}}));return s};const dl=({vertices_coords:e,edges_vertices:t,edges_assignment:n})=>{const s=ll({vertices_coords:e,edges_vertices:t,edges_assignment:n});Object.keys(s).forEach((e=>{const t=Hf.path(s[e]);ha(t,At[e]);s[e]=t}));return s};const ul=(e,t={})=>Object.keys(t).forEach((n=>e.setAttributeNS(null,n,t[n])));const ml=(e,t={})=>{const n=Hf.g();if(!e){return n}const s=$t(e);const r=dl(e);Object.keys(r).forEach((e=>{ha(r[e],At[e]);ul(r[e],s?sl[e]:rl[e]);ul(r[e],t[e]);ul(r[e],t[At[e]]);n.appendChild(r[e]);Object.defineProperty(n,At[e],{get:()=>r[e]})}));Object.keys(r).forEach((e=>ol(r[e],"assignment",e)));Object.keys(r).forEach((e=>ol(r[e],"foldAngle",xt[e])));ul(n,s?tl:nl);ul(n,t.stroke?{stroke:t.stroke}:{});return n};const gl=e=>Math.abs(e)/180;const pl=(e,t={})=>{const n=Hf.g();if(!e){return n}const s=$t(e);const r=(e.edges_assignment?e.edges_assignment:Os(e)).map((e=>e.toLowerCase()));const o={};["b","m","v","f","j","c","u"].forEach((e=>{const r=Hf.g();n.appendChild(r);ha(r,At[e]);ul(r,s?sl[e]:rl[e]);ul(r,t[At[e]]);Object.defineProperty(n,At[e],{get:()=>r});o[e]=r}));const c=e.edges_vertices.map((t=>t.map((t=>e.vertices_coords[t])))).map((e=>Hf.line(e[0][0],e[0][1],e[1][0],e[1][1])));if(e.edges_foldAngle){e.edges_foldAngle.forEach(((e,t)=>ol(c[t],"foldAngle",e)))}if(e.edges_assignment){e.edges_assignment.forEach(((e,t)=>ol(c[t],"assignment",e)))}if(e.edges_foldAngle){c.forEach(((t,n)=>{const s=e.edges_foldAngle[n];if(s===0||s===180||s===-180){return}t.setAttributeNS(null,"opacity",gl(s))}))}c.forEach(((e,t)=>o[r[t]].appendChild(e)));ul(n,s?tl:nl);ul(n,t.stroke?{stroke:t.stroke}:{});return n};const _l=(e,t)=>jt(e)?ml(e,t):pl(e,t);const hl=e=>e.map((e=>e[0]*e[4]-e[1]*e[3])).map((e=>e>=0));const vl=e=>e.map((e=>e[0]*e[3]-e[1]*e[2])).map((e=>e>=0));const bl=({vertices_coords:e,faces_vertices:t})=>t.map((t=>t.map((t=>e[t])).map(((e,t,n)=>[e,n[(t+1)%n.length]])).map((e=>(e[1][0]-e[0][0])*(e[1][1]+e[0][1]))).reduce(((e,t)=>e+t),0))).map((e=>e<0));const yl=Object.freeze({__proto__:null,makeFacesWinding:bl,makeFacesWindingFromMatrix:hl,makeFacesWindingFromMatrix2:vl});const El=e=>{const t=Kt(e.flat());const n=[];t.forEach((e=>{n[e]=[]}));e.forEach((e=>{n[e[1]].push(e[0])}));const s=[];const r={};const o=e=>{if(r[e]){return}r[e]=true;n[e].forEach(o);s.push(e)};t.forEach(o);return s};const Al=Object.freeze({__proto__:null,topologicalSort:El});const xl=e=>{const t=[];const n=(s,r)=>{if(t[s]!==undefined){return 0}t[s]=r;e[s].forEach((e=>n(e,r)));return 1};for(let t=0,s=0;t<e.length;t+=1){if(!(t in e)){continue}s+=n(t,s)}return t};const Ml=(e,t)=>{const n={};t.forEach((e=>{n[e]=true}));return e.filter((e=>n[e[0]]&&n[e[1]]))};const kl=({vertices_coords:e,faces_vertices:t,faceOrders:n,faces_normal:s})=>{if(!n||!n.length){return[]}if(!s){s=cs({vertices_coords:e,faces_vertices:t})}const r=n.flatMap((e=>[e[0],e[1]]));const o=Kt(r);const c=[];o.forEach((e=>{c[e]=F(s[e],s[o[0]])>0}));const a=n.map((e=>e[2]===-1^!c[e[1]]?[e[0],e[1]]:[e[1],e[0]]));return El(a)};const wl=({vertices_coords:e,faces_vertices:t,faceOrders:n})=>{const s=cs({vertices_coords:e,faces_vertices:t});const r=xl(gs({edges_vertices:n.map((e=>[e[0],e[1]]))}));const o=er(r).map((e=>e.constructor===Array?e:[e]));const c=o.map((e=>Ml(n,e))).map((e=>kl({faceOrders:e,faces_normal:s})));const a=o.map((e=>s[e[0]]));const i=[];c.forEach(((e,t)=>e.forEach(((e,n)=>{i[e]={vector:a[t],layer:n}}))));return i};const Ol=({faces_layer:e})=>{const t=[];const n=er(e);n.forEach(((e,n)=>{t[e]={vector:[0,0,1],layer:n}}));return t};const jl=({vertices_coords:e,faces_vertices:t,faceOrders:n,faces_normal:s})=>{if(!s){s=cs({vertices_coords:e,faces_vertices:t})}return er(kl({faceOrders:n,faces_normal:s}))};const Fl=Object.freeze({__proto__:null,faceOrdersSubset:Ml,linearizeFaceOrders:kl,makeFacesLayer:jl,nudgeFacesWithFaceOrders:wl,nudgeFacesWithFacesLayer:Ol});const Cl={back:{fill:"white"},front:{fill:"#ddd"}};const Sl={back:{opacity:.1},front:{opacity:.1}};const Pl={};const Nl={stroke:"black","stroke-linejoin":"bevel"};const Vl={stroke:"none",fill:"black","stroke-linejoin":"bevel"};const zl={fill:"none"};const $l=(e,t)=>{const n=e.faces_vertices.map(((e,t)=>t)).filter((e=>t[e]==null));return n.concat(er(t))};const Tl=e=>{if(e.faceOrders){return $l(e,er(kl(e)))}if(e.faces_layer){return $l(e,e.faces_layer)}return e.faces_vertices.map(((e,t)=>t)).filter((()=>true))};const Ll=(e,t,n)=>e.setAttribute(`data-${t}`,n);const Bl=(e,t={})=>Object.keys(t).forEach((n=>e.setAttributeNS(null,n,t[n])));const Il=(e,t,n,s)=>{const r=$t(e);const o=!!(e.faceOrders||e.faces_layer);const c=[["front"],["back"]];const a=bl(e);a.map((e=>e?c[0]:c[1])).forEach(((e,n)=>{ha(t[n],e);Ll(t[n],"side",e);Bl(t[n],r?o?Cl[e]:Sl[e]:Pl[e]);Bl(t[n],s[e])}));Tl(e).forEach((e=>n.appendChild(t[e])));Object.defineProperty(n,"front",{get:()=>t.filter(((e,t)=>a[t]))});Object.defineProperty(n,"back",{get:()=>t.filter(((e,t)=>!a[t]))});Bl(n,r?o?Nl:Vl:zl);return n};const Rl=(e,t={})=>{const n=Hf.g();if(!e||!e.vertices_coords||!e.faces_vertices){return n}const s=e.faces_vertices.map((t=>t.map((t=>[0,1].map((n=>e.vertices_coords[t][n])))))).map((e=>Hf.polygon(e)));s.forEach(((e,t)=>e.setAttributeNS(null,"index",t)));n.setAttributeNS(null,"fill","white");return Il(e,s,n,t)};const Ul=function(e,t={}){const n=Hf.g();if(!e||"faces_edges"in e===false||"edges_vertices"in e===false||"vertices_coords"in e===false){return n}const s=e["faces_edges"].map((t=>t.map((t=>e["edges_vertices"][t])).map(((e,t,n)=>{const s=n[(t+1)%n.length];return e[1]===s[0]||e[1]===s[1]?e[0]:e[1]})).map((t=>[0,1].map((n=>e["vertices_coords"][t][n])))))).map((e=>Hf.polygon(e)));s.forEach(((e,t)=>e.setAttributeNS(null,"index",t)));n.setAttributeNS(null,"fill","white");return Il(e,s,n,t)};const ql=(e,t)=>{if(e&&e["faces_vertices"]){return Rl(e,t)}if(e&&e["faces_edges"]){return Ul(e,t)}return Hf.g()};const Dl={fill:"none"};const Wl={stroke:"black",fill:"white"};const Gl=(e,t={})=>Object.keys(t).forEach((n=>e.setAttributeNS(null,n,t[n])));const Hl=(e,t={})=>{const n=Hf.g();if(!e){return n}const s=Uo(e).polygon;if(!s.length){return n}const r=Hf.polygon(s);ha(r,"boundary");n.appendChild(r);Gl(n,$t(e)?Dl:Wl);Object.keys(t).forEach((e=>n.setAttributeNS(null,e,t[e])));return n};const Jl={vertices:el,edges:_l,faces:ql,boundaries:Hl,edgesPaths:ml,edgesLines:pl,facesVerticesPolygon:Rl,facesEdgesPolygon:Ul};const Ql=1/50;const Zl={min:[0,0],span:[1,1]};const Yl=["boundaries","faces","edges","vertices"];const Xl=(e,t)=>{for(let n=0;n<e.childNodes.length;n+=1){e.childNodes[n].setAttributeNS(null,"r",t)}};const Kl=(e,t,n,s)=>{const r=t[3]&&t[3].childNodes.length;if(!(s.strokeWidth||s.viewBox||r)){return}const o=Bo(n)||Zl;const c=Math.max(...o.span);const a=pa(e,"svg");if(a&&s.viewBox){const e=Jf(o);a.setAttributeNS(null,"viewBox",e)}if(a&&s.padding){const e=a.getAttribute("viewBox");if(e!=null){const t=s.padding*c;const n=e.split(" ").map((e=>parseFloat(e)));const r=[-t,-t,t*2,t*2].map(((e,t)=>n[t]+e)).join(" ");a.setAttributeNS(null,"viewBox",r)}}if(s.strokeWidth||s["stroke-width"]){const t=s.strokeWidth?s.strokeWidth:s["stroke-width"];const r=typeof t==="number"?c*t:Kf(n);e.setAttributeNS(null,"stroke-width",r)}if(r){const e=s.vertices&&s.vertices.radius!=null?s.vertices.radius:s.radius;const n=typeof e==="string"?parseFloat(e):e;const r=typeof n==="number"&&!Number.isNaN(n)?c*n:c*Ql;Xl(t[3],r)}};const ed=(e,t={})=>Yl.map((n=>t[n]===false?Hf.g():Jl[n](e,t))).map(((e,t)=>{ha(e,Yl[t]);return e}));const td=(e,t,n={})=>{if(!$t(e)){if(n.faces===undefined){n.faces=false}}const s=ed(e,n);s.filter((e=>e.childNodes.length>0)).forEach((e=>t.appendChild(e)));Kl(t,s,e,n);ha(t,...[e.file_classes||[],e.frame_classes||[]].flat());return t};const nd=(e,t)=>td(typeof e==="string"?JSON.parse(e):e,Hf.svg(),{viewBox:true,strokeWidth:true,...t});Object.assign(nd,{...Jl,render:td,getViewBox:Qf,getStrokeWidth:Kf,boundingBoxToViewBox:Jf});const sd=e=>{const t=["file_title","file_author","file_description","frame_title","frame_author","frame_description"];return t.filter((t=>e[t])).map((t=>`# ${t.split("_")[1]}: ${e[t]}`)).join("\n")};const rd=e=>{const t=typeof e==="string"?JSON.parse(e):e;const n=sd(t);const s=(t.vertices_coords||[]).map((e=>e.join(" "))).map((e=>`v ${e}`)).join("\n");const r=(t.faces_vertices||[]).map((e=>e.map((e=>e+1)).join(" "))).map((e=>`f ${e}`)).join("\n");const o=[n,s,r].filter((e=>e!=="")).join("\n");return`${o}\n`};const od={};od.prototype=Object.create(Object.prototype);od.prototype.constructor=od;Object.entries({clean:sr,validate:Lo,populate:to,planarize:Xr,subgraph:Vo,boundary:Uo,boundingBox:Bo,nearest:wr,splitEdge:uo,splitFace:Po,faceSpanningTree:Go,invertAssignments:Lt,svg:nd,obj:rd,...ir,...Gt}).forEach((([e,t])=>{od.prototype[e]=function(){return t(this,...arguments)}}));od.prototype.clone=function(){return Object.assign(Object.create(Object.getPrototypeOf(this)),rr(this))};od.prototype.folded=function(){const e=this.faces_matrix2?Jo(this,this.faces_matrix2):Ko(this,...arguments);return{...this,vertices_coords:e,frame_classes:["foldedForm"]}};od.prototype.flatFolded=function(){const e=this.faces_matrix2?Jo(this,this.faces_matrix2):ec(this,...arguments);return{...this,vertices_coords:e,frame_classes:["foldedForm"]}};const cd=(e,t,n,s)=>{t.forEach((t=>{e.edges_assignment[t]=n;e.edges_foldAngle[t]=s}));return t};od.prototype.setValley=function(e=[],t=180){return cd(this,e,"V",Math.abs(t))};od.prototype.setMountain=function(e=[],t=-180){return cd(this,e,"M",-Math.abs(t))};od.prototype.setFlat=function(e=[]){return cd(this,e,"F",0)};od.prototype.setUnassigned=function(e=[]){return cd(this,e,"U",0)};od.prototype.setCut=function(e=[]){return cd(this,e,"C",0)};const ad=od.prototype;const id=(e,t,n,s,r=it,o=a)=>{const c=T(v(e),v(n));if(Math.abs(c)<o){return undefined}const i=T(e,n);const f=-i;const l=O(s,t);const d=U(l);const u=T(l,n)/i;const m=T(d,e)/f;if(r(m,o/g(n))){return u}return undefined};const fd=(e,t,n)=>M(t,E(e,n));const ld=(e,t,n,s,r)=>e.map(((e,t,n)=>[O(n[(t+1)%n.length],e),e])).map((e=>id(t,n,e[0],e[1],s,r))).filter((e=>e!==undefined)).sort(((e,t)=>e-t));const dd=(e,t,n)=>{let s=0;let r=e.length-1;while(s<r){if(t(e[s+1]-e[s],n)){break}s+=1}while(r>s){if(t(e[r]-e[r-1],n)){break}r-=1}if(s>=r){return undefined}return[e[s],e[r]]};const ud=(e,{vector:t,origin:n},s=nt,r=rt,o=a)=>{const c=ld(e,t,n,it,o);if(c.length<2){return undefined}const i=o*2/g(t);const f=dd(c,s,i);if(f===undefined){return undefined}const l=e=>{if(r(e)){return e}return e<.5?0:1};const d=f.map(l);if(Math.abs(d[0]-d[1])<o*2/g(t)){return undefined}const u=fd(t,n,(d[0]+d[1])/2);return vr(e,u,s,o)?d.map((e=>fd(t,n,e))):undefined};const md=(e,t,n=a)=>{const s=(e,t,s)=>(s[0]-t[0])*(e[1]-t[1])>(s[1]-t[1])*(e[0]-t[0])+n;const r=(e,t,n,s)=>{const r=O(e,t);const o=O(s,n);const c=T(e,t);const a=T(s,n);const i=1/T(r,o);return E(O(E(o,c),E(r,a)),i)};let o=e;let c=t[t.length-1];for(let e=0;e<t.length;e+=1){const n=t[e];const a=o;o=[];let i=a[a.length-1];for(let e=0;e<a.length;e+=1){const t=a[e];if(s(t,c,n)){if(!s(i,c,n)){o.push(r(c,n,t,i))}o.push(t)}else if(s(i,c,n)){o.push(r(c,n,t,i))}i=t}c=n}return o.length===0?undefined:o};const gd=Object.freeze({__proto__:null,clipLineConvexPolygon:ud,clipPolygonPolygon:md});const pd=(e,{vector:t,origin:n},s)=>{if(e.length<2){return e}const r=e.map((e=>O(e[1],e[0]))).map((e=>C(e,t)<s));e.map(((e,t)=>t)).filter((e=>r[e])).forEach((t=>{e[t]=[e[t][1],e[t][0]]}));const o=v(t);const c=e.map((e=>e.map((e=>C(O(e,n),o))))).sort(((e,t)=>e[0]-t[0]));const a=[[c[0][0],c[0][1]]];for(let e=1;e<c.length;e+=1){const t=c[e];if(t[0]-s<a[a.length-1][1]+s){a[a.length-1][1]=Math.max(t[1],a[a.length-1][1])}else{a.push([t])}}return a.map((e=>e.map((e=>M(n,E(o,e))))))};const _d=(e,t,n,s=rt,r=a)=>{const o=t.map((t=>e.faces_vertices[t].map((t=>e.vertices_coords[t])))).map((e=>ud(e,n,nt,s,r))).filter((e=>e!==undefined));return pd(o,n,r)};const hd=(e,t,n=a)=>{const s=Oo(e,t,n);return _d(e,s,t,rt,n)};const vd=(e,t,n=a)=>{const s=jo(e,t,n);return _d(e,s,t,ct,n)};const bd=(e,t,n=a)=>{const s=O(t[1],t[0]);const r=t[0];const o=Fo(e,t,n);return _d(e,o,{vector:s,origin:r},it,n)};const yd=function(e,t){const n=Uo(e).vertices.map((t=>e.vertices_coords[t]));const s=t.vector?t.vector:O(t[1],t[0]);const r=t.origin?t.origin:t[0];const o=t.domain?t.domain:rt;return ud(n,{vector:s,origin:r},nt,o)};const Ed=Object.freeze({__proto__:null,clip:yd,clipLine:hd,clipRay:vd,clipSegment:bd});const Ad=({vertices_coords:e,edges_vertices:t},{vector:n,origin:s},r=a)=>{const o=h(n);const c=e=>{const t=h(w(e,s));const n=Math.abs(F(t,o));return Math.abs(1-n)<r};const i=Ss({vertices_coords:e,edges_vertices:t});return t.map(((e,t)=>t)).filter((e=>H(n,i[e],r))).filter((n=>c(e[t[n][0]])))};const xd=({vertices_coords:e,edges_vertices:t},{min:n,max:s},r=a)=>{const o=Cs({vertices_coords:e,edges_vertices:t});const c=n.map((e=>e-r));const i=s.map((e=>e+r));return t.map(((e,t)=>t)).filter((e=>!(o[e][0][0]<c[0]&&o[e][1][0]<c[0]))).filter((e=>!(o[e][0][0]>i[0]&&o[e][1][0]>i[0]))).filter((e=>!(o[e][0][1]<c[1]&&o[e][1][1]<c[1]))).filter((e=>!(o[e][0][1]>i[1]&&o[e][1][1]>i[1])))};const Md=({vertices_coords:e,edges_vertices:t},n,s,r=a)=>{const o=Ye([n,s]);const c=O(s,n);const i={vector:c,origin:n};const f=xd({vertices_coords:e,edges_vertices:t},o,r);const l=[];f.forEach((n=>{const s=t[n].map((t=>e[t]));const o=O(s[1],s[0]);const c={vector:o,origin:s[0]};const a=Tr(i,c,it,it,r);if(!a){return}l[n]=a}));return l};const kd=Object.freeze({__proto__:null,getEdgesCollinearToLine:Ad,getEdgesRectOverlap:xd,getEdgesSegmentIntersection:Md});const wd=(e,t,n=a)=>{if(!e.vertices_coords){e.vertices_coords=[]}if(typeof t[0]==="number"){t=[t]}const s=t.map((t=>e.vertices_coords.map((e=>B(e,t)<n)).map(((e,t)=>e?t:undefined)).filter((e=>e!==undefined)).shift()));let r=e.vertices_coords.length;const o=t.filter(((e,t)=>s[t]===undefined));e.vertices_coords.push(...o);return s.map((e=>e===undefined?r++:e))};const Od=(e,t,n)=>{const s=Array.from(Array(t.length-1)).map(((e,n)=>[t[n],t[n+1]]));const r=s.map((e=>e.join(" "))).map((e=>n[e]===undefined));const o=s.filter(((e,t)=>r[t]));const c=Array.from(Array(o.length)).map(((t,n)=>e.edges_vertices.length+n));c.forEach(((t,n)=>{e.edges_vertices[t]=o[n]}));if(e.edges_assignment){c.forEach((t=>{e.edges_assignment[t]="U"}))}if(e.edges_foldAngle){c.forEach((t=>{e.edges_foldAngle[t]=0}))}for(let n=0;n<t.length;n+=1){const s=t[n];const o=r[n-1]?t[n-1]:undefined;const c=r[n]?t[n+1]:undefined;const a=[o,c].filter((e=>e!==undefined));const i=e.vertices_vertices[s]?e.vertices_vertices[s]:[];const f=i.concat(a);e.vertices_vertices[s]=ss(e,f,t[n])}const a=hs(e);for(let n=0;n<t.length;n+=1){const s=t[n];e.vertices_edges[s]=e.vertices_vertices[s].map((e=>a[`${s} ${e}`]))}t.map((t=>e.vertices_vertices[t].length===1?[l]:Tn(e.vertices_vertices[t].map((n=>O(e.vertices_coords[n],e.vertices_coords[t])))))).forEach(((n,s)=>{e.vertices_sectors[t[s]]=n}));return c};const jd=(e,t,n,s=a)=>{if(!e.vertices_sectors){e.vertices_sectors=Es(e)}const r=[t,n].map((e=>[e[0],e[1]]));const o=O(r[1],r[0]);const c=Md(e,r[0],r[1],s);const i=c.map(((e,t)=>t)).filter(rt);const f={};i.forEach((t=>e.edges_faces[t].forEach((e=>{f[e]=true}))));const l=Object.keys(f).map((e=>parseInt(e,10))).sort(((e,t)=>e-t));const d=i.reverse().map((t=>uo(e,t,c[t],s)));const u=d.map((e=>e.vertex));const m=wd(e,r,s);const g={};u.forEach((e=>{g[e]=true}));m.forEach((e=>{g[e]=true}));const p=Object.keys(g).map((e=>parseInt(e,10)));const _=rs(e,p,o);const h=hs(e);const v=Od(e,_,h);v.forEach((t=>{const n=e.edges_vertices[t];h[`${n[0]} ${n[1]}`]=t;h[`${n[1]} ${n[0]}`]=t}));const b=_.map((t=>e.vertices_vertices[t].map((e=>[[e,t],[t,e]])))).reduce(((e,t)=>e.concat(t)),[]).reduce(((e,t)=>e.concat(t)),[]);const y={};const E=b.map((t=>Dn(e,t[0],t[1],y))).filter((e=>e!==undefined));const A=Gn(E);dn(e,"faces",l);const x=A.map(((t,n)=>e.faces_vertices.length+n));if(e.faces_vertices){x.forEach(((t,n)=>{e.faces_vertices[t]=A[n].vertices}))}if(e.faces_edges){x.forEach(((t,n)=>{e.faces_edges[t]=A[n].edges.map((e=>h[e]))}))}if(e.faces_angles){x.forEach(((t,n)=>{e.faces_angles[t]=A[n].faces_angles}))}if(e.vertices_faces){e.vertices_faces=_s(e)}if(e.edges_faces){e.edges_faces=xs(e)}if(e.faces_faces){e.faces_faces=Ts(e)}if(e.vertices_coords.length!==e.vertices_vertices.length||e.vertices_coords.length!==e.vertices_edges.length||e.vertices_coords.length!==e.vertices_faces.length){console.warn("vertices mismatch",JSON.parse(JSON.stringify(e)))}if(e.edges_vertices.length!==e.edges_faces.length||e.edges_vertices.length!==e.edges_assignment.length){console.warn("edges mismatch",JSON.parse(JSON.stringify(e)))}if(e.faces_vertices.length!==e.faces_edges.length||e.faces_vertices.length!==e.faces_faces.length){console.warn("faces mismatch",JSON.parse(JSON.stringify(e)))}return v};const Fd=({vertices_vertices:e},t)=>{const n=[t[1],t[0]];t.map(((t,s)=>e[t].indexOf(n[s]))).forEach(((n,s)=>e[t[s]].splice(n,1)))};const Cd=({vertices_edges:e},t,n)=>{n.map(((n,s)=>e[n].indexOf(t))).forEach(((t,s)=>e[n[s]].splice(t,1)))};const Sd=(e,t,n,s)=>{const r=t.map((t=>e.faces_edges[t].indexOf(n)));const o=[];t.forEach(((t,n)=>e.faces_vertices[t].forEach(((e,t,r)=>{const c=r[(t+1)%r.length];if(e===s[0]&&c===s[1]||e===s[1]&&c===s[0]){o[n]=t}}))));if(o[0]===undefined||o[1]===undefined){console.warn("removePlanarEdge error joining faces")}const c=t.map((t=>e.faces_edges[t].length));const a=t.map((t=>e.faces_vertices[t].length));const i=c.map((e=>e-1));const f=a.map((e=>e-1));const l=r.map(((e,t)=>(e+1)%c[t]));const d=o.map(((e,t)=>(e+1)%a[t]));const u=t.map(((t,n)=>Array.from(Array(i[n])).map(((e,t)=>(l[n]+t)%c[n])).map((n=>e.faces_edges[t][n]))));const m=t.map(((t,n)=>Array.from(Array(f[n])).map(((e,t)=>(d[n]+t)%a[n])).map((n=>e.faces_vertices[t][n]))));const g=t.map((t=>e.faces_faces[t])).reduce(((e,t)=>e.concat(t)),[]).filter((e=>e!==t[0]&&e!==t[1]));return{vertices:m[0].concat(m[1]),edges:u[0].concat(u[1]),faces:g}};const Pd=(e,t)=>{const n=[...e.edges_vertices[t]].sort(((e,t)=>t-e));const s=[...e.edges_faces[t]];Fd(e,n);Cd(e,t,n);const r=n.map((t=>e.vertices_vertices[t].length===0));const o=n.filter(((e,t)=>r[t]));if(s.length===2&&s[0]!==s[1]){const r=e.faces_vertices.length;const o=Sd(e,s,t,n);e.faces_vertices.push(o.vertices);e.faces_edges.push(o.edges);e.faces_faces.push(o.faces);e.vertices_faces.forEach(((t,n)=>{let o=false;t.forEach(((c,a)=>{if(c===s[0]||c===s[1]){e.vertices_faces[n][a]=r;const s=o?[n,1]:[n,1,r];t.splice(...s);o=true}}))}));e.edges_faces.forEach(((t,n)=>t.forEach(((t,o)=>{if(t===s[0]||t===s[1]){e.edges_faces[n][o]=r}}))));e.faces_faces.forEach(((t,n)=>t.forEach(((t,o)=>{if(t===s[0]||t===s[1]){e.faces_faces[n][o]=r}}))));e.faces_vertices.forEach((t=>t.forEach((t=>{if(t===undefined){console.log("FOUND ONE before remove",e.faces_vertices)}}))));dn(e,"faces",s)}if(s.length===2&&s[0]===s[1]&&o.length){const n=s[0];e.faces_vertices[n]=e.faces_vertices[n].filter((e=>!o.includes(e))).filter(((e,t,n)=>e!==n[(t+1)%n.length]));e.faces_edges[n]=e.faces_edges[n].filter((e=>e!==t))}dn(e,"edges",[t]);dn(e,"vertices",o)};const Nd=(e,t,n,s=false,r=a)=>{const o=[e,n].map((e=>tt(t,e))).reduce(((e,t)=>e||t),false);if(o){return s}const c=[[e,t],[t,n]].map((e=>w(e[1],e[0]))).map((e=>h(e)));return Ke(1,F(...c),r)};const Vd=(e,t,n)=>{const s=$(e.vector,t.vector,n);const r=$(e.origin,t.origin,n);return{vector:s,origin:r}};const zd=(e,t,n,s=a)=>{const r=F(e.vector,t.vector);const o=T(e.vector,t.vector);const c=T(O(t.origin,e.origin),t.vector);const i=c/o;const f=[e.vector,t.vector].map((e=>h(e)));const l=o>-s?[[e.vector,t.vector],[U(t.vector),e.vector]]:[[t.vector,e.vector],[U(e.vector),t.vector]];const d=l.map((e=>Nn(e[0],e[1],n)));const u=Math.abs(T(...f))<s;const m=u?undefined:M(e.origin,E(e.vector,i));const g=Array.from(Array(n-1));const p=u?g.map(((s,r)=>$(e.origin,t.origin,(r+1)/n))):g.map((()=>m));const _=d.map((e=>e.map(((e,t)=>({vector:e,origin:[...p[t]]})))));if(u){_[r>-s?1:0]=[]}return _};const $d=(e,t,n=a)=>{const s=zd(e,t,2,n).map((e=>e[0]));s.forEach(((e,t)=>{if(e===undefined){delete s[t]}}));return s};const Td=Object.freeze({__proto__:null,bisectLines2:$d,collinearBetween:Nd,lerpLines:Vd,pleat:zd});const Ld=({vertices_edges:e},t,n)=>{const s=new Set(e[t]);return e[n].filter((e=>s.has(e))).shift()};const Bd=({edges_vertices:e},t,n)=>n.map((n=>e[n][0]===t?e[n][1]:e[n][0]));const Id=Object.freeze({__proto__:null,getEdgeBetweenVertices:Ld,getOtherVerticesInEdges:Bd});const Rd=({vertices_coords:e,vertices_edges:t,edges_vertices:n},s,r=a)=>{if(!e||!n){return false}if(!t){t=fs({edges_vertices:n})}const o=t[s];if(o===undefined||o.length!==2){return false}const c=Bd({edges_vertices:n},s,o);const i=[c[0],s,c[1]].map((t=>e[t]));return Nd(...i,false,r)};const Ud=Object.freeze({__proto__:null,isVertexCollinear:Rd});const qd=(e,t)=>{const n=e.vertices_edges[t];const s=Kt(e.vertices_faces[t].filter((e=>e!=null)));if(n.length!==2||s.length>2){console.warn("cannot remove non 2-degree vertex yet (e,f)",n,s);return}const r=Bd(e,t,n);const o=r.slice().reverse();n.sort(((e,t)=>e-t));r.forEach((t=>{const s=e.vertices_edges[t].indexOf(n[1]);if(s===-1){return}e.vertices_edges[t][s]=n[0]}));r.forEach(((n,s)=>{const r=e.vertices_vertices[n].indexOf(t);if(r===-1){console.warn("removePlanarVertex unknown vertex issue");return}e.vertices_vertices[n][r]=o[s]}));e.edges_vertices[n[0]]=[...r];s.forEach((n=>{const s=e.faces_vertices[n].indexOf(t);if(s===-1){console.warn("removePlanarVertex unknown face_vertex issue");return}e.faces_vertices[n].splice(s,1)}));s.forEach((t=>{const s=e.faces_edges[t].indexOf(n[1]);if(s===-1){console.warn("removePlanarVertex unknown face_edge issue");return}e.faces_edges[t].splice(s,1)}));dn(e,"vertices",[t]);dn(e,"edges",[n[1]])};const Dd=e=>[0,1].map((t=>e.filter(((e,n)=>n%2===t)).reduce(((e,t)=>e+t),0)));const Wd=e=>{const t=e.reduce(((e,t)=>e+t),0)/2;return Dd(e).map((e=>e-t))};const Gd=e=>e.map(((e,t,n)=>[e,n[(t+1)%n.length]])).map((e=>kn(...e))).map(((e,t,n)=>n.slice(t+1,n.length).concat(n.slice(0,t)))).map((e=>Dd(e).map((e=>Math.PI-e)))).map(((t,n)=>e[n]+t[0])).map(((t,n)=>xn(t,e[n],e[(n+1)%e.length])?t:undefined));const Hd=e=>{const t=e.map((e=>Math.atan2(e[1],e[0])));return Gd(t).map((e=>e===undefined?undefined:[Math.cos(e),Math.sin(e)]))};const Jd=Object.freeze({__proto__:null,alternatingSum:Dd,alternatingSumDifference:Wd,kawasakiSolutionsRadians:Gd,kawasakiSolutionsVectors:Hd});const Qd={B:true,b:true,F:true,f:true,U:true,u:true};const Zd=({vertices_edges:e,edges_assignment:t})=>e.map((e=>e.map((e=>Qd[t[e]])).reduce(((e,t)=>e&&t),true))).map(((e,t)=>e?t:undefined)).filter((e=>e!==undefined));const Yd={M:true,m:true,V:true,v:true};const Xd={M:-1,m:-1,V:1,v:1};const Kd=({edges_vertices:e,vertices_edges:t,edges_assignment:n})=>{if(!t){t=fs({edges_vertices:e})}const s=t.map((e=>e.map((e=>Xd[n[e]])).filter((e=>e!==undefined)).reduce(((e,t)=>e+t),0))).map((e=>e===2||e===-2));Io({edges_vertices:e,edges_assignment:n}).forEach((e=>{s[e]=true}));Zd({vertices_edges:t,edges_assignment:n}).forEach((e=>{s[e]=true}));return s.map(((e,t)=>!e?t:undefined)).filter((e=>e!==undefined))};const eu=({vertices_coords:e,vertices_vertices:t,vertices_edges:n,edges_vertices:s,edges_assignment:r,edges_vector:o},c=a)=>{if(!t){t=ms({vertices_coords:e,vertices_edges:n,edges_vertices:s})}const i=ys({vertices_coords:e,vertices_vertices:t,edges_vertices:s,edges_vector:o}).map(((e,t)=>e.filter(((e,s)=>Yd[r[n[t][s]]])))).map((e=>e.length>1?Tn(e):[0,0])).map((e=>Dd(e))).map((e=>Math.abs(e[0]-e[1])<c));Io({edges_vertices:s,edges_assignment:r}).forEach((e=>{i[e]=true}));Zd({vertices_edges:n,edges_assignment:r}).forEach((e=>{i[e]=true}));return i.map(((e,t)=>!e?t:undefined)).filter((e=>e!==undefined))};const tu=Object.freeze({__proto__:null,validateKawasaki:eu,validateMaekawa:Kd});const nu={};nu.prototype=Object.create(ad);nu.prototype.constructor=nu;const su=function(e){e.valley=t=>this.setValley(e,t);e.mountain=t=>this.setMountain(e,t);e.flat=()=>this.setFlat(e);e.unassigned=()=>this.setUnassigned(e);e.cut=()=>this.setCut(e);return e};const ru=(e,t)=>{const n=yd(e,t);if(!n){return undefined}const s=jd(e,n[0],n[1]);return su.call(e,s)};nu.prototype.line=function(...e){const t=Te(...e);if(!t){return undefined}t.domain=rt;return ru(this,t)};nu.prototype.ray=function(...e){const t=Te(...e);if(!t){return undefined}t.domain=ct;return ru(this,t)};nu.prototype.segment=function(...e){const t=bn(...ze(...e));if(!t){return undefined}t.domain=it;return ru(this,t)};nu.prototype.polygon=function(...e){const t=Ve(...e);if(!t){return undefined}const n=t.map(((e,t,n)=>[e,n[(t+1)%n.length]])).map((e=>bn(...e))).map((e=>({...e,domain:it}))).map((e=>yd(this,e))).filter((e=>e!==undefined));if(!n){return undefined}const s=n.flatMap((e=>jd(this,e[0],e[1])));return su.call(this,s)};nu.prototype.removeEdge=function(e){const t=this.edges_vertices[e];Pd(this,e);t.map((e=>Rd(this,e))).map(((e,n)=>e?t[n]:undefined)).filter((e=>e!==undefined)).sort(((e,t)=>t-e)).forEach((e=>qd(this,e)));return true};nu.prototype.validate=function(e){const t=Lo(this,e);t.vertices.kawasaki=eu(this,e);t.vertices.maekawa=Kd(this);if(this.edges_foldAngle){t.edges.not_flat=this.edges_foldAngle.map(((e,t)=>Ot(e)?undefined:t)).filter((e=>e!==undefined))}if(t.summary==="valid"){if(t.vertices.kawasaki.length||t.vertices.maekawa.length){t.summary="invalid"}else if(t.edges.not_flat.length){t.summary="not flat"}}return t};nu.prototype.defer=false;const ou=nu.prototype;const cu=(e,t)=>{const n=[];const s=e.map(((e,t)=>t));const r=s.filter((e=>t[e]));const o=s.filter((e=>!t[e]));o.sort(((t,n)=>e[t]-e[n])).forEach(((e,t)=>{n[e]=t}));r.sort(((t,n)=>e[n]-e[t])).forEach(((e,t)=>{n[e]=o.length+t}));return n};const au=(e,t,n,s)=>{const r=O(n,t);const o=T(e,r);return s?o>0:o<0};const iu=(e,t)=>!e.faces_vertices[t]?[0,0]:e.faces_vertices[t].map((t=>e.vertices_coords[t])).reduce(((e,t)=>[e[0]+t[0],e[1]+t[1]]),[0,0]).map((n=>n/e.faces_vertices[t].length));const fu={F:true,f:true,U:true,u:true};const lu={M:"V",m:"V",V:"M",v:"M"};const du=e=>lu[e]||e;const uu=(e,t)=>({center:e.faces_center[t],matrix:e.faces_matrix2[t],winding:e.faces_winding[t],crease:e.faces_crease[t],side:e.faces_side[t],layer:e.faces_layer[t]});const mu=(e,{vector:t,origin:n},s="V",r=a)=>{const o=du(s);to(e);if(!e.faces_layer){e.faces_layer=Array(e.faces_vertices.length).fill(0)}e.faces_center=e.faces_vertices.map(((t,n)=>iu(e,n)));if(!e.faces_matrix2){e.faces_matrix2=Yo(e,0)}e.faces_winding=vl(e.faces_matrix2);e.faces_crease=e.faces_matrix2.map(re).map((e=>te(e,t,n)));e.faces_side=e.faces_vertices.map(((t,n)=>au(e.faces_crease[n].vector,e.faces_crease[n].origin,e.faces_center[n],e.faces_winding[n])));const c=Jo(e,e.faces_matrix2);const i=Ad({vertices_coords:c,edges_vertices:e.edges_vertices},{vector:t,origin:n},r).filter((t=>fu[e.edges_assignment[t]]));i.map((t=>e.edges_faces[t].find((e=>e!=null)))).map((t=>e.faces_winding[t])).map((e=>e?s:o)).forEach(((t,n)=>{e.edges_assignment[i[n]]=t;e.edges_foldAngle[i[n]]=kt(t)}));const f=uu(e,0);const l=e.faces_vertices.map(((e,t)=>t)).reverse().map((t=>{const n=uu(e,t);const c=Po(e,t,n.crease,r);if(c===undefined){return undefined}e.edges_assignment[c.edges.new]=n.winding?s:o;e.edges_foldAngle[c.edges.new]=kt(e.edges_assignment[c.edges.new]);const a=c.faces.map[c.faces.remove];a.forEach((t=>{e.faces_center[t]=iu(e,t);e.faces_side[t]=au(n.crease.vector,n.crease.origin,e.faces_center[t],n.winding);e.faces_layer[t]=n.layer}));return c})).filter((e=>e!==undefined));const d=Ys(...l.map((e=>e.faces.map)));const u=Ys(...l.map((e=>e.edges.map)).filter((e=>e!==undefined)));const m=l.map((e=>e.faces.remove)).reverse();e.faces_layer=cu(e.faces_layer,e.faces_side);const g=d&&d[0]&&d[0].length===2;const p=g?d[0].filter((t=>e.faces_side[t])).shift():0;let _=f.matrix;if(s!==o){_=!g&&!e.faces_side[0]?f.matrix:ne(f.matrix,fe(f.crease.vector,f.crease.origin))}e.faces_matrix2=Yo(e,p).map((e=>ne(_,e)));delete e.faces_center;delete e.faces_winding;delete e.faces_crease;delete e.faces_side;return{faces:{map:d,remove:m},edges:{map:u}}};const gu={};gu.prototype=Object.create(ad);gu.prototype.constructor=gu;gu.prototype.flatFold=function(){mu(this,Te(arguments));return this};const pu=gu.prototype;const _u=1.1;const hu="Rabbit Ear";const vu=(e,t)=>[[0,0],[e,0],[e,t],[0,t]];const bu=e=>to({vertices_coords:e,edges_vertices:e.map(((e,t,n)=>[t,(t+1)%n.length])),edges_assignment:Array(e.length).fill("B")});const yu=(e=1)=>bu(vu(e,e));const Eu=(e=1,t=1)=>bu(vu(e,t));const Au=(e=3,t=1)=>bu(Re(e,t));const xu=()=>to({vertices_coords:[[0,0],[1,0],[1,Math.SQRT2-1],[1,1],[Math.SQRT2-1,1],[0,1]],edges_vertices:[[0,1],[1,2],[2,3],[3,4],[4,5],[5,0],[0,2],[0,4],[0,3]],edges_assignment:Array.from("BBBBBBVVF")});const Mu=()=>to({vertices_coords:[[0,0],[1,0],[1,1],[0,1],[.5,.5],[1-Math.SQRT1_2,Math.SQRT1_2],[Math.SQRT1_2,1-Math.SQRT1_2],[1,1-Math.SQRT1_2],[1-Math.SQRT1_2,1],[Math.SQRT1_2,0],[0,Math.SQRT1_2]],edges_vertices:[[0,4],[4,2],[4,5],[5,3],[0,5],[1,6],[6,4],[0,6],[2,5],[2,6],[1,7],[7,2],[6,7],[2,8],[8,3],[5,8],[0,9],[9,1],[6,9],[3,10],[10,0],[5,10]],edges_assignment:Array.from("FFFVVVFVVVBBFBBFBBMBBM")});const ku=Object.freeze({__proto__:null,fish:Mu,kite:xu,polygon:Au,rectangle:Eu,square:yu});const wu=(...e)=>to(Object.assign(Object.create(ad),{...e.reduce(((e,t)=>({...e,...t})),{}),file_spec:_u,file_creator:hu}));const Ou=(...e)=>to(Object.assign(Object.create(ou),{...e.length?e.reduce(((e,t)=>({...e,...t})),{}):yu(),file_spec:_u,file_creator:hu,frame_classes:["creasePattern"]}));const ju=(...e)=>to(Object.assign(Object.create(pu),{...e.length?e.reduce(((e,t)=>({...e,...t})),{}):yu(),file_spec:_u,file_creator:hu,frame_classes:["foldedForm"]}));wu.prototype=ad;wu.prototype.constructor=wu;Ou.prototype=ou;Ou.prototype.constructor=Ou;ju.prototype=pu;ju.prototype.constructor=ju;Object.keys(ku).forEach((e=>{wu[e]=(...t)=>wu(ku[e](...t));Ou[e]=(...t)=>Ou(ku[e](...t));ju[e]=(...t)=>ju(ku[e](...t))}));const Fu=(e,t)=>{const n=T(e.normal,t.normal);if(Math.abs(n)<a){return undefined}const s=e.distance*t.normal[1]-t.distance*e.normal[1];const r=t.distance*e.normal[0]-e.distance*t.normal[0];return[s/n,r/n]};const Cu=(e,t)=>{const n=v(q(O(t,e)));return[{normal:n,distance:C(M(e,t),n)/2}]};const Su=(e,t)=>{const n=v(O(t,e));return[{normal:n,distance:C(M(e,t),n)/2}]};const Pu=(e,t)=>{const n=Fu(e,t);return n===undefined?[{normal:e.normal,distance:(e.distance+t.distance*C(e.normal,t.normal))/2}]:[M,O].map((n=>v(n(e.normal,t.normal)))).map((e=>({normal:e,distance:C(n,e)})))};const Nu=(e,t)=>{const n=q(e.normal);const s=C(t,n);return[{normal:n,distance:s}]};const Vu=(e,t,n)=>{const s=C(t,e.normal);const r=e.distance-s;const o=I(t,n);if(r>o){return[]}const c=Math.sqrt(o*o-r*r);const i=E(e.normal,r);const f=M(t,i);const l=E(q(e.normal),c);const d=c<a?[f]:[M(f,l),O(f,l)];return d.map((e=>v(O(n,e)))).map((e=>({normal:e,distance:C(t,e)})))};const zu=e=>e<0?-Math.pow(-e,1/3):Math.pow(e,1/3);const $u=(e,t,n,s,r)=>{switch(e){case 1:return[-r/s];case 2:{const e=Math.pow(s,2)-4*n*r;if(e<-a){return[]}const t=-s/(2*n);if(e<a){return[t]}const o=Math.sqrt(e)/(2*n);return[t+o,t-o]}case 3:{const e=n/t;const o=s/t;const c=r/t;const i=(3*o-Math.pow(e,2))/9;const f=(9*e*o-27*c-2*Math.pow(e,3))/54;const l=Math.pow(i,3)+Math.pow(f,2);const d=-e/3;if(l>0){const e=Math.sqrt(l);const t=zu(f+e);const n=zu(f-e);return[d+t+n]}if(Math.abs(l)<a){const e=Math.pow(f,1/3);if(f<0){return[]}return[d+2*e,d-e]}const u=Math.sqrt(-l);const m=Math.atan2(u,f)/3;const g=Math.pow(Math.pow(f,2)-l,1/6);const p=g*Math.cos(m);const _=g*Math.sin(m);return[d+2*p,d-p-Math.sqrt(3)*_,d-p+Math.sqrt(3)*_]}default:return[]}};const Tu=(e,t,n,s)=>{if(Math.abs(1-C(e.normal,n)/e.distance)<.02){return[]}const r=q(e.normal);const o=O(M(n,E(e.normal,e.distance)),E(s,2));const c=O(E(e.normal,e.distance),n);const i=C(s,t.normal)-t.distance;const f=2*C(c,r);const l=C(c,c);const d=C(M(o,c),r);const u=C(o,c);const m=C(r,t.normal);const g=C(c,t.normal);const p=m;const _=i+d*m+g;const h=i*f+u*m+d*g;const b=i*l+u*g;let y=0;if(Math.abs(h)>a){y=1}if(Math.abs(_)>a){y=2}if(Math.abs(p)>a){y=3}return $u(y,p,_,h,b).map((t=>M(E(e.normal,e.distance),E(r,t)))).map((e=>({p:e,normal:v(O(e,n))}))).map((e=>({normal:e.normal,distance:C(e.normal,N(e.p,n))})))};const Lu=(e,t,n)=>{const s=q(e.normal);const r=C(s,t.normal);if(Math.abs(r)<a){return undefined}const o=C(n,s);const c=C(n,t.normal);const i=(t.distance+2*o*r-c)/(2*r);return[{normal:s,distance:i}]};const Bu=(e,...t)=>[null,Cu,Su,Pu,Nu,Vu,Tu,Lu][e](...t);const Iu=Object.freeze({__proto__:null,normalAxiom:Bu,normalAxiom1:Cu,normalAxiom2:Su,normalAxiom3:Pu,normalAxiom4:Nu,normalAxiom5:Vu,normalAxiom6:Tu,normalAxiom7:Lu});const Ru=(e,t)=>[{vector:v(O(...Z(t,e))),origin:e}];const Uu=(e,t)=>[{vector:v(q(O(...Z(t,e)))),origin:N(e,t)}];const qu=(e,t)=>$d(e,t);const Du=(e,t)=>[{vector:q(v(e.vector)),origin:t}];const Wu=(e,t,n)=>(Lr({radius:I(t,n),origin:t},e)||[]).map((e=>({vector:v(q(O(...Z(e,n)))),origin:N(n,e)})));const Gu=(e,t,n,s)=>Tu(yn(e),yn(t),n,s).map(En);const Hu=(e,t,n)=>{const s=Tr(e,{vector:t.vector,origin:n},rt,rt);return s===undefined?[]:[{vector:v(q(O(...Z(s,n)))),origin:N(n,s)}]};const Ju=(e,...t)=>[null,Ru,Uu,qu,Du,Wu,Gu,Hu][e](...t);const Qu=Object.freeze({__proto__:null,axiom:Ju,axiom1:Ru,axiom2:Uu,axiom3:qu,axiom4:Du,axiom5:Wu,axiom6:Gu,axiom7:Hu});const Zu=(e,t)=>{const n=fe(e.vector,e.origin);return ee(n,t)};const Yu=(e,t,n,s)=>[n,s].map((t=>vr(e,t,nt))).reduce(((e,t)=>e&&t),true);const Xu=Yu;const Ku=(e,t,n,s)=>{const r=[n,s].map((t=>ud(e,t,nt,rt)));if(r[0]===undefined||r[1]===undefined){return[false,false]}const o=t.map((t=>t===undefined?undefined:ud(e,t,nt,rt)));const c=[0,1].map((e=>o[e]!==undefined));const a=t.map((e=>e===undefined?undefined:[Zu(e,r[0][0]),Zu(e,r[0][1])]));const i=a.map((e=>e===undefined?false:pr({vector:w(r[1][1],r[1][0]),origin:r[1][0]},e[0],it)||pr({vector:w(r[1][1],r[1][0]),origin:r[1][0]},e[1],it)||pr({vector:w(e[1],e[0]),origin:e[0]},r[1][0],it)||pr({vector:w(e[1],e[0]),origin:e[0]},r[1][1],it)));return[0,1].map((e=>i[e]===true&&c[e]===true))};const em=(e,t,n,s)=>{const r=Tr(n,{vector:q(n.vector),origin:s},rt,rt);return[s,r].filter((e=>e!==undefined)).map((t=>vr(e,t,nt))).reduce(((e,t)=>e&&t),true)};const tm=(e,t,n,s,r)=>{if(t.length===0){return[]}const o=[s,r].map((t=>vr(e,t,nt))).reduce(((e,t)=>e&&t),true);const c=t.map((e=>Zu(e,r))).map((t=>vr(e,t,nt)));return c.map((e=>e&&o))};const nm=function(e,t,n,s,r,o){if(t.length===0){return[]}const c=[r,o].map((t=>vr(e,t,nt))).reduce(((e,t)=>e&&t),true);if(!c){return t.map((()=>false))}const a=t.map((e=>Zu(e,r))).map((t=>vr(e,t,nt)));const i=t.map((e=>Zu(e,o))).map((t=>vr(e,t,nt)));return t.map(((e,t)=>a[t]&&i[t]))};const sm=(e,t,n,s,r)=>{const o=vr(e,r,nt);if(!t.length){return[false]}const c=Zu(t[0],r);const a=vr(e,c,nt);const i=Dr(e,s,it,rt)!==undefined;const f=Tr(s,t[0],rt,rt);const l=f?vr(e,f,nt):false;return o&&a&&i&&l};const rm=(e,t,n,...s)=>[null,Yu,Xu,Ku,em,tm,nm,sm][e](t,n,...s);const om=Object.freeze({__proto__:null,validateAxiom:rm,validateAxiom1:Yu,validateAxiom2:Xu,validateAxiom3:Ku,validateAxiom4:em,validateAxiom5:tm,validateAxiom6:nm,validateAxiom7:sm});const cm=e=>e.map((e=>typeof e==="object"&&e.vector?En(e):e));const am=(e,t,...n)=>{const s=Ju(e,...n);rm(e,t,s,...n).forEach(((e,t)=>e?t:undefined)).filter((e=>e!==undefined)).forEach((e=>delete s[e]));return s};const im=(e,t,...n)=>{const s=Bu(e,...n).map(En);rm(e,t,s,...cm(n)).forEach(((e,t)=>e?t:undefined)).filter((e=>e!==undefined)).forEach((e=>delete s[e]));return s};const fm=Object.freeze({__proto__:null,axiomWithBoundary:am,normalAxiomWithBoundary:im});const lm={...Qu,...Iu,...fm,...om};const dm=()=>{const e={};e.file_spec=_u;e.file_creator=hu;e.file_classes=["singleModel"];e.frame_classes=[];e.frame_attributes=[];e.vertices_coords=[];e.faces_vertices=[];return e};const um=e=>{if(!e.edges_foldAngle||!e.edges_foldAngle.length){return}let t=true;for(let n=0;n<e.edges_foldAngle.length;n+=1){if(e.edges_foldAngle[n]!==0&&e.edges_foldAngle[n]!==-180&&e.edges_foldAngle[n]!==180){t=false;break}}e.frame_classes.push(t?"creasePattern":"foldedForm");e.frame_attributes.push(t?"2D":"3D")};const mm=e=>e.map(((e,t,n)=>[e,n[(t+1)%n.length]]));const gm=({faces_vertices:e})=>{const t={};const n=[];e.flatMap(mm).forEach((e=>{const s=[e.join(" "),`${e[1]} ${e[0]}`];if(s[0]in t||s[1]in t){return}n.push(e);t[s[0]]=true}));return n};const pm=e=>e.slice(1).map((e=>parseInt(e,10)-1));const _m=e=>e.slice(1).map((e=>parseFloat(e)));const hm=e=>{const t=e.split("\n").map((e=>e.trim().split(/\s+/)));const n=dm();for(let e=0;e<t.length;e+=1){switch(t[e][0].toLowerCase()){case"f":n.faces_vertices.push(pm(t[e]));break;case"v":n.vertices_coords.push(_m(t[e]));break}}n.faces_normal=cs(n);n.faces_center=Rs(n);n.edges_vertices=gm(n);n.faces_edges=$s(n);n.edges_faces=xs(n);n.edges_foldAngle=Fs(n);n.edges_assignment=Os(n);n.vertices_vertices=us(n);delete n.faces_normal;delete n.faces_center;delete n.edges_faces;um(n);return n};const vm=(e,t)=>{const n={...e};fn(n,t);Xr(n,t);n.vertices_vertices=ms(n);const s=Vs(n);n.faces_vertices=s.faces_vertices;n.faces_edges=s.faces_edges;return n};const bm=({vertices_coords:e,edges_vertices:t})=>{const n=t.map((t=>t.map((t=>e[t])))).map((e=>B(...e)));const s=n.reduce(((e,t)=>Math.min(e,t)),Infinity);return s===Infinity?undefined:s};const ym=({vertices_coords:e,edges_vertices:t})=>{const n=bm({vertices_coords:e,edges_vertices:t});if(n){return n/4}const s=Bo({vertices_coords:e});return s&&s.span?.001*Math.max(...s.span):.001};const Em=(e,t,n="epsilon")=>{if(typeof t==="object"&&typeof t[n]==="number"){return t[n]}return typeof t==="number"?t:ym(e)};const Am=(e,t)=>e==null?null:Array.from(e.childNodes).filter((e=>e.attributes&&e.attributes.length)).filter((e=>Array.from(e.attributes).filter((e=>e.nodeValue===t)).shift()!==undefined)).shift();const xm=(e,t)=>{const n=Am(e,t);const s=n?Array.from(n.childNodes).shift():null;return s?s.textContent:undefined};const Mm=e=>{const t=Am(e,"lines");const n=t?Array.from(t.childNodes).filter((e=>e.getAttribute)).filter((e=>e.getAttribute("class").split(" ").includes("oripa.OriLineProxy"))).shift():undefined;return n?Array.from(n.childNodes):[]};const km=e=>e.filter((e=>e.nodeName==="void")).filter((e=>e.childNodes)).map((e=>Am(e,"oripa.OriLineProxy"))).filter((e=>e)).map((e=>["type","x0","x1","y0","y1"].map((t=>Am(e,t))).map((e=>e?Array.from(e.childNodes):[])).map((e=>e.filter((e=>e.nodeName==="double"||e.nodeName==="int")).shift())).map((e=>e&&e.childNodes[0]?e.childNodes[0].data:"0")).map(parseFloat)));const wm=["F","B","M","V","U"];const Om=e=>{const t={};t.vertices_coords=e.flatMap((e=>[[e[1],e[3]],[e[2],e[4]]]));t.edges_vertices=e.map(((e,t)=>[t*2,t*2+1]));t.edges_assignment=e.map((e=>wm[e[0]]));t.edges_foldAngle=js(t);return t};const jm=e=>{const t=ma(e,"text/xml");const n=Array.from(t.childNodes).filter((e=>e.getAttribute)).filter((e=>e.getAttribute("class").split(" ").includes("oripa.DataSet"))).shift();return Om(km(Mm(n)))};const Fm=(e,t)=>{const n={file_description:"memo",file_author:"originalAuthorName",file_title:"title"};Object.keys(n).forEach((t=>{n[t]=xm(e,n[t])}));Object.keys(n).filter((e=>n[e])).forEach((e=>{t[e]=n[e]}));t.file_classes=["singleModel"];t.frame_classes=["creasePattern"]};const Cm=(e,t)=>{const n=ma(e,"text/xml");const s=n&&n.childNodes?Array.from(n.childNodes):[];const r=s.filter((e=>e.getAttribute)).filter((e=>e.getAttribute("class").split(" ").includes("oripa.DataSet"))).shift();const o=Om(km(Mm(r)));const c=Em(o,t);const a=vm(o,c);Fm(r,a);return a};Object.assign(Cm,{opxEdgeGraph:jm});const Sm=4;const Pm={M:[1,0,0],V:[0,0,1],J:[1,1,0],U:[1,0,1],C:[0,1,0]};const Nm=(e=0,t=0,n=0)=>{const s=A([e,t,n],1/255);const r=p(s);if(r<.05){return"B"}const o=s.reduce(((e,t)=>e+t),0)/3;const c=R(s,[o,o,o]);const a=Object.keys(Pm).map((e=>({key:e,dist:R(s,Pm[e])}))).sort(((e,t)=>e.dist-t.dist)).shift();if(a.dist<c*Sm){return a.key}return r<.1?"B":"F"};const Vm=Object.freeze({__proto__:null,assignmentColor:Pm,rgbToAssignment:Nm});const zm=(e,t)=>{const n=Wc(e).toUpperCase();return t&&t[n]?t[n]:Nm(...Dc(e))};const $m=(e,t)=>{switch(t){case"M":case"m":return-180*e;case"V":case"v":return 180*e;default:return 0}};const Tm=(e,t)=>{const n=c().getComputedStyle(e).stroke;if(n!==""&&n!=="none"){return n}if(t.stroke!==undefined){return t.stroke}return undefined};const Lm=(e,t)=>{const n=c().getComputedStyle(e).opacity;if(n!==""){const e=parseFloat(n);if(!Number.isNaN(e)){return e}}if(t.opacity!==undefined){const e=parseFloat(t.opacity);if(!Number.isNaN(e)){return e}}return undefined};const Bm=Object.freeze({__proto__:null,colorToAssignment:zm,getEdgeOpacity:Lm,getEdgeStroke:Tm,opacityToFoldAngle:$m});const Im=(e,t)=>t.map((t=>e.getAttribute(t))).map((e=>e==null?0:e)).map(parseFloat);const Rm=e=>[Im(e,["x1","y1","x2","y2"])];const Um=function(e){const[t,n,s,r]=Im(e,["x","y","width","height"]);return[[t,n,t+s,n],[t+s,n,t+s,n+r],[t+s,n+r,t,n+r],[t,n+r,t,n]]};const qm=e=>{const t=e.split(/[\s,]+/).map(parseFloat);return Array.from(Array(Math.floor(t.length/2))).map(((e,n)=>[t[n*2+0],t[n*2+1]]))};const Dm=e=>qm(e.getAttribute("points")||"").map(((e,t,n)=>[n[t][0],n[t][1],n[(t+1)%n.length][0],n[(t+1)%n.length][1]]));const Wm=function(e){const t=Dm(e);t.pop();return t};const Gm={L:true,V:true,H:true,Z:true};const Hm=e=>Pa(e.getAttribute("d")||"").filter((e=>Gm[e.command.toUpperCase()])).map((e=>[e.start,e.end])).filter((e=>!tt(...e))).map((e=>e.flat()));const Jm={line:Rm,rect:Um,polygon:Dm,polyline:Wm,path:Hm};const Qm=(e,t)=>{const n=[[e[0],e[1]],[e[2],e[3]]];if(!t){return n}const s=da(t);return s?n.map((e=>ee(s,e))):n};const Zm=e=>xa(e).filter((e=>Jm[e.element.nodeName])).flatMap((e=>Jm[e.element.nodeName](e.element).map((t=>Qm(t,e.attributes.transform))).map((t=>({...e,segment:t})))));const Ym=e=>{if(!c().document.body){return undefined}const t=c().document.createElement("div");t.setAttribute("display","none");c().document.body.appendChild(t);t.appendChild(e);return t};const Xm=e=>va(e).map((e=>e.nodeName==="style")).reduce(((e,t)=>e||t),false);const Km=e=>{const s=typeof e==="string"?ma(e,"image/svg+xml"):e;if(Xm(s)&&t){console.warn(n.backendStylesheet)}const r=ga(s)===c().document?undefined:Ym(s);const o=Zm(s);o.map((e=>({data:{assignment:e.attributes["data-assignment"],foldAngle:e.attributes["data-foldAngle"]},stroke:Tm(e.element,e.attributes),opacity:Lm(e.element,e.attributes)}))).forEach(((e,t)=>{o[t]={...o[t],...e}}));if(r&&r.parentNode){r.parentNode.removeChild(r)}return o};const eg=function(e){const t=`${e}`.match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);return Math.max(0,(t[1]?t[1].length:0)-(t[2]?+t[2]:0))};const tg=function(e,t=15){if(typeof e!=="number"){return e}const n=parseFloat(e.toFixed(t));if(eg(n)===Math.min(t,eg(e))){return e}return n};const ng=Object.freeze({__proto__:null,cleanNumber:tg});const sg=e=>{if(!e||!e.assignments){return undefined}const t={};Object.keys(e.assignments).forEach((n=>{const s=Wc(n).toUpperCase();t[s]=e.assignments[n]}));return t};const rg=(e,t="#f0f",n=undefined)=>{if(e){return e}return zm(t,n)};const og=(e,t=1,n=undefined)=>{if(e){return parseFloat(e)}return $m(t,n)};const cg=(e,t)=>{const n=sg(t);if(n){e.forEach((e=>{delete e.data.assignment;delete e.data.foldAngle}))}const s=e.map((e=>rg(e.data.assignment,e.stroke,n)));const r=e.map(((e,t)=>og(e.data.foldAngle,e.opacity,s[t])));return{edges_assignment:s,edges_foldAngle:r}};const ag=(e,t)=>{const n=Km(e);const{edges_assignment:s,edges_foldAngle:r}=cg(n,t);const o=t&&t.fast?e=>e:tg;const c=n.flatMap((e=>e.segment)).map((e=>e.map((e=>o(e,12)))));const a=n.map(((e,t)=>[t*2,t*2+1]));return{vertices_coords:c,edges_vertices:a,edges_assignment:s,edges_foldAngle:r}};const ig=(e,t)=>{const n=ag(e,t);const s=Em(n,t);const r=vm(n,s);if(typeof t!=="object"||t.boundary!==false){r.edges_assignment.map(((e,t)=>t)).filter((e=>r.edges_assignment[e]==="B"||r.edges_assignment[e]==="b")).forEach((e=>{r.edges_assignment[e]="F"}));const{edges:e}=qo(r);e.forEach((e=>{r.edges_assignment[e]="B"}))}return{file_spec:1.1,file_creator:"Rabbit Ear",frame_classes:["creasePattern"],...r}};Object.assign(ig,{...Bm,svgSegments:Km,svgEdgeGraph:ag,planarizeGraph:vm,makeEpsilon:ym});const fg={objToFold:hm,opxToFold:Cm,svgToFold:ig,foldToSvg:nd,foldToObj:rd};const lg=(e,t=1)=>{if(!e.file_frames||e.file_frames.length<t){return e}const s=["frame_parent","frame_inherit"];const r={visited_frames:[]};const o={};Ct(e,"file").filter((e=>e!=="file_frames")).forEach((t=>{o[t]=e[t]}));const c=(e,t,s)=>{if(r.visited_frames.indexOf(t)!==-1){throw new Error(n.graphCycle)}r.visited_frames.push(t);s=[t].concat(s);if(t===0){return s}if(e.file_frames[t-1].frame_inherit&&e.file_frames[t-1].frame_parent!=null){return c(e,e.file_frames[t-1].frame_parent,s)}return s};return c(e,t,[]).map((t=>{if(t===0){const t=e.file_frames;e.file_frames=null;const n=rr(e);e.file_frames=t;delete n.file_frames;s.forEach((e=>delete n[e]));return n}const n=rr(e.file_frames[t-1]);s.forEach((e=>delete n[e]));return n})).reduce(((e,t)=>Object.assign(e,t)),o)};const dg=function(e,t){const n=["frame_parent","frame_inherit"];const s=rr(t);n.forEach((e=>delete s[e]));const r=e.file_frames;e.file_frames=null;const o=rr(e);e.file_frames=r;delete o.file_frames;Object.assign(o,t);return o};const ug=e=>{const t={...e};delete t.file_frames;return t};const mg=e=>{if(!e.file_frames||!e.file_frames.length){return[e]}return[ug(e),...e.file_frames]};const gg=(e,t)=>mg(e).map(((e,n)=>e.frame_classes&&e.frame_classes.includes(t)?n:undefined)).filter((e=>e!==undefined)).map((t=>lg(e,t)));const pg=Object.freeze({__proto__:null,flattenFrame:lg,getFramesByClassName:gg,mergeFrame:dg});const _g=Object.keys(bt);const hg=(e,t,n=a)=>{let s=e.vertices_coords.length;return t.vertices_coords.map((t=>e.vertices_coords.map((e=>B(e,t)<n)).map(((e,t)=>e?t:undefined)).filter((e=>e!==undefined)).shift())).map((e=>e===undefined?s++:e))};const vg=(e,t)=>{const n={};const s={};for(let t=0;t<e.edges_vertices.length;t+=1){s[`${e.edges_vertices[t][0]} ${e.edges_vertices[t][1]}`]=t;s[`${e.edges_vertices[t][1]} ${e.edges_vertices[t][0]}`]=t}for(let e=0;e<t.edges_vertices.length;e+=1){const r=s[`${t.edges_vertices[e][0]} ${t.edges_vertices[e][1]}`];if(r!==undefined){n[e]=r}}return n};const bg=(e,t,n,s)=>n.forEach((n=>t[n].forEach((t=>e[t].forEach(((r,o)=>r.forEach(((r,c)=>{e[t][o][c]=s[n][r]}))))))));const yg=(e,t,n=a)=>{const s={};const r={};const o={};const c=[e,t].map((e=>e.vertices_coords)).map((e=>e&&e.length?e[0].length:0)).reduce(((e,t)=>Math.max(e,t)));e.vertices_coords=e.vertices_coords.map((e=>Q(c,e)));_g.forEach((e=>{s[e]=Ct(t,`${e}_`);r[e]=St(t,`_${e}`)}));_g.forEach((t=>s[t].filter((t=>!e[t])).forEach((t=>{e[t]=[]}))));o.vertices=hg(e,t,n);bg(t,r,["vertices"],o);const i=Zt.edges(e);o.edges=Array.from(Array(Zt.edges(t))).map(((e,t)=>i+t));const f=vg(e,t);Object.keys(f).forEach((e=>{o.edges[e]=f[e]}));const l=Zt.faces(e);o.faces=Array.from(Array(Zt.faces(t))).map(((e,t)=>l+t));bg(t,r,["edges","faces"],o);_g.forEach((n=>s[n].forEach((s=>t[s].forEach(((t,r)=>{const c=o[n][r];e[s][c]=t}))))));return o};const Eg=Object.freeze({__proto__:null,joinGraphs:yg});const Ag=(e,t=a)=>Ns(e,t).map((t=>e.vertices_coords.map((e=>e[0]>t.min[0]&&e[1]>t.min[1]&&e[0]<t.max[0]&&e[1]<t.max[1]))));const xg=({vertices_coords:e,edges_vertices:t,edges_coords:n},s=a)=>{const r=Ns({vertices_coords:e,edges_vertices:t,edges_coords:n},s);const o=t.map((()=>[]));for(let e=0;e<t.length-1;e+=1){for(let n=e+1;n<t.length;n+=1){const t=(r[e].max[0]<r[n].min[0]||r[n].max[0]<r[e].min[0])&&(r[e].max[1]<r[n].min[1]||r[n].max[1]<r[e].min[1]);o[e][n]=!t;o[n][e]=!t}}for(let e=0;e<t.length;e+=1){o[e][e]=true}return o};const Mg=Object.freeze({__proto__:null,getEdgesEdgesOverlapingSpans:xg,getEdgesVerticesOverlappingSpan:Ag});const kg=(e,t=a)=>{if(!e.vertices_coords||!e.edges_vertices||!e.edges_vertices.length){return{edges_line:[],lines:[]}}const n=Cs(e);const s=Ss(e).map(h);const r=s.map(((e,t)=>({vector:e,origin:n[t][0]})));const o=r.map((e=>dr(e,[0,0,0],lt,t)));const c=o.map((e=>m(e)));const i=nn(c,t);const f=i.map((e=>e.map((e=>s[e])))).map((e=>sn(e,t)));const l=f.map(((e,t)=>e.map((e=>e.map((e=>i[t][e]))))));const d=l.flatMap((e=>e.map((e=>e[0])).map((e=>({vector:s[e],origin:o[e]})))));const u=[];let g=0;l.forEach((e=>e.forEach((e=>{e.forEach((e=>{u[e]=g}));g+=1}))));return{lines:d,edges_line:u}};const wg=Object.freeze({__proto__:null,getEdgesLine:kg});const Og=({normal:e,distance:t})=>t<0?{normal:U(e),distance:-t}:{normal:e,distance:t};const jg=(e,t=a)=>{const{lines:n}=kg(e,t);const s=n.map(yn).map(Og);const r=n.map((({vector:e,origin:t})=>fe(e,t)));const o=r.map((e=>n.map((({vector:t,origin:n})=>te(e,t,n)))));const c=o.map((e=>e.map((e=>e.vector[0]<0?{vector:U(e.vector),origin:e.origin}:e)))).map((e=>e.map(yn).map(Og))).map((e=>e.concat(s)));const i=c.map((e=>nn(e.map((e=>e.distance)))));const f=i.map(((e,n)=>e.map((e=>e.map((e=>c[n][e].normal)))).map((e=>sn(e,t)))));const l=f.map(((e,t)=>e.flatMap(((e,n)=>e.map((e=>e.map((e=>i[t][n][e]))))))));const d=l.map((e=>(e.length-n.length)/n.length));return d.map(((e,t)=>({error:e,i:t}))).map((e=>({line:n[e.i],error:e.error}))).sort(((e,t)=>e.error-t.error))};const Fg=(e,t=a)=>jg(e,t)[0];const Cg=Object.freeze({__proto__:null,findSymmetryLine:Fg,findSymmetryLines:jg});const Sg=e=>Array.from(Array(e.length-2)).map(((t,n)=>[e[0],e[n+1],e[n+2]]));const Pg=({faces_vertices:e})=>e.flatMap((e=>e.length<4?[e]:Sg(e)));const Ng=e=>e.length===3?[e]:Array.from(Array(Math.floor(e.length/3))).map(((t,n)=>[n*3+0,n*3+1,n*3+2].map((t=>e[t]))));const Vg=({vertices_coords:e,faces_vertices:t},s)=>{if(!e||!e.length){throw new Error(n.nonConvexTriangulation)}const r=e[0].length;return t.map((t=>t.flatMap((t=>e[t])))).map((e=>s(e,null,r))).map(((e,n)=>e.map((e=>t[n][e])))).flatMap((e=>Ng(e)))};const zg=e=>{if(!e.edges_vertices){e.edges_vertices=[]}const t=hs(e);let n=e.edges_vertices.length;const s=[];e.faces_edges=e.faces_vertices.map((e=>e.map(((e,r,o)=>{const c=[e,o[(r+1)%o.length]];const a=c.join(" ");if(a in t){return t[a]}s.push(c);t[a]=n;t[c.reverse().join(" ")]=n;return n++}))));const r=s.length;e.edges_vertices.push(...s);if(e.edges_assignment){e.edges_assignment.push(...Array(r).fill("J"))}if(e.edges_foldAngle){e.edges_foldAngle.push(...Array(r).fill(0))}if(e.vertices_vertices){delete e.vertices_vertices}if(e.vertices_edges){delete e.vertices_edges}if(e.vertices_faces){delete e.vertices_faces}if(e.edges_faces){delete e.edges_faces}if(e.faces_faces){delete e.faces_faces}if(e.faceOrders){delete e.faceOrders}return e};const $g=({faces_vertices:e})=>{let t=0;return e.map((e=>Math.max(3,e.length))).map((e=>Array.from(Array(e-2)).map((()=>t++))))};const Tg=(e,t)=>{if(!e.faces_vertices){return{}}const n=e.edges_vertices?e.edges_vertices.length:0;const s=$g(e);e.faces_vertices=t?Vg(e,t):Pg(e);zg(e);const r=Array.from(Array(e.edges_vertices.length-n)).map(((e,t)=>n+t));return{faces:{map:s},edges:{new:r}}};const Lg=Object.freeze({__proto__:null,triangulate:Tg,triangulateConvexFacesVertices:Pg,triangulateNonConvexFacesVertices:Vg});const Bg=Object.freeze([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);const Ig=e=>Bg.map(((t,n)=>Math.abs(t-e[n])<a)).reduce(((e,t)=>e&&t),true);const Rg=(e,t)=>[e[0]*t[0]+e[4]*t[1]+e[8]*t[2]+e[12],e[1]*t[0]+e[5]*t[1]+e[9]*t[2]+e[13],e[2]*t[0]+e[6]*t[1]+e[10]*t[2]+e[14]];const Ug=(e,t,n)=>({vector:[e[0]*t[0]+e[4]*t[1]+e[8]*t[2],e[1]*t[0]+e[5]*t[1]+e[9]*t[2],e[2]*t[0]+e[6]*t[1]+e[10]*t[2]],origin:[e[0]*n[0]+e[4]*n[1]+e[8]*n[2]+e[12],e[1]*n[0]+e[5]*n[1]+e[9]*n[2]+e[13],e[2]*n[0]+e[6]*n[1]+e[10]*n[2]+e[14]]});const qg=(e,t)=>[e[0]*t[0]+e[4]*t[1]+e[8]*t[2]+e[12]*t[3],e[1]*t[0]+e[5]*t[1]+e[9]*t[2]+e[13]*t[3],e[2]*t[0]+e[6]*t[1]+e[10]*t[2]+e[14]*t[3],e[3]*t[0]+e[7]*t[1]+e[11]*t[2]+e[15]*t[3],e[0]*t[4]+e[4]*t[5]+e[8]*t[6]+e[12]*t[7],e[1]*t[4]+e[5]*t[5]+e[9]*t[6]+e[13]*t[7],e[2]*t[4]+e[6]*t[5]+e[10]*t[6]+e[14]*t[7],e[3]*t[4]+e[7]*t[5]+e[11]*t[6]+e[15]*t[7],e[0]*t[8]+e[4]*t[9]+e[8]*t[10]+e[12]*t[11],e[1]*t[8]+e[5]*t[9]+e[9]*t[10]+e[13]*t[11],e[2]*t[8]+e[6]*t[9]+e[10]*t[10]+e[14]*t[11],e[3]*t[8]+e[7]*t[9]+e[11]*t[10]+e[15]*t[11],e[0]*t[12]+e[4]*t[13]+e[8]*t[14]+e[12]*t[15],e[1]*t[12]+e[5]*t[13]+e[9]*t[14]+e[13]*t[15],e[2]*t[12]+e[6]*t[13]+e[10]*t[14]+e[14]*t[15],e[3]*t[12]+e[7]*t[13]+e[11]*t[14]+e[15]*t[15]];const Dg=e=>{const t=e[10]*e[15]-e[11]*e[14];const n=e[9]*e[15]-e[11]*e[13];const s=e[9]*e[14]-e[10]*e[13];const r=e[8]*e[15]-e[11]*e[12];const o=e[8]*e[14]-e[10]*e[12];const c=e[8]*e[13]-e[9]*e[12];return e[0]*(e[5]*t-e[6]*n+e[7]*s)-e[1]*(e[4]*t-e[6]*r+e[7]*o)+e[2]*(e[4]*n-e[5]*r+e[7]*c)-e[3]*(e[4]*s-e[5]*o+e[6]*c)};const Wg=e=>{const t=Dg(e);if(Math.abs(t)<1e-6||Number.isNaN(t)||!Number.isFinite(e[12])||!Number.isFinite(e[13])||!Number.isFinite(e[14])){return undefined}const n=e[10]*e[15]-e[11]*e[14];const s=e[9]*e[15]-e[11]*e[13];const r=e[9]*e[14]-e[10]*e[13];const o=e[8]*e[15]-e[11]*e[12];const c=e[8]*e[14]-e[10]*e[12];const a=e[8]*e[13]-e[9]*e[12];const i=e[6]*e[15]-e[7]*e[14];const f=e[5]*e[15]-e[7]*e[13];const l=e[5]*e[14]-e[6]*e[13];const d=e[6]*e[11]-e[7]*e[10];const u=e[5]*e[11]-e[7]*e[9];const m=e[5]*e[10]-e[6]*e[9];const g=e[4]*e[15]-e[7]*e[12];const p=e[4]*e[14]-e[6]*e[12];const _=e[4]*e[11]-e[7]*e[8];const h=e[4]*e[10]-e[6]*e[8];const v=e[4]*e[13]-e[5]*e[12];const b=e[4]*e[9]-e[5]*e[8];const y=[+(e[5]*n-e[6]*s+e[7]*r),-(e[1]*n-e[2]*s+e[3]*r),+(e[1]*i-e[2]*f+e[3]*l),-(e[1]*d-e[2]*u+e[3]*m),-(e[4]*n-e[6]*o+e[7]*c),+(e[0]*n-e[2]*o+e[3]*c),-(e[0]*i-e[2]*g+e[3]*p),+(e[0]*d-e[2]*_+e[3]*h),+(e[4]*s-e[5]*o+e[7]*a),-(e[0]*s-e[1]*o+e[3]*a),+(e[0]*f-e[1]*g+e[3]*v),-(e[0]*u-e[1]*_+e[3]*b),-(e[4]*r-e[5]*c+e[6]*a),+(e[0]*r-e[1]*c+e[2]*a),-(e[0]*l-e[1]*p+e[2]*v),+(e[0]*m-e[1]*h+e[2]*b)];const E=1/t;return y.map((e=>e*E))};const Gg=Object.freeze([1,0,0,0,0,1,0,0,0,0,1,0]);const Hg=(e=0,t=0,n=0)=>[...Gg,e,t,n,1];const Jg=(e,t,n,s,r)=>{const o=Hg(...t);const c=Math.cos(e);const a=Math.sin(e);o[n*4+n]=c;o[n*4+s]=(r?+1:-1)*a;o[s*4+n]=(r?-1:+1)*a;o[s*4+s]=c;return o};const Qg=(e,t=[0,0,0])=>Jg(e,t,1,2,true);const Zg=(e,t=[0,0,0])=>Jg(e,t,0,2,false);const Yg=(e,t=[0,0,0])=>Jg(e,t,0,1,true);const Xg=(e,t=[0,0,1],n=[0,0,0])=>{const s=[0,1,2].map((e=>n[e]||0));const[r,o,c]=Q(3,h(t));const a=Math.cos(e);const i=Math.sin(e);const f=1-a;const l=Hg(-s[0],-s[1],-s[2]);const d=Hg(s[0],s[1],s[2]);return qg(d,qg([f*r*r+a,f*o*r+c*i,f*c*r-o*i,0,f*r*o-c*i,f*o*o+a,f*c*o+r*i,0,f*r*c+o*i,f*o*c-r*i,f*c*c+a,0,0,0,0,1],l))};const Kg=(e=[1,1,1],t=[0,0,0])=>[e[0],0,0,0,0,e[1],0,0,0,0,e[2],0,e[0]*-t[0]+t[0],e[1]*-t[1]+t[1],e[2]*-t[2]+t[2],1];const ep=(e=1,t=[0,0,0])=>Kg([e,e,e],t);const tp=(e,t=[0,0])=>{const n=fe(e,t);return[n[0],n[1],0,0,n[2],n[3],0,0,0,0,1,0,n[4],n[5],0,1]};const np=(e,t,n,s)=>{const r=Math.tan(Math.PI*.5-.5*e);const o=1/(n-s);return[r/t,0,0,0,0,r,0,0,0,0,(n+s)*o,-1,0,0,n*s*o*2,0]};const sp=(e,t,n,s,r,o)=>[2/(t-s),0,0,0,0,2/(e-n),0,0,0,0,2/(r-o),0,(s+t)/(s-t),(n+e)/(n-e),(r+o)/(r-o),1];const rp=(e,t,n)=>{const s=b(j(e,t));const r=b(L(n,s));const o=b(L(s,r));return[r[0],r[1],r[2],0,o[0],o[1],o[2],0,s[0],s[1],s[2],0,e[0],e[1],e[2],1]};const op=Object.freeze({__proto__:null,determinant4:Dg,identity4x4:Bg,invertMatrix4:Wg,isIdentity4x4:Ig,makeLookAtMatrix4:rp,makeMatrix4ReflectZ:tp,makeMatrix4Rotate:Xg,makeMatrix4RotateX:Qg,makeMatrix4RotateY:Zg,makeMatrix4RotateZ:Yg,makeMatrix4Scale:Kg,makeMatrix4Translate:Hg,makeMatrix4UniformScale:ep,makeOrthographicMatrix4:sp,makePerspectiveMatrix4:np,multiplyMatrices4:qg,multiplyMatrix4Line3:Ug,multiplyMatrix4Vector3:Rg});const cp=(e,t)=>{const n=L(e,t);const s=[n[0],n[1],n[2],F(e,t)];s[3]+=m(s);return h(s)};const ap=e=>qg([e[3],e[2],-e[1],e[0],-e[2],e[3],e[0],e[1],e[1],-e[0],e[3],e[2],-e[0],-e[1],-e[2],e[3]],[e[3],e[2],-e[1],-e[0],-e[2],e[3],e[0],-e[1],e[1],-e[0],e[3],-e[2],e[0],e[1],e[2],e[3]]);const ip=Object.freeze({__proto__:null,matrix4FromQuaternion:ap,quaternionFromTwoVectors:cp});const fp=({vertices_coords:e,faces_vertices:t},n=a)=>{const s=cs({vertices_coords:e,faces_vertices:t});const r=t.map((()=>[]));for(let e=0;e<t.length-1;e+=1){for(let o=e+1;o<t.length;o+=1){if(e===o){continue}if(G(s[e],s[o],n)){r[e].push(o);r[o].push(e)}}}const o=xl(r);const c=er(o).map((e=>typeof e==="number"?[e]:e));const i=c.map((e=>s[e[0]]));const f=[];c.forEach(((e,t)=>e.forEach((e=>{f[e]=S(s[e],i[t])>0}))));const l=t.map((t=>e[t[0]])).map((e=>Q(3,e)));const d=c.map(((e,t)=>e.map((e=>S(i[t],l[e])))));const u=d.map(((e,t)=>nn(e).map((e=>e.map((e=>c[t][e]))))));const m=u.flatMap(((e,t)=>e.map((()=>[...i[t]]))));const g=u.flat();const p=g.map((e=>e[0])).map((e=>l[e])).map(((e,t)=>S(m[t],e))).map(((e,t)=>A(m[t],e)));const _=g.map(((e,t)=>({normal:m[t],origin:p[t]})));return g.map(((e,t)=>({faces:e,facesAligned:e.map((e=>f[e])),plane:_[t]})))};const lp=(e,t,n,s)=>{const r=e.vertices_coords.map((e=>Q(3,e)));const o=t.map((t=>t.faces.map(((n,s)=>t.facesAligned[s]?e.faces_vertices[n]:e.faces_vertices[n].slice().reverse())).map((e=>e.map((e=>r[e])))).map((e=>He(e,s)))));const c=[];const a=o.map(((e,t)=>e.map((e=>e.map((e=>Rg(n[t],e))).map((e=>[e[0],e[1]]))))));t.map((e=>e.faces)).forEach(((e,t)=>e.forEach(((e,n)=>{c[e]=a[t][n]}))));return c};const dp=({vertices_coords:e,faces_vertices:t,faces_faces:n},s=a)=>{if(!n){n=Ts({faces_vertices:t})}const r=fp({vertices_coords:e,faces_vertices:t},s);const o=[];r.forEach((e=>e.facesAligned.forEach(((t,n)=>{o[e.faces[n]]=t}))));const c=[0,0,1];const i=r.map((e=>e.plane.normal)).map((e=>{const t=F(e,c);return Math.abs(t+1)<.01?Xg(Math.PI,[1,0,0]):ap(cp(e,c))}));const f=lp({vertices_coords:e,faces_vertices:t},r,i,s);const l=r.map((e=>e.faces)).map((e=>No(n,e)));const d=l.map((e=>xl(e)));const u=d.map((e=>er(e).map((e=>e.constructor===Array?e:[e]))));const m=d.map((e=>{const t=e.map(((e,t)=>t));return e.map((n=>t.filter((t=>e[t]!==n))))}));const g=t.map((()=>[]));m.forEach((e=>e.forEach(((e,t)=>{for(let n=0;n<e.length;n+=1){const r=e[n];const o=[t,r].map((e=>f[e]));const c=br(...o,s);if(c){g[t][r]=true;g[r][t]=true}}}))));const p=m.map((e=>e.map(((e,t)=>e.filter((e=>g[t][e]))))));const _=[];p.forEach(((e,t)=>{_[t]=[];e.forEach(((e,n)=>{const s=d[t][n];const r=e.map((e=>d[t][e]));if(!_[t][s]){_[t][s]=new Set}r.forEach((e=>{if(!_[t][e]){_[t][e]=new Set}}));r.forEach((e=>{_[t][s].add(e);_[t][e].add(s)}))}))}));_.forEach(((e,t)=>e.forEach(((e,n)=>{_[t][n]=[...e]}))));const h=_.map((e=>er(xl(e)).map((e=>e.constructor===Array?e:[e]))));const v=h.flatMap(((e,t)=>e.map((()=>t))));const b=r.map(((e,t)=>h[t].map((e=>e.flatMap((e=>u[t][e]))))));const y=b.flatMap(((e,t)=>e.map((e=>({faces:e,facesAligned:e.map((e=>o[e])),plane:r[t].plane})))));const E=v.map((e=>r[e].plane));const A=v.map((e=>i[e]));const x=y.map((e=>e.faces));const M=er(x);return{sets_faces:x,sets_plane:E,sets_transformXY:A,faces_set:M,faces_winding:o}};const up=Object.freeze({__proto__:null,coplanarFacesGroups:fp,coplanarOverlappingFacesGroups:dp});const mp=e=>e.map((e=>e.map(((e,t)=>e===true?t:undefined)).filter((e=>e!==undefined))));const gp=({vertices_coords:e,edges_vertices:t,edges_coords:n},s=a)=>{if(!n){n=Cs({vertices_coords:e,edges_vertices:t})}const r=Ns({vertices_coords:e,edges_vertices:t,edges_coords:n});const o=Array.from(Array(n.length)).map((()=>[]));const c=r.length?r[0].min.length:0;for(let e=0;e<n.length-1;e+=1){for(let t=e+1;t<n.length;t+=1){let n=true;for(let o=0;o<c;o+=1){if(!Ke(r[e].min[o],r[t].min[o],s)||!Ke(r[e].max[o],r[t].max[o],s)){n=false}}o[e][t]=n;o[t][e]=n}}for(let e=0;e<n.length-1;e+=1){for(let t=e+1;t<n.length;t+=1){if(!o[e][t]){continue}const r=tt(n[e][0],n[t][0],s)&&tt(n[e][1],n[t][1],s);const c=tt(n[e][0],n[t][1],s)&&tt(n[e][1],n[t][0],s);const a=r||c;o[e][t]=a;o[t][e]=a}}return mp(o)};const pp=({vertices_coords:e,edges_vertices:t,edges_vector:n,edges_faces:s,faces_vertices:r},o=a)=>{if(!n){n=Ss({vertices_coords:e,edges_vertices:t})}const c=bl({vertices_coords:e,faces_vertices:r});const i=t.map((t=>e[t[0]]));const f=t.map((()=>Array.from(Array(r.length))));s.forEach(((e,t)=>e.forEach((e=>{f[t][e]=false}))));const l=gp({vertices_coords:e,edges_vertices:t});const d=t.map((t=>t.map((t=>e[t]))));const u=r.map((t=>t.map((t=>e[t]))));for(let e=0;e<c.length;e+=1){if(!c[e]){u[e].reverse()}}const m=Ns({edges_coords:d});const g=u.map((e=>Ye(e)));for(let e=0;e<f.length;e+=1){for(let t=0;t<f[e].length;t+=1){if(f[e][t]===false){continue}if(!yr(g[t],m[e],o)){f[e][t]=false;continue}}}const p={};for(let e=0;e<f.length;e+=1){if(p[e]){continue}for(let t=0;t<f[e].length;t+=1){if(f[e][t]!==undefined){continue}const s=d[e].map((e=>vr(u[t],e,st,o))).reduce(((e,t)=>e||t),false);if(s){f[e][t]=true;continue}const r=Dr(u[t],{vector:n[e],origin:i[e]},ft,ft,o);if(r){f[e][t]=true;continue}f[e][t]=false}l[e].forEach((t=>{f[t]=f[e].slice();p[t]=true}))}return f.map((e=>e.map(((e,t)=>e?t:undefined)).filter((e=>e!==undefined))))};const _p=Object.freeze({__proto__:null,getEdgesFacesOverlap:pp});const hp=({vertices_coords:e,faces_vertices:t},n=a)=>{const s=Ls({vertices_coords:e,faces_vertices:t});const r=s.map((e=>Ye(e)));const o=[];const c=[];Pr({vertices_coords:e,faces_vertices:t},0,n).forEach((e=>{e.start.forEach((e=>{c[e]=true}));c.forEach(((t,c)=>e.start.forEach((e=>{if(c===e){return}if(!yr(r[c],r[e],n)||!br(s[c],s[e],n)){return}if(!o[c]){o[c]=[]}if(!o[e]){o[e]=[]}o[c][e]=true;o[e][c]=true}))));e.end.forEach((e=>delete c[e]))}));return o.map((e=>Object.keys(e).map((e=>parseInt(e,10)))))};const vp=Object.freeze({__proto__:null,getFacesFacesOverlap:hp});const bp=(e,t,n,s=a)=>{e.faces_vertices[t].map((t=>e.vertices_coords[t])).map((e=>n.map((t=>tt(e,t,s)))));e.faces_vertices[t].map((t=>e.vertices_coords[t])).map(((e,t,n)=>[e,n[(t+1)%n.length]])).map((e=>bn(...e))).map((e=>n.map((t=>pr(e,t,ft,s)))))};const yp=(e,t,n=a)=>{const s=O(t[1],t[0]);const r=t[0];const o=Fo(e,t,n);const c=o.map((t=>e.faces_vertices[t].map((t=>e.vertices_coords[t])))).map((e=>ud(e,{vector:s,origin:r},nt,it,n)));const i=[];o.forEach(((e,t)=>{if(c[t]){i[e]=c[t]}}));return i};const Ep=(e,t,n=a)=>{const s=yp(e,t,n);console.log("facesSegment",s);const r=s.map(((t,s)=>bp(e,s,t,n)));return r};const Ap={count:Zt,countImplied:qn,validate:Lo,clean:sr,populate:to,remove:dn,replace:cn,removePlanarVertex:qd,removePlanarEdge:Pd,splitEdge:uo,splitFace:Po,flatFold:mu,addPlanarSegment:jd,addPlanarSegmentNew:Ep,planarize:Xr,connectedComponents:xl,clone:rr,...Vm,...pg,...vt,...Bt,...Do,...Ed,...ir,...Eg,...Us,...nr,...Or,...is,...Fl,...Mg,...$o,...Vr,...Cg,...Al,...Gt,...Lg,...Hn,...on,...Jt,...Ud,...ln,...tc,..._n,...os,...Qs,...Ws,...Id,...wg,...up,...Xo,...Ho,...yl,...kd,...Qr,..._p,...So,...vp,...$r};const xp=e=>{if(typeof e!=="object"){return typeof e}if(e.radius!==undefined){return"circle"}if(e.min&&e.max&&e.span){return"box"}if(typeof e[0]==="number"){return"vector"}if(e.vector!==undefined&&e.origin!==undefined){return"line"}if(e[0]!==undefined&&e[0].length&&typeof e[0][0]==="number"){return e.length===2?"segment":"polygon"}return"object"};const Mp={...d,...mt,...Le,...An,...Pe,...ng,...Yn,...ns,typeof:xp};const kp={...Y,...le,...je,...op,...ip};const wp=e=>e.concat(e.slice(0,-1).reverse());const Op=(e=[],t=false,n=a)=>{if(e.length<2){return[]}const s=ts(e,n).map((e=>e.length===1?e:wp(e))).flat();s.push(s[0]);const r=[s[0]];let o=1;const c={"-1":()=>r.pop(),1:e=>{r.push(e);o+=1},undefined:()=>{o+=1}};c[0]=t?c["1"]:c["-1"];while(o<s.length){if(r.length<2){r.push(s[o]);o+=1;continue}const t=r[r.length-2];const a=r[r.length-1];const i=s[o];const f=Ln(...[t,a,i].map((t=>e[t])),n);c[f](i)}r.pop();return r};const jp=Object.freeze({__proto__:null,convexHull:Op});const Fp=(e,t,n)=>{const s=e.map(((e,t)=>({vector:n[t],origin:e}))).map(((e,t,n)=>Tr(e,n[(t+1)%n.length],at,at)));const r=t.map(((e,t)=>dr(e,s[t],(e=>e))));if(e.length===3){return e.map((e=>({type:"skeleton",points:[e,s[0]]}))).concat([{type:"perpendicular",points:[r[0],s[0]]}])}const o=s.map(((e,t)=>B(e,r[t])));let c=0;o.forEach(((e,t)=>{if(e<o[c]){c=t}}));const a=[{type:"skeleton",points:[e[c],s[c]]},{type:"skeleton",points:[e[(c+1)%e.length],s[c]]},{type:"perpendicular",points:[r[c],s[c]]}];const i=jn(U(t[(c+t.length-1)%t.length].vector),t[(c+1)%t.length].vector);const f=c===e.length-1;e.splice(c,2,s[c]);t.splice(c,1);n.splice(c,2,i);if(f){e.splice(0,1);n.splice(0,1);t.push(t.shift())}return a.concat(Fp(e,t,n))};const Cp=e=>{const t=e.map(((e,t,n)=>[e,n[(t+1)%n.length]])).map((e=>({vector:w(e[1],e[0]),origin:e[0]})));const n=e.map(((e,t,n)=>[(t-1+n.length)%n.length,t,(t+1)%n.length].map((e=>n[e])))).map((e=>[w(e[0],e[1]),w(e[2],e[1])])).map((e=>jn(...e)));return Fp([...e],t,n)};const Sp={...jp,...Td,...gr,...Xe,...Bn,straightSkeleton:Cp};const Pp=(e,t,n=a)=>{const s=Math.min(e.min.length,t.min.length);for(let r=0;r<s;r+=1){if(t.min[r]<e.min[r]-n||t.max[r]>e.max[r]+n){return false}}return true};const Np=(e,t,n=nt)=>{const s=e.map((e=>vr(t,e,n))).reduce(((e,t)=>e||t),false);const r=t.map((e=>vr(t,e,n))).reduce(((e,t)=>e&&t),true);return!s&&r};const Vp=Object.freeze({__proto__:null,enclosingBoundingBoxes:Pp,enclosingPolygonPolygon:Np});const zp=(e,t)=>{const n=e.map(((e,n)=>{const s=pr(t,e,rt);return{point:s?e:null,at_index:n}})).filter((e=>e.point!=null));const s=e.map(((e,t,n)=>({vector:w(e,n[(t+1)%n.length]),origin:n[(t+1)%n.length]}))).map(((e,n)=>({point:Tr(t,e,ot,ft),at_index:n}))).filter((e=>e.point!=null));if(s.length===2){const t=s.slice().sort(((e,t)=>e.at_index-t.at_index));const n=e.slice(t[1].at_index+1).concat(e.slice(0,t[0].at_index+1));n.push(t[0].point);n.push(t[1].point);const r=e.slice(t[0].at_index+1,t[1].at_index+1);r.push(t[1].point);r.push(t[0].point);return[n,r]}if(s.length===1&&n.length===1){n[0].type="v";s[0].type="e";const t=n.concat(s).sort(((e,t)=>e.at_index-t.at_index));const r=e.slice(t[1].at_index+1).concat(e.slice(0,t[0].at_index+1));if(t[0].type==="e"){r.push(t[0].point)}r.push(t[1].point);const o=e.slice(t[0].at_index+1,t[1].at_index+1);if(t[1].type==="e"){o.push(t[1].point)}o.push(t[0].point);return[r,o]}if(n.length===2){const t=n.slice().sort(((e,t)=>e.at_index-t.at_index));const s=e.slice(t[1].at_index).concat(e.slice(0,t[0].at_index+1));const r=e.slice(t[0].at_index,t[1].at_index+1);return[s,r]}return[e.slice()]};const $p=Object.freeze({__proto__:null,splitConvexPolygon:zp});const Tp=e=>e.charAt(0).toUpperCase()+e.slice(1);const Lp={polygon:it,circle:nt,line:rt,ray:ct,segment:it};const Bp=(e,t,n=a)=>{const s=e=>e==="polygon"?"ConvexPolygon":Tp(e);const r=[e,t].map(xp);const o=[r,r.slice().reverse()].map((e=>e.map(s).join(""))).map((e=>Wr[`intersect${e}`]));const c=[e.domain,t.domain].map(((e,t)=>e||Lp[r[t]]));const i=[[e,t,...c],[t,e,...c.slice().reverse()]];const f=o.map(((e,t)=>({fn:e,params:i[t]}))).filter((e=>e.fn)).shift();return f?f.fn(...f.params,n):undefined};const Ip={...Vp,...Er,...Wr,...gd,...$p,intersect:Bp};const Rp={...Mp,...kp,...Sp,...Ip};const Up=e=>{let t=0;let n=0;for(let s=0;s<e.length;s+=1){if(e[s]==="M"||e[s]==="m"){t+=1}if(e[s]==="V"||e[s]==="v"){n+=1}}for(let s=0;s<e.length;s+=1){if(t>n&&(e[s]==="V"||e[s]==="v")){return s}if(n>t&&(e[s]==="M"||e[s]==="m")){return s}}return undefined};const qp=(e,t,n=0)=>{const s=Up(t);if(s===undefined){return}const r=e[(s+1)%e.length];const o=e[(s+2)%e.length];const c=Math.PI*n;const a=-Math.cos(r)*Math.cos(o)+Math.sin(r)*Math.sin(o)*Math.cos(Math.PI-c);const i=Math.cos(Math.PI-c)-Math.sin(Math.PI-c)**2*Math.sin(r)*Math.sin(o)/(1-a);const f=-Math.acos(i)+Math.PI;return s%2===0?[f,c,f,c].map(((e,t)=>s===t?-e:e)):[c,f,c,f].map(((e,t)=>s===t?-e:e))};const Dp=({vertices_coords:e,vertices_edges:t,edges_vertices:n,edges_vectors:s},r)=>{if(!s){s=Ss({vertices_coords:e,edges_vertices:n})}if(!t){t=fs({edges_vertices:n})}const o=t[r].map((e=>s[e]));const c=zn(o).map((e=>o[e]));return Hd(c)};const Wp=Object.freeze({__proto__:null,kawasakiSolutions:Dp});const Gp=e=>e.map(((e,t)=>t)).filter((t=>e[t]==="U"||e[t]==="u"));const Hp=e=>{const t=Gp(e);const n=Array.from(Array(2**t.length)).map(((e,t)=>t.toString(2))).map((e=>Array(t.length-e.length+1).join("0")+e)).map((e=>Array.from(e).map((e=>e==="0"?"V":"M"))));const s=n.map((n=>{const s=e.slice();t.forEach(((e,t)=>{s[e]=n[t]}));return s}));if(e.includes("B")||e.includes("b")){return s}const r=s.map((e=>e.filter((e=>e==="M"||e==="m")).length));const o=s.map((e=>e.filter((e=>e==="V"||e==="v")).length));return s.filter(((e,t)=>Math.abs(r[t]-o[t])===2))};const Jp=Object.freeze({__proto__:null,maekawaAssignments:Hp});const Qp=Object.assign(Object.create(null),{foldAngles4:qp},Jd,Wp,Jp,tu);const Zp=(e,t,n)=>{const s=e.createShader(n);e.shaderSource(s,t);e.compileShader(s);if(!e.getShaderParameter(s,e.COMPILE_STATUS)){throw new Error(e.getShaderInfoLog(s))}return s};const Yp=(e,t,n)=>{const s=e.createProgram();e.attachShader(s,t);e.attachShader(s,n);e.linkProgram(s);if(!e.getProgramParameter(s,e.LINK_STATUS)){throw new Error(e.getProgramInfoLog(s))}e.deleteShader(t);e.deleteShader(n);return s};const Xp=(e,t,n)=>{const s=Zp(e,t,e.VERTEX_SHADER);const r=Zp(e,n,e.FRAGMENT_SHADER);return Yp(e,s,r)};const Kp=(e,t)=>{const s=[null,"webgl","webgl2"];const r=window.devicePixelRatio||1;e.width=e.clientWidth*r;e.height=e.clientHeight*r;if(t){return{gl:e.getContext(s[t]),version:t}}const o=e.getContext(s[2]);if(o){return{gl:o,version:2}}const c=e.getContext(s[1]);if(c){return{gl:c,version:1}}throw new Error(n.noWebGL)};const e_=(e,t)=>{if(!e){return}const n=window.devicePixelRatio||1;const s=[t.clientWidth,t.clientHeight].map((e=>e*n));if(t.width!==s[0]||t.height!==s[1]){t.width=s[0];t.height=s[1]}e.viewport(0,0,e.canvas.width,e.canvas.height)};const t_=(e,t="perspective",n=45)=>{if(!e){return Bg}const s=.1;const r=20;const o=-100;const c=100;const a=[e.clientWidth,e.clientHeight];const i=Math.min(...a);const f=[0,1].map((e=>(a[e]-i)/i/2));const l=f.map((e=>e+.5));return t==="orthographic"?sp(l[1],l[0],-l[1],-l[0],o,c):np(n*(Math.PI/180),a[0]/a[1],s,r)};const n_=e=>{if(!e){return Bg}const t=Bo(e);if(!t){return Bg}const n=Math.max(...t.span);if(n===0){return Bg}const s=Q(3,P(t.min,t.max));const r=[n,0,0,0,0,n,0,0,0,0,n,0,...s,1];return Wg(r)||Bg};const s_=Object.freeze({__proto__:null,makeModelMatrix:n_,makeProjectionMatrix:t_,rebuildViewport:e_});const r_=(e,t,n,s)=>{switch(n){case"uniformMatrix4fv":e[n](t,false,s);break;default:e[n](t,s);break}};const o_=(e,t,n,s={})=>{e.useProgram(n.program);n.flags.forEach((t=>e.enable(t)));const r=e.getProgramParameter(n.program,e.ACTIVE_UNIFORMS);for(let t=0;t<r;t+=1){const r=e.getActiveUniform(n.program,t).name;const o=s[r];if(o){const t=e.getUniformLocation(n.program,r);r_(e,t,o.func,o.value)}}n.vertexArrays.forEach((t=>{e.bindBuffer(e.ARRAY_BUFFER,t.buffer);e.bufferData(e.ARRAY_BUFFER,t.data,e.STATIC_DRAW);e.vertexAttribPointer(t.location,t.length,t.type,false,0,0);e.enableVertexAttribArray(t.location)}));n.elementArrays.forEach((n=>{e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n.buffer);e.bufferData(e.ELEMENT_ARRAY_BUFFER,n.data,e.STATIC_DRAW);e.drawElements(n.mode,n.data.length,t===2?e.UNSIGNED_INT:e.UNSIGNED_SHORT,n.buffer)}));n.flags.forEach((t=>e.disable(t)))};const c_=(e,t)=>{t.vertexArrays.forEach((t=>e.disableVertexAttribArray(t.location)));t.vertexArrays.forEach((t=>e.deleteBuffer(t.buffer)));t.elementArrays.forEach((t=>e.deleteBuffer(t.buffer)));e.deleteProgram(t.program)};const a_=Object.freeze({__proto__:null,deallocProgram:c_,drawProgram:o_});const i_={B:[.5,.5,.5],b:[.5,.5,.5],V:[.2,.4,.6],v:[.2,.4,.6],M:[.75,.25,.15],m:[.75,.25,.15],F:[.3,.3,.3],f:[.3,.3,.3],J:[.3,.2,0],j:[.3,.2,0],C:[.5,.8,.1],c:[.5,.8,.1],U:[.6,.25,.9],u:[.6,.25,.9]};const f_={B:[0,0,0],b:[0,0,0],V:[.2,.5,.8],v:[.2,.5,.8],M:[.75,.25,.15],m:[.75,.25,.15],F:[.75,.75,.75],f:[.75,.75,.75],J:[1,.75,.25],j:[1,.75,.25],C:[.5,.8,.1],c:[.5,.8,.1],U:[.6,.25,.9],u:[.6,.25,.9]};const l_=e=>e!==undefined&&e.constructor===Array?e.slice(0,3):Dc(e).slice(0,3).map((e=>e/255));const d_=(e,t={})=>{const n=e.vertices_coords.map((e=>[...e].concat(Array(3-e.length).fill(0))));const s=as(e);const r=n.map(((e,t)=>t%3)).map((e=>[e===0?1:0,e===1?1:0,e===2?1:0]));const o=e.faces_edges.map((t=>t.map((t=>e.edges_assignment[t])).map((e=>e==="J"||e==="j"))));if(!t.showTrianglulation){for(let e=0;e<o.length;e+=1){if(o[e][0]){r[e*3+0][2]=r[e*3+1][2]=100}if(o[e][1]){r[e*3+1][0]=r[e*3+2][0]=100}if(o[e][2]){r[e*3+0][1]=r[e*3+2][1]=100}}}return{vertices_coords:n,vertices_normal:s,vertices_barycentric:r}};const u_=(e,t)=>{if(!e||!e.vertices_coords||!e.edges_vertices){return[]}const n=t&&t.dark?i_:f_;const s={...n,...t};const r=e.vertices_coords.map((e=>[...e].concat(Array(3-e.length).fill(0))));const o=e.edges_vertices.flatMap((e=>e.map((e=>r[e])))).flatMap((e=>[e,e,e,e]));const c=Ss(e);const a=e.edges_assignment?e.edges_assignment.flatMap((e=>Array(8).fill(s[e]))):e.edges_vertices.flatMap((()=>Array(8).fill(s.U)));const i=c.flatMap((e=>[e,e,e,e,e,e,e,e]));const f=e.edges_vertices.flatMap((()=>[[1,0],[0,1],[-1,0],[0,-1],[1,0],[0,1],[-1,0],[0,-1]]));return{vertices_coords:o,vertices_color:a,verticesEdgesVector:i,vertices_vector:f}};const m_=Object.freeze({__proto__:null,makeFacesVertexData:d_,makeThickEdgesVertexData:u_});const g_=(e,t,n,s={})=>{if(!n||!n.vertices_coords||!n.faces_vertices){return[]}const{vertices_coords:r,vertices_normal:o,vertices_barycentric:c}=d_(n,s);return[{location:e.getAttribLocation(t,"v_position"),buffer:e.createBuffer(),type:e.FLOAT,length:r.length?r[0].length:3,data:new Float32Array(r.flat())},{location:e.getAttribLocation(t,"v_normal"),buffer:e.createBuffer(),type:e.FLOAT,length:o.length?o[0].length:3,data:new Float32Array(o.flat())},{location:e.getAttribLocation(t,"v_barycentric"),buffer:e.createBuffer(),type:e.FLOAT,length:3,data:new Float32Array(c.flat())}].filter((e=>e.location!==-1))};const p_=(e,t=1,n={})=>{if(!n||!n.vertices_coords||!n.faces_vertices){return[]}return[{mode:e.TRIANGLES,buffer:e.createBuffer(),data:t===2?new Uint32Array(n.faces_vertices.flat()):new Uint16Array(n.faces_vertices.flat())}]};const __=(e,t,n,s={})=>{if(!n||!n.vertices_coords||!n.edges_vertices){return[]}const{vertices_coords:r,vertices_color:o,verticesEdgesVector:c,vertices_vector:a}=u_(n,s.assignment_color);return[{location:e.getAttribLocation(t,"v_position"),buffer:e.createBuffer(),type:e.FLOAT,length:r.length?r[0].length:3,data:new Float32Array(r.flat())},{location:e.getAttribLocation(t,"v_color"),buffer:e.createBuffer(),type:e.FLOAT,length:o.length?o[0].length:3,data:new Float32Array(o.flat())},{location:e.getAttribLocation(t,"edge_vector"),buffer:e.createBuffer(),type:e.FLOAT,length:c.length?c[0].length:3,data:new Float32Array(c.flat())},{location:e.getAttribLocation(t,"vertex_vector"),buffer:e.createBuffer(),type:e.FLOAT,length:a.length?a[0].length:3,data:new Float32Array(a.flat())}].filter((e=>e.location!==-1))};const h_=(e,t=1,n={})=>{if(!n||!n.edges_vertices){return[]}const s=n.edges_vertices.map(((e,t)=>t*8)).flatMap((e=>[e+0,e+1,e+4,e+4,e+1,e+5,e+1,e+2,e+5,e+5,e+2,e+6,e+2,e+3,e+6,e+6,e+3,e+7,e+3,e+0,e+7,e+7,e+0,e+4]));return[{mode:e.TRIANGLES,buffer:e.createBuffer(),data:t===2?new Uint32Array(s):new Uint16Array(s)}]};const v_=Object.freeze({__proto__:null,makeFoldedElementArrays:p_,makeFoldedVertexArrays:g_,makeThickEdgesElementArrays:h_,makeThickEdgesVertexArrays:__});const b_=5e-6;const y_=(e,t=b_)=>{const n=JSON.parse(JSON.stringify(e));if(!n.edges_assignment){const t=Zt.edges(e)||qn.edges(e);n.edges_assignment=Array(t).fill("U")}let s=[];if(n.faceOrders){s=wl(n)}else if(n.faces_layer){s=Ol(n)}const r=Tg(n);or(n);if(r.faces){const e=er(r.faces.map);e.forEach(((e,r)=>{const o=s[e];if(!o){return}n.faces_vertices[r].forEach((e=>{const s=y(o.vector,o.layer*t);n.vertices_coords[e]=x(Q(3,n.vertices_coords[e]),s)}))}))}return n};const E_=(e,{projectionMatrix:t,modelViewMatrix:n,frontColor:s,backColor:r,strokeWidth:o,opacity:c})=>({u_matrix:{func:"uniformMatrix4fv",value:qg(t,n)},u_projection:{func:"uniformMatrix4fv",value:t},u_modelView:{func:"uniformMatrix4fv",value:n},u_frontColor:{func:"uniform3fv",value:l_(s)},u_backColor:{func:"uniform3fv",value:l_(r)},u_strokeWidth:{func:"uniform1f",value:o},u_opacity:{func:"uniform1f",value:c}});const A_=`#version 300 es\nuniform mat4 u_modelView;\nuniform mat4 u_matrix;\nuniform vec3 u_frontColor;\nuniform vec3 u_backColor;\nin vec3 v_position;\nin vec3 v_normal;\nout vec3 front_color;\nout vec3 back_color;\nvoid main () {\n\tgl_Position = u_matrix * vec4(v_position, 1);\n\tvec3 light = abs(normalize((vec4(v_normal, 1) * u_modelView).xyz));\n\tfloat brightness = 0.5 + light.x * 0.15 + light.z * 0.35;\n\tfront_color = u_frontColor * brightness;\n\tback_color = u_backColor * brightness;\n}\n`;const x_=`#version 300 es\nuniform mat4 u_matrix;\nuniform mat4 u_projection;\nuniform mat4 u_modelView;\nuniform float u_strokeWidth;\nin vec3 v_position;\nin vec3 v_color;\nin vec3 edge_vector;\nin vec2 vertex_vector;\nout vec3 blend_color;\nvoid main () {\n\tvec3 edge_norm = normalize(edge_vector);\n\t// axis most dissimilar to edge_vector\n\tvec3 absNorm = abs(edge_norm);\n\tvec3 xory = absNorm.x < absNorm.y ? vec3(1,0,0) : vec3(0,1,0);\n\tvec3 axis = absNorm.x > absNorm.z && absNorm.y > absNorm.z ? vec3(0,0,1) : xory;\n\t// two perpendiculars. with edge_vector these make basis vectors\n\tvec3 one = cross(axis, edge_norm);\n\tvec3 two = cross(one, edge_norm);\n\tvec3 displaceNormal = normalize(\n\t\tone * vertex_vector.x + two * vertex_vector.y\n\t);\n\tvec3 displace = displaceNormal * (u_strokeWidth * 0.5);\n\tgl_Position = u_matrix * vec4(v_position + displace, 1);\n\tblend_color = v_color;\n}\n`;const M_=`#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\nuniform float u_opacity;\nin vec3 front_color;\nin vec3 back_color;\nin vec3 barycentric;\nout vec4 outColor;\nfloat edgeFactor(vec3 barycenter) {\n\tvec3 d = fwidth(barycenter);\n\tvec3 a3 = smoothstep(vec3(0.0), d*3.5, barycenter);\n\treturn min(min(a3.x, a3.y), a3.z);\n}\nvoid main () {\n\tgl_FragDepth = gl_FragCoord.z;\n\tvec3 color = gl_FrontFacing ? front_color : back_color;\n\toutColor = vec4(mix(vec3(0.0), color, edgeFactor(barycentric)), u_opacity);\n}\n`;const k_=`#version 100\nprecision mediump float;\nuniform float u_opacity;\nvarying vec3 barycentric;\nvarying vec3 front_color;\nvarying vec3 back_color;\nvoid main () {\n\tvec3 color = gl_FrontFacing ? front_color : back_color;\n\tvec3 boundary = vec3(0.0, 0.0, 0.0)\n\t// gl_FragDepth = 0.5;\n\tgl_FragColor = any(lessThan(barycentric, vec3(0.02)))\n\t\t? vec4(boundary, u_opacity)\n\t\t: vec4(color, u_opacity);\n}\n`;const w_=`#version 100\nattribute vec3 v_position;\nattribute vec3 v_normal;\nuniform mat4 u_projection;\nuniform mat4 u_modelView;\nuniform mat4 u_matrix;\nuniform vec3 u_frontColor;\nuniform vec3 u_backColor;\nvarying vec3 normal_color;\nvarying vec3 front_color;\nvarying vec3 back_color;\nvoid main () {\n\tgl_Position = u_matrix * vec4(v_position, 1);\n\tvec3 light = abs(normalize((vec4(v_normal, 1) * u_modelView).xyz));\n\tfloat brightness = 0.5 + light.x * 0.15 + light.z * 0.35;\n\tfront_color = u_frontColor * brightness;\n\tback_color = u_backColor * brightness;\n}\n`;const O_=`#version 100\nattribute vec3 v_position;\nattribute vec3 v_color;\nattribute vec3 edge_vector;\nattribute vec2 vertex_vector;\nuniform mat4 u_matrix;\nuniform mat4 u_projection;\nuniform mat4 u_modelView;\nuniform float u_strokeWidth;\nvarying vec3 blend_color;\nvoid main () {\n\tvec3 edge_norm = normalize(edge_vector);\n\t// axis most dissimilar to edge_vector\n\tvec3 absNorm = abs(edge_norm);\n\tvec3 xory = absNorm.x < absNorm.y ? vec3(1,0,0) : vec3(0,1,0);\n\tvec3 axis = absNorm.x > absNorm.z && absNorm.y > absNorm.z ? vec3(0,0,1) : xory;\n\t// two perpendiculars. with edge_vector these make basis vectors\n\tvec3 one = cross(axis, edge_norm);\n\tvec3 two = cross(one, edge_norm);\n\tvec3 displaceNormal = normalize(\n\t\tone * vertex_vector.x + two * vertex_vector.y\n\t);\n\tvec3 displace = displaceNormal * (u_strokeWidth * 0.5);\n\tgl_Position = u_matrix * vec4(v_position + displace, 1);\n\tblend_color = v_color;\n}\n`;const j_=`#version 100\nprecision mediump float;\nuniform float u_opacity;\nvarying vec3 front_color;\nvarying vec3 back_color;\nvoid main () {\n\tvec3 color = gl_FrontFacing ? front_color : back_color;\n\tgl_FragColor = vec4(color, u_opacity);\n}\n`;const F_=`#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\nin vec3 blend_color;\nout vec4 outColor;\n \nvoid main() {\n\toutColor = vec4(blend_color.rgb, 1);\n}\n`;const C_=`#version 100\nattribute vec3 v_position;\nattribute vec3 v_normal;\nattribute vec3 v_barycentric;\nuniform mat4 u_projection;\nuniform mat4 u_modelView;\nuniform mat4 u_matrix;\nuniform vec3 u_frontColor;\nuniform vec3 u_backColor;\nvarying vec3 normal_color;\nvarying vec3 barycentric;\nvarying vec3 front_color;\nvarying vec3 back_color;\nvoid main () {\n\tgl_Position = u_matrix * vec4(v_position, 1);\n\tbarycentric = v_barycentric;\n\tvec3 light = abs(normalize((vec4(v_normal, 1) * u_modelView).xyz));\n\tfloat brightness = 0.5 + light.x * 0.15 + light.z * 0.35;\n\tfront_color = u_frontColor * brightness;\n\tback_color = u_backColor * brightness;\n}\n`;const S_=`#version 300 es\nuniform mat4 u_modelView;\nuniform mat4 u_matrix;\nuniform vec3 u_frontColor;\nuniform vec3 u_backColor;\nin vec3 v_position;\nin vec3 v_normal;\nin vec3 v_barycentric;\nin float v_rawEdge;\nout vec3 front_color;\nout vec3 back_color;\nout vec3 barycentric;\n// flat out int rawEdge;\nflat out int provokedVertex;\nvoid main () {\n\tgl_Position = u_matrix * vec4(v_position, 1);\n\tprovokedVertex = gl_VertexID;\n\tbarycentric = v_barycentric;\n\t// rawEdge = int(v_rawEdge);\n\tvec3 light = abs(normalize((vec4(v_normal, 1) * u_modelView).xyz));\n\tfloat brightness = 0.5 + light.x * 0.15 + light.z * 0.35;\n\tfront_color = u_frontColor * brightness;\n\tback_color = u_backColor * brightness;\n}\n`;const P_=`#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\nuniform float u_opacity;\nin vec3 front_color;\nin vec3 back_color;\nout vec4 outColor;\nvoid main () {\n\tgl_FragDepth = gl_FragCoord.z;\n\tvec3 color = gl_FrontFacing ? front_color : back_color;\n\toutColor = vec4(color, u_opacity);\n}\n`;const N_=`#version 100\nprecision mediump float;\nvarying vec3 blend_color;\nvoid main () {\n\tgl_FragColor = vec4(blend_color.rgb, 1);\n}\n`;const V_=(e,t=1,n={},s={})=>{const r=y_(n,s.layerNudge);const o=t===1?Xp(e,w_,j_):Xp(e,A_,P_);return{program:o,vertexArrays:g_(e,o,r,s),elementArrays:p_(e,t,r),flags:[e.DEPTH_TEST],makeUniforms:E_}};const z_=(e,t=1,n={},s={})=>{const r=t===1?Xp(e,O_,N_):Xp(e,x_,F_);return{program:r,vertexArrays:__(e,r,n,s),elementArrays:h_(e,t,n),flags:[e.DEPTH_TEST],makeUniforms:E_}};const $_=(e,t=1,n={},s={})=>{const r=y_(n,s.layerNudge);const o=t===1?Xp(e,C_,k_):Xp(e,S_,M_);return{program:o,vertexArrays:g_(e,o,r,s),elementArrays:p_(e,t,r),flags:[e.DEPTH_TEST],makeUniforms:E_}};const T_=Object.freeze({__proto__:null,foldedFormEdges:z_,foldedFormFaces:V_,foldedFormFacesOutlined:$_});const L_=(e,t=1,n={},s={})=>{const r=[];if(s.faces!==false){if(s.outlines===false){r.push(V_(e,t,n,s))}else{r.push($_(e,t,n,s))}}if(s.edges===true){r.push(z_(e,t,n,s))}return r};const B_=e=>e.map((e=>[0,1].map((t=>e[t]||0))));const I_=(e,t)=>{if(!e||!e.vertices_coords||!e.edges_vertices){return[]}const n=t&&t.dark?i_:f_;const s={...n,...t};const r=B_(e.edges_vertices.flatMap((t=>t.map((t=>e.vertices_coords[t])))).flatMap((e=>[e,e])));const o=B_(Ss(e));const c=e.edges_assignment?e.edges_assignment.flatMap((e=>[s[e],s[e],s[e],s[e]])):e.edges_vertices.flatMap((()=>[s.U,s.U,s.U,s.U]));const a=o.flatMap((e=>[e,e,e,e]));const i=e.edges_vertices.flatMap((()=>[[1,0],[-1,0],[-1,0],[1,0]]));return{vertices_coords:r,vertices_color:c,verticesEdgesVector:a,vertices_vector:i}};const R_=Object.freeze({__proto__:null,makeCPEdgesVertexData:I_});const U_=(e,t,n,s)=>{if(!n||!n.vertices_coords||!n.edges_vertices){return[]}const{vertices_coords:r,vertices_color:o,verticesEdgesVector:c,vertices_vector:a}=I_(n,s);return[{location:e.getAttribLocation(t,"v_position"),buffer:e.createBuffer(),type:e.FLOAT,length:2,data:new Float32Array(r.flat())},{location:e.getAttribLocation(t,"v_color"),buffer:e.createBuffer(),type:e.FLOAT,length:o.length?o[0].length:2,data:new Float32Array(o.flat())},{location:e.getAttribLocation(t,"edge_vector"),buffer:e.createBuffer(),type:e.FLOAT,length:c.length?c[0].length:2,data:new Float32Array(c.flat())},{location:e.getAttribLocation(t,"vertex_vector"),buffer:e.createBuffer(),type:e.FLOAT,length:a.length?a[0].length:2,data:new Float32Array(a.flat())}].filter((e=>e.location!==-1))};const q_=(e,t=1,n={})=>{if(!n||!n.edges_vertices){return[]}const s=n.edges_vertices.map(((e,t)=>t*4)).flatMap((e=>[e+0,e+1,e+2,e+2,e+3,e+0]));return[{mode:e.TRIANGLES,buffer:e.createBuffer(),data:t===2?new Uint32Array(s):new Uint16Array(s)}]};const D_=e=>e.map((e=>[0,1].map((t=>e[t]||0))));const W_=(e,t,n)=>{if(!n||!n.vertices_coords){return[]}return[{location:e.getAttribLocation(t,"v_position"),buffer:e.createBuffer(),type:e.FLOAT,length:2,data:new Float32Array(D_(n.vertices_coords).flat())}].filter((e=>e.location!==-1))};const G_=(e,t=1,n={})=>{if(!n||!n.vertices_coords||!n.faces_vertices){return[]}return[{mode:e.TRIANGLES,buffer:e.createBuffer(),data:t===2?new Uint32Array(Pg(n).flat()):new Uint16Array(Pg(n).flat())}]};const H_=Object.freeze({__proto__:null,makeCPEdgesElementArrays:q_,makeCPEdgesVertexArrays:U_,makeCPFacesElementArrays:G_,makeCPFacesVertexArrays:W_});const J_=(e,{projectionMatrix:t,modelViewMatrix:n,cpColor:s,strokeWidth:r})=>({u_matrix:{func:"uniformMatrix4fv",value:qg(t,n)},u_projection:{func:"uniformMatrix4fv",value:t},u_modelView:{func:"uniformMatrix4fv",value:n},u_cpColor:{func:"uniform3fv",value:l_(s)},u_strokeWidth:{func:"uniform1f",value:r}});const Q_=`#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\nin vec3 blend_color;\nout vec4 outColor;\nvoid main() {\n\toutColor = vec4(blend_color.rgb, 1);\n}\n`;const Z_=`#version 100\nprecision mediump float;\nvarying vec3 blend_color;\nvoid main () {\n\tgl_FragColor = vec4(blend_color.rgb, 1);\n}\n`;const Y_=`#version 300 es\nuniform mat4 u_matrix;\nuniform float u_strokeWidth;\nin vec2 v_position;\nin vec3 v_color;\nin vec2 edge_vector;\nin vec2 vertex_vector;\nout vec3 blend_color;\nvoid main () {\n\tfloat sign = vertex_vector[0];\n\tfloat halfWidth = u_strokeWidth * 0.5;\n\tvec2 side = normalize(vec2(edge_vector.y * sign, -edge_vector.x * sign)) * halfWidth;\n\tgl_Position = u_matrix * vec4(side + v_position, 0, 1);\n\tblend_color = v_color;\n}\n`;const X_=`#version 100\nuniform mat4 u_matrix;\nuniform float u_strokeWidth;\nattribute vec2 v_position;\nattribute vec3 v_color;\nattribute vec2 edge_vector;\nattribute vec2 vertex_vector;\nvarying vec3 blend_color;\nvoid main () {\n\tfloat sign = vertex_vector[0];\n\tfloat halfWidth = u_strokeWidth * 0.5;\n\tvec2 side = normalize(vec2(edge_vector.y * sign, -edge_vector.x * sign)) * halfWidth;\n\tgl_Position = u_matrix * vec4(side + v_position, 0, 1);\n\tblend_color = v_color;\n}\n`;const K_=`#version 100\nuniform mat4 u_matrix;\nuniform vec3 u_cpColor;\nattribute vec2 v_position;\nvarying vec3 blend_color;\nvoid main () {\n\tgl_Position = u_matrix * vec4(v_position, 0, 1);\n\tblend_color = u_cpColor;\n}\n`;const eh=`#version 300 es\nuniform mat4 u_matrix;\nuniform vec3 u_cpColor;\nin vec2 v_position;\nout vec3 blend_color;\nvoid main () {\n\tgl_Position = u_matrix * vec4(v_position, 0, 1);\n\tblend_color = u_cpColor;\n}\n`;const th=(e,t={},n=undefined)=>{const s=Xp(e,K_,Z_);return{program:s,vertexArrays:W_(e,s,t),elementArrays:G_(e,1,t),flags:[],makeUniforms:J_}};const nh=(e,t={},n=undefined)=>{const s=Xp(e,X_,Z_);return{program:s,vertexArrays:U_(e,s,t,n),elementArrays:q_(e,1,t),flags:[],makeUniforms:J_}};const sh=(e,t={},n=undefined)=>{const s=Xp(e,eh,Q_);return{program:s,vertexArrays:W_(e,s,t),elementArrays:G_(e,2,t),flags:[],makeUniforms:J_}};const rh=(e,t={},n=undefined)=>{const s=Xp(e,Y_,Q_);return{program:s,vertexArrays:U_(e,s,t,n),elementArrays:q_(e,2,t),flags:[],makeUniforms:J_}};const oh=Object.freeze({__proto__:null,cpEdgesV1:nh,cpEdgesV2:rh,cpFacesV1:th,cpFacesV2:sh});const ch=(e,t=1,n={},s=undefined)=>{switch(t){case 1:return[th(e,n,s),nh(e,n,s)];case 2:default:return[sh(e,n,s),rh(e,n,s)]}};const ah=Object.assign(Object.create(null),{createProgram:Xp,initialize:Kp,foldedForm:L_,creasePattern:ch},s_,a_,v_,m_,T_,H_,R_,oh);const ih=({vertices_coords:e,edges_vertices:t})=>{const n=t.map((t=>t.map((t=>e[t])))).map((e=>B(...e)));const s=n.reduce(((e,t)=>Math.min(e,t)),Infinity);return s===Infinity?undefined:s};const fh=({vertices_coords:e,edges_vertices:t})=>{const n=ih({vertices_coords:e,edges_vertices:t});if(n){return Math.max(n*1e-4,1e-10)}const s=Bo({vertices_coords:e});return s&&s.span?Math.max(1e-6*Math.max(...s.span),1e-10):1e-6};const lh=e=>er(er(e).reverse());const dh=(e,t)=>{const n=[];const s=bl(e);const r=e.edges_faces?e.edges_faces:Ms(e);r.forEach(((e,r)=>{if(e.length===1){n[r]="B"}if(e.length===2){const o=e.map((e=>s[e]));if(o[0]===o[1]){n[r]="F";return}const c=e.map((e=>t[e]));const a=c[0]<c[1];const i=o[0]?a:!a;n[r]=i?"V":"M"}}));return n};const uh=e=>{const t=[];e.forEach((e=>{t[e[0]]=undefined;t[e[1]]=undefined}));const n=t.map((()=>[]));e.forEach((([e,t,s])=>{n[e][t]=s;n[t][e]=-s}));return n};const mh=Object.freeze({__proto__:null,faceOrdersToMatrix:uh,facesLayerToEdgesAssignments:dh,flipFacesLayer:lh,makeEpsilon:fh});const gh={taco_taco:e=>[[e[0],e[2]],[e[1],e[3]],[e[1],e[2]],[e[0],e[3]],[e[0],e[1]],[e[2],e[3]]],taco_tortilla:e=>[[e[0],e[2]],[e[0],e[1]],[e[1],e[2]]],tortilla_tortilla:e=>[[e[0],e[2]],[e[1],e[3]]],transitivity:e=>[[e[0],e[1]],[e[1],e[2]],[e[2],e[0]]]};const ph=e=>e[0]<e[1]?`${e[0]} ${e[1]}`:`${e[1]} ${e[0]}`;const _h={taco_taco:e=>[ph([e[0],e[2]]),ph([e[1],e[3]]),ph([e[1],e[2]]),ph([e[0],e[3]]),ph([e[0],e[1]]),ph([e[2],e[3]])],taco_tortilla:e=>[ph([e[0],e[2]]),ph([e[0],e[1]]),ph([e[1],e[2]])],tortilla_tortilla:e=>[ph([e[0],e[2]]),ph([e[1],e[3]])],transitivity:e=>[ph([e[0],e[1]]),ph([e[1],e[2]]),ph([e[2],e[0]])]};const hh={0:0,1:1,2:-1};const vh=(e,t)=>{const n=Object.keys(e);const s=n.map((e=>e.split(" ").map((e=>parseInt(e,10)))));s.forEach(((s,r)=>{const o=hh[e[n[r]]];const c=!t[s[1]]?-o:o;s.push(c)}));return s};const bh=Object.freeze({__proto__:null,constraintToFacePairs:gh,constraintToFacePairsStrings:_h,solverSolutionToFaceOrders:vh});const yh=({taco_taco:e,taco_tortilla:t,tortilla_tortilla:n,transitivity:s})=>{const r={};r.taco_taco=e.map((e=>[e[0][0],e[1][0],e[0][1],e[1][1]]));r.taco_tortilla=t.map((e=>[e.taco[0],e.tortilla,e.taco[1]]));r.tortilla_tortilla=n.map((e=>[e[0][0],e[0][1],e[1][0],e[1][1]]));r.transitivity=s.map((e=>[e[0],e[1],e[2]]));return r};const Eh=e=>{const t={};Object.keys(e).forEach((e=>{t[e]={}}));Object.keys(e).forEach((n=>{e[n].forEach(((e,s)=>_h[n](e).forEach((e=>{if(t[n][e]===undefined){t[n][e]=[]}t[n][e].push(s)}))))}));return t};const Ah=({vertices_coords:e,edges_vertices:t,edges_faces:n},s)=>{const r=t.map((t=>e[t[0]]));const o=t.map((t=>O(e[t[1]],e[t[0]])));return n.map(((e,t)=>e.map((e=>T(O(s[e],r[t]),o[t]))).map((e=>Math.sign(e)))))};const xh=({vertices_coords:e,edges_vertices:t},n,s,r)=>{const o=s.map((n=>t[n[0]].map((t=>e[t]))));const c=o.map((e=>e[0]));const a=o.map((e=>O(e[1],e[0])));const i=r.map((e=>e.map((e=>e.map((e=>n[e]))))));return i.map(((e,t)=>e.map((e=>e.map((e=>T(O(e,c[t]),a[t]))).map((e=>Math.sign(e)))))))};const Mh=e=>{if(e[0]===1&&e[1]===-1||e[0]===-1&&e[1]===1){return"both"}if(e[0]===1&&e[1]===1){return"right"}if(e[0]===-1&&e[1]===-1){return"left"}return undefined};const kh=e=>e[0]===e[1]&&e[0]!=="both";const wh=e=>e[0]===e[1]&&e[0]==="both";const Oh=e=>e[0]!==e[1]&&(e[0]==="both"||e[1]==="both");const jh=(e,t,n)=>{const s=t[0]==="left"||t[1]==="left"?-1:1;const r=t[0]==="both"?[...e[1]]:[...e[0]];const o=t[0]==="both"?0:1;const c=n[o][0]===s?e[o][0]:e[o][1];return{taco:r,tortilla:c}};const Fh=(e,t)=>{if(e===undefined){return undefined}return t[0][0]===t[1][0]?e:[e[0],[e[1][1],e[1][0]]]};const Ch=(e,t,n)=>{const s=t.map((e=>e.length===2&&e[0]!==e[1])).map(((e,t)=>e?t:undefined)).filter((e=>e!==undefined));const r=[];s.forEach((e=>{r[e]=n[e]}));const o=r.map(((t,n)=>t.map((t=>[e[n],[t,t]])))).reduce(((e,t)=>e.concat(t)),[]);return o};const Sh=({vertices_coords:e,edges_vertices:t,edges_faces:n,faces_vertices:s,faces_edges:r,edges_vector:o},c=a)=>{const i=Rs({vertices_coords:e,faces_vertices:s});const f=Ah({vertices_coords:e,edges_vertices:t,edges_faces:n},i);const l=Jr({vertices_coords:e,edges_vertices:t,edges_vector:o},c);const d=pp({vertices_coords:e,edges_vertices:t,edges_faces:n,faces_vertices:s,faces_edges:r},c);const u=tn(l).filter((e=>e.map((e=>n[e].length>1)).reduce(((e,t)=>e&&t),true)));const m=u.map((e=>e.map((e=>n[e]))));const g=xh({vertices_coords:e,edges_vertices:t},i,u,m);const p=g.map((e=>e.map(Mh)));const _=p.map(((e,t)=>kh(e)?m[t]:undefined)).filter((e=>e!==undefined));const h=p.map(((e,t)=>wh(e)?m[t]:undefined)).map(((e,t)=>Fh(e,g[t]))).filter((e=>e!==undefined));const v=Ch(n,f,d);const b=h.concat(v);const y=p.map(((e,t)=>Oh(e)?jh(m[t],p[t],g[t]):undefined)).filter((e=>e!==undefined));const E=d.map(((e,t)=>f[t].length>1&&f[t][0]===f[t][1]?e:[]));const A=E.map(((e,t)=>({taco:n[t],tortillas:e}))).filter((e=>e.tortillas.length));const x=A.flatMap((e=>e.tortillas.map((t=>({taco:[...e.taco],tortilla:t})))));const M=y.concat(x);return{taco_taco:_,tortilla_tortilla:b,taco_tortilla:M}};const Ph=({faces_polygon:e},t,n=a)=>{const s=t.map((()=>[]));t.forEach(((e,t)=>e.forEach((e=>{s[t][e]=true;s[e][t]=true}))));const r=e.map((()=>[]));t.forEach(((t,s)=>t.forEach((t=>{const o=md(e[s],e[t],n);if(o){r[s][t]=o;r[t][s]=o}}))));const o=[];for(let t=0;t<r.length-1;t+=1){if(!r[t]){continue}for(let c=t+1;c<r.length;c+=1){if(!r[t][c]){continue}for(let a=c+1;a<r.length;a+=1){if(t===a||c===a){continue}if(!s[t][a]||!s[c][a]){continue}const i=md(r[t][c],e[a],n);if(i){o.push([t,c,a].sort(((e,t)=>e-t)))}}}}return o};const Nh=(e,{taco_taco:t,taco_tortilla:n})=>{const s={};t.map((e=>[e[0][0],e[0][1],e[1][0],e[1][1]].sort(((e,t)=>e-t)))).forEach((e=>[`${e[0]} ${e[1]} ${e[2]}`,`${e[0]} ${e[1]} ${e[3]}`,`${e[0]} ${e[2]} ${e[3]}`,`${e[1]} ${e[2]} ${e[3]}`].forEach((e=>{s[e]=true}))));n.map((e=>[e.taco[0],e.taco[1],e.tortilla].sort(((e,t)=>e-t)).join(" "))).forEach((e=>{s[e]=true}));return e.filter((e=>s[e.join(" ")]===undefined))};const Vh=({vertices_coords:e,edges_vertices:t,edges_faces:n,faces_vertices:s,faces_edges:r,edges_vector:o,faces_polygon:c},i,f=a)=>{const{taco_taco:l,taco_tortilla:d,tortilla_tortilla:u}=Sh({vertices_coords:e,edges_vertices:t,edges_faces:n,faces_vertices:s,faces_edges:r,edges_vector:o},f);const m=Ph({faces_polygon:c},i,f);const g=Nh(m,{taco_taco:l,taco_tortilla:d});return{taco_taco:l,taco_tortilla:d,tortilla_tortilla:u,transitivity:g}};const zh=({vertices_coords:e,edges_vertices:t,edges_faces:n,faces_vertices:s,faces_edges:r,edges_vector:o},c=a)=>{const i=bl({vertices_coords:e,faces_vertices:s});const f=Ls({vertices_coords:e,faces_vertices:s},c);f.forEach(((e,t)=>{if(!i[t]){e.reverse()}}));const l=hp({vertices_coords:e,faces_vertices:s},c);const{taco_taco:d,taco_tortilla:u,tortilla_tortilla:m,transitivity:g}=Vh({vertices_coords:e,edges_vertices:t,edges_faces:n,faces_vertices:s,faces_edges:r,edges_vector:o,faces_polygon:f},l,c);const p=yh({taco_taco:d,taco_tortilla:u,tortilla_tortilla:m,transitivity:g});const _=Eh(p);const h=tn(l).map((e=>e.join(" ")));return{constraints:p,lookup:_,facePairs:h,faces_winding:i}};const $h=Object.freeze({__proto__:null,makeRelationships:Vh,setup:zh});const Th={0:0,1:2,2:1};const Lh={M:1,m:1,V:2,v:2};const Bh=({edges_faces:e,edges_assignment:t},n,s)=>{const r={};n.forEach((e=>{r[e]=true}));const o={};e.forEach(((e,n)=>{const c=t[n];const a=Lh[c];if(e.length<2||a===undefined){return}const i=s[e[0]];const f=i?a:Th[a];const l=`${e[0]} ${e[1]}`;const d=`${e[1]} ${e[0]}`;if(l in r){o[l]=f}if(d in r){o[d]=Th[f]}}));return o};const Ih=["111112","111121","111222","112111","121112","121222","122111","122212","211121","211222","212111","212221","221222","222111","222212","222221"];const Rh=["112","121","212","221"];const Uh=["11","22"];const qh=["112","121","122","211","212","221"];const Dh=(e,t,n)=>{const s=Array.from(n).map((e=>parseInt(e,10)));if(s.filter((e=>e===0)).length!==t){return}e[t][n]=false;let r=false;for(let n=0;n<s.length;n+=1){const o=[];if(s[n]!==0){continue}for(let r=1;r<=2;r+=1){s[n]=r;if(e[t-1][s.join("")]!==false){o.push([n,r])}}s[n]=0;if(o.length>0&&r===false){r=[]}if(o.length===1){r.push(o[0])}}if(r!==false&&r.length===0){r=true}e[t][n]=r};const Wh=e=>{const t=e[0].length;const n=Array.from(Array(t+1)).map((()=>({})));Array.from(Array(Math.pow(2,t))).map(((e,t)=>t.toString(2))).map((e=>Array.from(e).map((e=>parseInt(e,10)+1)).join(""))).map((e=>`11111${e}`.slice(-t))).forEach((e=>{n[0][e]=false}));e.forEach((e=>{n[0][e]=true}));Array.from(Array(t)).map(((e,t)=>t+1)).map((e=>Array.from(Array(Math.pow(3,t))).map(((e,t)=>t.toString(3))).map((e=>`000000${e}`.slice(-t))).forEach((t=>Dh(n,e,t)))));let s=[];Array.from(Array(t+1)).map(((e,n)=>t-n)).forEach((e=>{const t=[];Object.keys(n[e]).forEach((s=>{let r=n[e][s];if(r.constructor===Array){r=r[0]}t.push([s,r])}));s=s.concat(t)}));s.sort(((e,t)=>parseInt(e[0],10)-parseInt(t[0],10)));const r={};s.forEach((e=>{r[e[0]]=Object.freeze(e[1])}));return Object.freeze(r)};const Gh={taco_taco:Wh(Ih),taco_tortilla:Wh(Rh),tortilla_tortilla:Wh(Uh),transitivity:Wh(qh)};const Hh=Object.freeze(Object.keys(Gh));const Jh={0:0,1:2,2:1};const Qh=(e,t,...n)=>{const s=gh[e](t);const r=s.map((e=>e[1]<e[0]));const o=s.map(((e,t)=>r[t]?`${e[1]} ${e[0]}`:`${e[0]} ${e[1]}`));const c=o.map(((e,t)=>{for(let s=0;s<n.length;s+=1){if(n[s][e]){return r[t]?Jh[n[s][e]]:n[s][e]}}return 0})).join("");if(Gh[e][c]===true||Gh[e][c]===false){return Gh[e][c]}const a=Gh[e][c];const i=o[a[0]];const f=r[a[0]]?Jh[a[1]]:a[1];return[i,f]};const Zh=(e,t,n)=>{const s={};Hh.forEach((r=>{const o=n.flatMap((e=>t[r][e]));s[r]=Yt(o).filter((t=>e[r][t]))}));return s};const Yh=(e,t,n,...s)=>{let r=n;const o={};do{const n=Zh(e,t,r);const c={};for(let t=0;t<Hh.length;t+=1){const r=Hh[t];const a=n[r];for(let t=0;t<a.length;t+=1){const n=Qh(r,e[r][a[t]],...s,o);if(n===true){continue}if(n===false){throw new Error(`invalid ${r} ${a[t]}:${e[r][a[t]]}`)}if(o[n[0]]){if(o[n[0]]!==n[1]){throw new Error(`conflict ${r} ${a[t]}:${e[r][a[t]]}`)}}else{const[e,t]=n;c[e]=true;o[n[0]]=t}}}r=Object.keys(c)}while(r.length);return o};const Xh=(e,t,n,s={})=>{const r=Object.keys(t);const o={};e.forEach((e=>{o[e]=true}));let c=0;const a=[];while(c<e.length){if(!o[e[c]]){c+=1;continue}const i=[];const f=[e[c]];const l={[e[c]]:true};do{const e=f.shift();delete o[e];i.push(e);let c;if(s[e]){c=s[e]}else{const o={};r.forEach((s=>{const r=n[s][e];if(!r){return}r.map((e=>t[s][e])).map((e=>_h[s](e).forEach((e=>{o[e]=true}))))}));c=Object.keys(o);s[e]=c}const a=c.filter((e=>o[e])).filter((e=>!l[e]));f.push(...a);a.forEach((e=>{l[e]=true}))}while(f.length);c+=1;a.push(i)}return a};const Kh=(e,t,n,...s)=>{if(!n.length){return[]}const r=n[0];const o=[];const c=[];[1,2].forEach((a=>{let i;try{i=Yh(e,t,[r],...s,{[r]:a})}catch(e){return}i[r]=a;if(Object.keys(i).length===n.length){o.push(i)}else{c.push(i)}}));const a=c.map((r=>Kh(e,t,n.filter((e=>!(e in r))),...s,r)));return o.map((e=>[...s,e])).concat(...a)};const ev=({constraints:e,lookup:t,facePairs:s,orders:r})=>{let o;try{o=Yh(e,t,Object.keys(r),r)}catch(e){throw new Error(n.noLayerSolution,{cause:e})}const c=s.filter((e=>!(e in r))).filter((e=>!(e in o)));let a;try{a=Xh(c,e,t).map((n=>Kh(e,t,n,r,o)))}catch(e){throw new Error(n.noLayerSolution,{cause:e})}const i={...r,...o};const f=a.map((e=>e.map((e=>Object.assign({},...e)))));return{root:i,branches:f}};const tv=e=>{const t=e.reduce(((e,t)=>e*t),1);const n=e.slice();for(let e=n.length-2;e>=0;e-=1){n[e]*=n[e+1]}n.push(1);n.shift();return Array.from(Array(t)).map(((t,s)=>e.map(((e,t)=>Math.floor(s/n[t])%e))))};const nv={count:function(){return this.branches.map((e=>e.length))},faceOrders:function(...e){return vh(this.compile(...e),this.faces_winding)},facesLayer:function(...e){return er(this.linearize(...e).reverse())},compile:function(...e){const t=Array(this.branches.length).fill(0).map(((t,n)=>e[n]!=null?e[n]:t));const n=this.branches?this.branches.map(((e,n)=>e[t[n]])):[];return Object.assign({},this.root,...n)},directedPairs:function(...e){const t=this.compile(...e);return Object.keys(t).map((e=>t[e]===1?e.split(" "):e.split(" ").reverse())).map((e=>e.map((e=>parseInt(e,10)))))},linearize:function(...e){return El(this.directedPairs(...e))},allSolutions:function(){return tv(this.count()).map((e=>this.compile(...e)))},allFacesLayers:function(){return tv(this.count()).map((e=>this.facesLayer(...e)))}};const sv=()=>({root:{},branches:[],faces_winding:[]});const rv=({vertices_coords:e,edges_vertices:t,edges_faces:n,edges_assignment:s,faces_vertices:r,faces_edges:o,edges_vector:c},a)=>{if(!e||!t||!r){return Object.assign(Object.create(nv),sv())}if(!o){o=$s({edges_vertices:t,faces_vertices:r})}if(!n){n=xs({edges_vertices:t,faces_edges:o})}if(a===undefined){a=fh({vertices_coords:e,edges_vertices:t})}const{constraints:i,lookup:f,facePairs:l,faces_winding:d}=zh({vertices_coords:e,edges_vertices:t,edges_faces:n,faces_vertices:r,faces_edges:o,edges_vector:c},a);const u=Bh({edges_faces:n,edges_assignment:s},l,d);const{root:m,branches:g}=ev({constraints:i,lookup:f,facePairs:l,orders:u});return Object.assign(Object.create(nv),{root:m,branches:g,faces_winding:d})};const ov=(e,t,n)=>{const s=e.map((e=>e?(e[0]+e[1])/2:undefined));const r=[];e.forEach(((o,c)=>{if(!o){return}if(!t&&c===e.length-1){return}const a=o[1];const i=a-n*2;const f=a+n*2;const l=[c,(c+1)%e.length];const d=l.map((e=>s[e])).map((e=>e>a));const u=(!d[0]&&!d[1])*1+(d[0]&&d[1])*2;const m=r.filter((e=>e.min<a&&e.max>a)).shift();const g={faces:l,taco_type:u};if(m){m.pairs.push(g)}else{r.push({min:i,max:f,pairs:[g]})}}));return r.map((e=>e.pairs)).filter((e=>e.length>1)).map((e=>({both:e.filter((e=>e.taco_type===0)).map((e=>e.faces)),left:e.filter((e=>e.taco_type===1)).map((e=>e.faces)),right:e.filter((e=>e.taco_type===2)).map((e=>e.faces))})))};const cv=(e,t,n)=>t<n?e.slice(t+1,n):e.slice(n+1,t);const av=(e,t,n=true,s=a)=>{const r=er(t);const o=e.map((e=>e?e[1]:undefined));const c=e.map((e=>e?Math.min(...e):undefined)).map((e=>e+s));const i=e.map((e=>e?Math.max(...e):undefined)).map((e=>e-s));const f=r.length+(n?0:-1);for(let e=0;e<f;e+=1){const n=(e+1)%r.length;if(r[e]===r[n]){continue}const s=cv(t,r[e],r[n]).flat();const a=s.map((t=>o[e]<c[t])).reduce(((e,t)=>e&&t),true);const f=s.map((t=>o[e]>i[t])).reduce(((e,t)=>e&&t),true);if(!a&&!f){return false}}return true};const iv=e=>{const t=Xt(e);const n={};let s=0;for(let e=0;e<t.length;e+=1){if(n[t[e]]===undefined){s+=1;n[t[e]]=s}else if(n[t[e]]!==undefined){if(n[t[e]]!==s){return false}s-=1;n[t[e]]=undefined}}return true};const fv=(e,t)=>e.map((e=>t[e])).filter((e=>e!==undefined));const lv=(e,t,n,s,r)=>{const o=Se(t);if(!av(e,t,s,r)){return false}for(let e=0;e<n.length;e+=1){const t=fv(o,n[e]);if(!iv(t)){return false}}return true};const dv={V:true,v:true,M:true,m:true};const uv=e=>{let t=0;const n=e.slice(1);return[false].concat(n.map((e=>dv[e]?++t:t)).map((e=>e%2===1)))};const mv={V:1,v:1,M:-1,m:-1};const gv=(e,t)=>t%2===0?mv[e]||0:-(mv[e]||0);const pv=e=>{let t=0;return e.slice(1).concat([e[0]]).map((e=>{const n=gv(e,t);t+=mv[e]===undefined?0:1;return n}))};const _v=(e,t)=>{const n=uv(t).map(((t,n)=>e[n]*(t?-1:1)));const s=e.map((()=>undefined));s[0]=[0,n[0]];for(let r=1;r<e.length;r+=1){if(t[r]==="B"||t[r]==="b"){break}const o=(r-1+e.length)%e.length;const c=s[o][1];s[r]=[c,c+n[r]]}return s};const hv={B:true,b:true};const vv=(e,t,n=a)=>{const s=_v(e,t);const r=pv(t);const o=t.map((e=>!hv[e])).reduce(((e,t)=>e&&t),true);if(o){const e=s[0][0];const t=s[s.length-1][1];if(Math.abs(e-t)>n){return[]}}const c=ov(s,o,n).map((e=>[e.left,e.right].map(er).filter((e=>e.length>1)))).reduce(((e,t)=>e.concat(t)),[]);const i=(t=[0],a=0,f=0)=>{const l=a+1;const d=r[a];const u=a>=e.length-1;const m=o&&u;if(!lv(s,t,c,m,n)){return[]}if(m){const e=er(t);const n=e[0];const s=e[a];if(d>0&&s>n){return[]}if(d<0&&s<n){return[]}}if(u){return[t]}if(d===0){t[f]=[l].concat(t[f]);return i(t,l,f)}const g=d===1?Array.from(Array(t.length-f)).map(((e,t)=>f+t+1)):Array.from(Array(f+1)).map(((e,t)=>t));const p=g.map((()=>rr(t)));p.forEach(((e,t)=>e.splice(g[t],0,l)));return p.map(((e,t)=>i(e,l,g[t]))).reduce(((e,t)=>e.concat(t)),[])};return i().map(er)};const bv=(e,t,n)=>{if(t==null){t=e.map((()=>"U"))}const s=Hp(t);const r=s.map((t=>vv(e,t,n)));return s.map(((e,t)=>t)).filter((e=>r[e].length>0)).map((e=>({assignment:s[e],layer:r[e]})))};Object.assign(rv,{table:Gh,...mh,...bh,...$h,singleVertexSolver:vv,singleVertexAssignmentSolver:bv,foldStripWithAssignments:_v});Object.assign(wu,Ap);const yv={graph:wu,cp:Ou,origami:ju,axiom:lm,convert:fg,math:Rp,singleVertex:Qp,svg:Hf,webgl:ah,layer:rv};If.ear=yv;Object.defineProperty(yv,"window",{enumerable:false,set:e=>{Hf.window=o(e)}});export{yv as default};