const e=typeof window!=="undefined"&&typeof window.document!=="undefined";const t=typeof process!=="undefined"&&process.versions!=null&&process.versions.node!=null;const n={planarize:"graph could not planarize",manifold:"valid manifold required",graphCycle:"cycle not allowed",planarBoundary:"planar boundary detection error, bad graph",circularEdge:"circular edges not allowed",replaceModifyParam:"replace() index < value. indices parameter modified",replaceUndefined:"replace() generated undefined",flatFoldAngles:"foldAngles cannot be determined from flat-folded faces without an assignment",noWebGL:"WebGl not Supported",convexFace:"only convex faces are supported",window:"window not set; if using node/deno include package @xmldom/xmldom and set ear.window = xmldom",nonConvexTriangulation:"non-convex triangulation requires vertices_coords",backendStylesheet:"svgToFold found <style> in <svg>. rendering will be incomplete unless run in a major browser.",noLayerSolution:"LayerSolver bad input. no solution possible"};const s={window:undefined};if(e){s.window=window}const r=e=>(new e.DOMParser).parseFromString("<!DOCTYPE html><title>.</title>","text/html");const o=e=>{if(!e.document){e.document=r(e)}s.window=e;return s.window};const c=()=>{if(s.window===undefined){throw new Error(n.window)}return s.window};const a=e=>e!=null&&typeof e[Symbol.iterator]==="function";const i=function(){switch(arguments.length){case 0:return Array.from(arguments);case 1:return a(arguments[0])&&typeof arguments[0]!=="string"?i(...arguments[0]):[arguments[0]];default:return Array.from(arguments).map((e=>a(e)?[...i(e)]:e))}};const f=function(){switch(arguments.length){case 0:return Array.from(arguments);case 1:return a(arguments[0])&&typeof arguments[0]!=="string"?f(...arguments[0]):[arguments[0]];default:return Array.from(arguments).map((e=>a(e)?[...f(e)]:e)).flat()}};const l=function(){let e=f(arguments);const t=e[0];if(typeof t==="object"&&t!==null&&!Number.isNaN(t.x)){e=["x","y","z"].map((e=>t[e])).filter((e=>e!==undefined))}return e.filter((e=>typeof e==="number"))};const d=function(){return i(arguments).map((e=>l(e)))};const u=function(){const e=i(arguments);return e.length===4?[[0,1],[2,3]].map((t=>t.map((t=>e[t])))):e.map((e=>l(e)))};const m=(e,t=[])=>({vector:e,origin:t});const p=function(){const e=i(arguments);if(e.length===0||e[0]==null){return m([],[])}if(e[0].constructor===Object&&e[0].vector!==undefined){return m(e[0].vector,e[0].origin||[])}return typeof e[0]==="number"?m(l(e)):m(...e.map((e=>l(e))))};const g=Object.freeze({__proto__:null,getArrayOfVectors:d,getLine:p,getSegment:u,getVector:l});const _={file:["file_spec","file_creator","file_author","file_title","file_description","file_classes","file_frames"],frame:["frame_author","frame_title","frame_description","frame_attributes","frame_classes","frame_unit","frame_parent","frame_inherit"],graph:["vertices_coords","vertices_vertices","vertices_edges","vertices_faces","edges_vertices","edges_faces","edges_assignment","edges_foldAngle","edges_length","faces_vertices","faces_edges","faces_faces"],orders:["edgeOrders","faceOrders"]};const h=["singleModel","multiModel","animation","diagrams"];const v=["creasePattern","foldedForm","graph","linkage"];const b=["2D","3D","abstract","manifold","nonManifold","orientable","nonOrientable","selfTouching","nonSelfTouching","selfIntersecting","nonSelfIntersecting"];const y=Object.freeze({__proto__:null,foldFileClasses:h,foldFrameAttributes:b,foldFrameClasses:v,foldKeys:_});const E=1e-6;const M=180/Math.PI;const A=Math.PI/180;const x=Math.PI*2;const w=Object.freeze({__proto__:null,D2R:A,EPSILON:E,R2D:M,TWO_PI:x});const k=(e,t)=>e+(t||0);const O=e=>Math.sqrt(e.map((e=>e*e)).reduce(k,0));const j=e=>Math.sqrt(e[0]*e[0]+e[1]*e[1]);const F=e=>Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);const S=e=>e[0]*e[0]+e[1]*e[1];const C=e=>e.map((e=>e*e)).reduce(k,0);const V=e=>{const t=O(e);return t===0?e:e.map((e=>e/t))};const P=e=>{const t=j(e);return t===0?e:[e[0]/t,e[1]/t]};const T=e=>{const t=F(e);return t===0?e:[e[0]/t,e[1]/t,e[2]/t]};const z=(e,t)=>e.map((e=>e*t));const N=(e,t)=>[e[0]*t,e[1]*t];const B=(e,t)=>[e[0]*t,e[1]*t,e[2]*t];const $=(e,t)=>e.map(((e,n)=>e+(t[n]||0)));const R=(e,t)=>[e[0]+t[0],e[1]+t[1]];const L=(e,t)=>[e[0]+t[0],e[1]+t[1],e[2]+t[2]];const I=(e,t)=>e.map(((e,n)=>e-(t[n]||0)));const U=(e,t)=>[e[0]-t[0],e[1]-t[1]];const Q=(e,t)=>[e[0]-t[0],e[1]-t[1],e[2]-t[2]];const D=(e,t)=>e.map(((n,s)=>e[s]*t[s])).reduce(k,0);const q=(e,t)=>e[0]*t[0]+e[1]*t[1];const W=(e,t)=>e[0]*t[0]+e[1]*t[1]+e[2]*t[2];const G=(e,t)=>e.map(((e,n)=>(e+t[n])/2));const H=(e,t)=>N(R(e,t),.5);const J=(e,t)=>B(L(e,t),.5);const Z=function(){if(arguments.length===0){return undefined}const e=arguments[0].length>0?arguments[0].length:0;const t=Array(e).fill(0);Array.from(arguments).forEach((e=>t.forEach(((n,s)=>{t[s]+=e[s]||0}))));return t.map((e=>e/arguments.length))};const Y=(...e)=>{if(!e||!e.length){return undefined}const t=1/e.length;return e.reduce(((e,t)=>R(e,t)),[0,0]).map((e=>e*t))};const X=(e,t,n=0)=>{const s=1-n;return e.map(((e,r)=>e*s+(t[r]||0)*n))};const K=(e,t)=>e[0]*t[1]-e[1]*t[0];const ee=(e,t)=>[e[1]*t[2]-e[2]*t[1],e[2]*t[0]-e[0]*t[2],e[0]*t[1]-e[1]*t[0]];const te=(e,t)=>Math.sqrt(e.map(((n,s)=>(e[s]-t[s])**2)).reduce(k,0));const ne=(e,t)=>{const n=e[0]-t[0];const s=e[1]-t[1];return Math.sqrt(n*n+s*s)};const se=(e,t)=>{const n=e[0]-t[0];const s=e[1]-t[1];const r=e[2]-t[2];return Math.sqrt(n*n+s*s+r*r)};const re=e=>e.map((e=>-e));const oe=e=>[-e[1],e[0]];const ce=e=>[e[1],-e[0]];const ae=(e,t=E)=>e.map((e=>Math.abs(e))).reduce(k,0)<t;const ie=(e,t,n=E)=>1-Math.abs(D(e,t))<n;const fe=(e,t,n=E)=>ie(V(e),V(t),n);const le=(e,t,n=E)=>Math.abs(K(e,t))<n;const de=(e,t)=>t.length===e?t:Array(e).fill(0).map(((e,n)=>t[n]?t[n]:e));const ue=(e,t)=>[e,t].map((n=>de(Math.max(e.length,t.length),n)));const me=(e=[1,0])=>{const t=P(e);return[t,oe(t)]};const pe=(e=[1,0,0])=>{const t=T(e);const n=[[1,0,0],[0,1,0],[0,0,1]].map((e=>ee(e,t)));const s=n.map(F).map(((e,t)=>({n:e,i:t}))).sort(((e,t)=>t.n-e.n)).map((e=>e.i)).shift();const r=T(n[s]);return[t,r,ee(t,r)]};const ge=e=>e.length===2?me(e):pe(e);const _e=Object.freeze({__proto__:null,add:$,add2:R,add3:L,average:Z,average2:Y,basisVectors:ge,basisVectors2:me,basisVectors3:pe,cross2:K,cross3:ee,degenerate:ae,distance:te,distance2:ne,distance3:se,dot:D,dot2:q,dot3:W,flip:re,lerp:X,magSquared:C,magSquared2:S,magnitude:O,magnitude2:j,magnitude3:F,midpoint:G,midpoint2:H,midpoint3:J,normalize:V,normalize2:P,normalize3:T,parallel:fe,parallel2:le,parallelNormalized:ie,resize:de,resizeUp:ue,rotate270:ce,rotate90:oe,scale:z,scale2:N,scale3:B,subtract:I,subtract2:U,subtract3:Q});const he=[1,0,0,1];const ve=he.concat(0,0);const be=(e,t)=>[e[0]*t[0]+e[2]*t[1]+e[4],e[1]*t[0]+e[3]*t[1]+e[5]];const ye=(e,t,n)=>({vector:[e[0]*t[0]+e[2]*t[1],e[1]*t[0]+e[3]*t[1]],origin:[e[0]*n[0]+e[2]*n[1]+e[4],e[1]*n[0]+e[3]*n[1]+e[5]]});const Ee=(e,t)=>[e[0]*t[0]+e[2]*t[1],e[1]*t[0]+e[3]*t[1],e[0]*t[2]+e[2]*t[3],e[1]*t[2]+e[3]*t[3],e[0]*t[4]+e[2]*t[5]+e[4],e[1]*t[4]+e[3]*t[5]+e[5]];const Me=e=>e[0]*e[3]-e[1]*e[2];const Ae=e=>{const t=Me(e);if(Math.abs(t)<1e-12||Number.isNaN(t)||!Number.isFinite(e[4])||!Number.isFinite(e[5])){return undefined}return[e[3]/t,-e[1]/t,-e[2]/t,e[0]/t,(e[2]*e[5]-e[3]*e[4])/t,(e[1]*e[4]-e[0]*e[5])/t]};const xe=(e=0,t=0)=>he.concat(e,t);const we=(e=[1,1],t=[0,0])=>[e[0],0,0,e[1],e[0]*-t[0]+t[0],e[1]*-t[1]+t[1]];const ke=(e=1,t=[0,0])=>we([e,e],t);const Oe=(e,t=[0,0])=>{const n=Math.cos(e);const s=Math.sin(e);return[n,s,-s,n,t[0],t[1]]};const je=(e,t=[0,0])=>{const n=Math.atan2(e[1],e[0]);const s=Math.cos(n);const r=Math.sin(n);const o=Math.cos(-n);const c=Math.sin(-n);const a=s*o+r*c;const i=s*-c+r*o;const f=r*o+-s*c;const l=r*-c+-s*o;const d=t[0]+a*-t[0]+-t[1]*f;const u=t[1]+i*-t[0]+-t[1]*l;return[a,i,f,l,d,u]};const Fe=Object.freeze({__proto__:null,determinant2:Me,identity2x2:he,identity2x3:ve,invertMatrix2:Ae,makeMatrix2Reflect:je,makeMatrix2Rotate:Oe,makeMatrix2Scale:we,makeMatrix2Translate:xe,makeMatrix2UniformScale:ke,multiplyMatrices2:Ee,multiplyMatrix2Line2:ye,multiplyMatrix2Vector2:be});const Se=Object.freeze([1,0,0,0,1,0,0,0,1]);const Ce=Object.freeze(Se.concat(0,0,0));const Ve=e=>Ce.map(((t,n)=>Math.abs(t-e[n])<E)).reduce(((e,t)=>e&&t),true);const Pe=(e,t)=>[e[0]*t[0]+e[3]*t[1]+e[6]*t[2]+e[9],e[1]*t[0]+e[4]*t[1]+e[7]*t[2]+e[10],e[2]*t[0]+e[5]*t[1]+e[8]*t[2]+e[11]];const Te=(e,t,n)=>({vector:[e[0]*t[0]+e[3]*t[1]+e[6]*t[2],e[1]*t[0]+e[4]*t[1]+e[7]*t[2],e[2]*t[0]+e[5]*t[1]+e[8]*t[2]],origin:[e[0]*n[0]+e[3]*n[1]+e[6]*n[2]+e[9],e[1]*n[0]+e[4]*n[1]+e[7]*n[2]+e[10],e[2]*n[0]+e[5]*n[1]+e[8]*n[2]+e[11]]});const ze=(e,t)=>[e[0]*t[0]+e[3]*t[1]+e[6]*t[2],e[1]*t[0]+e[4]*t[1]+e[7]*t[2],e[2]*t[0]+e[5]*t[1]+e[8]*t[2],e[0]*t[3]+e[3]*t[4]+e[6]*t[5],e[1]*t[3]+e[4]*t[4]+e[7]*t[5],e[2]*t[3]+e[5]*t[4]+e[8]*t[5],e[0]*t[6]+e[3]*t[7]+e[6]*t[8],e[1]*t[6]+e[4]*t[7]+e[7]*t[8],e[2]*t[6]+e[5]*t[7]+e[8]*t[8],e[0]*t[9]+e[3]*t[10]+e[6]*t[11]+e[9],e[1]*t[9]+e[4]*t[10]+e[7]*t[11]+e[10],e[2]*t[9]+e[5]*t[10]+e[8]*t[11]+e[11]];const Ne=e=>e[0]*e[4]*e[8]-e[0]*e[7]*e[5]-e[3]*e[1]*e[8]+e[3]*e[7]*e[2]+e[6]*e[1]*e[5]-e[6]*e[4]*e[2];const Be=e=>{const t=Ne(e);if(Math.abs(t)<1e-12||Number.isNaN(t)||!Number.isFinite(e[9])||!Number.isFinite(e[10])||!Number.isFinite(e[11])){return undefined}const n=[e[4]*e[8]-e[7]*e[5],-e[1]*e[8]+e[7]*e[2],e[1]*e[5]-e[4]*e[2],-e[3]*e[8]+e[6]*e[5],e[0]*e[8]-e[6]*e[2],-e[0]*e[5]+e[3]*e[2],e[3]*e[7]-e[6]*e[4],-e[0]*e[7]+e[6]*e[1],e[0]*e[4]-e[3]*e[1],-e[3]*e[7]*e[11]+e[3]*e[8]*e[10]+e[6]*e[4]*e[11]-e[6]*e[5]*e[10]-e[9]*e[4]*e[8]+e[9]*e[5]*e[7],e[0]*e[7]*e[11]-e[0]*e[8]*e[10]-e[6]*e[1]*e[11]+e[6]*e[2]*e[10]+e[9]*e[1]*e[8]-e[9]*e[2]*e[7],-e[0]*e[4]*e[11]+e[0]*e[5]*e[10]+e[3]*e[1]*e[11]-e[3]*e[2]*e[10]-e[9]*e[1]*e[5]+e[9]*e[2]*e[4]];const s=1/t;return n.map((e=>e*s))};const $e=(e=0,t=0,n=0)=>Se.concat(e,t,n);const Re=(e,t,n,s,r)=>{const o=Math.cos(e);const c=Math.sin(e);const a=Se.concat([0,0,0]);a[n*3+n]=o;a[n*3+s]=(r?+1:-1)*c;a[s*3+n]=(r?-1:+1)*c;a[s*3+s]=o;const i=[0,1,2].map((e=>t[e]||0));const f=Se.concat(re(i));const l=Se.concat(i);return ze(l,ze(a,f))};const Le=(e,t=[0,0,0])=>Re(e,t,1,2,true);const Ie=(e,t=[0,0,0])=>Re(e,t,0,2,false);const Ue=(e,t=[0,0,0])=>Re(e,t,0,1,true);const Qe=(e,t=[0,0,1],n=[0,0,0])=>{const s=[0,1,2].map((e=>n[e]||0));const[r,o,c]=de(3,V(t));const a=Math.cos(e);const i=Math.sin(e);const f=1-a;const l=Se.concat(-s[0],-s[1],-s[2]);const d=Se.concat(s[0],s[1],s[2]);return ze(d,ze([f*r*r+a,f*o*r+c*i,f*c*r-o*i,f*r*o-c*i,f*o*o+a,f*c*o+r*i,f*r*c+o*i,f*o*c-r*i,f*c*c+a,0,0,0],l))};const De=(e=[1,1,1],t=[0,0,0])=>[e[0],0,0,0,e[1],0,0,0,e[2],e[0]*-t[0]+t[0],e[1]*-t[1]+t[1],e[2]*-t[2]+t[2]];const qe=(e=1,t=[0,0,0])=>De([e,e,e],t);const We=(e,t=[0,0])=>{const n=je(e,t);return[n[0],n[1],0,n[2],n[3],0,0,0,1,n[4],n[5],0]};const Ge=Object.freeze({__proto__:null,determinant3:Ne,identity3x3:Se,identity3x4:Ce,invertMatrix3:Be,isIdentity3x4:Ve,makeMatrix3ReflectZ:We,makeMatrix3Rotate:Qe,makeMatrix3RotateX:Le,makeMatrix3RotateY:Ie,makeMatrix3RotateZ:Ue,makeMatrix3Scale:De,makeMatrix3Translate:$e,makeMatrix3UniformScale:qe,multiplyMatrices3:ze,multiplyMatrix3Line3:Te,multiplyMatrix3Vector3:Pe});const He=e=>Array.from(Array(Math.floor(e))).map(((t,n)=>x*(n/e)));const Je=(e,t)=>e.map((e=>[t*Math.cos(e),t*Math.sin(e)]));const Ze=(e=3,t=1)=>Je(He(e),t);const Ye=(e=3,t=1)=>{const n=Math.PI/e;const s=He(e).map((e=>e+n));return Je(s,t)};const Xe=(e=3,t=1)=>Ze(e,t/Math.cos(Math.PI/e));const Ke=(e=3,t=1)=>Ye(e,t/Math.cos(Math.PI/e));const et=(e=3,t=1)=>Ze(e,t/2/Math.sin(Math.PI/e));const tt=(e=3,t=1)=>Ye(e,t/2/Math.sin(Math.PI/e));const nt=(e,t=E)=>{const n=e.map(((e,t,n)=>[e,n[(t+1)%n.length]])).map((e=>I(e[1],e[0])));const s=n.map(((e,t,n)=>[e,n[(t+n.length-1)%n.length]])).map((e=>!fe(e[1],e[0],t)));return e.filter(((e,t)=>s[t]))};const st=e=>.5*e.map(((e,t,n)=>[e,n[(t+1)%n.length]])).map((e=>K(...e))).reduce(((e,t)=>e+t),0);const rt=e=>{const t=1/(6*st(e));return e.map(((e,t,n)=>[e,n[(t+1)%n.length]])).map((e=>N(R(...e),K(...e)))).reduce(((e,t)=>R(e,t)),[0,0]).map((e=>e*t))};const ot=e=>{for(let t=0;t<e.length;t+=1){if(e[t]&&e[t].length){return e[t].length}}return 0};const ct=(e,t=0)=>{if(!e||!e.length){return undefined}const n=ot(e);const s=Array(n).fill(Infinity);const r=Array(n).fill(-Infinity);e.filter((e=>e!==undefined)).forEach((e=>e.forEach(((e,n)=>{if(e<s[n]){s[n]=e-t}if(e>r[n]){r[n]=e+t}}))));const o=r.map(((e,t)=>e-s[t]));return{min:s,max:r,span:o}};const at=Object.freeze({__proto__:null,boundingBox:ct,centroid:rt,makePolygonCircumradius:Ze,makePolygonCircumradiusSide:Ye,makePolygonInradius:Xe,makePolygonInradiusSide:Ke,makePolygonNonCollinear:nt,makePolygonSideLength:et,makePolygonSideLengthSide:tt,signedArea:st});const it=(e,t,n=E)=>Math.abs(e-t)<n;const ft=(e,t,n=E)=>it(e,t,n)?0:Math.sign(e-t);const lt=(e,t,n=E)=>{for(let s=0;s<Math.max(e.length,t.length);s+=1){if(!it(e[s]||0,t[s]||0,n)){return false}}return true};const dt=(e,t=E)=>e>-t;const ut=(e,t=E)=>e>t;const mt=()=>true;const pt=()=>true;const gt=dt;const _t=ut;const ht=(e,t=E)=>e>-t&&e<1+t;const vt=(e,t=E)=>e>t&&e<1-t;const bt=Object.freeze({__proto__:null,epsilonCompare:ft,epsilonEqual:it,epsilonEqualVectors:lt,exclude:ut,excludeL:pt,excludeR:_t,excludeS:vt,include:dt,includeL:mt,includeR:gt,includeS:ht});const yt={vertices:"vertex",edges:"edge",faces:"face"};const Et={vertex:"vertices",edge:"edges",face:"faces"};const Mt=Array.from("BbMmVvFfJjCcUu");const At={B:"boundary",M:"mountain",V:"valley",F:"flat",J:"join",C:"cut",U:"unassigned"};Object.keys(At).forEach((e=>{At[e.toLowerCase()]=At[e]}));const xt={B:0,b:0,M:-180,m:-180,V:180,v:180,F:0,f:0,J:0,j:0,C:0,c:0,U:0,u:0};const wt={B:false,b:false,M:true,m:true,V:true,v:true,F:false,f:false,J:false,j:false,C:false,c:false,U:true,u:true};const kt={B:true,b:true,M:false,m:false,V:false,v:false,F:false,f:false,J:false,j:false,C:true,c:true,U:false,u:false};const Ot=e=>xt[e]||0;const jt=e=>{if(e>E){return"V"}if(e<-E){return"M"}return"U"};const Ft=e=>it(0,e)||it(-180,e)||it(180,e);const St=({edges_foldAngle:e})=>{if(!e){return true}for(let t=0;t<e.length;t+=1){if(!Ft(e[t])){return false}}return true};const Ct=(e,t)=>Object.keys(e).filter((e=>t(e)));const Vt=(e,t)=>Ct(e,(e=>e.substring(0,t.length+1)===`${t}_`));const Pt=(e,t)=>Ct(e,(e=>e.substring(e.length-t.length-1,e.length)===`_${t}`));const Tt=e=>{const t={};Object.keys(e).filter((e=>e.includes("_"))).map((e=>e.substring(0,e.indexOf("_")))).forEach((e=>{t[e]=true}));return Object.keys(t)};const zt=e=>{const t={};Object.keys(e).filter((e=>e.includes("_"))).map((e=>e.substring(e.lastIndexOf("_")+1,e.length))).forEach((e=>{t[e]=true}));return Object.keys(t)};const Nt=(e,t)=>{const n=Vt(e,t);if(n.length===0){return[]}const s=Math.max(...n.map((t=>e[t].length)));const r=Array.from(Array(s)).map((()=>({})));n.forEach((t=>r.forEach(((n,s)=>{r[s][t]=e[t][s]}))));return r};const Bt=(e,t,n)=>{const s=Vt(e,t);if(s.length===0){return undefined}const r={};s.forEach((t=>{r[t]=e[t][n]}));return r};const $t=Object.freeze([].concat(_.file).concat(_.frame).concat(_.graph).concat(_.orders));const Rt=(e={})=>Object.keys(e).length===0?0:$t.filter((t=>e[t])).length/Object.keys(e).length;const Lt=({frame_classes:e,file_classes:t})=>e&&e.includes("foldedForm")||t&&t.includes("foldedForm");const It=({vertices_coords:e},t=E)=>{for(let n=0;n<e.length;n+=1){if(e[n]&&e[n].length===3&&!it(0,e[n][2],t)){return 3}}return 2};const Ut=({vertices_coords:e})=>{if(e[0]!==undefined){return e[0].length}const t=e.filter((()=>true)).shift();if(!t){return undefined}return t.length};const Qt=({edges_vertices:e,edges_foldAngle:t,edges_assignment:n})=>{if(n===undefined){return t===undefined?e.map((()=>true)):t.map((e=>e<-E||e>E))}return n.map((e=>wt[e]))};const Dt={M:"V",m:"v",V:"M",v:"m"};const qt=e=>Dt[e]||e;const Wt=e=>{if(e.edges_assignment){e.edges_assignment=e.edges_assignment.map((e=>Dt[e]?Dt[e]:e))}if(e.edges_foldAngle){e.edges_foldAngle=e.edges_foldAngle.map((e=>-e))}return e};const Gt=({edges_vertices:e,edges_assignment:t=[]})=>{const n=Array.from(new Set(Mt.map((e=>e.toUpperCase()))));const s=e.map(((e,n)=>t[n]||"U")).map((e=>e.toUpperCase()));const r={};n.forEach((e=>{r[e]=[]}));s.forEach(((e,t)=>r[e].push(t)));return r};const Ht=(e={})=>{const t={};_.file.filter((e=>e!=="file_frames")).filter((t=>e[t]!==undefined)).forEach((n=>{t[n]=e[n]}));return t};const Jt=Object.freeze({__proto__:null,assignmentCanBeFolded:wt,assignmentFlatFoldAngle:xt,assignmentIsBoundary:kt,edgeAssignmentToFoldAngle:Ot,edgeFoldAngleIsFlat:Ft,edgeFoldAngleToAssignment:jt,edgesAssignmentNames:At,edgesAssignmentValues:Mt,edgesFoldAngleAreAllFlat:St,filterKeysWithPrefix:Vt,filterKeysWithSuffix:Pt,getAllPrefixes:Tt,getAllSuffixes:zt,getDimension:It,getDimensionQuick:Ut,getFileMetadata:Ht,invertAssignment:qt,invertAssignments:Wt,isFoldObject:Rt,isFoldedForm:Lt,makeEdgesIsFolded:Qt,pluralize:Et,singularize:yt,sortEdgesByAssignment:Gt,transposeGraphArrayAtIndex:Bt,transposeGraphArrays:Nt});const Zt=function(e,t){Pt(e,"coords").forEach((n=>{e[n]=e[n].map((e=>de(3,e))).map((e=>Pe(t,e)))}));Pt(e,"matrix").forEach((n=>{e[n]=e[n].map((e=>ze(e,t)))}));return e};const Yt=(e,...t)=>{const n=t.flat();const s=n.length===1?[n[0],n[0],n[0]]:[1,1,1].map(((e,t)=>n[t]===undefined?e:n[t]));const r=De(s);return Zt(e,r)};const Xt=(e,...t)=>{const n=l(...t);const s=de(3,n);const r=$e(...s);return Zt(e,r)};const Kt=(e,t,n,s)=>Zt(e,Qe(t,n,s));const en=(e,t,...n)=>{const s=l(...n);const r=de(3,s);const o=Ue(t,r);return Zt(e,o)};const tn=function(e){if(!e.vertices_coords){return e}const t=ct(e.vertices_coords);const n=Math.max(...t.span);const s=n===0?1:1/n;const r=t.min;e.vertices_coords=e.vertices_coords.map((e=>I(e,r))).map((e=>e.map((e=>e*s))));return e};const nn=Object.freeze({__proto__:null,rotate:Kt,rotateZ:en,scale:Yt,transform:Zt,translate:Xt,unitize:tn});const sn=({vertices_coords:e},t=E)=>{if(!e){return[]}const n=Ut({vertices_coords:e});const s=Array.from(Array(n));const r=[];const o=[];const c=e.map(((e,t)=>({i:t,d:e[0]}))).sort(((e,t)=>e.d-t.d)).map((e=>e.i));let a=0;const i=s.map((()=>[0,0]));const f=t=>s.map(((n,s)=>e[t][s]>i[s][0]&&e[t][s]<i[s][1])).reduce(((e,t)=>e&&t),true);const l=s=>{const r=s[s.length-1];while(e[r][0]-e[s[a]][0]>t){a+=1}const o=s.slice(a,s.length).map((t=>e[t]));i[0]=[o[0][0]-t,o[o.length-1][0]+t];for(let e=1;e<n;e+=1){const n=o.map((t=>t[e]));i[e]=[Math.min(...n)-t,Math.max(...n)+t]}};while(o.length!==e.length){const t=[];const n=c.shift();t.push(n);o.push(n);a=0;l(t);let s=0;while(s<c.length&&e[c[s]][0]<i[0][1]){if(f(c[s])){const e=c.splice(s,1).shift();t.push(e);o.push(e);l(t)}else{s+=1}}r.push(t)}return r};const rn=Object.freeze({__proto__:null,getVerticesClusters:sn});const on=(...e)=>Math.max(0,...e.filter((e=>e!==undefined)).map((e=>e.length)));const cn=(e,t)=>on(...Vt(e,t).map((t=>e[t])));cn.vertices=({vertices_coords:e,vertices_faces:t,vertices_vertices:n})=>on(e,t,n);cn.edges=({edges_vertices:e,edges_edges:t,edges_faces:n})=>on(e,t,n);cn.faces=({faces_vertices:e,faces_edges:t,faces_faces:n})=>on(e,t,n);const an=e=>Array.from(new Set(e));const fn=e=>{const t={};e.forEach((e=>{if(t[e]===undefined){t[e]=0}t[e]+=1}));return e.filter((e=>t[e]>1))};const ln=e=>{const t={};e.forEach((e=>{t[e]=true}));return Object.keys(t).map(parseFloat)};const dn=(e,t=E)=>{const n=e.slice().sort(((e,t)=>e-t));if(n.length<2){return n}const s=[true];for(let e=1;e<n.length;e+=1){s[e]=!it(n[e],n[e-1],t)}return n.filter(((e,t)=>s[t]))};const un=e=>{const t=Array(e.length*(e.length-1)/2);let n=0;for(let s=0;s<e.length-1;s+=1){for(let r=s+1;r<e.length;r+=1,n+=1){t[n]=[e[s],e[r]]}}return t};const mn=(e,t)=>{const n=[];let s=0;let r=0;while(s<e.length&&r<t.length){if(e[s]===t[r]){s+=1}else if(e[s]>t[r]){r+=1}else if(t[r]>e[s]){n.push(e[s]);s+=1}}return n};const pn=(e,t,n=E)=>{const s=[];let r=0;let o=0;while(r<e.length&&o<t.length){if(it(e[r],t[o],n)){r+=1}else if(e[r]>t[o]){o+=1}else if(t[o]>e[r]){s.push(e[r]);r+=1}}return s};const gn=(e,t)=>{if(!e.length){return undefined}const n=typeof t==="function"?e.map((e=>t(e))):e;let s=0;for(let e=1;e<n.length;e+=1){if(n[e]<n[s]){s=e}}return s};const _n=(e,t)=>{if(!e.length){return undefined}const n=typeof t==="function"?e.map((e=>t(e))):e;let s=0;for(let e=1;e<n.length;e+=1){if(n[e]>n[s]){s=e}}return s};const hn=(...e)=>{const t=[];e.forEach((e=>e.forEach(((e,n)=>{t[n]=e}))));return t};const vn=Object.freeze({__proto__:null,arrayMaximumIndex:_n,arrayMinimumIndex:gn,chooseTwoPairs:un,epsilonUniqueSortedNumbers:dn,mergeArraysWithHoles:hn,nonUniqueElements:fn,setDifferenceSortedEpsilonNumbers:pn,setDifferenceSortedNumbers:mn,uniqueElements:an,uniqueSortedNumbers:ln});const bn=(...e)=>{if(e.length===0){return[]}const t=e[0].map(((e,t)=>t));e.forEach((e=>t.forEach(((n,s)=>{t[s]=e[n]}))));return t};const yn=(...e)=>{if(e.length===0){return[]}const t=e[0].map(((e,t)=>[t]));e.forEach((e=>{t.forEach(((n,s)=>n.forEach(((n,r)=>{t[s][r]=e[n]}))));t.forEach(((e,n)=>{t[n]=e.reduce(((e,t)=>e.concat(t)),[]).filter((e=>e!==undefined))}))}));return t};const En=(...e)=>{if(e.length===0){return[]}let t=e[0].map(((e,t)=>t));e.forEach((e=>{const n=e.map((e=>t[e]));t=n}));return t};const Mn=(...e)=>{if(e.length===0){return[]}let t=e[0].reduce(((e,t)=>e.concat(t)),[]).map(((e,t)=>[t]));e.forEach((e=>{const n=[];e.forEach(((e,s)=>{if(typeof e==="number"){n[s]=t[e]}else{n[s]=e.map((e=>t[e])).reduce(((e,t)=>e.concat(t)),[])}}));t=n}));return t};const An=e=>{const t=[];e.forEach(((e,n)=>{t[e]=n}));return t};const xn=e=>{const t=[];e.forEach(((e,n)=>{t[e]=t[e]===undefined?n:t[e]}));return t};const wn=e=>{const t=[];const n=(e,n)=>{if(t[e]===undefined){t[e]=[]}t[e].push(n)};e.forEach(((e,t)=>{if(e==null){return}if(typeof e==="number"){n(e,t)}if(e.constructor===Array){e.forEach((e=>n(e,t)))}}));return t};const kn=e=>{const t=[];const n=(e,n)=>{if(t[e]!==undefined){if(typeof t[e]==="number"){t[e]=[t[e],n]}else{t[e].push(n)}}else{t[e]=n}};e.forEach(((e,t)=>{if(e==null){return}if(typeof e==="number"){n(e,t)}if(e.constructor===Array){e.forEach((e=>n(e,t)))}}));return t};const On=(e,t,n=[])=>{Pt(e,t).forEach((t=>e[t].forEach(((s,r)=>e[t][r].forEach(((s,o)=>{e[t][r][o]=n[s]}))))));const s=An(n);Vt(e,t).forEach((t=>{e[t]=s.map((n=>e[t][n]))}))};const jn=(e,t,n)=>{const s=xn(n);Pt(e,t).forEach((t=>e[t].forEach(((s,r)=>e[t][r].forEach(((s,o)=>{e[t][r][o]=n[s]}))))));Pt(e,t).forEach((t=>e[t].forEach(((n,s)=>{e[t][s]=e[t][s].filter((e=>e!==undefined))}))));Vt(e,t).forEach((t=>{e[t]=s.map((n=>e[t][n]))}))};const Fn=Object.freeze({__proto__:null,invertArrayMap:wn,invertMap:kn,invertSimpleMap:An,invertSimpleMapNoReplace:xn,mergeBackmaps:Mn,mergeNextmaps:yn,mergeSimpleBackmaps:En,mergeSimpleNextmaps:bn,remapComponent:On,remapKey:jn});const Sn=(e,t,s,r)=>{const o=cn(e,t);const c=[];for(let e=0,t=0,a=0;e<o;e+=1,t+=1){while(e===r[a]){c[e]=c[s[r[a]]];if(c[e]===undefined){throw new Error(n.replaceUndefined)}e+=1;a+=1}if(e<o){c[e]=t}}return c};const Cn=(e,t,n)=>{Object.entries(n).filter((([e,t])=>e<t)).forEach((([e,t])=>{delete n[e];n[t]=e}));const s=Object.keys(n).map((e=>parseInt(e,10)));const r=ln(s);const o=Sn(e,t,n,r);jn(e,t,o);return o};const Vn=(e,t)=>sn(e,t).filter((e=>e.length>1));const Pn=(e,t=E,n=true)=>{const s=[];const r=[];const o=sn(e,t).filter((e=>e.length>1));o.forEach((e=>{if(Math.min(...e)!==e[0]){e.sort(((e,t)=>e-t))}for(let t=1;t<e.length;t+=1){s[e[t]]=e[0];r.push(e[t])}}));if(n){o.map((t=>t.map((t=>e.vertices_coords[t])))).map((e=>Z(...e))).forEach(((t,n)=>{e.vertices_coords[o[n][0]]=t}))}return{map:Cn(e,"vertices",s),remove:r}};const Tn=Object.freeze({__proto__:null,duplicateVertices:Vn,removeDuplicateVertices:Pn});const zn=(e,t,n)=>{const s=ln(n);const r=cn(e,t);const o=[];for(let e=0,t=0,n=0;e<r;e+=1,t+=1){while(e===s[n]){o[e]=undefined;e+=1;n+=1}if(e<r){o[e]=t}}return o};const Nn=(e,t,n)=>{const s=zn(e,t,n);jn(e,t,s);return s};const Bn=({vertices_coords:e,edges_vertices:t})=>{if(!e||!t){return[]}let n=e.length;const s=Array(n).fill(false);t.forEach((e=>{e.filter((e=>!s[e])).forEach((e=>{s[e]=true;n-=1}))}));return s.map(((e,t)=>e?undefined:t)).filter((e=>e!==undefined))};const $n=({vertices_coords:e,faces_vertices:t})=>{if(!e||!t){return[]}let n=e.length;const s=Array(n).fill(false);t.forEach((e=>{e.filter((e=>!s[e])).forEach((e=>{s[e]=true;n-=1}))}));return s.map(((e,t)=>e?undefined:t)).filter((e=>e!==undefined))};const Rn=({vertices_coords:e,edges_vertices:t,faces_vertices:n})=>{if(!e){return[]}let s=e.length;const r=Array(s).fill(false);if(t){t.forEach((e=>{e.filter((e=>!r[e])).forEach((e=>{r[e]=true;s-=1}))}))}if(n){n.forEach((e=>{e.filter((e=>!r[e])).forEach((e=>{r[e]=true;s-=1}))}))}return r.map(((e,t)=>e?undefined:t)).filter((e=>e!==undefined))};const Ln=(e,t)=>{if(!t){t=Rn(e)}return{map:Nn(e,"vertices",t),remove:t}};const In=Object.freeze({__proto__:null,edgeIsolatedVertices:Bn,faceIsolatedVertices:$n,isolatedVertices:Rn,removeIsolatedVertices:Ln});const Un=e=>Math.atan2(e[1],e[0]);const Qn=e=>[Math.cos(e),Math.sin(e)];const Dn=(e,t)=>({vector:I(t,e),origin:e});const qn=({vector:e,origin:t})=>{const n=O(e);const s=oe(e);const r=D(t,s)/n;return{normal:z(s,1/n),distance:r}};const Wn=({normal:e,distance:t})=>({vector:ce(e),origin:z(e,t)});const Gn=Object.freeze({__proto__:null,angleToVector:Qn,pointsToLine:Dn,uniqueLineToVecLine:Wn,vecLineToUniqueLine:qn,vectorToAngle:Un});const Hn=(e,t,n)=>{while(n<t){n+=x}while(e>t){e-=x}while(e<t){e+=x}return e<n};const Jn=(e,t)=>{while(e<0){e+=x}while(t<0){t+=x}while(e>x){e-=x}while(t>x){t-=x}const n=e-t;return n>=0?n:x-(t-e)};const Zn=(e,t)=>{while(e<0){e+=x}while(t<0){t+=x}while(e>x){e-=x}while(t>x){t-=x}const n=t-e;return n>=0?n:x-(e-t)};const Yn=(e,t)=>{const n=t[0]*e[0]+t[1]*e[1];const s=t[0]*e[1]-t[1]*e[0];let r=Math.atan2(s,n);if(r<0){r+=x}return r};const Xn=(e,t)=>{const n=e[0]*t[0]+e[1]*t[1];const s=e[0]*t[1]-e[1]*t[0];let r=Math.atan2(s,n);if(r<0){r+=x}return r};const Kn=(e,t)=>Qn(Un(e)-Yn(e,t)/2);const es=(e,t)=>Qn(Un(e)+Xn(e,t)/2);const ts=(e,t,n)=>{const s=Jn(e,t)/n;return Array.from(Array(n-1)).map(((t,n)=>e+s*(n+1)))};const ns=(e,t,n)=>{const s=Zn(e,t)/n;return Array.from(Array(n-1)).map(((t,n)=>e+s*(n+1)))};const ss=(e,t,n)=>{const s=Math.atan2(e[1],e[0]);const r=Math.atan2(t[1],t[0]);return ts(s,r,n).map(Qn)};const rs=(e,t,n)=>{const s=Math.atan2(e[1],e[0]);const r=Math.atan2(t[1],t[0]);return ns(s,r,n).map(Qn)};const os=e=>{const t=e.map(((e,t)=>t)).sort(((t,n)=>e[t]-e[n]));return t.slice(t.indexOf(0),t.length).concat(t.slice(0,t.indexOf(0)))};const cs=e=>os(e.map(Un));const as=e=>os(e).map((t=>e[t])).map(((e,t,n)=>[e,n[(t+1)%n.length]])).map((e=>Zn(e[0],e[1])));const is=e=>as(e.map(Un));const fs=(e,t,n,s=E)=>{const r=P(U(t,e));const o=P(U(n,e));const c=K(r,o);if(!it(c,0,s)){return Math.sign(c)}return it(ne(e,t)+ne(t,n),ne(e,n))?0:undefined};const ls=Object.freeze({__proto__:null,clockwiseAngle2:Yn,clockwiseAngleRadians:Jn,clockwiseBisect2:Kn,clockwiseSubsect2:ss,clockwiseSubsectRadians:ts,counterClockwiseAngle2:Xn,counterClockwiseAngleRadians:Zn,counterClockwiseBisect2:es,counterClockwiseOrder2:cs,counterClockwiseOrderRadians:os,counterClockwiseSectors2:is,counterClockwiseSectorsRadians:as,counterClockwiseSubsect2:rs,counterClockwiseSubsectRadians:ns,isCounterClockwiseBetween:Hn,threePointTurnDirection:fs});const ds=e=>{let t=-1;e.filter((e=>e!==undefined)).forEach((e=>e.forEach((e=>e.forEach((e=>{if(e>t){t=e}}))))));return t};const us=e=>{let t=-1;e.forEach((e=>{if(e[0]>t){t=e[0]}if(e[1]>t){t=e[1]}}));return t};const ms={edges:"edgeOrders",faces:"faceOrders"};const ps=(e,t)=>Math.max(ds(Pt(e,t).map((t=>e[t]))),e[ms[t]]?us(e[ms[t]]):-1)+1;ps.vertices=e=>ps(e,"vertices");ps.edges=e=>ps(e,"edges");ps.faces=e=>ps(e,"faces");const gs=({vertices_vertices:e,vertices_sectors:t},n,s,r={})=>{const o={};let c=n;let a=s;const i={vertices:[n],edges:[`${n} ${s}`],angles:[]};while(true){const n=e[a];const s=n.indexOf(c);const f=(s+n.length-1)%n.length;const l=n[f];const d=`${a} ${l}`;if(o[d]){Object.assign(r,o);i.vertices.pop();i.edges.pop();return i}o[d]=true;if(r[d]){return undefined}i.vertices.push(a);i.edges.push(d);if(t){i.angles.push(t[a][f])}c=a;a=l}};const _s=({vertices_vertices:e,vertices_sectors:t})=>{const n={vertices_vertices:e,vertices_sectors:t};const s={};return e.map(((e,t)=>e.map((e=>gs(n,t,e,s))).filter((e=>e!==undefined)))).flat()};const hs=e=>e.filter((e=>e.angles.map((e=>Math.PI-e)).reduce(((e,t)=>e+t),0)>0));const vs=Object.freeze({__proto__:null,counterClockwiseWalk:gs,filterWalkedBoundaryFace:hs,planarVertexWalk:_s});const bs=(e,t=[1,0,0],n=[0,0,0])=>{const s=de(3,e);const r=Q(s,de(3,n));const o=T(de(3,t));const c=W(o,r);const a=B(o,c);return Q(s,a)};const ys=Object.freeze({__proto__:null,projectPointOnPlane:bs});const Es=(e,t,n)=>e.map(((e,s)=>({i:s,n:n(e,t)}))).sort(((e,t)=>e.n-t.n)).map((e=>e.i));const Ms=(e,t)=>Es(e,t,D);const As=e=>{const t=[[],[]];e.map((e=>e[1]>=0?0:1)).forEach(((e,n)=>t[e].push(n)));const n=[(t,n)=>e[n][0]-e[t][0],(t,n)=>e[t][0]-e[n][0]];return t.flatMap(((e,t)=>e.sort(n[t])))};const xs=(e,t=[1,0,0],n=[0,0,0])=>{const s=pe(t);const r=[s[1],s[2],s[0]];const o=e.map((e=>bs(e,t,n)));const c=o.map((e=>I(e,n)));const a=c.map((e=>[D(e,r[0]),D(e,r[1])]));const i=a.map(P);return As(i)};const ws=Object.freeze({__proto__:null,radialSortPointIndices3:xs,radialSortUnitVectors2:As,sortPointsAlongVector:Ms});const ks=({vertices_coords:e},t,n)=>t.map((t=>e[t])).map((t=>I(t,e[n]))).map((e=>Math.atan2(e[1],e[0]))).map((e=>e>-E?e:e+Math.PI*2)).map(((e,t)=>({a:e,i:t}))).sort(((e,t)=>e.a-t.a)).map((e=>e.i)).map((e=>t[e]));const Os=({vertices_coords:e},t,n)=>Ms(t.map((t=>e[t])),n).map((e=>t[e]));const js=Object.freeze({__proto__:null,sortVerticesAlongVector:Os,sortVerticesCounterClockwise:ks});const Fs=({vertices_coords:e,faces_vertices:t})=>t.map((t=>t.map((t=>e[t])))).map((e=>{let t;let n;let s=0;do{t=I(e[(s+1)%e.length],e[s]);n=I(e[(s+2)%e.length],e[s]);s+=1}while(s<e.length&&fe(t,n));return T(ee(de(3,t),de(3,n)))}));const Ss=({vertices_coords:e,faces_vertices:t,faces_normal:n})=>{const s=(e,t)=>{e[0]+=t[0];e[1]+=t[1];e[2]+=t[2]};if(!n){n=Fs({vertices_coords:e,faces_vertices:t})}const r=e.map((()=>[0,0,0]));t.forEach(((e,t)=>e.forEach((e=>s(r[e],n[t])))));return r.map((e=>T(e)))};const Cs=Object.freeze({__proto__:null,makeFacesNormal:Fs,makeVerticesNormal:Ss});const Vs=({edges_vertices:e})=>{const t=[];e.forEach(((e,n)=>e.forEach((e=>{if(t[e]===undefined){t[e]=[]}t[e].push(n)}))));return t};const Ps=({edges_vertices:e,vertices_vertices:t})=>{const n=Ls({edges_vertices:e});return t.map(((e,t)=>e.map((e=>n[`${t} ${e}`]))))};const Ts=({vertices_coords:e,vertices_edges:t,edges_vertices:n})=>{if(!t){t=Vs({edges_vertices:n})}const s=t.map(((e,t)=>e.map((e=>n[e].filter((e=>e!==t)))).reduce(((e,t)=>e.concat(t)),[])));return e===undefined?s:s.map(((t,n)=>ks({vertices_coords:e},t,n)))};const zs=({vertices_coords:e,vertices_faces:t,faces_vertices:n})=>{if(!t){t=$s({vertices_coords:e,faces_vertices:n})}const s=t.map((e=>e.map((e=>n[e]))));const r=s.map(((e,t)=>e.map((e=>e.indexOf(t)))));const o=s.map(((e,t)=>e.map(((e,n)=>[(r[t][n]+e.length-1)%e.length,r[t][n],(r[t][n]+1)%e.length]))));const c=o.map(((e,t)=>e.map(((e,n)=>e.map((e=>s[t][n][e]))))));const a=c.map((e=>{const t=e.map((e=>[[0,1],[1,2]].map((t=>t.map((t=>e[t])).join(" ")))));const n={};const s={};t.forEach(((e,t)=>{n[e[0]]=t;s[e[1]]=t}));return{facesVerts:t,to:s,from:n}}));return a.map((e=>{const t=Object.keys(e.to);const n=t.map((e=>e.split(" ").reverse().join(" ")));const s=t.filter(((t,s)=>!(n[s]in e.from)));if(s.length>2){console.warn("vertices_vertices found an unsolvable vertex");return[]}const r=s.length?s:[t[0]];const o=[];const c={};for(let t=0;t<r.length;t+=1){const n=r[t];const s=[n];c[n]=true;let a=false;do{const t=s[s.length-1];const n=e.to[t];if(!(n in e.facesVerts)){break}let r;if(e.facesVerts[n][0]===t){r=e.facesVerts[n][1]}if(e.facesVerts[n][1]===t){r=e.facesVerts[n][0]}if(r===undefined){return"not found"}const o=r.split(" ").reverse().join(" ");s.push(r);a=o in c;if(!a){s.push(o)}c[r]=true;c[o]=true}while(!a);const i=s.filter(((e,t)=>t%2===0)).map((e=>e.split(" ")[1])).map((e=>parseInt(e,10)));o.push(...i)}return o}))};const Ns=e=>{if(!e.vertices_coords||!e.vertices_coords.length){return[]}const t=e.vertices_coords.filter((()=>true)).shift().length;switch(t){case 3:return zs(e);default:return Ts(e)}};const Bs=({vertices_edges:e,edges_vertices:t})=>{if(!e){e=Vs({edges_vertices:t})}return e.map(((e,n)=>e.flatMap((e=>t[e].filter((e=>e!==n))))))};const $s=({vertices_coords:e,vertices_edges:t,faces_vertices:n})=>{const s=e||t;if(!n){return(s||[]).map((()=>[]))}const r=s!==undefined?s.map((()=>[])):Array.from(Array(ps.vertices({faces_vertices:n}))).map((()=>[]));n.forEach(((e,t)=>{const n=[];e.forEach((e=>{n[e]=t}));n.forEach(((e,t)=>r[t].push(e)))}));return r};const Rs=({vertices_coords:e,vertices_vertices:t,faces_vertices:n})=>{if(!n){return e.map((()=>[]))}if(!t){return $s({vertices_coords:e,faces_vertices:n})}const s=Us({faces_vertices:n});return t.map(((e,t)=>e.map(((e,n,s)=>[s[(n+1)%s.length],t,e].join(" "))))).map((e=>e.map((e=>s[e]))))};const Ls=({edges_vertices:e})=>{const t={};e.map((e=>e.join(" "))).forEach(((e,n)=>{t[e]=n}));e.map((e=>`${e[1]} ${e[0]}`)).forEach(((e,n)=>{t[e]=n}));return t};const Is=({edges_vertices:e})=>{const t={};e.map((e=>e.join(" "))).forEach(((e,n)=>{t[e]=n}));return t};const Us=({faces_vertices:e})=>{const t={};e.forEach(((e,n)=>e.map(((t,n)=>[0,1,2].map((t=>(n+t)%e.length)).map((t=>e[t])).join(" "))).forEach((e=>{t[e]=n}))));return t};const Qs=({vertices_coords:e,vertices_vertices:t,vertices_edges:n,vertices_faces:s,edges_vertices:r,edges_vector:o,faces_vertices:c})=>{if(!o){o=er({vertices_coords:e,edges_vertices:r})}if(!t){t=Ns({vertices_coords:e,vertices_edges:n,vertices_faces:s,edges_vertices:r,faces_vertices:c})}const a=Is({edges_vertices:r});return t.map(((e,n)=>t[n].map((e=>{const t=a[`${n} ${e}`];const s=a[`${e} ${n}`];if(t!==undefined){return o[t]}if(s!==undefined){return re(o[s])}}))))};const Ds=({vertices_coords:e,vertices_vertices:t,edges_vertices:n,edges_vector:s})=>Qs({vertices_coords:e,vertices_vertices:t,edges_vertices:n,edges_vector:s}).map((e=>e.length===1?[x]:is(e)));const qs=({edges_vertices:e,vertices_edges:t})=>e.map(((e,n)=>{const s=t[e[0]].filter((e=>e!==n));const r=t[e[1]].filter((e=>e!==n));return s.concat(r)}));const Ws=({edges_vertices:e,faces_edges:t})=>{const n=e!==undefined?e.map((()=>[])):Array.from(Array(ps.edges({faces_edges:t}))).map((()=>[]));t.forEach(((e,t)=>{const s=[];e.forEach((e=>{s[e]=t}));s.forEach(((e,t)=>n[t].push(e)))}));return n};const Gs=({vertices_coords:e,edges_vertices:t,edges_vector:n,faces_vertices:s,faces_edges:r,faces_center:o})=>{if(!t||!s&&!r){return Ws({faces_edges:r})}if(!s){s=rr({edges_vertices:t,faces_edges:r})}if(!r){r=or({edges_vertices:t,faces_vertices:s})}if(!n){n=er({vertices_coords:e,edges_vertices:t})}const c=t.map((t=>e[t[0]]));if(!o){o=lr({vertices_coords:e,faces_vertices:s})}const a=t.map((()=>[]));r.forEach(((e,t)=>{const n=[];e.forEach((e=>{n[e]=t}));n.forEach(((e,t)=>a[t].push(e)))}));a.forEach(((e,t)=>{const s=e.map((e=>o[e])).map((e=>U(e,c[t]))).map((e=>K(e,n[t])));e.sort(((e,t)=>s[e]-s[t]))}));return a};const Hs={M:-180,m:-180,V:180,v:180};const Js=({edges_foldAngle:e})=>e.map((e=>{if(e===0){return"F"}return e<0?"M":"V"}));const Zs=({edges_vertices:e,edges_foldAngle:t,edges_faces:n,faces_vertices:s,faces_edges:r})=>{if(e&&!n){if(!r&&s){r=or({edges_vertices:e,faces_vertices:s})}if(r){n=Ws({edges_vertices:e,faces_edges:r})}}if(t){return n?t.map(((e,t)=>{if(n[t].length<2){return"B"}if(e===0){return"F"}return e<0?"M":"V"})):Js({edges_foldAngle:t})}return e.map((()=>"U"))};const Ys=({edges_assignment:e})=>e.map((e=>Hs[e]||0));const Xs=({vertices_coords:e,edges_vertices:t,edges_faces:s,edges_assignment:r,faces_vertices:o,faces_edges:c,faces_normal:a,faces_center:i})=>{if(!s){if(!c){c=or({edges_vertices:t,faces_vertices:o})}s=Ws({edges_vertices:t,faces_edges:c})}if(!a){a=Fs({vertices_coords:e,faces_vertices:o})}if(!i){i=lr({vertices_coords:e,faces_vertices:o})}return s.map(((e,t)=>{if(e.length>2){throw new Error(n.manifold)}if(e.length<2){return 0}const s=a[e[0]];const o=a[e[1]];const c=V(I(i[e[1]],i[e[0]]));let f=Math.sign(D(s,c));if(f===0){if(r&&r[t]){if(r[t]==="F"||r[t]==="F"){f=0}if(r[t]==="M"||r[t]==="m"){f=-1}if(r[t]==="V"||r[t]==="v"){f=1}}else{throw new Error(n.flatFoldAngles)}}return Math.acos(D(s,o))*(180/Math.PI)*f}))};const Ks=({vertices_coords:e,edges_vertices:t})=>t.map((t=>t.map((t=>e[t]))));const er=({vertices_coords:e,edges_vertices:t})=>Ks({vertices_coords:e,edges_vertices:t}).map((e=>I(e[1],e[0])));const tr=({vertices_coords:e,edges_vertices:t})=>er({vertices_coords:e,edges_vertices:t}).map((e=>O(e)));const nr=({vertices_coords:e,edges_vertices:t,edges_coords:n},s=0)=>{if(!n){n=Ks({vertices_coords:e,edges_vertices:t})}return n.map((e=>ct(e,s)))};const sr=({vertices_coords:e,vertices_vertices:t,vertices_edges:n,vertices_sectors:s,edges_vertices:r,edges_vector:o})=>{if(!t){t=Ns({vertices_coords:e,edges_vertices:r,vertices_edges:n})}if(!s){s=Ds({vertices_coords:e,vertices_vertices:t,edges_vertices:r,edges_vector:o})}const c=Ls({edges_vertices:r});const a=hs(_s({vertices_vertices:t,vertices_sectors:s})).map((e=>({...e,edges:e.edges.map((e=>c[e]))})));return{faces_vertices:a.map((e=>e.vertices)),faces_edges:a.map((e=>e.edges)),faces_sectors:a.map((e=>e.angles))}};const rr=({edges_vertices:e,faces_edges:t})=>t.map((t=>t.map((t=>e[t])).map(((e,t,n)=>{const s=n[(t+1)%n.length];return e[0]===s[0]||e[0]===s[1]?e[1]:e[0]}))));const or=({edges_vertices:e,faces_vertices:t})=>{const n=Ls({edges_vertices:e});return t.map((e=>e.map(((e,t,n)=>[e,n[(t+1)%n.length]].join(" "))))).map((e=>e.map((e=>n[e]))))};const cr=({faces_vertices:e})=>{const t=e.map((()=>[]));const n={};e.forEach(((e,t)=>e.forEach(((s,r,o)=>{let c=o[(r+1)%e.length];if(c<s){[s,c]=[c,s]}const a=`${s} ${c}`;if(n[a]===undefined){n[a]={}}n[a][t]=true}))));Object.values(n).map((e=>Object.keys(e))).filter((e=>e.length>1)).forEach((e=>{t[e[0]].push(parseInt(e[1],10));t[e[1]].push(parseInt(e[0],10))}));return t};const ar=({vertices_coords:e,faces_vertices:t},n)=>t.map((t=>t.map((t=>e[t])))).map((e=>nt(e,n)));const ir=({vertices_coords:e,faces_vertices:t})=>t.map((t=>t.map((t=>e[t]))));const fr=({vertices_coords:e,faces_vertices:t})=>t.map((t=>t.map((t=>e[t])))).map((e=>rt(e)));const lr=({vertices_coords:e,faces_vertices:t})=>{const n=e.filter((()=>true)).shift();if(!n){return t.map((()=>[]))}const s=n.length;return t.map((t=>t.map((t=>e[t])).reduce(((e,t)=>$(e,t)),Array(s).fill(0)).map((e=>e/t.length))))};const dr=Object.freeze({__proto__:null,makeEdgesAssignment:Zs,makeEdgesAssignmentSimple:Js,makeEdgesBoundingBox:nr,makeEdgesCoords:Ks,makeEdgesEdges:qs,makeEdgesFaces:Gs,makeEdgesFacesUnsorted:Ws,makeEdgesFoldAngle:Ys,makeEdgesFoldAngleFromFaces:Xs,makeEdgesLength:tr,makeEdgesVector:er,makeFacesCenter2D:fr,makeFacesConvexCenter:lr,makeFacesEdgesFromVertices:or,makeFacesFaces:cr,makeFacesPolygon:ar,makeFacesPolygonQuick:ir,makeFacesVerticesFromEdges:rr,makePlanarFaces:sr,makeVerticesEdges:Ps,makeVerticesEdgesUnsorted:Vs,makeVerticesFaces:Rs,makeVerticesFacesUnsorted:$s,makeVerticesSectors:Ds,makeVerticesToEdge:Is,makeVerticesToEdgeBidirectional:Ls,makeVerticesToFace:Us,makeVerticesVertices:Ns,makeVerticesVertices2D:Ts,makeVerticesVerticesFromFaces:zs,makeVerticesVerticesUnsorted:Bs,makeVerticesVerticesVector:Qs});const ur=({edges_vertices:e})=>{if(!e){return[]}const t=[];const n={};for(let s=0;s<e.length;s+=1){const r=`${e[s][0]} ${e[s][1]}`;const o=`${e[s][1]} ${e[s][0]}`;if(n[r]!==undefined){t[s]=n[r]}else{n[r]=s;n[o]=s}}return t};const mr=(e,t)=>{if(!t){t=ur(e)}const n=Object.keys(t).map((e=>parseInt(e,10)));const s=Cn(e,"edges",t);if(n.length){if(e.vertices_edges||e.vertices_vertices||e.vertices_faces){e.vertices_edges=Vs(e);e.vertices_vertices=Ns(e);e.vertices_edges=Ps(e);e.vertices_faces=Rs(e)}}return{map:s,remove:n}};const pr=Object.freeze({__proto__:null,duplicateEdges:ur,removeDuplicateEdges:mr});const gr=({edges_vertices:e})=>{if(!e){return[]}const t=[];for(let n=0;n<e.length;n+=1){if(e[n][0]===e[n][1]){t.push(n)}}return t};const _r=(e,t,n)=>{const s={};n.forEach((e=>{s[e]=true}));Pt(e,t).forEach((t=>e[t].forEach(((n,r)=>{for(let o=n.length-1;o>=0;o-=1){if(s[n[o]]===true){e[t][r].splice(o,1)}}}))))};const hr=(e,t)=>{if(!t){t=gr(e)}if(t.length){_r(e,"edges",t)}return{map:Nn(e,"edges",t),remove:t}};const vr=Object.freeze({__proto__:null,circularEdges:gr,removeCircularEdges:hr});const br=(e,t)=>{const n=Pn(e,t);const s=hr(e);const r=mr(e);const o=Ln(e);const c=An(n.map);const a=o.remove.map((e=>c[e]));const i=An(s.map);const f=r.remove.map((e=>i[e]));return{vertices:{map:bn(n.map,o.map),remove:n.remove.concat(a)},edges:{map:bn(s.map,r.map),remove:s.remove.concat(f)}}};const yr=({vertices_coords:e,edges_vertices:t,edges_assignment:n,edges_foldAngle:s,faces_vertices:r,faces_edges:o})=>{if(!r){return undefined}let c=0;let a=0;const i={faces_vertices:r.map((e=>e.map((()=>a++))))};if(!e){return i}i.vertices_coords=structuredClone(r.flatMap((t=>t.map((t=>e[t])))));if(!t){return i}if(!o){o=or({edges_vertices:t,faces_vertices:r})}i.edges_vertices=o.flatMap((e=>e.map(((e,t,n)=>t===n.length-1?[c,++c-n.length]:[c,++c]))));const f=o.flatMap((e=>e));if(n){i.edges_assignment=structuredClone(f.map((e=>n[e])))}if(s){i.edges_foldAngle=structuredClone(f.map((e=>s[e])))}return i};const Er=({vertices_coords:e,edges_vertices:t,edges_assignment:n,edges_foldAngle:s})=>{if(!t){return undefined}let r=0;const o={edges_vertices:t.map((e=>e.map((()=>r++))))};if(n){o.edges_assignment=n}if(s){o.edges_foldAngle=s}if(e){o.vertices_coords=structuredClone(t.flatMap((t=>t.map((t=>e[t])))))}return o};const Mr=Object.freeze({__proto__:null,explodeEdges:Er,explodeFaces:yr});const Ar=e=>e;const xr=e=>e<-E?0:e;const wr=e=>{if(e<-E){return 0}if(e>1+E){return 1}return e};const kr=(e,t,n,s=E)=>{const r=[[e,t],[t,n]].map((e=>I(e[1],e[0]))).map((e=>V(e)));return it(1,Math.abs(D(...r)),s)};const Or=(e,t,n,s=false,r=E)=>{const o=[e,n].map((e=>lt(t,e,r))).reduce(((e,t)=>e||t),false);if(o){return s}const c=[[e,t],[t,n]].map((e=>I(e[1],e[0]))).map((e=>V(e)));return it(1,D(...c),E)};const jr=(e,t,n)=>{const s=X(e.vector,t.vector,n);const r=X(e.origin,t.origin,n);return{vector:s,origin:r}};const Fr=(e,t,n)=>{const s=D(e.vector,t.vector)<0;const r=e.vector;const o=s?re(t.vector):t.vector;const c=Array.from(Array(n-1)).map(((s,r)=>X(e.origin,t.origin,(r+1)/n)));const a=Array.from(Array(n-1)).map(((e,t)=>X(r,o,(t+1)/n)));const i=a.map(((e,t)=>({vector:e,origin:[...c[t]]})));const f=[i,i];f[s?0:1]=[];return f};const Sr=(e,t,n,s=E)=>{const r=K(e.vector,t.vector);const o=K(U(t.origin,e.origin),t.vector);const c=o/r;const a=[e.vector,t.vector].map((e=>V(e)));const i=Math.abs(K(...a))<s;if(i){return Fr(e,t,n)}const f=r>-s?[[e.vector,t.vector],[re(t.vector),e.vector]]:[[t.vector,e.vector],[re(e.vector),t.vector]];const l=f.map((e=>rs(e[0],e[1],n)));const d=R(e.origin,N(e.vector,c));const u=Array.from(Array(n-1)).map((()=>d));return l.map((e=>e.map(((e,t)=>({vector:e,origin:[...u[t]]})))))};const Cr=(e,t,n=E)=>{const s=Sr(e,t,2,n).map((e=>e[0]));s.forEach(((e,t)=>{if(e===undefined){delete s[t]}}));return s};const Vr=Object.freeze({__proto__:null,bisectLines2:Cr,clampLine:Ar,clampRay:xr,clampSegment:wr,collinearBetween:Or,isCollinear:kr,lerpLines:jr,pleat:Sr});const Pr=(e,t)=>{const n=gn(e,(e=>ne(e,t)));return n===undefined?undefined:e[n]};const Tr=(e,t)=>{const n=gn(e,(e=>te(e,t)));return n===undefined?undefined:e[n]};const zr=({vector:e,origin:t},n,s=Ar,r=E)=>{t=de(e.length,t);n=de(e.length,n);const o=C(e);const c=I(n,t);const a=D(e,c);const i=a/o;const f=s(i,r);return $(t,z(e,f))};const Nr=(e,t)=>e.map(((e,t,n)=>I(n[(t+1)%n.length],e))).map(((t,n)=>({vector:t,origin:e[n]}))).map((e=>zr(e,t,wr))).map(((e,n)=>({point:e,edge:n,distance:te(e,t)}))).sort(((e,t)=>e.distance-t.distance)).shift();const Br=({radius:e,origin:t},n)=>$(t,z(V(I(n,t)),e));const $r=Object.freeze({__proto__:null,nearestPoint:Tr,nearestPoint2:Pr,nearestPointOnCircle:Br,nearestPointOnLine:zr,nearestPointOnPolygon:Nr});const Rr=({vector:e,origin:t},n,s=mt,r=E)=>{const o=U(n,t);const c=C(e);const a=Math.sqrt(c);if(a<r){return false}const i=K(o,e.map((e=>e/a)));const f=q(o,e)/c;return Math.abs(i)<r&&s(f,r/a)};const Lr=(e,t,n=mt,s=mt,r=E)=>{const o=K(e.vector,t.vector);const c=-o;const a=U(t.origin,e.origin);const i=[-a[0],-a[1]];if(Math.abs(o)<r){if(Math.abs(K(a,e.vector))>r){return false}const o=i;const c=R(o,e.vector);const f=H(o,c);const l=a;const d=R(l,t.vector);const u=H(l,d);const m=q(e.vector,e.vector);const p=q(t.vector,t.vector);const g=q(o,t.vector)/p;const _=q(c,t.vector)/p;const h=q(f,t.vector)/p;const v=q(l,e.vector)/m;const b=q(d,e.vector)/m;const y=q(u,e.vector)/m;return n(v,r)||n(b,r)||s(g,r)||s(_,r)||n(y,r)||s(h,r)}const f=K(a,t.vector)/o;const l=K(i,e.vector)/c;return n(f,r/j(e.vector))&&s(l,r/j(t.vector))};const Ir=({radius:e,origin:t},n,s=ut,r=E)=>s(e-ne(t,n),r);const Ur=(e,t,n=ut,s=E)=>e.map(((e,t,n)=>[e,n[(t+1)%n.length]])).map((e=>K(P(U(e[1],e[0])),U(t,e[0])))).map((e=>n(e,s))).map(((e,t,n)=>e===n[0])).reduce(((e,t)=>e&&t),true);const Qr=(e,t,n=ut,s=E)=>{const r=e.map(((e,t,n)=>[e,n[(t+1)%n.length]])).map((([e,n])=>[U(n,e),U(t,e)])).map((([e,t])=>K(e,t)));const o=Math.sign(r.reduce(((e,t)=>e+t),0));const c=r.map((e=>e*o)).map((e=>n(e,s))).map(((e,t,n)=>e===n[0])).reduce(((e,t)=>e&&t),true);return{overlap:c,t:r}};const Dr=(e,t,n=E)=>{for(let s=0;s<2;s+=1){const r=s===0?e:t;const o=s===0?t:e;for(let e=0;e<r.length;e+=1){const t=r[e];const s=oe(U(r[(e+1)%r.length],r[e]));const c=o.map((e=>U(e,t))).map((e=>q(s,e)));const a=r[(e+2)%r.length];const i=q(s,U(a,t));const f=i>0;const l=c.map((e=>f?e<n:e>-n)).reduce(((e,t)=>e&&t),true);if(l){return false}}}return true};const qr=(e,t,n=E)=>{const s=Math.min(e.min.length,t.min.length);for(let r=0;r<s;r+=1){if(e.min[r]>t.max[r]+n||e.max[r]<t.min[r]-n){return false}}return true};const Wr=Object.freeze({__proto__:null,overlapBoundingBoxes:qr,overlapCirclePoint:Ir,overlapConvexPolygonPoint:Ur,overlapConvexPolygonPointNew:Qr,overlapConvexPolygons:Dr,overlapLineLine:Lr,overlapLinePoint:Rr});const Gr=({vertices_coords:e},t)=>{if(!e){return undefined}const n=Ut({vertices_coords:e});if(n===undefined){return undefined}const s=de(n,t);const r=e.map(((e,t)=>({d:te(s,e),i:t}))).sort(((e,t)=>e.d-t.d)).shift();return r?r.i:undefined};const Hr=({vertices_coords:e,edges_vertices:t},n)=>{if(!e||!t){return undefined}const s=t.map((t=>t.map((t=>e[t])))).map((e=>zr({vector:I(e[1],e[0]),origin:e[0]},n,wr)));return gn(s,(e=>te(e,n)))};const Jr=({vertices_coords:e,faces_vertices:t},n,s=ut)=>!e||!t?[]:t.map(((t,n)=>({face:t.map((t=>e[t])),i:n}))).filter((e=>Ur(e.face,n,s))).map((e=>e.i));const Zr=({vertices_coords:e,faces_vertices:t},n)=>{const s=Jr({vertices_coords:e,faces_vertices:t},n);return s.length?s.shift():undefined};const Yr=(e,t)=>{const n=Zr(e,t);if(n!==undefined){return n}if(e.edges_faces){const n=Hr(e,t);if(n===undefined){return undefined}const s=e.edges_faces[n];if(s.length===1){return s[0]}if(s.length>1){const n=lr({vertices_coords:e.vertices_coords,faces_vertices:s.map((t=>e.faces_vertices[t]))});const r=n.map((e=>te(e,t)));let o=0;for(let e=0;e<r.length;e+=1){if(r[e]<r[o]){o=e}}return s[o]}}return undefined};const Xr=(e,...t)=>{const n={vertices:Gr,edges:Hr,faces:Yr};const s=l(...t);const r=Object.create(null);["vertices","edges","faces"].forEach((t=>{Object.defineProperty(r,yt[t],{enumerable:true,get:()=>n[t](e,s)});Vt(e,t).forEach((n=>Object.defineProperty(r,n,{enumerable:true,get:()=>e[n][r[yt[t]]]})))}));return r};const Kr=Object.freeze({__proto__:null,faceContainingPoint:Zr,facesContainingPoint:Jr,nearest:Xr,nearestEdge:Hr,nearestFace:Yr,nearestVertex:Gr});const eo=(e,t,n=mt,s=mt,r=E)=>{const o=K(P(e.vector),P(t.vector));if(Math.abs(o)<r){return{a:undefined,b:undefined,point:undefined}}const c=K(e.vector,t.vector);const a=-c;const i=[t.origin[0]-e.origin[0],t.origin[1]-e.origin[1]];const f=[-i[0],-i[1]];const l=K(i,t.vector)/c;const d=K(f,e.vector)/a;if(n(l,r/j(e.vector))&&s(d,r/j(t.vector))){return{a:l,b:d,point:R(e.origin,N(e.vector,l))}}return{a:undefined,b:undefined,point:undefined}};const to=(e,t,n=dt,s=mt,r=E)=>{const o=t.vector[0]**2+t.vector[1]**2;const c=Math.sqrt(o);const a=c===0?t.vector:t.vector.map((e=>e/c));const i=oe(a);const f=U(t.origin,e.origin);const l=K(f,a);if(Math.abs(l)>e.radius+r){return undefined}const d=Math.sqrt(e.radius**2-l**2);const u=(t,n)=>e.origin[n]-i[n]*l+a[n]*t;const m=Math.abs(e.radius-Math.abs(l))<r?[d].map((e=>[e,e].map(u))):[-d,d].map((e=>[e,e].map(u)));const p=m.map((e=>e.map(((e,n)=>e-t.origin[n])))).map((e=>e[0]*t.vector[0]+t.vector[1]*e[1])).map((e=>e/o));return m.filter(((e,t)=>s(p[t],r)))};const no=e=>{if(e>=1)return 0;if(e<=-1)return Math.PI;return Math.acos(e)};const so=(e,t,n)=>{const s=t[0]-e[0];const r=t[1]-e[1];const o=s*Math.cos(n)+r*Math.sin(n);const c=r*Math.cos(n)-s*Math.sin(n);return[e[0]+o,e[1]+c]};const ro=(e,t,n=dt,s=dt,r=E)=>{const o=e.radius<t.radius?e.radius:t.radius;const c=e.radius<t.radius?t.radius:e.radius;const a=e.radius<t.radius?e.origin:t.origin;const i=e.radius<t.radius?t.origin:e.origin;const f=[a[0]-i[0],a[1]-i[1]];const l=Math.sqrt(f[0]**2+f[1]**2);if(l<r){return undefined}const d=f.map(((e,t)=>e/l*c+i[t]));if(Math.abs(c+o-l)<r||Math.abs(c-(o+l))<r){return[d]}if(l+o<c||c+o<l){return undefined}const u=no((o*o-l*l-c*c)/(-2*l*c));const m=so(i,d,+u);const p=so(i,d,-u);return[m,p]};const oo=e=>{for(let t=1;t<e.length;t+=1){if(!lt(e[0],e[t])){return[e[0],e[t]]}}return undefined};const co=(e,{vector:t,origin:n},s=ht,r=mt,o=E)=>{const c=e.map(((e,t,n)=>[e,n[(t+1)%n.length]])).map((e=>eo({vector:U(e[1],e[0]),origin:e[0]},{vector:t,origin:n},s,r,o).point)).filter((e=>e!==undefined));switch(c.length){case 0:return undefined;case 1:return[c];default:return oo(c)||[c[0]]}};const ao=(e,{vector:t,origin:n},s=ht,r=pt,o=E)=>{const c=co(e,{vector:t,origin:n},s,r,o);let a;switch(r){case _t:a=gt;break;case vt:a=ht;break;default:return c}const i=co(e,{vector:t,origin:n},ht,a,o);if(i===undefined){return undefined}const f=oo(i);if(f===undefined){switch(r){case _t:return Ur(e,n,ut,.001)?i:undefined;case vt:return Ur(e,R(n,t),ut,.001)||Ur(e,n,ut,.001)?i:undefined;case pt:return undefined;default:return undefined}}return Ur(e,H(...f),ut,.001)?f:c};const io=Object.freeze({__proto__:null,intersectCircleCircle:ro,intersectCircleLine:to,intersectConvexPolygonLine:ao,intersectLineLine:eo});const fo=(e,t)=>{if(!e.length){return[]}const n=e.map(((e,t)=>t));const s=[[n.shift()]];n.forEach((n=>{const r=s[s.length-1];const o=r[r.length-1];if(t(e[o],e[n])){r.push(n)}else{s.push([n])}}));return s};const lo=(e,t=E)=>{const n=e.map(((e,t)=>({v:e,i:t}))).sort(((e,t)=>e.v-t.v)).map((e=>e.i));const s=n.map((t=>e[t]));const r=(e,n)=>Math.abs(e-n)<t;return fo(s,r).map((e=>e.map((e=>n[e]))))};const uo=(e,t=E)=>{const n=e.map(V);const s=[[0]];e:for(let e=1;e<n.length;e+=1){for(let r=0;r<s.length;r+=1){if(ie(n[e],n[s[r][0]],t)){s[r].push(e);continue e}}s.push([e])}return s};const mo=Object.freeze({__proto__:null,clusterParallelVectors:uo,clusterScalars:lo,clusterSortedGeneric:fo});const po=({vertices_coords:e,faces_vertices:t},n=0)=>t.map((t=>[t.reduce(((t,s)=>e[t][n]<e[s][n]?t:s)),t.reduce(((t,s)=>e[t][n]>e[s][n]?t:s))]));const go=({vertices_coords:e},t=0,n=E)=>lo(e.map((e=>e[t])),n).map((n=>({vertices:n,t:n.reduce(((n,s)=>n+e[s][t]),0)/n.length})));const _o=(e,{edges_vertices:t,vertices_edges:n},s=E)=>{if(!n){n=Vs({edges_vertices:t})}const r=t.map((t=>t.map((t=>e[t]))));const o=r.map((e=>it(...e,s)));const c=r.map((([e,t])=>Math.sign(e-t)));const a=t.map((([e,t],n)=>o[n]?{[e]:0,[t]:0}:{[e]:c[n],[t]:-c[n]}));return lo(e,s).map((e=>e.filter((e=>n[e])))).filter((e=>e.length)).map((t=>({vertices:t,t:t.reduce(((t,n)=>t+e[n]),0)/t.length,start:an(t.flatMap((e=>n[e].filter((t=>a[t][e]<=0))))),end:an(t.flatMap((e=>n[e].filter((t=>a[t][e]>=0)))))})))};const ho=({vertices_coords:e,edges_vertices:t,vertices_edges:n},s=0,r=E)=>_o(e.map((e=>e[s])),{edges_vertices:t,vertices_edges:n},r);const vo=({vertices_coords:e,faces_vertices:t},n=0,s=E)=>_o(e.map((e=>e[n])),{edges_vertices:po({vertices_coords:e,faces_vertices:t},n)},s);const bo=({vertices_coords:e,edges_vertices:t,faces_vertices:n},s=0,r=E)=>{const o=e.map((e=>e[s]));const c=po({vertices_coords:e,faces_vertices:n},s);const a=Vs({edges_vertices:t});const i=Vs({edges_vertices:c});const f=t.map((e=>e.map((e=>o[e]))));const l=c.map((e=>e.map((e=>o[e]))));const d=f.map((e=>it(...e,r)));const u=l.map((e=>it(...e,r)));const m=f.map((([e,t])=>Math.sign(e-t)));const p=l.map((([e,t])=>Math.sign(e-t)));const g=t.map((([e,t],n)=>d[n]?{[e]:0,[t]:0}:{[e]:m[n],[t]:-m[n]}));const _=n.map((([e,t],n)=>u[n]?{[e]:0,[t]:0}:{[e]:p[n],[t]:-p[n]}));return lo(o,r).map((e=>({vertices:e,t:e.reduce(((e,t)=>e+o[t]),0)/e.length,edges:{start:an(e.filter((e=>a[e]!==undefined)).flatMap((e=>a[e].filter((t=>g[t][e]<=0))))),end:an(e.filter((e=>a[e]!==undefined)).flatMap((e=>a[e].filter((t=>g[t][e]>=0)))))},faces:{start:an(e.filter((e=>i[e]!==undefined)).flatMap((e=>i[e].filter((t=>_[t][e]<=0))))),end:an(e.filter((e=>i[e]!==undefined)).flatMap((e=>i[e].filter((t=>_[t][e]>=0)))))}})))};const yo=Object.freeze({__proto__:null,sweep:bo,sweepEdges:ho,sweepFaces:vo,sweepValues:_o,sweepVertices:go});const Eo=({edges_vertices:e},t,n)=>n.map((n=>e[n][0]===t?e[n][1]:e[n][0]));const Mo=Object.freeze({__proto__:null,getOtherVerticesInEdges:Eo});const Ao=({vertices_coords:e,vertices_edges:t,edges_vertices:n},s,r=E)=>{if(!e||!n){return false}if(!t){t=Vs({edges_vertices:n})}const o=t[s];if(o===undefined||o.length!==2){return false}const c=Eo({edges_vertices:n},s,o);const a=[c[0],s,c[1]].map((t=>e[t]));return Or(...a,false,r)};const xo=Object.freeze({__proto__:null,isVertexCollinear:Ao});const wo=({vertices_coords:e,edges_vertices:t},n)=>Dn(e[t[n][0]],e[t[n][1]]);const ko=({vertices_coords:e,edges_vertices:t},n=E)=>{if(!e||!t||!t.length){return{edges_line:[],lines:[]}}const s=Ks({vertices_coords:e,edges_vertices:t});const r=s.map((e=>I(e[1],e[0]))).map(V);const o=r.map(((e,t)=>({vector:e,origin:s[t][0]})));const c=o.map((e=>zr(e,[0,0,0],Ar))).map((e=>O(e)));const a=lo(c,n);const i=a.map((e=>e.map((e=>r[e])))).map((e=>uo(e,.001))).map(((e,t)=>e.map((e=>e.map((e=>a[t][e]))))));const f=i.map((s=>s.map((s=>{if(Math.abs(c[s[0]])<n){return[s]}const r=o[s[0]].vector;const a=s.map((n=>e[t[n][0]])).map((e=>bs(e,r)));const i=xs(a,r);const f=(e,t)=>lt(a[e],a[t],n);const l=e=>e.map((e=>i[e])).map((e=>s[e]));const d=fo(i,f);if(d.length===1){return d.map(l)}const u=d[0][0];const m=d[d.length-1];const p=m[m.length-1];const g=[u,p].map((e=>i[e]));if(f(...g)){const e=d.pop();d[0]=e.concat(d[0])}return d.map(l)}))));const l=f.flatMap((e=>e.flatMap((e=>e))));const d=kn(l);const u=l.map((e=>e.flatMap((e=>t[e])))).map(an);const m=l.map((e=>r[e[0]]));const p=u.map(((t,n)=>t.map((t=>D(m[n],e[t])))));const g=p.map(((e,t)=>u[t][gn(e)]));const _=p.map(((e,t)=>u[t][_n(e)]));const h=u.map(((t,n)=>I(e[_[n]],e[g[n]])));const v=g.map((t=>e[t]));const b=h.map(((e,t)=>({vector:e,origin:v[t]})));return{lines:b,edges_line:d}};const Oo=Object.freeze({__proto__:null,edgeToLine:wo,getEdgesLine:ko});const jo=(e,t=E)=>{const n=e.map((()=>[]));for(let s=0;s<e.length-1;s+=1){for(let r=s+1;r<e.length;r+=1){const{a:o,b:c,point:a}=eo(e[s],e[r],ht,ht,t);if(a===undefined){continue}n[s].push(o);n[r].push(c)}}return n};const Fo=({edges_vertices:e,vertices_edges:t},n)=>{const s=t[n].sort(((e,t)=>e-t));const r=s.flatMap((t=>e[t])).filter((e=>e!==n)).slice(0,2);e[s[0]]=r;e[s[1]]=undefined;r.forEach((e=>{const n=t[e].indexOf(s[1]);if(n===-1){return}t[e][n]=s[0]}));return s[1]};const So=({vertices_coords:e,edges_vertices:t,edges_assignment:n,edges_foldAngle:s},r=E)=>{const{lines:o,edges_line:c}=ko({vertices_coords:e,edges_vertices:t},r);const a=o.map((({vector:e})=>S(e)));const i=wn(c);const f=t.map(((t,n)=>t.map((t=>e[t])).map((e=>q(U(e,o[c[n]].origin),o[c[n]].vector)))));const l=i.map((e=>e.flatMap((e=>f[e])))).map((e=>dn(e,r)));const d=jo(o,r).map((e=>dn(e,r))).map(((e,t)=>e.map((e=>e*a[t])))).map(((e,t)=>pn(e,l[t],r)));const u=i.map((e=>e.flatMap((e=>f[e]))));const m=i.map((e=>An(e).map((e=>[e*2,e*2+1]))));const p=i.map(((e,t)=>_o(u[t],{edges_vertices:m[t]},r)));const g=p.map((e=>e.map((e=>e.t))));const _=p.map((e=>{const t={};const n=e.map((e=>{e.start.forEach((e=>{t[e]=true}));e.end.forEach((e=>{delete t[e]}));return Object.keys(t).map((e=>parseInt(e,10)))}));n.pop();return n}));d.forEach(((e,t)=>{const n=g[t];const s=_[t];let r=0;let o=0;while(r<e.length&&o<n.length-1){if(e[r]<=n[o]){throw new Error("bad algorithm")}if(e[r]>n[o+1]){o+=1;continue}n.splice(o+1,0,e[r]);s.splice(o+1,0,s[o]);r+=1}}));const h=g.flatMap(((e,t)=>e.map((e=>e/a[t])).map((e=>R(o[t].origin,N(o[t].vector,e))))));let v=0;const b=_.map((e=>{const t=e.map((()=>[v,++v]));v+=1;return t})).flatMap(((e,t)=>e.filter(((e,n)=>_[t][n].length))));const y={vertices_coords:h,edges_vertices:b};if(n||s){const e=_.flatMap((e=>e.filter((e=>e.length))));if(n){y.edges_assignment=e.map((e=>n[e[0]]))}if(s){y.edges_foldAngle=e.map((e=>s[e[0]]))}}Ln(y,Bn(y));Pn(y,r);hr(y);y.vertices_edges=Vs(y);const M=y.vertices_edges.map(((e,t)=>e.length===2?t:undefined)).filter((e=>e!==undefined)).filter((e=>Ao(y,e,r))).reverse();const A=M.map((e=>Fo(y,e)));Nn(y,"edges",A);Nn(y,"vertices",M);const x=ur(y);if(x.length){mr(y,x)}if(gr(y).length){console.error("planarize: found circular edges")}delete y.vertices_edges;return y};const Co=e=>{const t=e.edges_vertices.length;if(!e.edges_assignment){e.edges_assignment=[]}if(!e.edges_foldAngle){e.edges_foldAngle=[]}if(e.edges_assignment.length>e.edges_foldAngle.length){for(let t=e.edges_foldAngle.length;t<e.edges_assignment.length;t+=1){e.edges_foldAngle[t]=Ot(e.edges_assignment[t])}}if(e.edges_foldAngle.length>e.edges_assignment.length){for(let t=e.edges_assignment.length;t<e.edges_foldAngle.length;t+=1){e.edges_assignment[t]=jt(e.edges_foldAngle[t])}}for(let n=e.edges_assignment.length;n<t;n+=1){e.edges_assignment[n]="U";e.edges_foldAngle[n]=0}};const Vo=(e,t)=>{if(t===undefined&&!e.faces_vertices&&!e.faces_edges&&e.vertices_coords&&It(e)===2){t=true}if(t&&e.vertices_coords){const t=sr(e);e.faces_vertices=t.faces_vertices;e.faces_edges=t.faces_edges;return}if(e.faces_vertices&&e.faces_edges){return}if(e.faces_vertices&&!e.faces_edges){e.faces_edges=or(e)}else if(e.faces_edges&&!e.faces_vertices){e.faces_vertices=rr(e)}else{e.faces_vertices=[];e.faces_edges=[]}};const Po=(e,t)=>{if(typeof e!=="object"){return e}if(!e.edges_vertices){return e}e.vertices_edges=Vs(e);e.vertices_vertices=Ns(e);e.vertices_edges=Ps(e);Co(e);Vo(e,t);e.vertices_faces=Rs(e);e.edges_faces=Ws(e);e.faces_faces=cr(e);return e};const To=({vertices_vertices:e},t,n)=>{if(!e){return}e[t]=[...n];n.forEach(((n,s,r)=>{const o=r[(s+1)%r.length];const c=e[n].indexOf(o);e[n][c]=t}))};const zo=({vertices_coords:e,vertices_vertices:t,vertices_sectors:n},s)=>{if(!n){return}n[s]=t[s].length===1?[x]:is(t[s].map((t=>U(e[t],e[s]))))};const No=({vertices_edges:e},t,n,s,r)=>{if(!e){return}e[n]=[...r];s.map((n=>e[n].indexOf(t))).forEach(((t,n)=>{e[s[n]][t]=r[n]}))};const Bo=({vertices_faces:e},t,n)=>{if(!e){return}e[t]=[...n]};const $o=({edges_faces:e},t,n)=>{if(!e){return}t.forEach((t=>{e[t]=[...n]}))};const Ro=({faces_vertices:e},t,n,s)=>{if(!e){return}s.map((t=>e[t])).forEach((e=>e.map(((e,t,s)=>{const r=(t+1)%s.length;return e===n[0]&&s[r]===n[1]||e===n[1]&&s[r]===n[0]?r:undefined})).filter((e=>e!==undefined)).sort(((e,t)=>t-e)).forEach((n=>e.splice(n,0,t)))))};const Lo=({edges_vertices:e,faces_vertices:t,faces_edges:n},s)=>{const r=Ls({edges_vertices:e});s.map((e=>t[e].map(((e,t,n)=>[e,n[(t+1)%n.length]])).map((e=>r[e.join(" ")])))).forEach(((e,t)=>{n[s[t]]=e}))};const Io=({vertices_faces:e,edges_vertices:t,edges_faces:n,faces_edges:s,faces_vertices:r},o)=>{if(n&&n[o]){return n[o]}const c=t[o];if(e!==undefined){const t=[];for(let n=0;n<e[c[0]].length;n+=1){for(let s=0;s<e[c[1]].length;s+=1){if(e[c[0]][n]===e[c[1]][s]){if(e[c[0]][n]===undefined){continue}t.push(e[c[0]][n])}}}return t}if(s){const e=[];for(let t=0;t<s.length;t+=1){for(let n=0;n<s[t].length;n+=1){if(s[t][n]===o){e.push(t)}}}return e}if(r){console.warn("todo: findAdjacentFacesToEdge")}};const Uo=(e,t,n)=>{const s=e.edges_vertices[t];const r=[{edges_vertices:[s[0],n]},{edges_vertices:[n,s[1]]}];r.forEach((n=>["edges_assignment","edges_foldAngle"].filter((n=>e[n]&&e[n][t]!==undefined)).forEach((s=>{n[s]=e[s][t]}))));return r};const Qo=(e,t,n,s=E)=>{if(e.edges_vertices.length<t){return{}}const r=e.edges_vertices[t];if(!n){n=G(...r.map((t=>e.vertices_coords[t])))}const o=r.map((t=>e.vertices_coords[t])).map((e=>te(e,n)<s));if(o[0]){return{vertex:r[0],edges:{}}}if(o[1]){return{vertex:r[1],edges:{}}}const c=e.vertices_coords.length;e.vertices_coords[c]=n;const a=[0,1].map((t=>t+e.edges_vertices.length));Uo(e,t,c).forEach(((t,n)=>Object.keys(t).forEach((s=>{e[s][a[n]]=t[s]}))));To(e,c,r);zo(e,c);No(e,t,c,r,a);const i=Io(e,t);if(i){Bo(e,c,i);$o(e,a,i);Ro(e,c,r,i);Lo(e,i)}const f=Nn(e,"edges",[t]);a.forEach(((e,t)=>{a[t]=f[a[t]]}));f.splice(-2);f[t]=a;return{vertex:c,edges:{map:f,new:a,remove:t}}};const Do=({vertices_coords:e},t,n)=>{const s=t.map((t=>e[t])).reverse();return{edges_vertices:[...t],edges_foldAngle:0,edges_assignment:"U",edges_length:te(...s),edges_vector:I(...s),edges_faces:[n,n]}};const qo=(e,t,n)=>{const s=e.edges_vertices.length;const r=Do(e,n,t);Object.keys(r).filter((t=>e[t]!==undefined)).forEach((t=>{e[t][s]=r[t]}));return s};const Wo=(e,t)=>{t.sort(((e,t)=>e-t));return[e.slice(t[1]).concat(e.slice(0,t[0]+1)),e.slice(t[0],t[1]+1)]};const Go=({edges_vertices:e,faces_vertices:t,faces_edges:n},s,r)=>{const o=r.map((e=>t[s].indexOf(e)));const c=Wo(t[s],o).map((e=>({faces_vertices:e})));if(n){const t=Ls({edges_vertices:e});c.map((e=>e.faces_vertices.map(((e,t,n)=>`${e} ${n[(t+1)%n.length]}`)).map((e=>t[e])))).forEach(((e,t)=>{c[t].faces_edges=e}))}return c};const Ho=(e,t,n)=>{const s=[0,1].map((t=>e.faces_vertices.length+t));Go(e,t,n).forEach(((t,n)=>Object.keys(t).forEach((r=>{e[r][s[n]]=t[r]}))));return s};const Jo=(e,{vertices:t,edges:n})=>{let s;const r=n.map((t=>{const n=Qo(e,s?s[t.edge]:t.edge,t.coords);s=s?yn(s,n.edges.map):n.edges.map;return n}));t.push(...r.map((e=>e.vertex)));let o;r.forEach((e=>{e.edges.remove=o?o[e.edges.remove]:e.edges.remove;const t=An(e.edges.map);o=o?Mn(o,t):t}));return{vertices:t,edges:{map:s,remove:r.map((e=>e.edges.remove))}}};const Zo=({vertices_coords:e,vertices_vertices:t,edges_vertices:n},s)=>{const r=n[s][0];const o=n[s][1];t[r]=ks({vertices_coords:e},t[r].concat(o),r);t[o]=ks({vertices_coords:e},t[o].concat(r),o)};const Yo=({edges_vertices:e,vertices_edges:t,vertices_vertices:n},s)=>{if(!t||!n){return}const r=e[s];r.map((e=>n[e])).map(((e,t)=>e.indexOf(r[(t+1)%r.length]))).forEach(((e,n)=>t[r[n]].splice(e,0,s)))};const Xo=(e,t,s)=>{const r={};s.forEach((t=>e.faces_vertices[t].forEach((e=>{if(!r[e]){r[e]=[]}r[e].push(t)}))));e.faces_vertices[t].forEach((s=>{const o=e.vertices_faces[s].indexOf(t);const c=r[s];if(o===-1||!c){throw new Error(n.convexFace)}e.vertices_faces[s].splice(o,1,...c)}))};const Ko=(e,t,s,r)=>{const o={};r.forEach((t=>e.faces_edges[t].forEach((e=>{if(!o[e]){o[e]=[]}o[e].push(t)}))));const c=[...e.faces_edges[t],s];c.forEach((s=>{const r=o[s];const c=[];for(let n=0;n<e.edges_faces[s].length;n+=1){if(e.edges_faces[s][n]===t){c.push(n)}}if(c.length===0||!r){throw new Error(n.convexFace)}c.reverse().forEach((t=>e.edges_faces[s].splice(t,1)));const a=c[c.length-1];e.edges_faces[s].splice(a,0,...r)}))};const ec=({faces_vertices:e,faces_faces:t},n,s)=>{const r=t[n];const o=s.map((t=>e[t]));const c=r.map((t=>{const n=e[t];const r=[0,0];for(let e=0;e<o.length;e+=1){let t=0;for(let s=0;s<n.length;s+=1){if(o[e].indexOf(n[s])!==-1){t+=1}}r[e]=t}if(r[0]>=2){return s[0]}if(r[1]>=2){return s[1]}}));s.forEach(((e,n,r)=>{t[e]=[r[(n+1)%s.length]]}));r.forEach(((e,s)=>{for(let r=0;r<t[e].length;r+=1){if(t[e][r]===n){t[e][r]=c[s];t[c[s]].push(e)}}}))};const tc=()=>0;const nc=(e,t)=>e<-t?-1:0;const sc=(e,t)=>e<-t?-1:e>1+t?1:0;const rc=({vertices_coords:e,faces_vertices:t},{vector:n,origin:s},r=tc,o=E)=>{const c=q(n,n);const a=P(n);const i=e.map((e=>U(e,s))).map((e=>P(e))).map((e=>K(a,e))).map((e=>Math.abs(e)<o?0:Math.sign(e)));const f=e.map((e=>U(e,s))).map((e=>q(e,n))).map((e=>e/c)).map((e=>r(e,o)));const l=t.map((e=>e.map((e=>i[e])).map(((e,t,n)=>e===n[0])).reduce(((e,t)=>e&&t),true))).map((e=>!e));const d=t.map((e=>e.map((e=>f[e])).map(((e,t,n)=>e===n[0])).reduce(((e,t)=>e&&t),true))).map((e=>!e)).map(((e,n)=>e||f[t[n][0]]===0));return t.map(((e,t)=>t)).filter((e=>l[e]&&d[e]))};const oc=(e,{vector:t,origin:n},s=E)=>rc(e,{vector:t,origin:n},tc,s);const cc=(e,{vector:t,origin:n},s=E)=>rc(e,{vector:t,origin:n},nc,s);const ac=(e,t,n=E)=>{const s=U(t[1],t[0]);const r=t[0];return rc(e,{vector:s,origin:r},sc,n)};const ic=({vertices_coords:e,edges_vertices:t,faces_vertices:n,faces_edges:s},r,{vector:o,origin:c},a=E)=>{const i=n[r].map((t=>e[t])).map((e=>Rr({vector:o,origin:c},e,(()=>true),a))).map(((e,t)=>e?t:undefined)).filter((e=>e!==undefined));const f=i.map((e=>n[r][e]));const l=i.concat(i.map((e=>e+n[r].length))).map(((e,t,n)=>n[t+1]-e===1)).reduce(((e,t)=>e||t),false);if(l){return undefined}if(f.length>1){return{vertices:f,edges:[]}}const d=s[r].map((n=>t[n].map((t=>e[t])))).map((e=>eo({vector:o,origin:c},{vector:U(e[1],e[0]),origin:e[0]},mt,vt,a).point)).map(((e,t)=>({coords:e,edge:s[r][t]}))).filter((e=>e.coords!==undefined)).filter((e=>!f.map((n=>t[e.edge].includes(n))).reduce(((e,t)=>e||t),false)));return d.length+f.length===2?{vertices:f,edges:d}:undefined};const fc=Object.freeze({__proto__:null,facesLineTypeOverlap:rc,getFacesLineOverlap:oc,getFacesRayOverlap:cc,getFacesSegmentOverlap:ac,intersectConvexFaceLine:ic});const lc=(e,t,n,s)=>{const r=ic(e,t,n,s);if(r===undefined){return undefined}const o=Jo(e,r);o.edges.new=qo(e,t,o.vertices);Zo(e,o.edges.new);Yo(e,o.edges.new);const c=Ho(e,t,o.vertices);Xo(e,t,c);Ko(e,t,o.edges.new,c);ec(e,t,c);const a=Nn(e,"faces",[t]);c.forEach(((e,t)=>{c[t]=a[c[t]]}));a.splice(-2);a[t]=c;o.faces={map:a,new:c,remove:t};return o};const dc=(e,t)=>{const n={};t.forEach((e=>{n[e]=true}));const s=[];t.forEach((t=>{s[t]=e[t].filter((e=>n[e]))}));return s};const uc=(e,t={})=>{const n={vertices:[],edges:[],faces:[],...t};const s=Object.keys(n);const r={...e};_.graph.forEach((e=>delete r[e]));delete r.file_frames;const o={};s.forEach((e=>{o[e]={}}));s.forEach((e=>n[e].forEach((t=>{o[e][t]=true}))));const c={};s.forEach((t=>{Vt(e,t).forEach((e=>{c[e]={}}));Pt(e,t).forEach((e=>{c[e]={}}))}));s.forEach((t=>{Vt(e,t).forEach((e=>{c[e].prefix=t}));Pt(e,t).forEach((e=>{c[e].suffix=t}))}));Object.keys(c).forEach((e=>{r[e]=[]}));Object.keys(c).forEach((t=>{const{prefix:s,suffix:a}=c[t];if(s&&a){n[s].forEach((n=>{r[t][n]=e[t][n].filter((e=>o[a][e]))}))}else if(s){n[s].forEach((n=>{r[t][n]=e[t][n]}))}else if(a){r[t]=e[t].map((e=>e.filter((e=>o[a][e]))))}else{r[t]=e[t]}}));return r};const mc=(e,t={})=>{const n={vertices:[],edges:[],faces:[],...t};const s={vertices:{},edges:{},faces:{}};n.vertices.forEach((e=>{s.vertices[e]=true}));n.edges.forEach((e=>{s.edges[e]=true}));n.edges.forEach((t=>e.edges_vertices[t].forEach((e=>{s.vertices[e]=true}))));n.faces.forEach((e=>{s.faces[e]=true}));n.faces.forEach((t=>e.faces_vertices[t].forEach((e=>{s.vertices[e]=true}))));e.faces_vertices.map(((e,t)=>t)).filter((t=>e.faces_vertices[t].map((e=>s.vertices[e])).reduce(((e,t)=>e&&t),true))).forEach((e=>{s.faces[e]=true}));e.edges_vertices.map(((e,t)=>t)).filter((t=>e.edges_vertices[t].map((e=>s.vertices[e])).reduce(((e,t)=>e&&t),true))).forEach((e=>{s.edges[e]=true}));return uc(e,{vertices:Object.keys(s.vertices),edges:Object.keys(s.edges),faces:Object.keys(s.faces)})};const pc=(e,t)=>{let n=[];if(e.faces_vertices){n=ln(t.flatMap((t=>e.faces_vertices[t])))}let s=[];if(e.faces_edges){s=ln(t.flatMap((t=>e.faces_edges[t])))}else if(e.edges_vertices){const t={};n.forEach((e=>{t[e]=true}));s=e.edges_vertices.map(((e,n)=>t[e[0]]&&t[e[1]]?n:undefined)).filter((e=>e!==undefined))}return uc(e,{vertices:n,edges:s,faces:t})};const gc=(e,t=[])=>{const n={vertices:[],edges:[]};t.forEach((e=>{n.vertices[e]=true}));if(e.vertices_edges){n.vertices.forEach(((t,s)=>e.vertices_edges[s].forEach((e=>{n.edges[e]=true}))))}if(e.edges_vertices){n.edges.forEach(((t,s)=>e.edges_vertices[s].forEach((e=>{n.vertices[e]=true}))))}return uc(e,{vertices:n.vertices.map(((e,t)=>e?t:undefined)).filter((e=>e!==undefined)),edges:n.edges.map(((e,t)=>e?t:undefined)).filter((e=>e!==undefined))})};const _c=Object.freeze({__proto__:null,selfRelationalArraySubset:dc,subgraph:mc,subgraphExclusive:uc,subgraphWithFaces:pc,subgraphWithVertices:gc});const hc=(e,t)=>{const n={};e.forEach((e=>{n[e]=1}));t.forEach((e=>{n[e]=n[e]===1?2:1}));return Object.keys(n).filter((e=>n[e]===2))};const vc=(e=[])=>{if(e.length<2){return[]}const t={};e[0].forEach(((e,n)=>{t[n]=true}));return Array.from(Array(e.length-1)).map(((t,n)=>e[n+1])).flatMap(((e,n)=>e.map(((e,s)=>t[s]?undefined:[0,n+1,s])).filter((e=>e!==undefined))))};const bc=e=>{const t=Tt(e).filter((e=>e!=="file"&&e!=="frame"));const n=zt(e);const s=t.map((t=>Vt(e,t)));const r=s.map((t=>t.map((t=>e[t])).filter((e=>e.constructor===Array)))).map(vc).flatMap(((e,t)=>e.map((e=>[s[t][e[0]],s[t][e[1]],e[2]])))).map((([e,t,n])=>`array indices differ ${e}, ${t} at index ${n}`));const o=hc(t,n).flatMap((n=>{const r=s[t.indexOf(n)];const o=e[r[0]];return Pt(e,n).flatMap((t=>e[t].flatMap(((e,s)=>e.map(((e,c)=>e===null||e===undefined||o[e]!==undefined?undefined:`${t}[${s}][${c}] references ${n} ${e}, missing in ${r[0]}`)).filter((e=>e!==undefined))))))}));return r.concat(o)};const yc=(e,t)=>{const n=bc(e);const s=ur(e);const r=gr(e);const o=Rn(e);const c=Vn(e,t);if(r.length!==0){n.push(`contains circular edges: ${r.join(", ")}`)}if(o.length!==0){n.push(`contains isolated vertices: ${o.join(", ")}`)}if(s.length!==0){n.push("contains duplicate edges")}if(c.length!==0){n.push(`contains duplicate vertices`)}return n};const Ec=Object.freeze({__proto__:null,validate:bc,validateComprehensive:yc});const Mc=(e,t)=>{const n={};t.forEach((e=>{n[e]=true}));const s=e.map((e=>!!n[e]));const r=[];const o=s.indexOf(false);const c={};for(let t=o+1;t<s.length;t+=1){if(s[t]&&!c[e[t]]){r.push(e[t]);c[e[t]]=true}}for(let t=0;t<o;t+=1){if(s[t]&&!c[e[t]]){r.push(e[t]);c[e[t]]=true}}return r};const Ac=Object.freeze({__proto__:null,getFaceFaceSharedVertices:Mc});const xc=(e=[],t=0)=>{if(e.length===0){return[]}const n=[];const s={};e.forEach(((e,t)=>{s[t]=true}));do{const r=t!==undefined&&s[t]?t:parseInt(Object.keys(s).shift(),10);t=undefined;const o=[];delete s[r];let c=[{index:r}];do{o.push(c);const t=c.flatMap((t=>e[t.index].filter((e=>s[e])).map((e=>({index:e,parent:t.index})))));const n={};t.forEach(((e,t)=>{if(!s[e.index]){n[t]=true}delete s[e.index]}));c=t.filter(((e,t)=>!n[t]))}while(c.length);n.push(o)}while(Object.keys(s).length);return n};const wc=(e,t)=>xc(e,t).shift();const kc=Object.freeze({__proto__:null,minimumSpanningTree:wc,minimumSpanningTrees:xc});const Oc=({vertices_coords:e,vertices_faces:t,faces_vertices:n},s)=>{if(!t){t=Rs({faces_vertices:n})}const r=t.map((e=>e.filter((e=>e!=null)).shift())).map((e=>e===undefined?ve:s[e]));return e.map(((e,t)=>be(r[t],e)))};const jc={U:true,u:true};const Fc=({vertices_coords:e,edges_vertices:t,edges_foldAngle:n,edges_assignment:s,faces_vertices:r,faces_faces:o},c=0)=>{if(!s&&n){s=Js({edges_foldAngle:n})}if(!n){if(s){n=Ys({edges_assignment:s})}else{n=Array(t.length).fill(0)}}if(!o){o=cr({faces_vertices:r})}const a=Ls({edges_vertices:t});const i=r.map((()=>Ce));xc(o,c).forEach((t=>t.slice(1).forEach((t=>t.forEach((t=>{const o=Mc(r[t.index],r[t.parent]).slice(0,2);const c=o.map((t=>e[t]));const f=o.join(" ");const l=a[f];const d=jc[s[l]]?Math.PI:n[l]*Math.PI/180;const u=Qe(d,I(...ue(c[1],c[0])),c[0]);i[t.index]=ze(i[t.parent],u)}))))));return i};const Sc=({vertices_coords:e,edges_vertices:t,edges_foldAngle:n,edges_assignment:s,faces_vertices:r,faces_faces:o},c=0)=>{if(!n){if(s){n=Ys({edges_assignment:s})}else{n=Array(t.length).fill(0)}}if(!o){o=cr({faces_vertices:r})}const a=Qt({edges_vertices:t,edges_foldAngle:n,edges_assignment:s});const i=Ls({edges_vertices:t});const f=r.map((()=>ve));xc(o,c).forEach((t=>t.slice(1).forEach((t=>t.forEach((t=>{const n=Mc(r[t.index],r[t.parent]).slice(0,2);const s=n.map((t=>e[t]));const o=n.join(" ");const c=i[o];const l=U(s[1],s[0]);const d=s[0];const u=a[c]?je(l,d):ve;f[t.index]=Ee(f[t.parent],u)}))))));return f};const Cc=Object.freeze({__proto__:null,makeFacesMatrix:Fc,makeFacesMatrix2:Sc,multiplyVerticesFacesMatrix2:Oc});const Vc=({vertices_coords:e},{vector:t,origin:n},s=E)=>{const r=V(t);const o=e=>{const t=I(e,n);const o=O(t);if(Math.abs(o)<s){return true}const c=t.map((e=>e/o));const a=Math.abs(D(c,r));return Math.abs(1-a)<s};return e.map(o).map(((e,t)=>({a:e,i:t}))).filter((e=>e.a)).map((e=>e.i))};const Pc=Object.freeze({__proto__:null,getVerticesCollinearToLine:Vc});const Tc=({vertices_coords:e,edges_vertices:t,vertices_edges:n},{vector:s,origin:r},o=E)=>{if(!n){n=Vs({edges_vertices:t})}const c=Vc({vertices_coords:e},{vector:s,origin:r},o);const a=t.map((()=>0));c.forEach((e=>n[e].forEach((e=>{a[e]+=1}))));return a.map(((e,t)=>({count:e,i:t}))).filter((e=>e.count===2)).map((e=>e.i))};const zc=({vertices_coords:e,edges_vertices:t},{min:n,max:s},r=E)=>{const o=Ks({vertices_coords:e,edges_vertices:t});const c=n.map((e=>e-r));const a=s.map((e=>e+r));return t.map(((e,t)=>t)).filter((e=>!(o[e][0][0]<c[0]&&o[e][1][0]<c[0]))).filter((e=>!(o[e][0][0]>a[0]&&o[e][1][0]>a[0]))).filter((e=>!(o[e][0][1]<c[1]&&o[e][1][1]<c[1]))).filter((e=>!(o[e][0][1]>a[1]&&o[e][1][1]>a[1])))};const Nc=({vertices_coords:e,edges_vertices:t},n,s,r=E)=>{const o=ct([n,s]);const c=U(s,n);const a={vector:c,origin:n};const i=zc({vertices_coords:e,edges_vertices:t},o,r);const f=[];i.forEach((n=>{const s=t[n].map((t=>e[t]));const o=U(s[1],s[0]);const c={vector:o,origin:s[0]};const i=eo(a,c,ht,ht,r).point;if(!i){return}f[n]=i}));return f};const Bc=({vertices_coords:e,edges_vertices:t},{vector:n,origin:s},r=E,o=ht)=>t.map((t=>{const c=t.map((t=>e[t]));const a=U(c[1],c[0]);const i={vector:a,origin:c[0]};return eo(i,{vector:n,origin:s},o,mt,r)}));const $c=Object.freeze({__proto__:null,getEdgesCollinearToLine:Tc,getEdgesLineIntersection:Bc,getEdgesRectOverlap:zc,getEdgesSegmentIntersection:Nc});const Rc=e=>e.map((e=>e[0]*e[4]-e[1]*e[3])).map((e=>e>=0));const Lc=e=>e.map((e=>e[0]*e[3]-e[1]*e[2])).map((e=>e>=0));const Ic=({vertices_coords:e,faces_vertices:t})=>t.map((t=>t.map((t=>e[t])).map(((e,t,n)=>[e,n[(t+1)%n.length]])).map((e=>(e[1][0]-e[0][0])*(e[1][1]+e[0][1]))).reduce(((e,t)=>e+t),0))).map((e=>e<0));const Uc=Object.freeze({__proto__:null,makeFacesWinding:Ic,makeFacesWindingFromMatrix:Rc,makeFacesWindingFromMatrix2:Lc});const Qc=(e,t)=>{const n=[];const s=e.map(((e,t)=>t));const r=s.filter((e=>t[e]));const o=s.filter((e=>!t[e]));o.sort(((t,n)=>e[t]-e[n])).forEach(((e,t)=>{n[e]=t}));r.sort(((t,n)=>e[n]-e[t])).forEach(((e,t)=>{n[e]=o.length+t}));return n};const Dc=(e,t,n,s=E)=>{const r=Jr(e,t);if(r.length===0){return undefined}if(r.length===1){return r[0]}return r[0]};const qc=(e,t,n,s)=>{const r=U(n,t);const o=K(e,r);return s?o>0:o<0};const Wc=(e,t)=>!e.faces_vertices[t]?[0,0]:e.faces_vertices[t].map((t=>e.vertices_coords[t])).reduce(((e,t)=>[e[0]+t[0],e[1]+t[1]]),[0,0]).map((n=>n/e.faces_vertices[t].length));const Gc={F:true,f:true,U:true,u:true};const Hc={M:"V",m:"V",V:"M",v:"M"};const Jc=e=>Hc[e]||e;const Zc=(e,t)=>({center:e.faces_center[t],matrix:e.faces_matrix2[t],winding:e.faces_winding[t],crease:e.faces_crease[t],side:e.faces_side[t],layer:e.faces_layer[t]});const Yc=(e,{vector:t,origin:n},s="V",r=E)=>{const o=Jc(s);Po(e);if(!e.faces_layer){e.faces_layer=Array(e.faces_vertices.length).fill(0)}e.faces_center=e.faces_vertices.map(((t,n)=>Wc(e,n)));if(!e.faces_matrix2){e.faces_matrix2=Sc(e,Dc(e,n,t,r))}e.faces_winding=Lc(e.faces_matrix2);e.faces_crease=e.faces_matrix2.map(Ae).map((e=>ye(e,t,n)));e.faces_side=e.faces_vertices.map(((t,n)=>qc(e.faces_crease[n].vector,e.faces_crease[n].origin,e.faces_center[n],e.faces_winding[n])));const c=Oc(e,e.faces_matrix2);const a=Tc({vertices_coords:c,edges_vertices:e.edges_vertices},{vector:t,origin:n},r).filter((t=>Gc[e.edges_assignment[t]]));a.map((t=>e.edges_faces[t].find((e=>e!=null)))).map((t=>e.faces_winding[t])).map((e=>e?s:o)).forEach(((t,n)=>{e.edges_assignment[a[n]]=t;e.edges_foldAngle[a[n]]=Ot(t)}));const i=Zc(e,0);const f=e.faces_vertices.map(((e,t)=>t)).reverse().map((t=>{const n=Zc(e,t);const c=lc(e,t,n.crease,r);if(c===undefined){return undefined}e.edges_assignment[c.edges.new]=n.winding?s:o;e.edges_foldAngle[c.edges.new]=Ot(e.edges_assignment[c.edges.new]);const a=c.faces.map[c.faces.remove];a.forEach((t=>{e.faces_center[t]=Wc(e,t);e.faces_side[t]=qc(n.crease.vector,n.crease.origin,e.faces_center[t],n.winding);e.faces_layer[t]=n.layer}));return c})).filter((e=>e!==undefined));const l=yn(...f.map((e=>e.faces.map)));const d=yn(...f.map((e=>e.edges.map)).filter((e=>e!==undefined)));const u=f.map((e=>e.faces.remove)).reverse();e.faces_layer=Qc(e.faces_layer,e.faces_side);const m=l&&l[0]&&l[0].length===2;const p=m?l[0].filter((t=>e.faces_side[t])).shift():0;let g=i.matrix;if(s!==o){g=!m&&!e.faces_side[0]?i.matrix:Ee(i.matrix,je(i.crease.vector,i.crease.origin))}e.faces_matrix2=Sc(e,p).map((e=>Ee(g,e)));delete e.faces_center;delete e.faces_winding;delete e.faces_crease;delete e.faces_side;return{faces:{map:l,remove:u},edges:{map:d}}};const Xc=e=>{const t=[];const n=(s,r)=>{if(t[s]!==undefined){return 0}t[s]=r;e[s].forEach((e=>n(e,r)));return 1};for(let t=0,s=0;t<e.length;t+=1){if(!(t in e)){continue}s+=n(t,s)}return t};const Kc=e=>{const t=[];const n=[];e.forEach(((e,s)=>e.forEach((e=>{if(s<e){n.push([s,e])}if(s===e&&!t[s]){t[s]=true;n.push([s,e])}}))));return n};const ea=Object.freeze({__proto__:null,connectedComponents:Xc,connectedComponentsPairs:Kc});const ta=e=>{const t=e.edges_vertices||[];const n=e.faces_vertices||[];const s=e.vertices_edges?e.vertices_edges:Vs({edges_vertices:t});const r=e.vertices_vertices?e.vertices_vertices:Bs({vertices_edges:s,edges_vertices:t});const o=e.vertices_faces?e.vertices_faces:$s({vertices_edges:s,faces_vertices:n});const c=wn(Xc(r));const a=c.map((e=>e.flatMap((e=>s[e])))).map(an);const i=c.map((e=>e.flatMap((e=>o[e])))).map(an);return Array.from(Array(c.length)).map(((e,t)=>({vertices:c[t]||[],edges:a[t]||[],faces:i[t]||[]})))};const na=e=>{const t=ta(e);const n=Vt(e,"vertices");const s=Vt(e,"edges");const r=Vt(e,"faces");return t.map((({vertices:t,edges:o,faces:c})=>{const a={};n.forEach((n=>{a[n]=[];t.forEach((t=>{a[n][t]=e[n][t]}))}));s.forEach((t=>{a[t]=[];o.forEach((n=>{a[t][n]=e[t][n]}))}));r.forEach((t=>{a[t]=[];c.forEach((n=>{a[t][n]=e[t][n]}))}));return a}))};const sa=Object.freeze({__proto__:null,disjointGraphs:na,disjointGraphsIndices:ta});const ra=({vertices_coords:e},t)=>ct(e,t);const oa=({edges_vertices:e,edges_assignment:t=[]})=>an(e.filter(((e,n)=>kt[t[n]])).flat());const ca=()=>({vertices:[],edges:[],polygon:[]});const aa=({vertices_coords:e,vertices_edges:t,edges_vertices:n,edges_assignment:s})=>{if(!s||!n){return ca()}if(!t){t=Vs({edges_vertices:n})}const r=s.map((e=>e==="B"||e==="b"));const o=[];const c=[];let a=-1;for(let e=0;e<r.length;e+=1){if(r[e]){a=e;break}}if(a===-1){return ca()}r[a]=false;o.push(a);c.push(n[a][0]);let i=n[a][1];while(c[0]!==i){c.push(i);a=t[i].filter((e=>r[e])).shift();if(a===undefined){return ca()}if(n[a][0]===i){[,i]=n[a]}else{[i]=n[a]}r[a]=false;o.push(a)}return{vertices:c,edges:o,polygon:e?c.map((t=>e[t])):[]}};const ia=()=>console.error("todo");const fa=({vertices_coords:e,vertices_edges:t,vertices_vertices:n,edges_vertices:s})=>{if(!n){n=Ts({vertices_coords:e,vertices_edges:t,edges_vertices:s})}const r=Ls({edges_vertices:s});const o=[];const c=[];const a={vertices:c,edges:o};let i=-Infinity;let f=-1;e.forEach(((e,t)=>{if(e[0]>i){i=e[0];f=t}}));if(f===-1){return a}c.push(f);const l=e[f];const d=n[f];if(!d){return a}const u=d.map((t=>e[t])).map((e=>[e[0]-l[0],e[1]-l[1]])).map((e=>Math.atan2(e[1],e[0]))).map((e=>e<0?e+Math.PI*2:e)).map(((e,t)=>({a:e,i:t}))).sort(((e,t)=>e.a-t.a)).shift().i;const m=d[u];const p=f<m?`${f} ${m}`:`${m} ${f}`;const g=r[p];o.push(g);let _=f;let h=m;const v={[`${_} ${h}`]:true};while(true){const e=n[h];const t=e.indexOf(_);const s=(t+1)%e.length;const i=e[s];const f=h<i?`${h} ${i}`:`${i} ${h}`;const l=r[f];if(v[`${h} ${i}`]){if(l!==o[0]){console.warn("bad boundary")}return a}v[`${h} ${i}`]=true;c.push(h);o.push(l);_=h;h=i}};const la=({vertices_coords:e,vertices_edges:t,vertices_vertices:n,edges_vertices:s})=>{if(!n){n=Ts({vertices_coords:e,vertices_edges:t,edges_vertices:s})}return na({vertices_coords:e,vertices_vertices:n,edges_vertices:s}).map(fa)};const da=Object.freeze({__proto__:null,boundaries:ia,boundary:aa,boundaryVertices:oa,boundingBox:ra,planarBoundaries:la,planarBoundary:fa});const ua=({vertices_coords:e,vertices_faces:t,edges_vertices:n,edges_foldAngle:s,edges_assignment:r,faces_vertices:o,faces_faces:c,faces_matrix:a},i)=>{if(!e||!e.length){return[]}if(!o||!o.length){return e}a=Fc({vertices_coords:e,edges_vertices:n,edges_foldAngle:s,edges_assignment:r,faces_vertices:o,faces_faces:c},i);if(!t){t=Rs({faces_vertices:o})}const f=t.map((e=>e.filter((e=>e!=null)).shift())).map((e=>e===undefined?Ce:a[e]));return e.map((e=>de(3,e))).map(((e,t)=>Pe(f[t],e)))};const ma=({vertices_coords:e,edges_vertices:t,edges_foldAngle:n,edges_assignment:s,faces_vertices:r,faces_faces:o},c=0)=>{if(!e||!e.length){return[]}if(!r||!r.length){return e}if(!o){o=cr({faces_vertices:r})}const a=Qt({edges_vertices:t,edges_foldAngle:n,edges_assignment:s});const i=[];const f=[];const l=Ls({edges_vertices:t});xc(o,c).forEach((n=>{const s=n.shift();if(!s||!s.length){return}const o=s[0];f[o.index]=false;r[o.index].forEach((t=>{i[t]=[...e[t]]}));n.forEach((n=>n.forEach((n=>{const s=Mc(r[n.index],r[n.parent]).slice(0,2).join(" ");const o=l[s];const c=t[o].map((e=>i[e]));if(c[0]===undefined||c[1]===undefined){return}const d=t[o].map((t=>e[t]));const u=d[0];const m=P(U(d[1],d[0]));const p=oe(m);f[n.index]=a[o]?!f[n.parent]:f[n.parent];const g=P(U(c[1],c[0]));const _=c[0];const h=f[n.index]?ce(g):oe(g);r[n.index].filter((e=>i[e]===undefined)).forEach((t=>{const n=U(e[t],u);const s=D(n,p);const r=D(n,m);const o=N(g,r);const c=N(h,s);const a=R(R(_,o),c);i[t]=a}))}))))}));return i};const pa=Object.freeze({__proto__:null,makeVerticesCoordsFlatFolded:ma,makeVerticesCoordsFolded:ua});const ga=function(e){let t;let n;if(typeof e!=="object"){return e}if(!e){return e}if(Object.prototype.toString.apply(e)==="[object Array]"){t=[];for(n=0;n<e.length;n+=1){t[n]=ga(e[n])}return t}t={};for(n in e){if(e.hasOwnProperty(n)){t[n]=ga(e[n])}}return t};const _a=typeof structuredClone==="function"?structuredClone:ga;const ha="class";const va="function";const ba="undefined";const ya="boolean";const Ea="number";const Ma="string";const Aa="object";const xa="svg";const wa="path";const ka="id";const Oa="style";const ja="viewBox";const Fa="transform";const Sa="points";const Ca="stroke";const Va="fill";const Pa="none";const Ta="arrow";const za="head";const Na="tail";const Ba=typeof window!==ba&&typeof window.document!==ba;typeof process!==ba&&process.versions!=null&&process.versions.node!=null;const $a={window:"window not set; svg.window = @xmldom/xmldom"};const Ra={window:undefined};const La=e=>(new e.DOMParser).parseFromString("<!DOCTYPE html><title>.</title>","text/html");const Ia=e=>{if(!e.document){e.document=La(e)}Ra.window=e;return Ra.window};if(Ba){Ra.window=window}const Ua=()=>{if(Ra.window===undefined){throw $a.window}return Ra.window};const Qa="http://www.w3.org/2000/svg";const Da={presentation:["color","color-interpolation","cursor","direction","display","fill","fill-opacity","fill-rule","font-family","font-size","font-size-adjust","font-stretch","font-style","font-variant","font-weight","image-rendering","letter-spacing","opacity","overflow","paint-order","pointer-events","preserveAspectRatio","shape-rendering","stroke","stroke-dasharray","stroke-dashoffset","stroke-linecap","stroke-linejoin","stroke-miterlimit","stroke-opacity","stroke-width","tabindex","transform-origin","user-select","vector-effect","visibility"],animation:["accumulate","additive","attributeName","begin","by","calcMode","dur","end","from","keyPoints","keySplines","keyTimes","max","min","repeatCount","repeatDur","restart","to","values"],effects:["azimuth","baseFrequency","bias","color-interpolation-filters","diffuseConstant","divisor","edgeMode","elevation","exponent","filter","filterRes","filterUnits","flood-color","flood-opacity","in","in2","intercept","k1","k2","k3","k4","kernelMatrix","lighting-color","limitingConeAngle","mode","numOctaves","operator","order","pointsAtX","pointsAtY","pointsAtZ","preserveAlpha","primitiveUnits","radius","result","seed","specularConstant","specularExponent","stdDeviation","stitchTiles","surfaceScale","targetX","targetY","type","xChannelSelector","yChannelSelector"],text:["dx","dy","alignment-baseline","baseline-shift","dominant-baseline","lengthAdjust","method","overline-position","overline-thickness","rotate","spacing","startOffset","strikethrough-position","strikethrough-thickness","text-anchor","text-decoration","text-rendering","textLength","underline-position","underline-thickness","word-spacing","writing-mode"],gradient:["gradientTransform","gradientUnits","spreadMethod"]};const qa={svg:["svg"],defs:["defs"],header:["desc","filter","metadata","style","script","title","view"],cdata:["cdata"],group:["g"],visible:["circle","ellipse","line","path","polygon","polyline","rect","arc","arrow","curve","parabola","roundRect","wedge","origami"],text:["text"],invisible:["marker","symbol","clipPath","mask"],patterns:["linearGradient","radialGradient","pattern"],childrenOfText:["textPath","tspan"],gradients:["stop"],filter:["feBlend","feColorMatrix","feComponentTransfer","feComposite","feConvolveMatrix","feDiffuseLighting","feDisplacementMap","feDistantLight","feDropShadow","feFlood","feFuncA","feFuncB","feFuncG","feFuncR","feGaussianBlur","feImage","feMerge","feMergeNode","feMorphology","feOffset","fePointLight","feSpecularLighting","feSpotLight","feTile","feTurbulence"]};const Wa={svg:[ja],line:["x1","y1","x2","y2"],rect:["x","y","width","height"],circle:["cx","cy","r"],ellipse:["cx","cy","rx","ry"],polygon:[Sa],polyline:[Sa],path:["d"],text:["x","y"],mask:[ka],symbol:[ka],clipPath:[ka,"clip-rule"],marker:[ka,"markerHeight","markerUnits","markerWidth","orient","refX","refY"],linearGradient:["x1","x2","y1","y2"],radialGradient:["cx","cy","r","fr","fx","fy"],stop:["offset","stop-color","stop-opacity"],pattern:["patternContentUnits","patternTransform","patternUnits"]};const Ga=[{nodes:[xa,"defs","g"].concat(qa.visible,qa.text),attr:Da.presentation},{nodes:["filter"],attr:Da.effects},{nodes:qa.childrenOfText.concat("text"),attr:Da.text},{nodes:qa.filter,attr:Da.effects},{nodes:qa.gradients,attr:Da.gradient}];Ga.forEach((e=>e.nodes.forEach((t=>{if(!Wa[t]){Wa[t]=[]}Wa[t].push(...e.attr)}))));const Ha=[qa.header,qa.invisible,qa.patterns].flat();const Ja=[qa.group,qa.visible,qa.text].flat();const Za={svg:[["svg","defs"],Ha,Ja].flat(),defs:Ha,filter:qa.filter,g:Ja,text:qa.childrenOfText,marker:Ja,symbol:Ja,clipPath:Ja,mask:Ja,linearGradient:qa.gradients,radialGradient:qa.gradients};const Ya=Object.values(qa).flat();const Xa={black:"#000000",silver:"#c0c0c0",gray:"#808080",white:"#ffffff",maroon:"#800000",red:"#ff0000",purple:"#800080",fuchsia:"#ff00ff",green:"#008000",lime:"#00ff00",olive:"#808000",yellow:"#ffff00",navy:"#000080",blue:"#0000ff",teal:"#008080",aqua:"#00ffff",orange:"#ffa500",aliceblue:"#f0f8ff",antiquewhite:"#faebd7",aquamarine:"#7fffd4",azure:"#f0ffff",beige:"#f5f5dc",bisque:"#ffe4c4",blanchedalmond:"#ffebcd",blueviolet:"#8a2be2",brown:"#a52a2a",burlywood:"#deb887",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",cornflowerblue:"#6495ed",cornsilk:"#fff8dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",darkkhaki:"#bdb76b",darkmagenta:"#8b008b",darkolivegreen:"#556b2f",darkorange:"#ff8c00",darkorchid:"#9932cc",darkred:"#8b0000",darksalmon:"#e9967a",darkseagreen:"#8fbc8f",darkslateblue:"#483d8b",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",darkturquoise:"#00ced1",darkviolet:"#9400d3",deeppink:"#ff1493",deepskyblue:"#00bfff",dimgray:"#696969",dimgrey:"#696969",dodgerblue:"#1e90ff",firebrick:"#b22222",floralwhite:"#fffaf0",forestgreen:"#228b22",gainsboro:"#dcdcdc",ghostwhite:"#f8f8ff",gold:"#ffd700",goldenrod:"#daa520",greenyellow:"#adff2f",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",indianred:"#cd5c5c",indigo:"#4b0082",ivory:"#fffff0",khaki:"#f0e68c",lavender:"#e6e6fa",lavenderblush:"#fff0f5",lawngreen:"#7cfc00",lemonchiffon:"#fffacd",lightblue:"#add8e6",lightcoral:"#f08080",lightcyan:"#e0ffff",lightgoldenrodyellow:"#fafad2",lightgray:"#d3d3d3",lightgreen:"#90ee90",lightgrey:"#d3d3d3",lightpink:"#ffb6c1",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",lightskyblue:"#87cefa",lightslategray:"#778899",lightslategrey:"#778899",lightsteelblue:"#b0c4de",lightyellow:"#ffffe0",limegreen:"#32cd32",linen:"#faf0e6",magenta:"#ff00ff",mediumaquamarine:"#66cdaa",mediumblue:"#0000cd",mediumorchid:"#ba55d3",mediumpurple:"#9370db",mediumseagreen:"#3cb371",mediumslateblue:"#7b68ee",mediumspringgreen:"#00fa9a",mediumturquoise:"#48d1cc",mediumvioletred:"#c71585",midnightblue:"#191970",mintcream:"#f5fffa",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",navajowhite:"#ffdead",oldlace:"#fdf5e6",olivedrab:"#6b8e23",orangered:"#ff4500",orchid:"#da70d6",palegoldenrod:"#eee8aa",palegreen:"#98fb98",paleturquoise:"#afeeee",palevioletred:"#db7093",papayawhip:"#ffefd5",peachpuff:"#ffdab9",peru:"#cd853f",pink:"#ffc0cb",plum:"#dda0dd",powderblue:"#b0e0e6",rosybrown:"#bc8f8f",royalblue:"#4169e1",saddlebrown:"#8b4513",salmon:"#fa8072",sandybrown:"#f4a460",seagreen:"#2e8b57",seashell:"#fff5ee",sienna:"#a0522d",skyblue:"#87ceeb",slateblue:"#6a5acd",slategray:"#708090",slategrey:"#708090",snow:"#fffafa",springgreen:"#00ff7f",steelblue:"#4682b4",tan:"#d2b48c",thistle:"#d8bfd8",tomato:"#ff6347",turquoise:"#40e0d0",violet:"#ee82ee",wheat:"#f5deb3",whitesmoke:"#f5f5f5",yellowgreen:"#9acd32"};const Ka=e=>Math.round(e*100)/100;const ei=(e,t,n,s)=>{const r=t/100;const o=n/100;const c=t=>(t+e/30)%12;const a=r*Math.min(o,1-o);const i=e=>o-a*Math.max(-1,Math.min(c(e)-3,Math.min(9-c(e),1)));return s===undefined?[i(0)*255,i(8)*255,i(4)*255]:[i(0)*255,i(8)*255,i(4)*255,s]};const ti=(e,t)=>{const n=Array.from(Array(t.length)).map(((t,n)=>e[n]||"0"));return e.length<=4?t.map((e=>n[e])).join(""):n.join("")};const ni=e=>{const t=e.replace(/#(?=\S)/g,"");const n=t.length===4||t.length===8;const s=n?ti(t,[0,0,1,1,2,2,3,3]):ti(t,[0,0,1,1,2,2]);const r=parseInt(s,16);return n?[r>>24&255,r>>16&255,r>>8&255,Ka((r&255)/256)]:[r>>16&255,r>>8&255,r&255]};const si=(e,t,n,s)=>{const r=e=>`00${Math.max(0,Math.min(Math.round(e),255)).toString(16)}`.slice(-2);const o=`#${[e,t,n].map(r).join("")}`;return s===undefined?o:`${o}${r(s*255)}`};const ri=Object.freeze({__proto__:null,hexToRgb:ni,hslToRgb:ei,rgbToHex:si});const oi=e=>{const t=e.match(/\(([^\)]+)\)/g);if(t==null||!t.length){return[]}return t[0].substring(1,t[0].length-1).split(/[\s,]+/).map(parseFloat)};const ci=e=>{if(Xa[e]){return ni(Xa[e])}if(e[0]==="#"){return ni(e)}if(e.substring(0,4)==="rgba"||e.substring(0,3)==="rgb"){const t=oi(e);[0,1,2].filter((e=>t[e]===undefined)).forEach((e=>{t[e]=0}));return t}if(e.substring(0,4)==="hsla"||e.substring(0,3)==="hsl"){const t=oi(e);[0,1,2].filter((e=>t[e]===undefined)).forEach((e=>{t[e]=0}));return ei(...t)}return undefined};const ai=e=>{if(Xa[e]){return Xa[e].toUpperCase()}if(e[0]==="#"){return si(...ni(e))}if(e.substring(0,4)==="rgba"||e.substring(0,3)==="rgb"){return si(...oi(e))}if(e.substring(0,4)==="hsla"||e.substring(0,3)==="hsl"){const t=oi(e);[0,1,2].filter((e=>t[e]===undefined)).forEach((e=>{t[e]=0}));const n=ei(...t);if(t.length===4){n.push(t[3])}return si(...n)}return undefined};const ii=Object.freeze({__proto__:null,parseColorToHex:ai,parseColorToRgb:ci});const fi={cssColors:Xa,...ri,...ii};const li=(e,t)=>[e[0]+t[0],e[1]+t[1]];const di=(e,t)=>[e[0]-t[0],e[1]-t[1]];const ui=(e,t)=>[e[0]*t,e[1]*t];const mi=e=>e[0]**2+e[1]**2;const pi=e=>Math.sqrt(mi(e));const gi=(e,t)=>mi(di(e,t));const _i=(e,t)=>Math.sqrt(gi(e,t));const hi=(e,t)=>[Math.cos(e)*t,Math.sin(e)*t];const vi=(e,t)=>[e[0]*t[0]+e[2]*t[1],e[1]*t[0]+e[3]*t[1],e[0]*t[2]+e[2]*t[3],e[1]*t[2]+e[3]*t[3],e[0]*t[4]+e[2]*t[5]+e[4],e[1]*t[4]+e[3]*t[5]+e[5]];const bi=Object.freeze({__proto__:null,svg_add2:li,svg_distance2:_i,svg_distanceSq2:gi,svg_magnitude2:pi,svg_magnitudeSq2:mi,svg_multiplyMatrices2:vi,svg_polar_to_cart:hi,svg_scale2:ui,svg_sub2:di});const yi=function(e){const t=e.match(/(\w+\((\-?\d+\.?\d*e?\-?\d*,?\s*)+\))+/g);if(!t){return[]}const n=t.map((e=>e.match(/[\w\.\-]+/g)));return n.map((e=>({transform:e.shift(),parameters:e.map((e=>parseFloat(e)))})))};const Ei=function(e){switch(e.length){case 1:return[1,0,0,1,e[0],0];case 2:return[1,0,0,1,e[0],e[1]];default:console.warn(`improper translate, ${e}`)}return undefined};const Mi=function(e){const t=Math.cos(e[0]/(180*Math.PI));const n=Math.sin(e[0]/(180*Math.PI));switch(e.length){case 1:return[t,n,-n,t,0,0];case 3:return[t,n,-n,t,-e[1]*t+e[2]*n+e[1],-e[1]*n-e[2]*t+e[2]];default:console.warn(`improper rotate, ${e}`)}return undefined};const Ai=function(e){switch(e.length){case 1:return[e[0],0,0,e[0],0,0];case 2:return[e[0],0,0,e[1],0,0];default:console.warn(`improper scale, ${e}`)}return undefined};const xi=function(e){return[1,0,Math.tan(e[0]/(180*Math.PI)),1,0,0]};const wi=function(e){return[1,Math.tan(e[0]/(180*Math.PI)),0,1,0,0]};const ki=function(e,t){switch(e){case"translate":return Ei(t);case"rotate":return Mi(t);case"scale":return Ai(t);case"skewX":return xi(t);case"skewY":return wi(t);case"matrix":return t;default:console.warn(`unknown transform type ${e}`)}return undefined};const Oi=function(e){return yi(e).map((e=>ki(e.transform,e.parameters))).filter((e=>e!==undefined)).reduce(((e,t)=>vi(e,t)),[1,0,0,1,0,0])};const ji=Object.freeze({__proto__:null,parseTransform:yi,transformStringToMatrix:Oi});const Fi=(e,t="text/xml")=>{const n=(new(Ua().DOMParser)).parseFromString(e,t);return n?n.documentElement:null};const Si=e=>{let t=e;while(t.parentNode!=null){t=t.parentNode}return t};const Ci=(e,t)=>{if((e.nodeName||"")===t){return e}return e.parentNode?Ci(e.parentNode,t):undefined};const Vi=(e,...t)=>{const n={};const s=e.getAttribute("class");const r=s?s.split(" "):[];r.push(...t);r.forEach((e=>{n[e]=true}));const o=Object.keys(n).join(" ");e.setAttribute("class",o)};const Pi=(e,...t)=>{if(!e||!t.length){return undefined}return e.classList?e.classList.add(...t):Vi(e,...t)};const Ti=e=>e.childNodes==null||!e.childNodes.length?[e]:Array.from(e.childNodes).flatMap((e=>Ti(e)));const zi={svg:["viewBox","xmlns","version"],line:["x1","y1","x2","y2"],rect:["x","y","width","height"],circle:["cx","cy","r"],ellipse:["cx","cy","rx","ry"],polygon:["points"],polyline:["points"],path:["d"]};const Ni=e=>{const t=e.attributes;if(t==null){return[]}const n=Array.from(t);return zi[e.nodeName]?n.filter((t=>!zi[e.nodeName].includes(t.name))):n};const Bi=e=>{const t={};e.forEach((e=>{t[e.nodeName]=e.value}));return t};const $i=(e,t)=>{const n=Bi(Ni(t));if(!n.transform&&!e.transform){return{...e,...n}}const s=n.transform||"";const r=e.transform||"";const o=Oi(s);const c=Oi(r);const a=vi(c,o);const i=`matrix(${a.join(", ")})`;return{...e,...n,transform:i}};const Ri=(e,t={})=>e.childNodes==null||!e.childNodes.length?[{element:e,attributes:t}]:Array.from(e.childNodes).flatMap((e=>Ri(e,$i(t,e))));const Li=Object.freeze({__proto__:null,addClass:Pi,findElementTypeInParents:Ci,flattenDomTree:Ti,flattenDomTreeWithStyle:Ri,getRootParent:Si,xmlStringToElement:Fi});const Ii=e=>(new(Ua().DOMParser)).parseFromString("<root></root>","text/xml").createCDATASection(e);const Ui=/[MmLlSsQqLlHhVvCcSsQqTtAaZz]/g;const Qi=/-?[0-9]*\.?\d+/g;const Di={m:"move",l:"line",v:"vertical",h:"horizontal",a:"ellipse",c:"curve",s:"smoothCurve",q:"quadCurve",t:"smoothQuadCurve",z:"close"};Object.keys(Di).forEach((e=>{const t=Di[e];Di[e.toUpperCase()]=t.charAt(0).toUpperCase()+t.slice(1)}));const qi=(e,t)=>[e[0]+(t[0]||0),e[1]+(t[1]||0)];const Wi=(e,t,n=[0,0])=>{const s=e.toUpperCase();let r=e===s?[0,0]:n;if(e==="V"){r=[n[0],0]}if(e==="H"){r=[0,n[1]]}switch(s){case"V":return qi(r,[0,t[0]]);case"H":return qi(r,[t[0],0]);case"M":case"L":case"T":return qi(r,t);case"A":return qi(r,[t[5],t[6]]);case"C":return qi(r,[t[4],t[5]]);case"S":case"Q":return qi(r,[t[2],t[3]]);case"Z":return undefined;default:return r}};const Gi=e=>{const t=[];let n;while((n=Ui.exec(e))!==null){t.push(n)}return t.map(((t,n,s)=>[t[0],t.index,n===s.length-1?e.length-1:s[(n+1)%s.length].index-1])).map((t=>{const n=t[0];const s=e.substring(t[1]+1,t[2]+1);const r=s.match(Qi);const o=r?r.map(parseFloat):[];return{command:n,values:o}}))};const Hi=e=>{let t=[0,0];const n=Gi(e);if(!n.length){return n}n.forEach(((e,s)=>{n[s].end=Wi(e.command,e.values,t);n[s].start=s===0?t:n[s-1].end;t=n[s].end}));const s=n[n.length-1];const r=n.filter((e=>e.command.toUpperCase()!=="M"&&e.command.toUpperCase()!=="Z")).shift();if(s.command.toUpperCase()==="Z"){s.end=[...r.start]}return n};const Ji=Object.freeze({__proto__:null,parsePathCommands:Gi,parsePathCommandsWithEndpoints:Hi,pathCommandNames:Di});const Zi=(...e)=>e.filter((e=>typeof e===Ea)).concat(e.filter((e=>typeof e===Aa&&e!==null)).map((e=>{if(typeof e.x===Ea){return[e.x,e.y]}if(typeof e[0]===Ea){return[e[0],e[1]]}return undefined})).filter((e=>e!==undefined)).reduce(((e,t)=>e.concat(t)),[]));const Yi=function(e,t,n,s,r=0){const o=1;const c=n/o-n;const a=e-c-r;const i=t-c-r;const f=n+c*2+r*2;const l=s+c*2+r*2;return[a,i,f,l].join(" ")};const Xi=(...e)=>{const t=Zi(...e.flat());if(t.length===2){t.unshift(0,0)}return t.length===4?Yi(...t):undefined};const Ki=(e,...t)=>{const n=t.length===1&&typeof t[0]===Ma?t[0]:Xi(...t);if(n){e.setAttribute(ja,n)}return e};const ef=function(e){const t=e.getAttribute(ja);return t==null?undefined:t.split(" ").map((e=>parseFloat(e)))};const tf=function(e,t,n){const s=e.createSVGPoint();s.x=t;s.y=n;const r=s.matrixTransform(e.getScreenCTM().inverse());return[r.x,r.y]};const nf=({vertices_coords:e})=>{if(!e){return undefined}const t=[Infinity,Infinity];const n=[-Infinity,-Infinity];e.forEach((e=>[0,1].forEach((s=>{t[s]=Math.min(e[s],t[s]);n[s]=Math.max(e[s],n[s])}))));return[t[0],t[1],n[0]-t[0],n[1]-t[1]].join(" ")};const sf=Object.freeze({__proto__:null,convertToViewBox:tf,foldToViewBox:nf,getViewBox:ef,setViewBox:Ki});const rf={...bi,...Li,makeCDATASection:Ii,...Ji,...ji,...sf};const of=function(e){const t=ef(e);if(t!==undefined){return t}if(typeof e.getBoundingClientRect===va){const t=e.getBoundingClientRect();return[t.x,t.y,t.width,t.height]}return[]};const cf="svg-background-rectangle";const af=function(e,t){let n=Array.from(e.childNodes).filter((e=>e.getAttribute(ha)===cf)).shift();if(n==null){n=Ua().document.createElementNS(Qa,"rect");of(e).forEach(((e,t)=>n.setAttribute(Wa.rect[t],e)));n.setAttribute(ha,cf);n.setAttribute(Ca,Pa);e.insertBefore(n,e.firstChild)}n.setAttribute(Va,t);return e};const ff=e=>{const t=e.getAttribute(Fa);return t==null||t===""?undefined:t};const lf={clearTransform:e=>{e.removeAttribute(Fa);return e}};["translate","rotate","scale","matrix"].forEach((e=>{lf[e]=(t,...n)=>{t.setAttribute(Fa,[ff(t),`${e}(${n.join(" ")})`].filter((e=>e!==undefined)).join(" "));return t}}));const df=e=>e.replace(/([-_][a-z])/gi,(e=>e.toUpperCase().replace("-","").replace("_","")));const uf=e=>e.replace(/([a-z0-9])([A-Z])/g,"$1-$2").replace(/([A-Z])([A-Z])(?=[a-z])/g,"$1-$2").toLowerCase();const mf=e=>e.charAt(0).toUpperCase()+e.slice(1);const pf=e=>{while(e.lastChild){e.removeChild(e.lastChild)}return e};const gf=(e,t)=>{if(t&&t.appendChild){t.appendChild(e)}return e};const _f=(e,t)=>{Object.keys(t).forEach((n=>e.setAttribute(uf(n),t[n])));return e};const hf=Object.freeze({__proto__:null,appendTo:gf,removeChildren:pf,setAttributes:_f});const vf=function(e,t){const n=ef(e);if(n!==undefined){Ki(e,...[-t,-t,t*2,t*2].map(((e,t)=>n[t]+e)))}return e};const bf=function(e,t){const n=e.getElementsByTagName(t);return n.length?n[0]:null};const yf=function(e,t){let n=bf(e,Oa);if(n==null){n=Ua().document.createElementNS(Qa,Oa);n.setTextContent=e=>{n.textContent="";n.appendChild(Ii(e));return n};e.insertBefore(n,e.firstChild)}n.textContent="";n.appendChild(Ii(t));return n};const Ef=e=>{Array.from(e.attributes).filter((e=>e.name!=="xmlns"&&e.name!=="version")).forEach((t=>e.removeAttribute(t.name)));return pf(e)};const Mf={clear:Ef,size:Ki,setViewBox:Ki,getViewBox:ef,padding:vf,background:af,getWidth:e=>of(e)[2],getHeight:e=>of(e)[3],stylesheet:function(e,t){return yf.call(this,e,t)},...lf,...hf};const Af={move:["mousemove","touchmove"],press:["mousedown","touchstart"],release:["mouseup","touchend"],leave:["mouseleave","touchcancel"]};const xf=(e,t)=>Object.values(Af).flat().forEach((n=>{t[n].forEach((t=>e.removeEventListener(n,t)));t[n]=[]}));const wf=(e,t,n)=>Object.defineProperty(e,t,{get:()=>n,enumerable:true,configurable:true});const kf=function(e){const t=[];Object.keys(Af).forEach((e=>{Af[e].forEach((e=>{t[e]=[]}))}));const n=n=>Af[n].forEach((n=>t[n].forEach((t=>e.removeEventListener(n,t)))));Object.keys(Af).forEach((s=>{Object.defineProperty(e,`on${mf(s)}`,{set:r=>{if(!e.addEventListener){return}if(r==null){n(s);return}Af[s].forEach((n=>{const s=t=>{const n=t.touches!=null?t.touches[0]:t;if(n!==undefined){const{clientX:s,clientY:r}=n;const[o,c]=tf(e,s,r);wf(t,"x",o);wf(t,"y",c)}r(t)};t[n].push(s);e.addEventListener(n,s)}))},enumerable:true})}));Object.defineProperty(e,"off",{value:()=>xf(e,t)})};const Of=()=>Math.random().toString(36).replace(/[^a-z]+/g,"").concat("aaaaa").substr(0,5);const jf=function(e){let t;let n=0;let s;const r={};const o=()=>{if(Ua().cancelAnimationFrame){Ua().cancelAnimationFrame(s)}Object.keys(r).forEach((e=>delete r[e]))};const c=e=>{o();if(!e||!Ua().requestAnimationFrame){return}t=performance.now();n=0;const c=Of();r[c]=o=>{const a=(o-t)*.001;e({time:a,frame:n});n+=1;if(r[c]){s=Ua().requestAnimationFrame(r[c])}};s=Ua().requestAnimationFrame(r[c])};Object.defineProperty(e,"play",{set:c,enumerable:true});Object.defineProperty(e,"stop",{value:o,enumerable:true})};const Ff=e=>e&&e.parentNode?e.parentNode.removeChild(e):undefined;const Sf=[["cx","cy"],["x","y"]];const Cf=function(e,t={}){const n=[0,0];const s={selected:false,svg:undefined,updatePosition:e=>e};const r=()=>{if(!s.svg){return}if(!s.svg.parentNode){e.appendChild(s.svg)}Sf.filter((e=>s.svg[e[0]]!=null)).forEach((e=>e.forEach(((e,t)=>{s.svg.setAttribute(e,n[t])}))))};const o=new Proxy(n,{set:(e,t,n)=>{e[t]=n;r();return true}});const c=function(...e){Zi(...e.flat()).forEach(((e,t)=>{n[t]=e}));r();if(typeof n.delegate===va){n.delegate.apply(n.pointsContainer,[o,n.pointsContainer])}};n.delegate=undefined;n.setPosition=c;n.onMouseMove=e=>s.selected?c(s.updatePosition(e)):undefined;n.onMouseUp=()=>{s.selected=false};n.distance=e=>Math.sqrt(gi(e,n));["x","y"].forEach(((e,t)=>Object.defineProperty(n,e,{get:()=>n[t],set:e=>{n[t]=e}})));[xa,"updatePosition","selected"].forEach((e=>Object.defineProperty(n,e,{get:()=>s[e],set:t=>{s[e]=t}})));Object.defineProperty(n,"remove",{value:()=>{Ff(s.svg);n.delegate=undefined}});return o};const Vf=function(e,t,n){let s;let r;const o=Array.from(Array(t)).map((()=>Cf(e,n)));const c=e=>typeof r===va?r.call(o,e,s,o):undefined;o.forEach((e=>{e.delegate=c;e.pointsContainer=o}));const a=function(e){if(!(o.length>0)){return}s=o.map(((t,n)=>({i:n,d:gi(t,[e.x,e.y])}))).sort(((e,t)=>e.d-t.d)).shift().i;o[s].selected=true};const i=function(e){o.forEach((t=>t.onMouseMove(e)))};const f=function(){o.forEach((e=>e.onMouseUp()));s=undefined};e.onPress=a;e.onMove=i;e.onRelease=f;Object.defineProperty(o,"selectedIndex",{get:()=>s});Object.defineProperty(o,"selected",{get:()=>o[s]});Object.defineProperty(o,"add",{value:t=>{o.push(Cf(e,t))}});o.removeAll=()=>{while(o.length>0){o.pop().remove()}};const l={onChange:(e,t)=>{r=e;if(t===true){const t=o.length-1;e.call(o,o[t],t,o)}},position:e=>o.forEach(((t,n)=>t.setPosition(e.call(o,t,n,o)))),svg:e=>o.forEach(((t,n)=>{t.svg=e.call(o,t,n,o)}))};Object.keys(l).forEach((e=>{o[e]=function(){if(typeof arguments[0]===va){l[e](...arguments)}return o}}));o.parent=function(e){if(e!=null&&e.appendChild!=null){o.forEach((t=>{e.appendChild(t.svg)}))}return o};return o};const Pf=e=>{e.controls=(...t)=>Vf.call(e,e,...t)};const Tf={svg:{args:(...e)=>[Xi(Zi(...e))].filter((e=>e!=null)),methods:Mf,init:(...e)=>{const t=Ua().document.createElementNS(Qa,"svg");t.setAttribute("version","1.1");t.setAttribute("xmlns",Qa);e.filter((e=>e!=null)).filter((e=>e.appendChild)).forEach((e=>e.appendChild(t)));kf(t);jf(t);Pf(t);return t}}};const zf=function(e){if(e==null){return""}if(typeof e===Ma){return e.slice(0,3)==="url"?e:`url(#${e})`}if(e.getAttribute!=null){const t=e.getAttribute(ka);return`url(#${t})`}return""};const Nf={};["clip-path","mask","symbol","marker-end","marker-mid","marker-start"].forEach((e=>{Nf[df(e)]=(t,n)=>{t.setAttribute(e,zf(n));return t}}));const Bf={g:{methods:{...lf,...Nf,...hf}}};const $f=(e,t)=>{e.setAttribute(Wa.circle[2],t);return e};const Rf=(e,t,n)=>{[...Zi(...[t,n].flat()).slice(0,2)].forEach(((t,n)=>e.setAttribute(Wa.circle[n],t)));return e};const Lf=(e,t,n,s)=>[e,t,_i([e,t],[n,s])];const If={circle:{args:(e,t,n,s)=>{const r=Zi(...[e,t,n,s].flat());switch(r.length){case 0:case 1:return[,,...r];case 2:case 3:return r;default:return Lf(...r)}},methods:{radius:$f,setRadius:$f,origin:Rf,setOrigin:Rf,center:Rf,setCenter:Rf,position:Rf,setPosition:Rf,...lf,...Nf,...hf}}};const Uf=(e,t,n)=>{[,,t,n].forEach(((t,n)=>e.setAttribute(Wa.ellipse[n],t)));return e};const Qf=(e,t,n)=>{[...Zi(...[t,n].flat()).slice(0,2)].forEach(((t,n)=>e.setAttribute(Wa.ellipse[n],t)));return e};const Df={ellipse:{args:(e,t,n,s)=>{const r=Zi(...[e,t,n,s].flat()).slice(0,4);switch(r.length){case 0:case 1:case 2:return[,,...r];default:return r}},methods:{radius:Uf,setRadius:Uf,origin:Qf,setOrigin:Qf,center:Qf,setCenter:Qf,position:Qf,setPosition:Qf,...lf,...Nf,...hf}}};const qf=e=>e!=null&&typeof e[Symbol.iterator]===va;const Wf=function(){switch(arguments.length){case 0:return Array.from(arguments);case 1:return qf(arguments[0])&&typeof arguments[0]!==Ma?Wf(...arguments[0]):[arguments[0]];default:return Array.from(arguments).map((e=>qf(e)?[...Wf(e)]:e))}};const Gf=(...e)=>Zi(...Wf(...e)).slice(0,4);const Hf=(e,...t)=>{Gf(...t).forEach(((t,n)=>e.setAttribute(Wa.line[n],t)));return e};const Jf={line:{args:Gf,methods:{setPoints:Hf,...lf,...Nf,...hf}}};const Zf=e=>{const t=e.getAttribute("d");return t==null?"":t};const Yf=e=>{e.removeAttribute("d");return e};const Xf=(e,t,...n)=>{e.setAttribute("d",`${Zf(e)}${t}${n.flat().join(" ")}`);return e};const Kf=e=>Gi(Zf(e));const el={addCommand:Xf,appendCommand:Xf,clear:Yf,getCommands:Kf,get:Kf,getD:e=>e.getAttribute("d"),...lf,...Nf,...hf};Object.keys(Di).forEach((e=>{el[Di[e]]=(t,...n)=>Xf(t,e,...n)}));const tl={path:{methods:el}};const nl=(e,t,n)=>{[,,t,n].forEach(((t,n)=>e.setAttribute(Wa.rect[n],t)));return e};const sl=(e,t,n)=>{[...Zi(...[t,n].flat()).slice(0,2)].forEach(((t,n)=>e.setAttribute(Wa.rect[n],t)));return e};const rl=function(e){[0,1].forEach((t=>{if(e[2+t]<0){if(e[0+t]===undefined){e[0+t]=0}e[0+t]+=e[2+t];e[2+t]=-e[2+t]}}));return e};const ol={rect:{args:(e,t,n,s)=>{const r=Zi(...[e,t,n,s].flat()).slice(0,4);switch(r.length){case 0:case 1:case 2:case 3:return rl([,,...r]);default:return rl(r)}},methods:{origin:sl,setOrigin:sl,center:sl,setCenter:sl,size:nl,setSize:nl,...lf,...Nf,...hf}}};const cl={style:{init:e=>{const t=Ua().document.createElementNS(Qa,"style");t.setAttribute("type","text/css");t.textContent="";t.appendChild(Ii(e));return t},methods:{setTextContent:(e,t)=>{e.textContent="";e.appendChild(Ii(t));return e}}}};const al={text:{args:(e,t,n)=>Zi(...[e,t,n].flat()).slice(0,2),init:(e,t,n,s)=>{const r=Ua().document.createElementNS(Qa,"text");const o=[e,t,n,s].filter((e=>typeof e===Ma)).shift();r.appendChild(Ua().document.createTextNode(o||""));return r},methods:{...lf,...Nf,appendTo:gf,setAttributes:_f}}};const il=function(){return Array.from(arguments).filter((e=>typeof e===Ma||e instanceof String)).shift()||Of()};const fl=(...e)=>[il(...e)];const ll={mask:{args:fl,methods:{...lf,...Nf,...hf}},clipPath:{args:fl,methods:{...lf,...Nf,...hf}},symbol:{args:fl,methods:{...lf,...Nf,...hf}},marker:{args:fl,methods:{size:Ki,setViewBox:Ki,...lf,...Nf,...hf}}};const dl=e=>{const t=e.getAttribute(Sa);return t==null?"":t};const ul=function(){return Array.from(Array(Math.floor(arguments.length/2))).map(((e,t)=>`${arguments[t*2+0]},${arguments[t*2+1]}`)).join(" ")};const ml=(...e)=>[ul(...Zi(...Wf(...e)))];const pl=(e,...t)=>{e.setAttribute(Sa,ml(...t)[0]);return e};const gl=(e,...t)=>{e.setAttribute(Sa,[dl(e),ml(...t)[0]].filter((e=>e!=="")).join(" "));return e};const _l=function(...e){return e.length===1&&typeof e[0]===Ma?[e[0]]:ml(...e)};const hl={polyline:{args:_l,methods:{setPoints:pl,addPoint:gl,...lf,...Nf,...hf}},polygon:{args:_l,methods:{setPoints:pl,addPoint:gl,...lf,...Nf,...hf}}};const vl=(e,t,n,s,r,o=false)=>{if(r==null){return""}const c=hi(s,n);const a=hi(r,n);const i=[a[0]-c[0],a[1]-c[1]];const f=c[0]*a[1]-c[1]*a[0];const l=c[0]*a[0]+c[1]*a[1];const d=Math.atan2(f,l)>0?0:1;let u=o?`M ${e},${t} l ${c[0]},${c[1]} `:`M ${e+c[0]},${t+c[1]} `;u+=["a ",n,n,0,d,1,i[0],i[1]].join(" ");if(o){u+=" Z"}return u};const bl=(e,t,n,s,r)=>[vl(e,t,n,s,r,false)];const yl={arc:{nodeName:wa,attributes:["d"],args:bl,methods:{setArc:(e,...t)=>e.setAttribute("d",bl(...t)),...lf}}};const El=[Na,za];const Ml=e=>e.join(",");const Al=e=>"M"+e.map((e=>e.join(","))).join("L")+"Z";const xl=function(e){let t=[[0,1],[2,3]].map((t=>t.map((t=>e.points[t]||0))));let n=di(t[1],t[0]);let s=li(t[0],ui(n,.5));const r=pi(n);const o=El.map((t=>e[t].visible?(1+e[t].padding)*e[t].height*2.5:0)).reduce(((e,t)=>e+t),0);if(r<o){const e=r===0?[o,0]:ui(n,o/r);t=[di,li].map((t=>t(s,ui(e,.5))));n=di(t[1],t[0])}let c=[n[1],-n[0]];let a=li(s,ui(c,e.bend));const i=t.map((e=>di(a,e)));const f=i.map((e=>pi(e)));const l=i.map(((e,t)=>f[t]===0?e:ui(e,1/f[t])));const d=l.map((e=>ui(e,-1)));const u=d.map((e=>[e[1],-e[0]]));const m=El.map(((t,n)=>e[t].padding?e[t].padding:e.padding?e.padding:0));const p=El.map(((t,n)=>e[t].height*(e[t].visible?1:0))).map(((e,t)=>e+m[t]));const g=t.map(((e,t)=>li(e,ui(l[t],p[t]))));n=di(g[1],g[0]);c=[n[1],-n[0]];s=li(g[0],ui(n,.5));a=li(s,ui(c,e.bend));const _=g.map(((t,n)=>li(t,ui(di(a,t),e.pinch))));const h=El.map(((t,n)=>[li(g[n],ui(d[n],e[t].height)),li(g[n],ui(u[n],e[t].width/2)),li(g[n],ui(u[n],-e[t].width/2))]));return{line:`M${Ml(g[0])}C${Ml(_[0])},${Ml(_[1])},${Ml(g[1])}`,tail:Al(h[0]),head:Al(h[1])}};const wl=(e,t,n)=>{if(typeof t===ya){e.options[n].visible=t}else if(typeof t===Aa){Object.assign(e.options[n],t);if(t.visible==null){e.options[n].visible=true}}else if(t==null){e.options[n].visible=true}};const kl=(e,t={},n=za)=>{const s=e.getElementsByClassName(`${Ta}-${n}`)[0];Object.keys(t).map((e=>({key:e,fn:s[df(e)]}))).filter((e=>typeof e.fn===va&&e.key!=="class")).forEach((e=>e.fn(t[e.key])));Object.keys(t).filter((e=>e==="class")).forEach((e=>s.classList.add(t[e])))};const Ol=e=>{const t=xl(e.options);Object.keys(t).map((t=>({path:t,element:e.getElementsByClassName(`${Ta}-${t}`)[0]}))).filter((e=>e.element)).map((e=>{e.element.setAttribute("d",t[e.path]);return e})).filter((t=>e.options[t.path])).forEach((t=>t.element.setAttribute("visibility",e.options[t.path].visible?"visible":"hidden")));return e};const jl=(e,...t)=>{e.options.points=Zi(...Wf(...t)).slice(0,4);return Ol(e)};const Fl=(e,t)=>{e.options.bend=t;return Ol(e)};const Sl=(e,t)=>{e.options.pinch=t;return Ol(e)};const Cl=(e,t)=>{e.options.padding=t;return Ol(e)};const Vl=(e,t)=>{wl(e,t,za);kl(e,t,za);return Ol(e)};const Pl=(e,t)=>{wl(e,t,Na);kl(e,t,Na);return Ol(e)};const Tl=e=>e.getElementsByClassName(`${Ta}-line`)[0];const zl=e=>e.getElementsByClassName(`${Ta}-${za}`)[0];const Nl=e=>e.getElementsByClassName(`${Ta}-${Na}`)[0];const Bl={setPoints:jl,points:jl,bend:Fl,pinch:Sl,padding:Cl,head:Vl,tail:Pl,getLine:Tl,getHead:zl,getTail:Nl,...lf};const $l=()=>({visible:false,width:8,height:10,padding:0});const Rl=()=>({head:$l(),tail:$l(),bend:0,padding:0,pinch:.618,points:[]});const Ll=Object.keys(Rl());const Il=(...e)=>{for(let t=0;t<e.length;t+=1){if(typeof e[t]!==Aa){continue}const n=Object.keys(e[t]);for(let s=0;s<n.length;s+=1){if(Ll.includes(n[s])){return e[t]}}}return undefined};const Ul=function(...e){const t=Ua().document.createElementNS(Qa,"g");t.setAttribute(ha,Ta);const n=["line",Na,za].map((e=>{const n=Ua().document.createElementNS(Qa,wa);n.setAttribute(ha,`${Ta}-${e}`);t.appendChild(n);return n}));n[0].setAttribute(Oa,"fill:none;");n[1].setAttribute(Ca,Pa);n[2].setAttribute(Ca,Pa);t.options=Rl();Bl.setPoints(t,...e);const s=Il(...e);if(s){Object.keys(s).filter((e=>Bl[e])).forEach((e=>Bl[e](t,s[e])))}return t};const Ql={arrow:{nodeName:"g",attributes:[],args:()=>[],methods:Bl,init:Ul}};const Dl=(e=[],t=0,n=.5)=>{const s=[e[0]||0,e[1]||0];const r=[e[2]||0,e[3]||0];const o=di(r,s);const c=li(s,ui(o,.5));const a=[o[1],-o[0]];const i=li(c,ui(a,t));const f=li(s,ui(di(i,s),n));const l=li(r,ui(di(i,r),n));return`M${s[0]},${s[1]}C${f[0]},${f[1]} ${l[0]},${l[1]} ${r[0]},${r[1]}`};const ql=(...e)=>[Dl(Zi(...e.flat()))];const Wl=e=>e.slice(1).split(/[, ]+/).map((e=>parseFloat(e)));const Gl=e=>e.match(/[Cc][(0-9), .-]+/).map((e=>Wl(e)));const Hl=e=>e.match(/[Mm][(0-9), .-]+/).map((e=>Wl(e)));const Jl=e=>{const t=Hl(e).shift();const n=Gl(e).shift();const s=t?[t[t.length-2],t[t.length-1]]:[0,0];const r=n?[n[n.length-2],n[n.length-1]]:[0,0];return[...s,...r]};const Zl=(e,...t)=>{const n=Zi(...t.flat()).slice(0,4);e.setAttribute("d",Dl(n,e._bend,e._pinch));return e};const Yl=(e,t)=>{e._bend=t;return Zl(e,...Jl(e.getAttribute("d")))};const Xl=(e,t)=>{e._pinch=t;return Zl(e,...Jl(e.getAttribute("d")))};const Kl={setPoints:Zl,bend:Yl,pinch:Xl,...lf};const ed={curve:{nodeName:wa,attributes:["d"],args:ql,methods:Kl}};const td=(e,t,n,s,r)=>[vl(e,t,n,s,r,true)];const nd={wedge:{nodeName:wa,args:td,attributes:["d"],methods:{setArc:(e,...t)=>e.setAttribute("d",td(...t)),...lf}}};const sd={};const rd=(e,...t)=>{const n=Ua().document.createElementNS(Qa,"g");sd.ear.convert.foldToSvg.render(e,n,...t);return n};const od={...lf,...Nf,...hf};const cd={origami:{nodeName:"g",init:rd,args:()=>[],methods:od}};const ad={...Tf,...Bf,...If,...Df,...Jf,...tl,...ol,...cl,...al,...ll,...hl,...yl,...Ql,...ed,...nd,...cd};const id=(...e)=>e;const fd=(e,t,...n)=>{const s=ad[e]&&ad[e].nodeName?ad[e].nodeName:e;const{init:r,args:o,methods:c}=ad[e]||{};const a=Wa[s]||[];const i=Za[s]||[];const f=r?r(...n):Ua().document.createElementNS(Qa,s);if(t){t.appendChild(f)}const l=o||id;l(...n).forEach(((e,t)=>{f.setAttribute(Wa[s][t],e)}));if(c){Object.keys(c).forEach((e=>Object.defineProperty(f,e,{value:function(){return c[e](f,...arguments)}})))}a.forEach((e=>{const t=df(e);if(f[t]){return}Object.defineProperty(f,t,{value:function(){f.setAttribute(e,...arguments);return f}})}));i.forEach((e=>{if(f[e]){return}const t=function(){return fd(e,f,...arguments)};Object.defineProperty(f,e,{value:t})}));return f};const ld=(...e)=>{const t=fd(xa,null,...e);const n=()=>e.filter((e=>typeof e===va)).forEach((e=>e.call(t,t)));if(Ua().document.readyState==="loading"){Ua().document.addEventListener("DOMContentLoaded",n)}else{n()}return t};Object.assign(ld,{NS:Qa,nodes_attributes:Wa,nodes_children:Za,extensions:ad,...fi,...rf});Ya.forEach((e=>{ld[e]=(...t)=>fd(e,null,...t)}));Object.defineProperty(ld,"window",{enumerable:false,set:Ia});const dd={min:[0,0],span:[1,1]};const ud=(e,t={})=>Object.keys(t).forEach((n=>e.setAttributeNS(null,n,t[n])));const md=e=>[e.min,e.span].flatMap((e=>[e[0],e[1]])).join(" ");const pd=e=>{const t=ra(e);return t===undefined?"":md(t)};const gd=({vertices_coords:e,edges_vertices:t,edges_length:n},s=.1)=>{if(!e||!t){return undefined}if(!n){n=tr({vertices_coords:e,edges_vertices:t})}const r=n.slice().sort(((e,t)=>e-t));const o=Math.max(0,Math.min(Math.floor(r.length*s),r.length-1));return r[o]};const _d=(e,t)=>{const n=t===undefined?Math.max(...(ra(e)||dd).span):t;const s=gd(e,.1);return s?s*.1:n*.01};const hd=(e,t={})=>{const n=ld.g();if(!e||!e.vertices_coords){return n}e.vertices_coords.map((e=>ld.circle(e[0],e[1],.01))).forEach((e=>n.appendChild(e)));ud(n,t);return n};const vd={B:"black",M:"crimson",V:"royalblue",F:"lightgray",J:"gold",C:"limegreen",U:"orchid"};Object.keys(vd).forEach((e=>{vd[e.toLowerCase()]=vd[e]}));const bd=4;const yd={M:[1,0,0],V:[0,0,1],J:[1,1,0],U:[1,0,1],C:[0,1,0]};const Ed=(e=0,t=0,n=0)=>{const s=B([e,t,n],1/255);const r=F(s);if(r<.05){return"B"}const o=s.reduce(((e,t)=>e+t),0)/3;const c=se(s,[o,o,o]);const a=Object.keys(yd).map((e=>({key:e,dist:se(s,yd[e])}))).sort(((e,t)=>e.dist-t.dist)).shift();if(a.dist<c*bd){return a.key}return r<.1?"B":"F"};const Md=Object.freeze({__proto__:null,assignmentColor:vd,rgbToAssignment:Ed});const Ad={foldedForm:{},creasePattern:{stroke:"black"}};const xd={foldedForm:{},creasePattern:{}};Object.keys(vd).forEach((e=>{xd.creasePattern[e]={stroke:vd[e]}}));const wd=(e,t,n)=>e.setAttribute(`data-${t}`,n);const kd=e=>`M${e[0][0]} ${e[0][1]}L${e[1][0]} ${e[1][1]}`;const Od=e=>e.vertices_coords&&e.edges_vertices?Ks(e).map((e=>kd(e))).join(""):[];const jd=({vertices_coords:e,edges_vertices:t,edges_assignment:n})=>{if(!e||!t){return{}}if(!n){return{U:Od({vertices_coords:e,edges_vertices:t})}}const s=Gt({vertices_coords:e,edges_vertices:t,edges_assignment:n});Object.keys(s).forEach((e=>{if(!s[e].length){delete s[e]}}));const r={};Object.keys(s).forEach((n=>{const o=Od({vertices_coords:e,edges_vertices:s[n].map((e=>t[e]))});r[n]=ld.path(o)}));return r};const Fd=e=>{const t=_a(e);Object.keys(t).filter((e=>At[e]!==undefined)).forEach((e=>delete t[e]));return t};const Sd=e=>{const t={boolean:true,number:true,string:true};const n=_a(e);Object.keys(n).filter((e=>!t[typeof n[e]])).forEach((e=>delete n[e]));return n};const Cd=(e,t)=>{const n=Lt(e)?"foldedForm":"creasePattern";const s=_a(Ad[n]);const r=_a(xd[n]);const o=Sd(Fd(t));Object.assign(s,o);Mt.forEach((e=>{r[e]={...r[e],...o}}));return{groupStyle:s,edgeStyle:r}};const Vd=(e,t={})=>{const n=ld.g();if(!e){return n}const{groupStyle:s,edgeStyle:r}=Cd(e,t);const o=jd(e);Object.keys(o).forEach((e=>{Pi(o[e],At[e]);ud(o[e],r[e]);ud(o[e],t[e]);ud(o[e],t[At[e]])}));ud(n,s);Object.keys(o).forEach((e=>n.appendChild(o[e])));Object.keys(o).forEach((e=>wd(o[e],"assignment",e)));Object.keys(o).forEach((e=>wd(o[e],"foldAngle",xt[e])));return n};const Pd=e=>Math.abs(e)/180;const Td=(e,t={})=>{const n=ld.g();if(!e){return n}const{groupStyle:s,edgeStyle:r}=Cd(e,t);const o={};Array.from(new Set(Mt.map((e=>e.toUpperCase())))).forEach((e=>{const n=ld.g();Pi(n,At[e]);ud(n,r[e]);ud(n,t[e]);ud(n,t[At[e]]);o[e]=n}));const c=Ks(e).map((e=>ld.line(e[0][0],e[0][1],e[1][0],e[1][1])));if(e.edges_foldAngle){e.edges_foldAngle.forEach(((e,t)=>wd(c[t],"foldAngle",e)))}if(e.edges_assignment){e.edges_assignment.forEach(((e,t)=>wd(c[t],"assignment",e)))}if(e.edges_foldAngle){c.forEach(((t,n)=>{const s=e.edges_foldAngle[n];if(s===undefined||s===null||s===0||s===180||s===-180){return}t.setAttributeNS(null,"opacity",Pd(s))}))}if(e.edges_assignment){c.forEach(((t,n)=>{const s=e.edges_assignment[n]||"U";o[s].appendChild(t)}))}else{c.forEach((e=>o.U.appendChild(e)))}Object.keys(o).filter((e=>o[e].childNodes.length)).forEach((e=>n.appendChild(o[e])));ud(n,s);return n};const zd=(e,t)=>St(e)?Vd(e,t):Td(e,t);const Nd=e=>{const t=ln(e.flat());const n=[];t.forEach((e=>{n[e]=[]}));e.forEach((e=>{n[e[1]].push(e[0])}));const s=[];const r={};const o=e=>{if(r[e]){return}r[e]=true;n[e].forEach(o);s.push(e)};t.forEach(o);return s};const Bd=Object.freeze({__proto__:null,topologicalSort:Nd});const $d=(e,t)=>{const n={};t.forEach((e=>{n[e]=true}));return e.filter((e=>n[e[0]]&&n[e[1]]))};const Rd=({faceOrders:e,faces_normal:t},n)=>{if(!e||!e.length){return[]}if(!t){throw new Error("linearizeFaceOrders: faces_normal required")}const s=ln(e.flatMap((e=>[e[0],e[1]])));const r=n!==undefined&&s.includes(n)?t[n]:t[s[0]];const o=[];s.forEach((e=>{o[e]=D(t[e],r)>0}));const c=e.map((e=>e[2]===-1^!o[e[1]]?[e[0],e[1]]:[e[1],e[0]]));return Nd(c)};const Ld=({faces_vertices:e},t)=>{if(!e){return t}const n=e.map(((e,t)=>t)).filter((e=>t[e]==null));return n.concat(kn(t))};const Id=({vertices_coords:e,faces_vertices:t,faceOrders:n,faces_layer:s,faces_normal:r},o)=>{if(!r){r=Fs({vertices_coords:e,faces_vertices:t})}if(n){return Ld({faces_vertices:t},kn(Rd({faceOrders:n,faces_normal:r},o)))}if(s){return Ld({faces_vertices:t},s)}return t.map(((e,t)=>t)).filter((()=>true))};const Ud=({vertices_coords:e,faces_vertices:t,faceOrders:n,faces_normal:s})=>{if(!s){s=Fs({vertices_coords:e,faces_vertices:t})}const r=Xc(Bs({edges_vertices:n.map((e=>[e[0],e[1]]))}));const o=wn(r);const c=o.map((e=>$d(n,e))).map((e=>Rd({faceOrders:e,faces_normal:s})));const a=o.map((e=>s[e[0]]));const i=[];c.forEach(((e,t)=>e.forEach(((e,n)=>{i[e]={vector:a[t],layer:n}}))));return i};const Qd=({faces_layer:e})=>{const t=[];const n=kn(e);n.forEach(((e,n)=>{t[e]={vector:[0,0,1],layer:n}}));return t};const Dd=({vertices_coords:e,faces_vertices:t,faceOrders:n,faces_normal:s})=>{if(!s){s=Fs({vertices_coords:e,faces_vertices:t})}return kn(Rd({faceOrders:n,faces_normal:s}))};const qd=Object.freeze({__proto__:null,faceOrdersSubset:$d,linearize2DFaces:Id,linearizeFaceOrders:Rd,makeFacesLayer:Dd,nudgeFacesWithFaceOrders:Ud,nudgeFacesWithFacesLayer:Qd});const Wd=["front","back"];const Gd={foldedForm:{ordered:{back:{fill:"white"},front:{fill:"#ddd"}},unordered:{back:{opacity:.1},front:{opacity:.1}}},creasePattern:{}};const Hd={foldedForm:{ordered:{stroke:"black","stroke-linejoin":"bevel"},unordered:{stroke:"none",fill:"black","stroke-linejoin":"bevel"}},creasePattern:{fill:"none"}};const Jd=(e,t,n,s={})=>{const r=Lt(e);const o=!!(e.faceOrders||e.faces_layer);const c=Ic(e);c.map((e=>e?Wd[0]:Wd[1])).forEach(((e,n)=>{Pi(t[n],e);t[n].setAttribute("data-side",e);const c=o?Gd.foldedForm.ordered[e]:Gd.foldedForm.unordered[e];const a=r?c:Gd.creasePattern[e];ud(t[n],a);ud(t[n],s[e])}));Id(e).forEach((e=>n.appendChild(t[e])));const a=o?Hd.foldedForm.ordered:Hd.foldedForm.unordered;ud(n,r?a:Hd.creasePattern);return n};const Zd=(e,t)=>{const n=e.faces_vertices.map((t=>t.map((t=>[0,1].map((n=>e.vertices_coords[t][n])))))).map((e=>ld.polygon(e)));n.forEach(((e,t)=>e.setAttributeNS(null,"index",t)));return Jd(e,n,ld.g(),t)};const Yd=function(e,t){const n=e.faces_edges.map((t=>t.map((t=>e.edges_vertices[t])).map(((e,t,n)=>{const s=n[(t+1)%n.length];return e[1]===s[0]||e[1]===s[1]?e[0]:e[1]})).map((t=>[0,1].map((n=>e.vertices_coords[t][n])))))).map((e=>ld.polygon(e)));n.forEach(((e,t)=>e.setAttributeNS(null,"index",t)));return Jd(e,n,ld.g(),t)};const Xd=(e,t)=>{if(e&&e.vertices_coords&&e.faces_vertices){return Zd(e,t)}if(e&&e.vertices_coords&&e.edges_vertices&&e.faces_edges){return Yd(e,t)}return ld.g()};const Kd={fill:"none"};const eu={stroke:"black",fill:"white"};const tu=(e,t={})=>{const n=ld.g();if(!e){return n}const s=[aa(e).polygon].filter((e=>e.length));s.forEach((e=>{const t=ld.polygon(e);Pi(t,"boundary");n.appendChild(t)}));ud(n,Lt(e)?Kd:eu);ud(n,t);return n};const nu={vertices:hd,edges:zd,faces:Xd,boundaries:tu,edgesPaths:Vd,edgesLines:Td,facesVerticesPolygon:Zd,facesEdgesPolygon:Yd};const su=1/50;const ru={min:[0,0],span:[1,1]};const ou=["boundaries","faces","edges","vertices"];const cu=(e,t)=>{if(t.vertices===undefined){t.vertices=false}if(!Lt(e)){if(t.faces===undefined){t.faces=false}}};const au=(e,t,n,s)=>{const r=t[3]&&t[3].childNodes.length;if(!r&&(s.strokeWidth===undefined||s.strokeWidth===false)&&(s.viewBox===undefined||s.viewBox===false)){return}const o=ra(n)||ru;const c=Math.max(...o.span);const a=Ci(e,"svg");if(a&&s.viewBox){const e=md(o);a.setAttributeNS(null,"viewBox",e)}if(a&&s.padding){const e=a.getAttribute("viewBox");if(e!=null){const t=s.padding*c;const n=e.split(" ").map((e=>parseFloat(e)));const r=[-t,-t,t*2,t*2].map(((e,t)=>n[t]+e)).join(" ");a.setAttributeNS(null,"viewBox",r)}}if(s.strokeWidth||s["stroke-width"]){const t=s.strokeWidth?s.strokeWidth:s["stroke-width"];const r=typeof t==="number"?c*t:_d(n);e.setAttributeNS(null,"stroke-width",r)}if(r){const e=s.vertices&&s.vertices.radius!=null?s.vertices.radius:s.radius;const n=typeof e==="string"?parseFloat(e):e;const r=typeof n==="number"&&!Number.isNaN(n)?c*n:c*su;for(let e=0;e<t[3].childNodes.length;e+=1){t[3].childNodes[e].setAttributeNS(null,"r",r)}}};const iu=(e,t={})=>ou.map((n=>t[n]===false?ld.g():nu[n](e,t[n]))).map(((e,t)=>{Pi(e,ou[t]);return e}));const fu=(e,t,n={})=>{cu(e,n);const s=iu(e,n);s.filter((e=>e.childNodes.length>0)).forEach((e=>t.appendChild(e)));au(t,s,e,n);Pi(t,...[e.file_classes||[],e.frame_classes||[]].flat());return t};const lu=(e,t={})=>{const n=fu(typeof e==="string"?JSON.parse(e):e,ld.svg(),{viewBox:true,strokeWidth:true,...t});return t&&t.string?(new(c().XMLSerializer)).serializeToString(n):n};Object.assign(lu,{...nu,render:fu,getViewBox:pd,getStrokeWidth:_d,boundingBoxToViewBox:md});const du=e=>["file_title","file_author","file_description","frame_title","frame_author","frame_description"].filter((t=>e[t])).map((t=>`# ${t.split("_")[1]}: ${e[t]}`)).join("\n");const uu=e=>{const t=typeof e==="string"?JSON.parse(e):e;const n=du(t);const s=(t.vertices_coords||[]).map((e=>e.join(" "))).map((e=>`v ${e}`)).join("\n");const r=(t.faces_vertices||[]).map((e=>e.map((e=>e+1)).join(" "))).map((e=>`f ${e}`)).join("\n");const o=[n,s,r].filter((e=>e!=="")).join("\n");return`${o}\n`};const mu={};mu.prototype=Object.create(Object.prototype);mu.prototype.constructor=mu;Object.entries({clean:br,populate:Po,subgraph:mc,boundary:aa,boundaries:ia,planarBoundary:fa,planarBoundaries:la,boundingBox:ra,nearest:Xr,splitEdge:Qo,splitFace:lc,invertAssignments:Wt,svg:lu,obj:uu,...Mr,...nn,...Ec}).forEach((([e,t])=>{mu.prototype[e]=function(){return t(this,...arguments)}}));mu.prototype.clone=function(){return Object.assign(Object.create(Object.getPrototypeOf(this)),_a(this))};mu.prototype.planarize=function(){const e=So(this);this.clear();Object.assign(this,e);return this};mu.prototype.clear=function(){_.graph.forEach((e=>delete this[e]));_.orders.forEach((e=>delete this[e]));delete this.file_frames;return this};mu.prototype.folded=function(){const e=this.faces_matrix2?Oc(this,this.faces_matrix2):ua(this,...arguments);Object.assign(this,{vertices_coords:e,frame_classes:["foldedForm"]});return this};mu.prototype.flatFolded=function(){const e=this.faces_matrix2?Oc(this,this.faces_matrix2):ma(this,...arguments);Object.assign(this,{vertices_coords:e,frame_classes:["foldedForm"]});return this};mu.prototype.flatFold=function(){Yc(this,p(arguments));return this};const pu=mu.prototype;const gu=(e,t,n,s,r=ht,o=E)=>{const c=K(P(e),P(n));if(Math.abs(c)<o){return undefined}const a=K(e,n);const i=-a;const f=U(s,t);const l=re(f);const d=K(f,n)/a;const u=K(l,e)/i;if(r(u,o/j(n))){return d}return undefined};const _u=(e,t,n)=>R(t,N(e,n));const hu=(e,t,n,s,r)=>e.map(((e,t,n)=>[U(n[(t+1)%n.length],e),e])).map((e=>gu(t,n,e[0],e[1],s,r))).filter((e=>e!==undefined)).sort(((e,t)=>e-t));const vu=(e,t,n)=>{let s=0;let r=e.length-1;while(s<r){if(t(e[s+1]-e[s],n)){break}s+=1}while(r>s){if(t(e[r]-e[r-1],n)){break}r-=1}if(s>=r){return undefined}return[e[s],e[r]]};const bu=(e,{vector:t,origin:n},s=dt,r=mt,o=E)=>{const c=hu(e,t,n,ht,o);if(c.length<2){return undefined}const a=o*2/j(t);const i=vu(c,s,a);if(i===undefined){return undefined}const f=e=>{if(r(e)){return e}return e<.5?0:1};const l=i.map(f);if(Math.abs(l[0]-l[1])<o*2/j(t)){return undefined}const d=_u(t,n,(l[0]+l[1])/2);return Ur(e,d,s,o)?l.map((e=>_u(t,n,e))):undefined};const yu=(e,t,n=E)=>{const s=(e,t,s)=>(s[0]-t[0])*(e[1]-t[1])>(s[1]-t[1])*(e[0]-t[0])+n;const r=(e,t,n,s)=>{const r=U(e,t);const o=U(s,n);const c=K(e,t);const a=K(s,n);const i=1/K(r,o);return N(U(N(o,c),N(r,a)),i)};let o=e;let c=t[t.length-1];for(let e=0;e<t.length;e+=1){const n=t[e];const a=o;o=[];let i=a[a.length-1];for(let e=0;e<a.length;e+=1){const t=a[e];if(s(t,c,n)){if(!s(i,c,n)){o.push(r(c,n,t,i))}o.push(t)}else if(s(i,c,n)){o.push(r(c,n,t,i))}i=t}c=n}return o.length===0?undefined:o};const Eu=Object.freeze({__proto__:null,clipLineConvexPolygon:bu,clipPolygonPolygon:yu});const Mu=(e,{vector:t,origin:n},s)=>{if(e.length<2){return e}const r=e.map((e=>U(e[1],e[0]))).map((e=>q(e,t)<s));e.map(((e,t)=>t)).filter((e=>r[e])).forEach((t=>{e[t]=[e[t][1],e[t][0]]}));const o=P(t);const c=e.map((e=>e.map((e=>q(U(e,n),o))))).sort(((e,t)=>e[0]-t[0]));const a=[[c[0][0],c[0][1]]];for(let e=1;e<c.length;e+=1){const t=c[e];if(t[0]-s<a[a.length-1][1]+s){a[a.length-1][1]=Math.max(t[1],a[a.length-1][1])}else{a.push([t])}}return a.map((e=>e.map((e=>R(n,N(o,e))))))};const Au=(e,t,n,s=mt,r=E)=>{const o=t.map((t=>e.faces_vertices[t].map((t=>e.vertices_coords[t])))).map((e=>bu(e,n,dt,s,r))).filter((e=>e!==undefined));return Mu(o,n,r)};const xu=(e,t,n=E)=>{const s=oc(e,t,n);return Au(e,s,t,mt,n)};const wu=(e,t,n=E)=>{const s=cc(e,t,n);return Au(e,s,t,gt,n)};const ku=(e,t,n=E)=>{const s=U(t[1],t[0]);const r=t[0];const o=ac(e,t,n);return Au(e,o,{vector:s,origin:r},ht,n)};const Ou=Object.freeze({__proto__:null,clipLine:xu,clipRay:wu,clipSegment:ku});const ju=(e,t,n=E)=>{if(!e.vertices_coords){e.vertices_coords=[]}if(typeof t[0]==="number"){t=[t]}const s=t.map((t=>e.vertices_coords.map((e=>te(e,t)<n)).map(((e,t)=>e?t:undefined)).filter((e=>e!==undefined)).shift()));let r=e.vertices_coords.length;const o=t.filter(((e,t)=>s[t]===undefined));e.vertices_coords.push(...o);return s.map((e=>e===undefined?r++:e))};const Fu=(e,t,n)=>{const s=Array.from(Array(t.length-1)).map(((e,n)=>[t[n],t[n+1]]));const r=s.map((e=>e.join(" "))).map((e=>n[e]===undefined));const o=s.filter(((e,t)=>r[t]));const c=Array.from(Array(o.length)).map(((t,n)=>e.edges_vertices.length+n));c.forEach(((t,n)=>{e.edges_vertices[t]=o[n]}));if(e.edges_assignment){c.forEach((t=>{e.edges_assignment[t]="U"}))}if(e.edges_foldAngle){c.forEach((t=>{e.edges_foldAngle[t]=0}))}for(let n=0;n<t.length;n+=1){const s=t[n];const o=r[n-1]?t[n-1]:undefined;const c=r[n]?t[n+1]:undefined;const a=[o,c].filter((e=>e!==undefined));const i=e.vertices_vertices[s]?e.vertices_vertices[s]:[];const f=i.concat(a);e.vertices_vertices[s]=ks(e,f,t[n])}const a=Ls(e);for(let n=0;n<t.length;n+=1){const s=t[n];e.vertices_edges[s]=e.vertices_vertices[s].map((e=>a[`${s} ${e}`]))}t.map((t=>e.vertices_vertices[t].length===1?[x]:is(e.vertices_vertices[t].map((n=>U(e.vertices_coords[n],e.vertices_coords[t])))))).forEach(((n,s)=>{e.vertices_sectors[t[s]]=n}));return c};const Su=(e,t,n,s=E)=>{if(!e.vertices_sectors){e.vertices_sectors=Ds(e)}const r=[t,n].map((e=>[e[0],e[1]]));const o=U(r[1],r[0]);const c=Nc(e,r[0],r[1],s);const a=c.map(((e,t)=>t)).filter(mt);const i={};a.forEach((t=>e.edges_faces[t].forEach((e=>{i[e]=true}))));const f=Object.keys(i).map((e=>parseInt(e,10))).sort(((e,t)=>e-t));const l=a.reverse().map((t=>Qo(e,t,c[t],s)));const d=l.map((e=>e.vertex));const u=ju(e,r,s);const m={};d.forEach((e=>{m[e]=true}));u.forEach((e=>{m[e]=true}));const p=Object.keys(m).map((e=>parseInt(e,10)));const g=Os(e,p,o);const _=Ls(e);const h=Fu(e,g,_);h.forEach((t=>{const n=e.edges_vertices[t];_[`${n[0]} ${n[1]}`]=t;_[`${n[1]} ${n[0]}`]=t}));const v=g.map((t=>e.vertices_vertices[t].map((e=>[[e,t],[t,e]])))).reduce(((e,t)=>e.concat(t)),[]).reduce(((e,t)=>e.concat(t)),[]);const b={};const y=v.map((t=>gs(e,t[0],t[1],b))).filter((e=>e!==undefined));const M=hs(y);Nn(e,"faces",f);const A=M.map(((t,n)=>e.faces_vertices.length+n));if(e.faces_vertices){A.forEach(((t,n)=>{e.faces_vertices[t]=M[n].vertices}))}if(e.faces_edges){A.forEach(((t,n)=>{e.faces_edges[t]=M[n].edges.map((e=>_[e]))}))}if(e.faces_angles){A.forEach(((t,n)=>{e.faces_angles[t]=M[n].faces_angles}))}if(e.vertices_faces){e.vertices_faces=Rs(e)}if(e.edges_faces){e.edges_faces=Ws(e)}if(e.faces_faces){e.faces_faces=cr(e)}if(e.vertices_coords.length!==e.vertices_vertices.length||e.vertices_coords.length!==e.vertices_edges.length||e.vertices_coords.length!==e.vertices_faces.length){console.warn("vertices mismatch",JSON.parse(JSON.stringify(e)))}if(e.edges_vertices.length!==e.edges_faces.length||e.edges_vertices.length!==e.edges_assignment.length){console.warn("edges mismatch",JSON.parse(JSON.stringify(e)))}if(e.faces_vertices.length!==e.faces_edges.length||e.faces_vertices.length!==e.faces_faces.length){console.warn("faces mismatch",JSON.parse(JSON.stringify(e)))}return h};const Cu=({vertices_vertices:e},t)=>{const n=[t[1],t[0]];t.map(((t,s)=>e[t].indexOf(n[s]))).forEach(((n,s)=>e[t[s]].splice(n,1)))};const Vu=({vertices_edges:e},t,n)=>{n.map(((n,s)=>e[n].indexOf(t))).forEach(((t,s)=>e[n[s]].splice(t,1)))};const Pu=(e,t,n,s)=>{const r=t.map((t=>e.faces_edges[t].indexOf(n)));const o=[];t.forEach(((t,n)=>e.faces_vertices[t].forEach(((e,t,r)=>{const c=r[(t+1)%r.length];if(e===s[0]&&c===s[1]||e===s[1]&&c===s[0]){o[n]=t}}))));if(o[0]===undefined||o[1]===undefined){console.warn("removePlanarEdge error joining faces")}const c=t.map((t=>e.faces_edges[t].length));const a=t.map((t=>e.faces_vertices[t].length));const i=c.map((e=>e-1));const f=a.map((e=>e-1));const l=r.map(((e,t)=>(e+1)%c[t]));const d=o.map(((e,t)=>(e+1)%a[t]));const u=t.map(((t,n)=>Array.from(Array(i[n])).map(((e,t)=>(l[n]+t)%c[n])).map((n=>e.faces_edges[t][n]))));const m=t.map(((t,n)=>Array.from(Array(f[n])).map(((e,t)=>(d[n]+t)%a[n])).map((n=>e.faces_vertices[t][n]))));const p=t.map((t=>e.faces_faces[t])).reduce(((e,t)=>e.concat(t)),[]).filter((e=>e!==t[0]&&e!==t[1]));return{vertices:m[0].concat(m[1]),edges:u[0].concat(u[1]),faces:p}};const Tu=(e,t)=>{const n=[...e.edges_vertices[t]].sort(((e,t)=>t-e));const s=[...e.edges_faces[t]];Cu(e,n);Vu(e,t,n);const r=n.map((t=>e.vertices_vertices[t].length===0));const o=n.filter(((e,t)=>r[t]));if(s.length===2&&s[0]!==s[1]){const r=e.faces_vertices.length;const o=Pu(e,s,t,n);e.faces_vertices.push(o.vertices);e.faces_edges.push(o.edges);e.faces_faces.push(o.faces);e.vertices_faces.forEach(((t,n)=>{let o=false;t.forEach(((c,a)=>{if(c===s[0]||c===s[1]){e.vertices_faces[n][a]=r;const s=o?[n,1]:[n,1,r];t.splice(...s);o=true}}))}));e.edges_faces.forEach(((t,n)=>t.forEach(((t,o)=>{if(t===s[0]||t===s[1]){e.edges_faces[n][o]=r}}))));e.faces_faces.forEach(((t,n)=>t.forEach(((t,o)=>{if(t===s[0]||t===s[1]){e.faces_faces[n][o]=r}}))));e.faces_vertices.forEach((t=>t.forEach((t=>{if(t===undefined){console.log("FOUND ONE before remove",e.faces_vertices)}}))));Nn(e,"faces",s)}if(s.length===2&&s[0]===s[1]&&o.length){const n=s[0];e.faces_vertices[n]=e.faces_vertices[n].filter((e=>!o.includes(e))).filter(((e,t,n)=>e!==n[(t+1)%n.length]));e.faces_edges[n]=e.faces_edges[n].filter((e=>e!==t))}Nn(e,"edges",[t]);Nn(e,"vertices",o)};const zu=(e,t)=>{const n=e.vertices_edges[t];const s=ln(e.vertices_faces[t].filter((e=>e!=null)));if(n.length!==2||s.length>2){console.warn("cannot remove non 2-degree vertex yet (e,f)",n,s);return}const r=Eo(e,t,n);const o=r.slice().reverse();n.sort(((e,t)=>e-t));r.forEach((t=>{const s=e.vertices_edges[t].indexOf(n[1]);if(s===-1){return}e.vertices_edges[t][s]=n[0]}));r.forEach(((n,s)=>{const r=e.vertices_vertices[n].indexOf(t);if(r===-1){console.warn("removePlanarVertex unknown vertex issue");return}e.vertices_vertices[n][r]=o[s]}));e.edges_vertices[n[0]]=[...r];s.forEach((n=>{const s=e.faces_vertices[n].indexOf(t);if(s===-1){console.warn("removePlanarVertex unknown face_vertex issue");return}e.faces_vertices[n].splice(s,1)}));s.forEach((t=>{const s=e.faces_edges[t].indexOf(n[1]);if(s===-1){console.warn("removePlanarVertex unknown face_edge issue");return}e.faces_edges[t].splice(s,1)}));Nn(e,"vertices",[t]);Nn(e,"edges",[n[1]])};const Nu=e=>[0,1].map((t=>e.filter(((e,n)=>n%2===t)).reduce(((e,t)=>e+t),0)));const Bu=e=>{const t=e.reduce(((e,t)=>e+t),0)/2;return Nu(e).map((e=>e-t))};const $u=e=>e.map(((e,t,n)=>[e,n[(t+1)%n.length]])).map((e=>Zn(...e))).map(((e,t,n)=>n.slice(t+1,n.length).concat(n.slice(0,t)))).map((e=>Nu(e).map((e=>Math.PI-e)))).map(((t,n)=>e[n]+t[0])).map(((t,n)=>Hn(t,e[n],e[(n+1)%e.length])?t:undefined));const Ru=e=>{const t=e.map((e=>Math.atan2(e[1],e[0])));return $u(t).map((e=>e===undefined?undefined:[Math.cos(e),Math.sin(e)]))};const Lu=({vertices_coords:e,vertices_edges:t,edges_assignment:n,edges_vertices:s},r)=>{if(!t){t=Vs({edges_vertices:s})}const o=n?t[r].filter((e=>wt[n[e]])):t[r];if(o.length%2===0){return[]}const c=o.map((e=>s[e][0]===r?s[e]:[s[e][1],s[e][0]]));const a=c.map((t=>t.map((t=>e[t]))));const i=a.map((e=>U(e[1],e[0])));const f=cs(i).map((e=>i[e]));const l=Ru(f);const d=f.map(P);const u=l.filter((e=>e!==undefined)).filter((e=>!d.map((t=>q(e,t))).map((e=>Math.abs(1-e)<.001)).reduce(((e,t)=>e||t),false)));return u};const Iu=Object.freeze({__proto__:null,alternatingSum:Nu,alternatingSumDifference:Bu,kawasakiSolutions:Lu,kawasakiSolutionsRadians:$u,kawasakiSolutionsVectors:Ru});const Uu=({vertices_edges:e,edges_assignment:t})=>e.map((e=>e.map((e=>!wt[t[e]])).reduce(((e,t)=>e&&t),true))).map(((e,t)=>e?t:undefined)).filter((e=>e!==undefined));const Qu=({edges_vertices:e,vertices_edges:t,edges_assignment:n})=>{if(!t){t=Vs({edges_vertices:e})}const s=t.map((e=>e.map((e=>xt[n[e]])).filter((e=>e!==0)).map(Math.sign).reduce(((e,t)=>e+t),0))).map((e=>e===2||e===-2));oa({edges_vertices:e,edges_assignment:n}).forEach((e=>{s[e]=true}));Uu({vertices_edges:t,edges_assignment:n}).forEach((e=>{s[e]=true}));return s.map(((e,t)=>!e?t:undefined)).filter((e=>e!==undefined))};const Du=({vertices_coords:e,vertices_vertices:t,vertices_edges:n,edges_vertices:s,edges_assignment:r},o=E)=>{if(!t){t=Ns({vertices_coords:e,vertices_edges:n,edges_vertices:s})}if(!n){n=Vs({edges_vertices:s})}const c=Qs({vertices_coords:e,vertices_vertices:t,edges_vertices:s}).map(((e,t)=>e.filter(((e,s)=>wt[r[n[t][s]]])))).map((e=>e.length>1?is(e):[0,0])).map((e=>Nu(e))).map((e=>Math.abs(e[0]-e[1])<o));oa({edges_vertices:s,edges_assignment:r}).forEach((e=>{c[e]=true}));Uu({vertices_edges:n,edges_assignment:r}).forEach((e=>{c[e]=true}));return c.map(((e,t)=>!e?t:undefined)).filter((e=>e!==undefined))};const qu=Object.freeze({__proto__:null,validateKawasaki:Du,validateMaekawa:Qu});const Wu={};Wu.prototype=Object.create(pu);Wu.prototype.constructor=Wu;const Gu=function(e){e.valley=t=>this.setValley(e,t);e.mountain=t=>this.setMountain(e,t);e.flat=()=>this.setFlat(e);e.unassigned=()=>this.setUnassigned(e);e.cut=()=>this.setCut(e);return e};Wu.prototype.line=function(...e){const t=p(...e);if(!t){return undefined}const n=xu(this,t);const s=n.flatMap((e=>Su(this,e[0],e[1])));return Gu.call(this,s)};Wu.prototype.ray=function(...e){const t=p(...e);if(!t){return undefined}const n=wu(this,t);const s=n.flatMap((e=>Su(this,e[0],e[1])));return Gu.call(this,s)};Wu.prototype.segment=function(...e){const t=u(...e);if(!t){return undefined}const n=ku(this,t);const s=n.flatMap((e=>Su(this,e[0],e[1])));return Gu.call(this,s)};Wu.prototype.polygon=function(...e){const t=d(...e);if(!t){return undefined}const n=t.map(((e,t,n)=>[e,n[(t+1)%n.length]]));const s=n.flatMap((e=>ku(this,e)));const r=s.flatMap((e=>Su(this,e[0],e[1])));return Gu.call(this,r)};Wu.prototype.removeEdge=function(e){const t=this.edges_vertices[e];Tu(this,e);t.map((e=>Ao(this,e))).map(((e,n)=>e?t[n]:undefined)).filter((e=>e!==undefined)).sort(((e,t)=>t-e)).forEach((e=>zu(this,e)));return true};Wu.prototype.validate=function(e){const t=bc(this);t.vertices.kawasaki=Du(this,e);t.vertices.maekawa=Qu(this);if(this.edges_foldAngle){t.edges.not_flat=this.edges_foldAngle.map(((e,t)=>Ft(e)?undefined:t)).filter((e=>e!==undefined))}if(t.summary==="valid"){if(t.vertices.kawasaki.length||t.vertices.maekawa.length){t.summary="invalid"}else if(t.edges.not_flat.length){t.summary="not flat"}}return t};const Hu=(e,t,n,s)=>{t.forEach((t=>{e.edges_assignment[t]=n;e.edges_foldAngle[t]=s}));return t};Wu.prototype.setValley=function(e=[],t=180){return Hu(this,e,"V",Math.abs(t))};Wu.prototype.setMountain=function(e=[],t=-180){return Hu(this,e,"M",-Math.abs(t))};Wu.prototype.setFlat=function(e=[]){return Hu(this,e,"F",0)};Wu.prototype.setUnassigned=function(e=[]){return Hu(this,e,"U",0)};Wu.prototype.setCut=function(e=[]){return Hu(this,e,"C",0)};Wu.prototype.defer=false;const Ju=Wu.prototype;const Zu=1.2;const Yu="Rabbit Ear";const Xu=(e,t)=>[[0,0],[e,0],[e,t],[0,t]];const Ku=e=>({vertices_coords:e,edges_vertices:e.map(((e,t,n)=>[t,(t+1)%n.length])),edges_assignment:Array(e.length).fill("B"),faces_vertices:[e.map(((e,t)=>t))],faces_edges:[e.map(((e,t)=>t))]});const em=(e=1)=>Po(Ku(Xu(e,e)));const tm=(e=1,t=1)=>Po(Ku(Xu(e,t)));const nm=(e=3,t=1)=>Po(Ku(Ze(e,t)));const sm=()=>Po({vertices_coords:[[0,0],[1,0],[1,Math.SQRT2-1],[1,1],[Math.SQRT2-1,1],[0,1]],edges_vertices:[[0,1],[1,2],[2,3],[3,4],[4,5],[5,0],[0,2],[0,4],[0,3]],edges_assignment:Array.from("BBBBBBVVF")});const rm=()=>Po({vertices_coords:[[0,0],[Math.SQRT1_2,0],[1,0],[1,1-Math.SQRT1_2],[1,1],[1-Math.SQRT1_2,1],[0,1],[0,Math.SQRT1_2],[.5,.5],[Math.SQRT1_2,1-Math.SQRT1_2],[1-Math.SQRT1_2,Math.SQRT1_2]],edges_vertices:[[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,0],[9,0],[9,2],[9,4],[10,0],[10,6],[10,4],[9,1],[10,7],[9,3],[10,5],[8,0],[8,9],[8,4],[8,10]],edges_assignment:Array.from("BBBBBBBBVVVVVVMMFFFFFF")});const om=()=>Po({vertices_coords:[[0,0],[.5,0],[1,0],[1,.5],[1,1],[.5,1],[0,1],[0,.5],[.5,.5],[.5,(Math.SQRT2-1)/2],[(3-Math.SQRT2)/2,.5],[.5,(3-Math.SQRT2)/2],[(Math.SQRT2-1)/2,.5],[Math.SQRT1_2/2,Math.SQRT1_2/2],[1-Math.SQRT1_2/2,1-Math.SQRT1_2/2]],edges_vertices:[[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,0],[0,9],[9,2],[2,10],[10,4],[4,11],[11,6],[6,12],[12,0],[1,9],[9,8],[3,10],[10,8],[5,11],[11,8],[7,12],[12,8],[2,8],[6,8],[0,13],[13,8],[13,9],[13,12],[4,14],[14,8],[14,10],[14,11]],edges_assignment:Array.from("BBBBBBBBVVVVVVVVMVMVMVMVMMFFFFFFFF")});const cm=()=>Po({vertices_coords:[[0,1],[0,Math.SQRT1_2],[0,.5],[0,1-Math.SQRT1_2],[0,0],[.5,.5],[1,1],[(1-Math.SQRT1_2)/2,Math.SQRT1_2/2],[Math.SQRT1_2/2,(1-Math.SQRT1_2)/2],[1-Math.SQRT1_2,0],[.5,0],[Math.SQRT1_2,0],[1,0],[.5,(1-Math.SQRT1_2)/2],[1-Math.SQRT1_2/2,(1-Math.SQRT1_2)/2],[(1-Math.SQRT1_2)/2,1-Math.SQRT1_2/2],[(1-Math.SQRT1_2)/2,.5],[(1+Math.SQRT1_2)/2,1-Math.SQRT1_2/2],[1,Math.SQRT1_2],[Math.SQRT1_2,1],[1-Math.SQRT1_2/2,(1+Math.SQRT1_2)/2],[Math.SQRT1_2/2,(1+Math.SQRT1_2)/2],[.5,1],[1,.5],[(1+Math.SQRT1_2)/2,Math.SQRT1_2/2],[.5,(1+Math.SQRT1_2)/2],[(1+Math.SQRT1_2)/2,.5],[1-Math.SQRT1_2,1],[1,1-Math.SQRT1_2]],edges_vertices:[[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[4,7],[4,8],[4,9],[9,10],[10,11],[11,12],[8,13],[13,14],[15,16],[16,7],[3,7],[7,5],[5,17],[17,18],[19,20],[20,5],[5,8],[8,9],[2,15],[14,10],[21,22],[23,24],[10,8],[7,2],[12,14],[0,15],[22,25],[25,5],[5,13],[13,10],[2,16],[16,5],[5,26],[26,23],[6,17],[6,20],[11,14],[14,5],[5,21],[21,27],[28,24],[24,5],[5,15],[15,1],[12,5],[5,0],[20,25],[25,21],[24,26],[26,17],[12,24],[0,21],[12,28],[28,23],[23,18],[18,6],[6,19],[19,22],[22,27],[27,0],[22,20],[17,23]],edges_assignment:Array.from("BBBBFFVVBBBBMMMMFVVFFVVFVVVVVVVVVMMVVMMVVVFVVFFVVFMMMMMMVVBBBBBBBBVV")});const am=()=>Po({vertices_coords:[[0,0],[.25,0],[.5,0],[.75,0],[1,0],[0,1],[0,.75],[0,.5],[0,.25],[.25,.25],[.5,.5],[.75,.75],[1,1],[.25,1],[.25,.75],[.25,.5],[1,.25],[.75,.25],[.5,.25],[.5,1],[1,.5],[.5,.75],[.75,.5],[.75,1],[1,.75]],edges_vertices:[[0,1],[1,2],[2,3],[3,4],[5,6],[6,7],[7,8],[8,0],[0,9],[9,10],[10,11],[11,12],[13,14],[14,15],[15,9],[9,1],[16,17],[17,18],[18,9],[9,8],[7,14],[14,19],[20,17],[17,2],[2,9],[9,7],[19,21],[21,10],[10,18],[18,2],[20,22],[22,10],[10,15],[15,7],[4,17],[17,10],[10,14],[14,5],[23,11],[11,22],[22,17],[17,3],[6,14],[14,21],[21,11],[11,24],[12,23],[23,19],[19,13],[13,5],[4,16],[16,20],[20,24],[24,12],[19,11],[11,20]],edges_assignment:Array.from("BBBBBBBBVFFVFVVFFVVFMFMFMFFFFFFFFFVFFVFVVFFVVFBBBBBBBBMF")});const im=()=>Po({vertices_coords:[[0,0],[2-Math.SQRT2,0],[1,0],[0,1],[0,2-Math.SQRT2],[.5,.5],[Math.SQRT1_2,Math.SQRT1_2],[1,1],[Math.SQRT1_2,1-Math.SQRT1_2],[1,Math.SQRT2-1],[1-Math.SQRT1_2,Math.SQRT1_2],[Math.SQRT2-1,1],[Math.SQRT1_2,1],[1,Math.SQRT1_2]],edges_vertices:[[0,1],[1,2],[3,4],[4,0],[0,5],[5,6],[6,7],[0,8],[8,9],[0,10],[10,11],[8,1],[10,4],[8,6],[6,12],[3,10],[10,5],[5,8],[8,2],[10,6],[6,13],[7,12],[12,11],[11,3],[11,6],[6,9],[2,9],[9,13],[13,7]],edges_assignment:Array.from("BBBBFFFVFVFMMVVVFFVVVBBBMMBBB")});const fm=Object.freeze({__proto__:null,bird:om,fish:rm,frog:cm,kite:sm,polygon:nm,rectangle:tm,square:em,squareFish:im,windmill:am});const lm=(...e)=>Object.assign(Object.create(pu),{...e.reduce(((e,t)=>({...e,...t})),{}),file_spec:Zu,file_creator:Yu});const dm=(...e)=>Object.assign(Object.create(Ju),{...e.length?e.reduce(((e,t)=>({...e,...t})),{}):em(),file_spec:Zu,file_creator:Yu,frame_classes:["creasePattern"]});const um=(...e)=>Po(lm(...e));um.prototype=pu;um.prototype.constructor=um;const mm=(...e)=>Po(dm(...e));mm.prototype=Ju;mm.prototype.constructor=mm;Object.keys(fm).forEach((e=>{um[e]=(...t)=>lm(fm[e](...t));mm[e]=(...t)=>dm(fm[e](...t))}));const pm=e=>e<0?-((-e)**(1/3)):e**(1/3);const gm=(e,t,n,s,r)=>{switch(e){case 1:return[-r/s];case 2:{const e=s**2-4*n*r;if(e<-E){return[]}const t=-s/(2*n);if(e<E){return[t]}const o=Math.sqrt(e)/(2*n);return[t+o,t-o]}case 3:{const e=n/t;const o=s/t;const c=r/t;const a=(3*o-e**2)/9;const i=(9*e*o-27*c-2*e**3)/54;const f=a**3+i**2;const l=-e/3;if(f>0){const e=Math.sqrt(f);const t=pm(i+e);const n=pm(i-e);return[l+t+n]}if(Math.abs(f)<E){const e=i**(1/3);if(i<0){return[]}return[l+2*e,l-e]}const d=Math.sqrt(-f);const u=Math.atan2(d,i)/3;const m=(i**2-f)**(1/6);const p=m*Math.cos(u);const g=m*Math.sin(u);return[l+2*p,l-p-Math.sqrt(3)*g,l-p+Math.sqrt(3)*g]}default:return[]}};const _m=(e,t)=>{const n=K(e.normal,t.normal);if(Math.abs(n)<E){return undefined}const s=e.distance*t.normal[1]-t.distance*e.normal[1];const r=t.distance*e.normal[0]-e.distance*t.normal[0];return[s/n,r/n]};const hm=(e,t)=>[{vector:P(U(...ue(t,e))),origin:e}];const vm=(e,t)=>{const n=P(oe(U(t,e)));return[{normal:n,distance:q(R(e,t),n)/2}]};const bm=(e,t)=>[{vector:P(oe(U(...ue(t,e)))),origin:H(e,t)}];const ym=(e,t)=>{const n=P(U(t,e));return[{normal:n,distance:q(R(e,t),n)/2}]};const Em=(e,t)=>Cr(e,t);const Mm=(e,t)=>{const n=_m(e,t);return n===undefined?[{normal:e.normal,distance:(e.distance+t.distance*q(e.normal,t.normal))/2}]:[R,U].map((n=>P(n(e.normal,t.normal)))).map((e=>({normal:e,distance:q(n,e)})))};const Am=(e,t)=>[{vector:oe(P(e.vector)),origin:t}];const xm=(e,t)=>{const n=oe(e.normal);const s=q(t,n);return[{normal:n,distance:s}]};const wm=(e,t,n)=>(to({radius:ne(t,n),origin:t},e)||[]).map((e=>({vector:P(oe(U(...ue(e,n)))),origin:H(n,e)})));const km=(e,t,n)=>{const s=q(t,e.normal);const r=e.distance-s;const o=ne(t,n);if(r>o){return[]}const c=Math.sqrt(o*o-r*r);const a=N(e.normal,r);const i=R(t,a);const f=N(oe(e.normal),c);const l=c<E?[i]:[R(i,f),U(i,f)];return l.map((e=>P(U(n,e)))).map((e=>({normal:e,distance:q(t,e)})))};const Om=(e,t,n,s)=>jm(qn(e),qn(t),n,s).map(Wn);const jm=(e,t,n,s)=>{if(Math.abs(1-q(e.normal,n)/e.distance)<.02){return[]}const r=oe(e.normal);const o=U(R(n,N(e.normal,e.distance)),N(s,2));const c=U(N(e.normal,e.distance),n);const a=q(s,t.normal)-t.distance;const i=2*q(c,r);const f=q(c,c);const l=q(R(o,c),r);const d=q(o,c);const u=q(r,t.normal);const m=q(c,t.normal);const p=u;const g=a+l*u+m;const _=a*i+d*u+l*m;const h=a*f+d*m;let v=0;if(Math.abs(_)>E){v=1}if(Math.abs(g)>E){v=2}if(Math.abs(p)>E){v=3}return gm(v,p,g,_,h).map((t=>R(N(e.normal,e.distance),N(r,t)))).map((e=>({p:e,normal:P(U(e,n))}))).map((e=>({normal:e.normal,distance:q(e.normal,H(e.p,n))})))};const Fm=(e,t,n)=>{const s=eo(e,{vector:t.vector,origin:n},mt,mt).point;return s===undefined?[]:[{vector:P(oe(U(...ue(s,n)))),origin:H(n,s)}]};const Sm=(e,t,n)=>{const s=oe(e.normal);const r=q(s,t.normal);if(Math.abs(r)<E){return undefined}const o=q(n,s);const c=q(n,t.normal);const a=(t.distance+2*o*r-c)/(2*r);return[{normal:s,distance:a}]};const Cm=(e,...t)=>[null,hm,bm,Em,Am,wm,Om,Fm][e](...t);const Vm=(e,...t)=>[null,vm,ym,Mm,xm,km,jm,Sm][e](...t);const Pm=Object.freeze({__proto__:null,axiom:Cm,axiom1:hm,axiom2:bm,axiom3:Em,axiom4:Am,axiom5:wm,axiom6:Om,axiom7:Fm,normalAxiom:Vm,normalAxiom1:vm,normalAxiom2:ym,normalAxiom3:Mm,normalAxiom4:xm,normalAxiom5:km,normalAxiom6:jm,normalAxiom7:Sm});const Tm=(e,t)=>{const n=je(e.vector,e.origin);return be(n,t)};const zm=(e,t,n,s)=>[[n,s].map((t=>Ur(e,t,dt))).reduce(((e,t)=>e&&t),true)];const Nm=zm;const Bm=(e,t,n,s)=>{const r=[n,s].map((t=>bu(e,t,dt,mt)));if(r[0]===undefined||r[1]===undefined){return[false,false]}const o=t.map((t=>t===undefined?undefined:bu(e,t,dt,mt)));const c=[0,1].map((e=>o[e]!==undefined));const a=t.map((e=>e===undefined?undefined:[Tm(e,r[0][0]),Tm(e,r[0][1])]));const i=a.map((e=>e===undefined?false:Rr({vector:I(r[1][1],r[1][0]),origin:r[1][0]},e[0],ht)||Rr({vector:I(r[1][1],r[1][0]),origin:r[1][0]},e[1],ht)||Rr({vector:I(e[1],e[0]),origin:e[0]},r[1][0],ht)||Rr({vector:I(e[1],e[0]),origin:e[0]},r[1][1],ht)));return[0,1].map((e=>i[e]===true&&c[e]===true))};const $m=(e,t,n,s)=>{const r=eo(n,{vector:oe(n.vector),origin:s},mt,mt).point;return[[s,r].filter((e=>e!==undefined)).map((t=>Ur(e,t,dt))).reduce(((e,t)=>e&&t),true)]};const Rm=(e,t,n,s,r)=>{if(t.length===0){return[]}const o=[s,r].map((t=>Ur(e,t,dt))).reduce(((e,t)=>e&&t),true);const c=t.map((e=>Tm(e,r))).map((t=>Ur(e,t,dt)));return c.map((e=>e&&o))};const Lm=function(e,t,n,s,r,o){if(t.length===0){return[]}const c=[r,o].map((t=>Ur(e,t,dt))).reduce(((e,t)=>e&&t),true);if(!c){return t.map((()=>false))}const a=t.map((e=>Tm(e,r))).map((t=>Ur(e,t,dt)));const i=t.map((e=>Tm(e,o))).map((t=>Ur(e,t,dt)));return t.map(((e,t)=>a[t]&&i[t]))};const Im=(e,t,n,s,r)=>{const o=Ur(e,r,dt);if(!t.length){return[false]}const c=Tm(t[0],r);const a=Ur(e,c,dt);const i=ao(e,s,ht,mt)!==undefined;const f=eo(s,t[0],mt,mt).point;const l=f?Ur(e,f,dt):false;return[o&&a&&i&&l]};const Um=(e,t,n,...s)=>[null,zm,Nm,Bm,$m,Rm,Lm,Im][e](t,n,...s);const Qm=Object.freeze({__proto__:null,validateAxiom:Um,validateAxiom1:zm,validateAxiom2:Nm,validateAxiom3:Bm,validateAxiom4:$m,validateAxiom5:Rm,validateAxiom6:Lm,validateAxiom7:Im});const Dm=e=>e.map((e=>typeof e==="object"&&e.vector?Wn(e):e));const qm=(e,t,...n)=>{const s=Cm(e,...n);Um(e,t,s,...n).map(((e,t)=>!e?t:undefined)).filter((e=>e!==undefined)).forEach((e=>delete s[e]));return s};const Wm=(e,t,...n)=>{const s=Vm(e,...n).map(Wn);Um(e,t,s,...Dm(n)).map(((e,t)=>!e?t:undefined)).filter((e=>e!==undefined)).forEach((e=>delete s[e]));return s};const Gm=Object.freeze({__proto__:null,axiomWithBoundary:qm,normalAxiomWithBoundary:Wm});const Hm={...Pm,...Gm,...Qm};const Jm=()=>{const e={};e.file_spec=Zu;e.file_creator=Yu;e.file_classes=["singleModel"];e.frame_classes=[];e.frame_attributes=[];e.vertices_coords=[];e.faces_vertices=[];return e};const Zm=e=>{if(!e.edges_foldAngle||!e.edges_foldAngle.length){return}let t=true;for(let n=0;n<e.edges_foldAngle.length;n+=1){if(e.edges_foldAngle[n]!==0&&e.edges_foldAngle[n]!==-180&&e.edges_foldAngle[n]!==180){t=false;break}}e.frame_classes.push(t?"creasePattern":"foldedForm");e.frame_attributes.push(t?"2D":"3D")};const Ym=e=>e.map(((e,t,n)=>[e,n[(t+1)%n.length]]));const Xm=({faces_vertices:e})=>{const t={};const n=[];e.flatMap(Ym).forEach((e=>{const s=[e.join(" "),`${e[1]} ${e[0]}`];if(s[0]in t||s[1]in t){return}n.push(e);t[s[0]]=true}));return n};const Km=e=>e.slice(1).map((e=>parseInt(e,10)-1));const ep=e=>e.slice(1).map((e=>parseFloat(e)));const tp=e=>{const t=e.split("\n").map((e=>e.trim().split(/\s+/)));const n=Jm();for(let e=0;e<t.length;e+=1){switch(t[e][0].toLowerCase()){case"f":n.faces_vertices.push(Km(t[e]));break;case"v":n.vertices_coords.push(ep(t[e]));break}}n.faces_normal=Fs(n);n.faces_center=lr(n);n.edges_vertices=Xm(n);n.faces_edges=or(n);n.edges_faces=Ws(n);n.edges_foldAngle=Xs(n);n.edges_assignment=Zs(n);n.vertices_vertices=zs(n);delete n.faces_normal;delete n.faces_center;delete n.edges_faces;Zm(n);return n};const np=(e,t)=>{const n=So(e,t);n.vertices_vertices=Ns(n);const s=sr(n);n.faces_vertices=s.faces_vertices;n.faces_edges=s.faces_edges;delete n.vertices_edges;return n};const sp=({vertices_coords:e,edges_vertices:t})=>{const n=t.map((t=>t.map((t=>e[t])))).map((e=>te(...e))).filter((e=>e>1e-4));const s=n.reduce(((e,t)=>Math.min(e,t)),Infinity);return s===Infinity?undefined:s};const rp=({vertices_coords:e,edges_vertices:t})=>{const n=sp({vertices_coords:e,edges_vertices:t});const s=ra({vertices_coords:e});const r=s&&s.span?Math.max(...s.span):1;const o=r*.01;const c=n/20;return n===undefined?o:Math.min(o,c)};const op=function(e){const t=`${e}`.match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);return Math.max(0,(t[1]?t[1].length:0)-(t[2]?+t[2]:0))};const cp=function(e,t=15){const n=typeof e==="number"?e:parseFloat(e);if(Number.isNaN(n)){return e}const s=parseFloat(n.toFixed(t));if(op(s)===Math.min(t,op(n))){return n}return s};const ap=Object.freeze({__proto__:null,cleanNumber:cp});const ip=(e,t,n="epsilon")=>{if(typeof t==="object"&&typeof t[n]==="number"){return t[n]}return typeof t==="number"?t:rp(e)};const fp=e=>{const t=ra({vertices_coords:e});const n=t.min[1]+t.span[1]/2;const s=Math.min(-t.min[1],-t.max[1]);const r=Math.max(-t.min[1],-t.max[1]);const o=r-s;const c=s+o/2;const a=n-c;const i=cp(a,8);for(let t=0;t<e.length;t+=1){e[t][1]=-e[t][1]+i}};const lp=(e,t)=>e==null?null:Array.from(e.childNodes).filter((e=>e.attributes&&e.attributes.length)).filter((e=>Array.from(e.attributes).filter((e=>e.nodeValue===t)).shift()!==undefined)).shift();const dp=(e,t)=>{const n=lp(e,t);const s=n?Array.from(n.childNodes).shift():null;return s?s.textContent:undefined};const up=e=>{const t=lp(e,"lines");const n=t?Array.from(t.childNodes).filter((e=>e.getAttribute)).filter((e=>e.getAttribute("class").split(" ").includes("oripa.OriLineProxy"))).shift():undefined;return n?Array.from(n.childNodes):[]};const mp=e=>e.filter((e=>e.nodeName==="void")).filter((e=>e.childNodes)).map((e=>lp(e,"oripa.OriLineProxy"))).filter((e=>e)).map((e=>["type","x0","x1","y0","y1"].map((t=>lp(e,t))).map((e=>e?Array.from(e.childNodes):[])).map((e=>e.filter((e=>e.nodeName==="double"||e.nodeName==="int")).shift())).map((e=>e&&e.childNodes[0]?e.childNodes[0].data:"0")).map(parseFloat)));const pp=["F","B","M","V","U"];const gp=e=>{const t={};t.vertices_coords=e.flatMap((e=>[[e[1],e[3]],[e[2],e[4]]]));t.edges_vertices=e.map(((e,t)=>[t*2,t*2+1]));t.edges_assignment=e.map((e=>pp[e[0]]));t.edges_foldAngle=Ys(t);return t};const _p=e=>{const t=Fi(e,"text/xml");const n=Array.from(t.childNodes).filter((e=>e.getAttribute)).filter((e=>e.getAttribute("class").split(" ").includes("oripa.DataSet"))).shift();return gp(mp(up(n)))};const hp=(e,t)=>{const n={file_description:"memo",file_author:"originalAuthorName",file_title:"title"};Object.keys(n).forEach((t=>{n[t]=dp(e,n[t])}));Object.keys(n).filter((e=>n[e])).forEach((e=>{t[e]=n[e]}));t.file_classes=["singleModel"];t.frame_classes=["creasePattern"]};const vp=(e,t)=>{const n=Fi(e,"text/xml");const s=n&&n.childNodes?Array.from(n.childNodes):[];const r=s.filter((e=>e.getAttribute)).filter((e=>e.getAttribute("class").split(" ").includes("oripa.DataSet"))).shift();const o=gp(mp(up(r)));if(t&&t.invertVertical&&o.vertices_coords){fp(o.vertices_coords)}const c=ip(o,t);const a=np(o,c);hp(r,a);return a};Object.assign(vp,{opxEdgeGraph:_p});const bp=(e,t)=>{const n=ai(e).toUpperCase();return t&&t[n]?t[n]:Ed(...ci(e))};const yp=(e,t)=>{switch(t){case"M":case"m":return-180*e;case"V":case"v":return 180*e;default:return 0}};const Ep=(e,t)=>{const n=c().getComputedStyle!=null?c().getComputedStyle(e).stroke:"";if(n!==""&&n!=="none"){return n}if(t.stroke!==undefined){return t.stroke}return undefined};const Mp=(e,t)=>{const n=c().getComputedStyle!=null?c().getComputedStyle(e).opacity:"";if(n!==""){const e=parseFloat(n);if(!Number.isNaN(e)){return e}}if(t.opacity!==undefined){const e=parseFloat(t.opacity);if(!Number.isNaN(e)){return e}}return undefined};const Ap=Object.freeze({__proto__:null,colorToAssignment:bp,getEdgeOpacity:Mp,getEdgeStroke:Ep,opacityToFoldAngle:yp});const xp=(e,t)=>t.map((t=>e.getAttribute(t))).map((e=>e==null?0:e)).map(parseFloat);const wp=e=>[xp(e,["x1","y1","x2","y2"])];const kp=function(e){const[t,n,s,r]=xp(e,["x","y","width","height"]);return[[t,n,t+s,n],[t+s,n,t+s,n+r],[t+s,n+r,t,n+r],[t,n+r,t,n]]};const Op=e=>{const t=e.split(/[\s,]+/).map(parseFloat);return Array.from(Array(Math.floor(t.length/2))).map(((e,n)=>[t[n*2+0],t[n*2+1]]))};const jp=e=>Op(e.getAttribute("points")||"").map(((e,t,n)=>[n[t][0],n[t][1],n[(t+1)%n.length][0],n[(t+1)%n.length][1]]));const Fp=function(e){const t=jp(e);t.pop();return t};const Sp={L:true,V:true,H:true,Z:true};const Cp=e=>Hi(e.getAttribute("d")||"").filter((e=>Sp[e.command.toUpperCase()])).map((e=>[e.start,e.end])).filter((e=>!lt(...e))).map((e=>e.flat()));const Vp={line:wp,rect:kp,polygon:jp,polyline:Fp,path:Cp};const Pp=(e,t)=>{const n=[[e[0],e[1]],[e[2],e[3]]];if(!t){return n}const s=Oi(t);return s?n.map((e=>be(s,e))):n};const Tp=e=>Ri(e).filter((e=>Vp[e.element.nodeName])).flatMap((e=>Vp[e.element.nodeName](e.element).map((t=>Pp(t,e.attributes.transform))).map((t=>({...e,segment:t})))));const zp=e=>{if(!c().document.body){return undefined}const t=c().document.createElement("div");t.setAttribute("display","none");c().document.body.appendChild(t);t.appendChild(e);return t};const Np=e=>Ti(e).map((e=>e.nodeName==="style")).reduce(((e,t)=>e||t),false);const Bp=e=>{const s=typeof e==="string"?Fi(e,"image/svg+xml"):e;if(Np(s)&&t){console.warn(n.backendStylesheet)}const r=Si(s)===c().document?undefined:zp(s);const o=Tp(s);o.map((e=>({data:{assignment:e.attributes["data-assignment"],foldAngle:e.attributes["data-foldAngle"]},stroke:Ep(e.element,e.attributes),opacity:Mp(e.element,e.attributes)}))).forEach(((e,t)=>{o[t]={...o[t],...e}}));if(r&&r.parentNode){r.parentNode.removeChild(r)}return o};const $p=e=>{if(!e||!e.assignments){return undefined}const t={};Object.keys(e.assignments).forEach((n=>{const s=ai(n).toUpperCase();t[s]=e.assignments[n]}));return t};const Rp=(e,t="#f0f",n=undefined)=>{if(e){return e}return bp(t,n)};const Lp=(e,t=1,n=undefined)=>{if(e){return parseFloat(e)}return yp(t,n)};const Ip=(e,t)=>{const n=$p(t);if(n){e.forEach((e=>{delete e.data.assignment;delete e.data.foldAngle}))}const s=e.map((e=>Rp(e.data.assignment,e.stroke,n)));const r=e.map(((e,t)=>Lp(e.data.foldAngle,e.opacity,s[t])));return{edges_assignment:s,edges_foldAngle:r}};const Up=(e,t)=>{const n=Bp(e);const{edges_assignment:s,edges_foldAngle:r}=Ip(n,t);const o=t&&t.fast?e=>e:cp;const c=n.flatMap((e=>e.segment)).map((e=>e.map((e=>o(e,12)))));const a=n.map(((e,t)=>[t*2,t*2+1]));return{vertices_coords:c,edges_vertices:a,edges_assignment:s,edges_foldAngle:r}};const Qp=(e,t)=>{const n=Up(e,t);const s=ip(n,t);if(t&&t.invertVertical&&n.vertices_coords){fp(n.vertices_coords)}const r=np(n,s);const o=t&&t.fast?e=>e:cp;r.vertices_coords=r.vertices_coords.map((e=>e.map((e=>o(e,12)))));if(typeof t!=="object"||t.boundary!==false){r.edges_assignment.map(((e,t)=>t)).filter((e=>r.edges_assignment[e]==="B"||r.edges_assignment[e]==="b")).forEach((e=>{r.edges_assignment[e]="F"}));const{edges:e}=fa(r);e.forEach((e=>{r.edges_assignment[e]="B"}))}return{file_spec:1.1,file_creator:"Rabbit Ear",frame_classes:["creasePattern"],...r}};Object.assign(Qp,{...Ap,svgSegments:Bp,svgEdgeGraph:Up,planarizeGraph:np,makeEpsilon:rp});const Dp={objToFold:tp,opxToFold:vp,svgToFold:Qp,foldToSvg:lu,foldToObj:uu};const qp=e=>e.replace(/([-_][a-z])/gi,(e=>e.toUpperCase().replace("-","").replace("_","")));const Wp=e=>e.replace(/([a-z0-9])([A-Z])/g,"$1-$2").replace(/([A-Z])([A-Z])(?=[a-z])/g,"$1-$2").toLowerCase();const Gp=e=>e.charAt(0).toUpperCase()+e.slice(1);const Hp=Object.freeze({__proto__:null,capitalized:Gp,toCamel:qp,toKebab:Wp});const Jp={...vn,...mo,...g,...ap,...ws,...Hp};const Zp=(e,t=0)=>{if(!e.file_frames||e.file_frames.length<t){return e}const s={};const r={};Vt(e,"file").filter((e=>e!=="file_frames")).forEach((t=>{r[t]=e[t]}));const o=(t,r)=>{if(s[t]){throw new Error(n.graphCycle)}s[t]=true;const c=[t].concat(r);const a=t>0?{...e.file_frames[t-1]}:{...e};return a.frame_inherit&&a.frame_parent!=null?o(a.frame_parent,c):c};const c=o(t,[]).map((t=>{const n=t>0?{...e.file_frames[t-1]}:{...e};["file_frames","frame_parent","frame_inherit"].forEach((e=>delete n[e]));return n})).reduce(((e,t)=>({...e,...t})),r);return _a(c)};const Yp=e=>{if(!e){return[]}if(!e.file_frames||!e.file_frames.length){return[e]}const t={...e};delete t.file_frames;return[t,...e.file_frames]};const Xp=({file_frames:e})=>!e?1:e.length+1;const Kp=(e,t)=>Array.from(Array(Xp(e))).map(((t,n)=>Zp(e,n))).filter((e=>e.frame_classes&&e.frame_classes.includes(t)));const eg=Object.freeze({__proto__:null,countFrames:Xp,flattenFrame:Zp,getFileFramesAsArray:Yp,getFramesByClassName:Kp});const tg=({vertices_coords:e,edges_vertices:t},n,s=E)=>{const r=t=>t.map((t=>e[t])).map((e=>U(e,n.origin))).map((e=>K(n.vector,e))).sort(((e,t)=>Math.abs(t)-Math.abs(e))).map(Math.sign).shift();const o=Bc({vertices_coords:e,edges_vertices:t},n,s,vt);const c={};Tc({vertices_coords:e,edges_vertices:t},n,s).forEach((e=>{c[e]=true}));return t.map(((e,t)=>{if(c[t]===true){return 2}if(o[t].point!==undefined){return 0}return r(e)}))};const ng=({vertices_coords:e,edges_vertices:t,faces_vertices:n,faces_edges:s},r,o=E)=>{if(!s){s=or({edges_vertices:t,faces_vertices:n})}const c=tg({vertices_coords:e,edges_vertices:t},r,o);const a=s.map((e=>e.map((e=>c[e])).filter((e=>e!==2))));const i=a.map((e=>e.includes(0)));const f=a.map(((e,t)=>i[t]?false:e.reduce(((t,n)=>t&&n===e[0]),true)));return f.map(((e,t)=>e?a[t][0]:0))};const sg=({vertices_coords:e,edges_vertices:t,faces_vertices:n,faces_edges:s,faceOrders:r},o,c=E)=>{if(!r){throw new Error("faceOrders required")}const a=ng({vertices_coords:e,edges_vertices:t,faces_vertices:n,faces_edges:s},o,c);const i=[-1,1].map((e=>a.map(((e,t)=>({s:e,f:t}))).filter((t=>t.s===e||t.s===0)).map((e=>e.f))));const f=i.map((e=>$d(r,e)));console.log("facesSide",a);console.log("sidesFaces",i);console.log("sidesFaceOrders",f);const l=Fs({vertices_coords:e,faces_vertices:n});const d=f.map((e=>Rd({faceOrders:e,faces_normal:l})));console.log("sidesLayersFace",d)};const rg=Object.freeze({__proto__:null,getEdgesSide:tg,getFacesSide:ng,getFlapsThroughLine:sg});const og=({vertices_coords:e},{vector:t,origin:n},s=mt,r=E)=>{const o=C(t);const c=Math.sqrt(o);if(c<r){return e.map((()=>false))}return e.map((e=>U(e,n))).map((e=>Math.abs(K(e,t))<r&&s(q(e,t)/o,r/c)))};const cg=({vertices_coords:e,edges_vertices:t},n,s=mt,r=E)=>{if(!e||!t){return{vertices:[],edges:{collinear:[],intersected:[]}}}const o=og({vertices_coords:e},n,s,r);const c=t.map((e=>o[e[0]]+o[e[1]]));const a=t.map((t=>t.map((t=>e[t])))).map(((e,t)=>c[t]===0?eo(Dn(...e),n,ht,s):{}));a.map(((e,t)=>t)).filter((e=>!a[e].point)).forEach((e=>delete a[e]));const i=c.map((e=>e===2));return{vertices:o,edges:{collinear:i,intersected:a}}};const ag=({vertices_coords:e,edges_vertices:t,faces_vertices:n,faces_edges:s},r,o=mt,c=E)=>{const{vertices:a,edges:{collinear:i,intersected:f}}=cg({vertices_coords:e,edges_vertices:t},r,o,c);if(!n){return{vertices:a,edges:{collinear:i,intersected:f},faces:{edges:[],vertices:[]}}}if(!s){s=or({edges_vertices:t,faces_vertices:n})}const l=s.map((e=>e.filter((e=>i[e]))));const d=s.map((e=>e.filter((e=>f[e]))));const u=n.map((e=>e.filter((e=>a[e]))));const m=n.map(((e,t)=>{if(l[t].length){return undefined}const n=d[t];const s=u[t];return n.length+s.length?{edges:n,vertices:s}:undefined}));Object.keys(m).filter((e=>m[e]===undefined)).forEach((e=>delete m[e]));return{faces:m,edges:{intersected:f,collinear:i.map(((e,t)=>e?t:undefined)).filter((e=>e!==undefined))},vertices:a.map(((e,t)=>e?t:undefined)).filter((e=>e!==undefined))}};const ig=(e,t,n=E)=>ag(e,t,mt,n);const fg=(e,t,n=E)=>ag(e,t,gt,n);const lg=(e,t,n=E)=>ag(e,Dn(...t),ht,n);const dg=Object.freeze({__proto__:null,intersectEdgesLineFunc:cg,intersectGraphLine:ig,intersectGraphLineFunc:ag,intersectGraphRay:fg,intersectGraphSegment:lg,intersectVerticesLineFunc:og});const ug=(e,t)=>{const n=Object.keys(yt);const s=Ut(t);const r=Ut(e);const o={};n.forEach((e=>{const n=Vt(t,e).shift();o[e]=n!==undefined?t[n]:[]}));const c={};n.forEach((t=>{c[t]=cn(e,t)}));const a={vertices:[],edges:[],faces:[]};n.forEach((e=>o[e].forEach(((t,n)=>{a[e][n]=c[e]++}))));const i=_a(t);n.forEach((e=>On(i,e,a[e])));Object.keys(i).filter((e=>i[e].constructor===Array)).filter((t=>!(t in e))).forEach((t=>{e[t]=[]}));Object.keys(i).filter((e=>i[e].constructor===Array)).forEach((t=>i[t].forEach(((n,s)=>{e[t][s]=n}))));const f={};const l={};n.forEach((t=>{const n=Vt(e,t).shift();l[t]=n!==undefined?e[n]:[]}));n.forEach((e=>{const t=l[e].map((()=>0));a[e].forEach((e=>{t[e]=1}));f[e]=wn(t)}));const d=s!==r?(e.vertices_coords||[]).map(((e,t)=>e.length===2?t:undefined)).filter((e=>e!==undefined)):[];d.forEach((t=>{e.vertices_coords[t][2]=0}));return f};const mg=Object.freeze({__proto__:null,join:ug});const pg=({vertices_coords:e,edges_vertices:t},n)=>Dn(...t[n].map((t=>e[t])));const gg=({vertices_coords:e,edges_vertices:t},n,s,r,o=E)=>{const c=pg({vertices_coords:e,edges_vertices:t},n);const a=pg({vertices_coords:e,edges_vertices:t},s);const i=er({vertices_coords:e,edges_vertices:t}).map(((n,s)=>({vector:n,origin:e[t[s][0]]})));return Sr(c,a,r,o).map((e=>e.map((e=>{const t=i.map((t=>eo(e,t,mt,ht,o).a)).filter((e=>e!==undefined));if(t.length<2){return undefined}const n=Math.min(...t);const s=Math.max(...t);return Math.abs(s-n)<o?undefined:[R(e.origin,N(e.vector,n)),R(e.origin,N(e.vector,s))]})).filter((e=>e!==undefined))))};const _g=Object.freeze({__proto__:null,pleat:gg});const hg=(e,t=E)=>nr(e,t).map((t=>e.vertices_coords.map((e=>e[0]>t.min[0]&&e[1]>t.min[1]&&e[0]<t.max[0]&&e[1]<t.max[1]))));const vg=({vertices_coords:e,edges_vertices:t,edges_coords:n},s=E)=>{const r=nr({vertices_coords:e,edges_vertices:t,edges_coords:n},s);const o=t.map((()=>[]));for(let e=0;e<t.length-1;e+=1){for(let n=e+1;n<t.length;n+=1){const t=(r[e].max[0]<r[n].min[0]||r[n].max[0]<r[e].min[0])&&(r[e].max[1]<r[n].min[1]||r[n].max[1]<r[e].min[1]);o[e][n]=!t;o[n][e]=!t}}for(let e=0;e<t.length;e+=1){o[e][e]=true}return o};const bg=Object.freeze({__proto__:null,getEdgesEdgesOverlapingSpans:vg,getEdgesVerticesOverlappingSpan:hg});const yg=({vertices_coords:e,edges_vertices:t,faces_vertices:n,faces_edges:s},r,o=[],c=mt,a=E)=>{if(!e||!t||!n){return undefined}const{faces:i,edges:f}=ag({vertices_coords:e,edges_vertices:t,faces_vertices:n,faces_edges:s},r,c,a);if(o.length){i.forEach(((t,s)=>{const r=n[s].map((t=>e[t]));const c=o.map((e=>({...Qr(r,e),point:e}))).filter((e=>e.overlap));i[s].points=c}))}i.forEach(((e,t)=>{const n=i[t].points?i[t].vertices.length+i[t].edges.length+i[t].points.length:i[t].vertices.length+i[t].edges.length;if(n!==2){delete i[t]}}));let l=e.length;const d=[];const u=[];const m=[];const p=[];f.intersected.forEach((({a:e,b:t,point:n},s)=>{m[l]=s;u[l]={a:e,b:t,point:n,edge:s};d[l++]=n}));i.forEach((({points:e},t)=>e.forEach((e=>{p[l]=t;u[l]={...e,face:t};d[l++]=e.point}))));const g=An(m);const _=wn(p);let h=t.length;const v=[];i.forEach(((e,t)=>{const n=e.edges.map((e=>g[e]));const s=_[t];v[h++]=n.concat(s).concat(e.vertices).filter((e=>e!==undefined))}));return{vertices_coords:d,vertices_overlapInfo:u,edges_vertices:v,collinear_edges:f.collinear}};const Eg=(e,t,n=E)=>yg(e,t,[],mt,n);const Mg=(e,t,n=E)=>yg(e,t,[t.origin],gt,n);const Ag=(e,t,n=E)=>yg(e,Dn(...t),t,ht,n);const xg=Object.freeze({__proto__:null,splitGraphLineFunction:yg,splitLineWithGraph:Eg,splitRayWithGraph:Mg,splitSegmentWithGraph:Ag});const wg=({normal:e,distance:t})=>t<0?{normal:re(e),distance:-t}:{normal:e,distance:t};const kg=(e,t=E)=>{const{lines:n}=ko(e,t);const s=n.map(qn).map(wg);const r=n.map((({vector:e,origin:t})=>je(e,t)));const o=r.map((e=>n.map((({vector:t,origin:n})=>ye(e,t,n)))));const c=o.map((e=>e.map((e=>e.vector[0]<0?{vector:re(e.vector),origin:e.origin}:e)))).map((e=>e.map(qn).map(wg))).map((e=>e.concat(s)));const a=c.map((e=>lo(e.map((e=>e.distance)))));const i=a.map(((e,n)=>e.map((e=>e.map((e=>c[n][e].normal)))).map((e=>uo(e,t)))));const f=i.map(((e,t)=>e.flatMap(((e,n)=>e.map((e=>e.map((e=>a[t][n][e]))))))));const l=f.map((e=>(e.length-n.length)/n.length));return l.map(((e,t)=>({error:e,i:t}))).map((e=>({line:n[e.i],error:e.error}))).sort(((e,t)=>e.error-t.error))};const Og=(e,t=E)=>kg(e,t)[0];const jg=Object.freeze({__proto__:null,findSymmetryLine:Og,findSymmetryLines:kg});const Fg=(e,t)=>{if(e[0]===undefined||e[1]===undefined||e[2]===undefined){return undefined}const n=N(U(e[1],e[0]),1/ne(e[1],e[0]));const s=q(n,U(e[2],e[0]));const r=N(n,s);const o=U(U(e[2],e[0]),r);const c=N(o,1/j(o));const a=ne(e[1],e[0]);const i=q(c,U(e[2],e[0]));const f=(t[0]**2-t[1]**2+a**2)/(2*a);const l=(t[0]**2-t[2]**2+s**2+i**2)/(2*i)-s*f/i;return R(R(e[0],N(n,f)),N(c,l))};const Sg=(e,t,n)=>{const s=t[0]-e[0];const r=t[1]-e[1];const o=n[0]-e[0];const c=n[1]-e[1];const a=s*(e[0]+t[0])+r*(e[1]+t[1]);const i=o*(e[0]+n[0])+c*(e[1]+n[1]);const f=2*(s*(n[1]-t[1])-r*(n[0]-t[0]));if(Math.abs(f)<E){const s=Math.min(e[0],t[0],n[0]);const r=Math.min(e[1],t[1],n[1]);const o=(Math.max(e[0],t[0],n[0])-s)*.5;const c=(Math.max(e[1],t[1],n[1])-r)*.5;return{origin:[s+o,r+c],radius:Math.sqrt(o*o+c*c)}}const l=[(c*a-r*i)/f,(s*i-o*a)/f];const d=l[0]-e[0];const u=l[1]-e[1];return{origin:l,radius:Math.sqrt(d*d+u*u)}};const Cg=Object.freeze({__proto__:null,circumcircle:Sg,trilateration:Fg});const Vg=(e,t,n,s)=>{const r=e.faces_vertices[n];if(r.length<3){return s}let o=r.map((t=>e.vertices_coords[t]));let c=r.map((e=>t.vertices_coords[e]));if(kr(o[0],o[1],o[2])){o=nt(o)}if(kr(c[0],c[1],c[2])){c=nt(c)}const a=o.map((e=>ne(e,s)));return Fg(c,a)};const Pg=(e,t,n,s)=>{const r=t.edges_vertices[n].map((e=>t.vertices_coords[e]));const o=Dn(...r);return R(o.origin,N(o.vector,s))};const Tg=Object.freeze({__proto__:null,transferPointBetweenGraphs:Vg,transferPointOnEdgeBetweenGraphs:Pg});const zg=e=>Array.from(Array(e.length-2)).map(((t,n)=>[e[0],e[n+1],e[n+2]]));const Ng=({faces_vertices:e})=>e.flatMap((e=>e.length<4?[e]:zg(e)));const Bg=e=>e.length===3?[e]:Array.from(Array(Math.floor(e.length/3))).map(((t,n)=>[n*3+0,n*3+1,n*3+2].map((t=>e[t]))));const $g=({vertices_coords:e,faces_vertices:t},s)=>{if(!e||!e.length){throw new Error(n.nonConvexTriangulation)}const r=e.filter((()=>true)).shift().length;return t.map((t=>t.flatMap((t=>e[t])))).map((e=>s(e,null,r))).map(((e,n)=>e.map((e=>t[n][e])))).flatMap((e=>Bg(e)))};const Rg=e=>{if(!e.edges_vertices){e.edges_vertices=[]}const t=Ls(e);let n=e.edges_vertices.length;const s=[];e.faces_edges=e.faces_vertices.map((e=>e.map(((e,r,o)=>{const c=[e,o[(r+1)%o.length]];const a=c.join(" ");if(a in t){return t[a]}s.push(c);t[a]=n;t[c.reverse().join(" ")]=n;return n++}))));const r=s.length;e.edges_vertices.push(...s);if(e.edges_assignment){e.edges_assignment.push(...Array(r).fill("J"))}if(e.edges_foldAngle){e.edges_foldAngle.push(...Array(r).fill(0))}if(e.vertices_vertices){delete e.vertices_vertices}if(e.vertices_edges){delete e.vertices_edges}if(e.vertices_faces){delete e.vertices_faces}if(e.edges_faces){delete e.edges_faces}if(e.faces_faces){delete e.faces_faces}if(e.faceOrders){delete e.faceOrders}return e};const Lg=({faces_vertices:e})=>{let t=0;return e.map((e=>Math.max(3,e.length))).map((e=>Array.from(Array(e-2)).map((()=>t++))))};const Ig=(e,t)=>{if(!e.faces_vertices){return{}}const n=e.edges_vertices?e.edges_vertices.length:0;const s=Lg(e);e.faces_vertices=t?$g(e,t):Ng(e);Rg(e);const r=Array.from(Array(e.edges_vertices.length-n)).map(((e,t)=>n+t));return{faces:{map:s},edges:{new:r}}};const Ug=Object.freeze({__proto__:null,triangulate:Ig,triangulateConvexFacesVertices:Ng,triangulateNonConvexFacesVertices:$g});const Qg=Object.freeze([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);const Dg=e=>Qg.map(((t,n)=>Math.abs(t-e[n])<E)).reduce(((e,t)=>e&&t),true);const qg=(e,t)=>[e[0]*t[0]+e[4]*t[1]+e[8]*t[2]+e[12],e[1]*t[0]+e[5]*t[1]+e[9]*t[2]+e[13],e[2]*t[0]+e[6]*t[1]+e[10]*t[2]+e[14]];const Wg=(e,t,n)=>({vector:[e[0]*t[0]+e[4]*t[1]+e[8]*t[2],e[1]*t[0]+e[5]*t[1]+e[9]*t[2],e[2]*t[0]+e[6]*t[1]+e[10]*t[2]],origin:[e[0]*n[0]+e[4]*n[1]+e[8]*n[2]+e[12],e[1]*n[0]+e[5]*n[1]+e[9]*n[2]+e[13],e[2]*n[0]+e[6]*n[1]+e[10]*n[2]+e[14]]});const Gg=(e,t)=>[e[0]*t[0]+e[4]*t[1]+e[8]*t[2]+e[12]*t[3],e[1]*t[0]+e[5]*t[1]+e[9]*t[2]+e[13]*t[3],e[2]*t[0]+e[6]*t[1]+e[10]*t[2]+e[14]*t[3],e[3]*t[0]+e[7]*t[1]+e[11]*t[2]+e[15]*t[3],e[0]*t[4]+e[4]*t[5]+e[8]*t[6]+e[12]*t[7],e[1]*t[4]+e[5]*t[5]+e[9]*t[6]+e[13]*t[7],e[2]*t[4]+e[6]*t[5]+e[10]*t[6]+e[14]*t[7],e[3]*t[4]+e[7]*t[5]+e[11]*t[6]+e[15]*t[7],e[0]*t[8]+e[4]*t[9]+e[8]*t[10]+e[12]*t[11],e[1]*t[8]+e[5]*t[9]+e[9]*t[10]+e[13]*t[11],e[2]*t[8]+e[6]*t[9]+e[10]*t[10]+e[14]*t[11],e[3]*t[8]+e[7]*t[9]+e[11]*t[10]+e[15]*t[11],e[0]*t[12]+e[4]*t[13]+e[8]*t[14]+e[12]*t[15],e[1]*t[12]+e[5]*t[13]+e[9]*t[14]+e[13]*t[15],e[2]*t[12]+e[6]*t[13]+e[10]*t[14]+e[14]*t[15],e[3]*t[12]+e[7]*t[13]+e[11]*t[14]+e[15]*t[15]];const Hg=e=>{const t=e[10]*e[15]-e[11]*e[14];const n=e[9]*e[15]-e[11]*e[13];const s=e[9]*e[14]-e[10]*e[13];const r=e[8]*e[15]-e[11]*e[12];const o=e[8]*e[14]-e[10]*e[12];const c=e[8]*e[13]-e[9]*e[12];return e[0]*(e[5]*t-e[6]*n+e[7]*s)-e[1]*(e[4]*t-e[6]*r+e[7]*o)+e[2]*(e[4]*n-e[5]*r+e[7]*c)-e[3]*(e[4]*s-e[5]*o+e[6]*c)};const Jg=e=>{const t=Hg(e);if(Math.abs(t)<1e-12||Number.isNaN(t)||!Number.isFinite(e[12])||!Number.isFinite(e[13])||!Number.isFinite(e[14])){return undefined}const n=e[10]*e[15]-e[11]*e[14];const s=e[9]*e[15]-e[11]*e[13];const r=e[9]*e[14]-e[10]*e[13];const o=e[8]*e[15]-e[11]*e[12];const c=e[8]*e[14]-e[10]*e[12];const a=e[8]*e[13]-e[9]*e[12];const i=e[6]*e[15]-e[7]*e[14];const f=e[5]*e[15]-e[7]*e[13];const l=e[5]*e[14]-e[6]*e[13];const d=e[6]*e[11]-e[7]*e[10];const u=e[5]*e[11]-e[7]*e[9];const m=e[5]*e[10]-e[6]*e[9];const p=e[4]*e[15]-e[7]*e[12];const g=e[4]*e[14]-e[6]*e[12];const _=e[4]*e[11]-e[7]*e[8];const h=e[4]*e[10]-e[6]*e[8];const v=e[4]*e[13]-e[5]*e[12];const b=e[4]*e[9]-e[5]*e[8];const y=[+(e[5]*n-e[6]*s+e[7]*r),-(e[1]*n-e[2]*s+e[3]*r),+(e[1]*i-e[2]*f+e[3]*l),-(e[1]*d-e[2]*u+e[3]*m),-(e[4]*n-e[6]*o+e[7]*c),+(e[0]*n-e[2]*o+e[3]*c),-(e[0]*i-e[2]*p+e[3]*g),+(e[0]*d-e[2]*_+e[3]*h),+(e[4]*s-e[5]*o+e[7]*a),-(e[0]*s-e[1]*o+e[3]*a),+(e[0]*f-e[1]*p+e[3]*v),-(e[0]*u-e[1]*_+e[3]*b),-(e[4]*r-e[5]*c+e[6]*a),+(e[0]*r-e[1]*c+e[2]*a),-(e[0]*l-e[1]*g+e[2]*v),+(e[0]*m-e[1]*h+e[2]*b)];const E=1/t;return y.map((e=>e*E))};const Zg=Object.freeze([1,0,0,0,0,1,0,0,0,0,1,0]);const Yg=(e=0,t=0,n=0)=>[...Zg,e,t,n,1];const Xg=(e,t,n,s,r)=>{const o=Math.cos(e);const c=Math.sin(e);const a=[...Qg];a[n*4+n]=o;a[n*4+s]=(r?+1:-1)*c;a[s*4+n]=(r?-1:+1)*c;a[s*4+s]=o;const i=[0,1,2].map((e=>t[e]||0));const f=[...Qg];const l=[...Qg];[12,13,14].forEach(((e,t)=>{f[e]=-i[t];l[e]=i[t]}));return Gg(l,Gg(a,f))};const Kg=(e,t=[0,0,0])=>Xg(e,t,1,2,true);const e_=(e,t=[0,0,0])=>Xg(e,t,0,2,false);const t_=(e,t=[0,0,0])=>Xg(e,t,0,1,true);const n_=(e,t=[0,0,1],n=[0,0,0])=>{const s=[0,1,2].map((e=>n[e]||0));const[r,o,c]=de(3,V(t));const a=Math.cos(e);const i=Math.sin(e);const f=1-a;const l=Yg(-s[0],-s[1],-s[2]);const d=Yg(s[0],s[1],s[2]);return Gg(d,Gg([f*r*r+a,f*o*r+c*i,f*c*r-o*i,0,f*r*o-c*i,f*o*o+a,f*c*o+r*i,0,f*r*c+o*i,f*o*c-r*i,f*c*c+a,0,0,0,0,1],l))};const s_=(e=[1,1,1],t=[0,0,0])=>[e[0],0,0,0,0,e[1],0,0,0,0,e[2],0,e[0]*-t[0]+t[0],e[1]*-t[1]+t[1],e[2]*-t[2]+t[2],1];const r_=(e=1,t=[0,0,0])=>s_([e,e,e],t);const o_=(e,t=[0,0])=>{const n=je(e,t);return[n[0],n[1],0,0,n[2],n[3],0,0,0,0,1,0,n[4],n[5],0,1]};const c_=(e,t,n,s)=>{const r=Math.tan(Math.PI*.5-.5*e);const o=1/(n-s);const c=t<1?r:r/t;const a=t<1?r*t:r;return[c,0,0,0,0,a,0,0,0,0,(n+s)*o,-1,0,0,n*s*o*2,0]};const a_=(e,t,n,s,r,o)=>[2/(t-s),0,0,0,0,2/(e-n),0,0,0,0,2/(r-o),0,(s+t)/(s-t),(n+e)/(n-e),(r+o)/(r-o),1];const i_=(e,t,n)=>{const s=T(Q(e,t));const r=T(ee(n,s));const o=T(ee(s,r));return[r[0],r[1],r[2],0,o[0],o[1],o[2],0,s[0],s[1],s[2],0,e[0],e[1],e[2],1]};const f_=Object.freeze({__proto__:null,determinant4:Hg,identity4x4:Qg,invertMatrix4:Jg,isIdentity4x4:Dg,makeLookAtMatrix4:i_,makeMatrix4ReflectZ:o_,makeMatrix4Rotate:n_,makeMatrix4RotateX:Kg,makeMatrix4RotateY:e_,makeMatrix4RotateZ:t_,makeMatrix4Scale:s_,makeMatrix4Translate:Yg,makeMatrix4UniformScale:r_,makeOrthographicMatrix4:a_,makePerspectiveMatrix4:c_,multiplyMatrices4:Gg,multiplyMatrix4Line3:Wg,multiplyMatrix4Vector3:qg});const l_=(e,t)=>{const n=ee(e,t);const s=[n[0],n[1],n[2],D(e,t)];s[3]+=O(s);return V(s)};const d_=e=>Gg([+e[3],+e[2],-e[1],+e[0],-e[2],+e[3],+e[0],+e[1],+e[1],-e[0],+e[3],+e[2],-e[0],-e[1],-e[2],+e[3]],[+e[3],+e[2],-e[1],-e[0],-e[2],+e[3],+e[0],-e[1],+e[1],-e[0],+e[3],-e[2],+e[0],+e[1],+e[2],+e[3]]);const u_=Object.freeze({__proto__:null,matrix4FromQuaternion:d_,quaternionFromTwoVectors:l_});const m_=({vertices_coords:e,faces_vertices:t},n=E)=>{const s=Fs({vertices_coords:e,faces_vertices:t});const r=t.map((()=>[]));for(let e=0;e<t.length-1;e+=1){for(let o=e+1;o<t.length;o+=1){if(e===o){continue}if(ie(s[e],s[o],n)){r[e].push(o);r[o].push(e)}}}const o=Xc(r);const c=kn(o).map((e=>typeof e==="number"?[e]:e));const a=c.map((e=>s[e[0]]));const i=[];c.forEach(((e,t)=>e.forEach((e=>{i[e]=W(s[e],a[t])>0}))));const f=t.map((t=>e[t[0]])).map((e=>de(3,e)));const l=c.map(((e,t)=>e.map((e=>W(a[t],f[e])))));const d=l.map(((e,t)=>lo(e).map((e=>e.map((e=>c[t][e]))))));const u=d.flatMap(((e,t)=>e.map((()=>[...a[t]]))));const m=d.flat();const p=m.map((e=>e[0])).map((e=>f[e])).map(((e,t)=>W(u[t],e))).map(((e,t)=>B(u[t],e)));const g=m.map(((e,t)=>({normal:u[t],origin:p[t]})));return m.map(((e,t)=>({faces:e,facesAligned:e.map((e=>i[e])),plane:g[t]})))};const p_=(e,t,n,s)=>{const r=e.vertices_coords.map((e=>de(3,e)));const o=t.map((t=>t.faces.map(((n,s)=>t.facesAligned[s]?e.faces_vertices[n]:e.faces_vertices[n].slice().reverse())).map((e=>e.map((e=>r[e])))).map((e=>nt(e,s)))));const c=[];const a=o.map(((e,t)=>e.map((e=>e.map((e=>qg(n[t],e))).map((e=>[e[0],e[1]]))))));t.map((e=>e.faces)).forEach(((e,t)=>e.forEach(((e,n)=>{c[e]=a[t][n]}))));return c};const g_=({vertices_coords:e,faces_vertices:t,faces_faces:n},s=E)=>{if(!n){n=cr({faces_vertices:t})}const r=m_({vertices_coords:e,faces_vertices:t},s);const o=[];r.forEach((e=>e.facesAligned.forEach(((t,n)=>{o[e.faces[n]]=t}))));const c=[0,0,1];const a=r.map((e=>e.plane.normal)).map((e=>{const t=D(e,c);return Math.abs(t+1)<.01?n_(Math.PI,[1,0,0]):d_(l_(e,c))}));const i=p_({vertices_coords:e,faces_vertices:t},r,a,s);const f=r.map((e=>e.faces)).map((e=>dc(n,e)));const l=f.map((e=>Xc(e)));const d=l.map((e=>kn(e).map((e=>e.constructor===Array?e:[e]))));const u=l.map((e=>{const t=e.map(((e,t)=>t));return e.map((n=>t.filter((t=>e[t]!==n))))}));const m=t.map((()=>[]));u.forEach((e=>e.forEach(((e,t)=>{for(let n=0;n<e.length;n+=1){const r=e[n];const o=[t,r].map((e=>i[e]));const c=Dr(...o,s);if(c){m[t][r]=true;m[r][t]=true}}}))));const p=u.map((e=>e.map(((e,t)=>e.filter((e=>m[t][e]))))));const g=[];p.forEach(((e,t)=>{g[t]=[];e.forEach(((e,n)=>{const s=l[t][n];const r=e.map((e=>l[t][e]));if(!g[t][s]){g[t][s]=new Set}r.forEach((e=>{if(!g[t][e]){g[t][e]=new Set}}));r.forEach((e=>{g[t][s].add(e);g[t][e].add(s)}))}))}));g.forEach(((e,t)=>e.forEach(((e,n)=>{g[t][n]=[...e]}))));const _=g.map((e=>kn(Xc(e)).map((e=>e.constructor===Array?e:[e]))));const h=_.flatMap(((e,t)=>e.map((()=>t))));const v=r.map(((e,t)=>_[t].map((e=>e.flatMap((e=>d[t][e]))))));const b=v.flatMap(((e,t)=>e.map((e=>({faces:e,facesAligned:e.map((e=>o[e])),plane:r[t].plane})))));const y=h.map((e=>r[e].plane));const M=h.map((e=>a[e]));const A=b.map((e=>e.faces));const x=kn(A);return{sets_faces:A,sets_plane:y,sets_transformXY:M,faces_set:x,faces_winding:o}};const __=Object.freeze({__proto__:null,coplanarFacesGroups:m_,coplanarOverlappingFacesGroups:g_});const h_=({vertices_coords:e,edges_vertices:t,edges_vector:n},s=E)=>{if(!n){n=er({vertices_coords:e,edges_vertices:t})}const r=n.map((e=>V(e)));const o=t.map((()=>[]));r.forEach(((e,t)=>{r.forEach(((e,n)=>{if(n>=t){return}if(1-Math.abs(D(r[t],r[n]))<s){o[t].push(n);o[n].push(t)}}))}));return o};const v_=({vertices_coords:e,edges_vertices:t,edges_vector:n},s)=>{if(!n){n=er({vertices_coords:e,edges_vertices:t})}const r=t.map((t=>e[t[0]]));const o=n.map(((e,t)=>({vector:e,origin:r[t]})));return h_({vertices_coords:e,edges_vertices:t,edges_vector:n},.001).map(((e,t)=>e.filter((e=>Lr(o[t],o[e],vt,vt,s)))))};const b_=Object.freeze({__proto__:null,makeEdgesEdgesParallelOverlap:v_});const y_=e=>e.map((e=>e.map(((e,t)=>e===true?t:undefined)).filter((e=>e!==undefined))));const E_=({vertices_coords:e,edges_vertices:t,edges_coords:n,edges_boundingBox:s},r=E)=>{if(!n){n=Ks({vertices_coords:e,edges_vertices:t})}if(!s){s=nr({vertices_coords:e,edges_vertices:t,edges_coords:n})}const o=t.map(((e,t)=>t)).shift();const c=Array.from(Array(n.length)).map((()=>[]));if(o===undefined){return y_(c)}const a=s[o].min.length;for(let e=0;e<n.length-1;e+=1){if(!s[e]){continue}for(let t=e+1;t<n.length;t+=1){if(!s[t]){continue}let n=true;for(let o=0;o<a;o+=1){if(!it(s[e].min[o],s[t].min[o],r)||!it(s[e].max[o],s[t].max[o],r)){n=false}}c[e][t]=n;c[t][e]=n}}for(let e=0;e<n.length-1;e+=1){for(let t=e+1;t<n.length;t+=1){if(!c[e][t]){continue}const s=lt(n[e][0],n[t][0],r)&&lt(n[e][1],n[t][1],r);const o=lt(n[e][0],n[t][1],r)&&lt(n[e][1],n[t][0],r);const a=s||o;c[e][t]=a;c[t][e]=a}}return y_(c)};const M_=({vertices_coords:e,edges_vertices:t,edges_vector:n,edges_faces:s,faces_vertices:r},o=E)=>{if(!n){n=er({vertices_coords:e,edges_vertices:t})}const c=t.map((t=>e[t[0]]));const a=t.map((()=>Array.from(Array(r.length))));s.forEach(((e,t)=>e.forEach((e=>{a[t][e]=false}))));const i=t.map((t=>t.map((t=>e[t]))));const f=r.map((t=>t.map((t=>e[t]))));Ic({vertices_coords:e,faces_vertices:r}).map(((e,t)=>!e?t:undefined)).filter((e=>e!==undefined)).forEach((e=>f[e].reverse()));const l=nr({edges_coords:i});const d=f.map((e=>ct(e)));for(let e=0;e<a.length;e+=1){if(!l[e]){continue}for(let t=0;t<a[e].length;t+=1){if(a[e][t]===false){continue}if(!d[t]){continue}if(!qr(d[t],l[e],o)){a[e][t]=false;continue}}}const u=E_({vertices_coords:e,edges_vertices:t,edges_coords:i,edges_boundingBox:l});const m={};for(let e=0;e<a.length;e+=1){if(m[e]){continue}if(!i[e]){continue}for(let t=0;t<a[e].length;t+=1){if(a[e][t]!==undefined){continue}if(!f[t]){continue}const s=i[e].map((e=>Ur(f[t],e,ut,.001))).reduce(((e,t)=>e||t),false);if(s){a[e][t]=true;continue}const r=ao(f[t],{vector:n[e],origin:c[e]},vt,vt,o);if(r){a[e][t]=true;continue}a[e][t]=false}u[e].forEach((t=>{a[t]=a[e].slice();m[t]=true}))}return a.map((e=>e.map(((e,t)=>e?t:undefined)).filter((e=>e!==undefined))))};const A_=Object.freeze({__proto__:null,getEdgesFacesOverlap:M_});const x_=({vertices_coords:e,faces_vertices:t},n=E)=>{const s=ar({vertices_coords:e,faces_vertices:t});const r=s.map((e=>ct(e)));const o=[];const c=[];vo({vertices_coords:e,faces_vertices:t},0,n).forEach((e=>{e.start.forEach((e=>{c[e]=true}));c.forEach(((t,c)=>e.start.forEach((e=>{if(c===e){return}if(!qr(r[c],r[e],n)||!Dr(s[c],s[e],n)){return}if(!o[c]){o[c]=[]}if(!o[e]){o[e]=[]}o[c][e]=true;o[e][c]=true}))));e.end.forEach((e=>delete c[e]))}));return o.map((e=>Object.keys(e).map((e=>parseInt(e,10)))))};const w_=Object.freeze({__proto__:null,getFacesFacesOverlap:x_});const k_=(e,t)=>{if(!e.vertices_coords){e.vertices_coords=[]}const n=e.vertices_coords.length;Vt(e,"vertices").forEach((t=>{e[t][n]=[]}));e.vertices_coords[n]=t;return n};const O_=(e,t=[])=>{if(!e.vertices_coords){e.vertices_coords=[]}const n=e.vertices_coords.length;Vt(e,"vertices").forEach((s=>{t.forEach(((t,r)=>{e[s][n+r]=[]}))}));t.forEach(((t,s)=>{e.vertices_coords[n+s]=t}));return t.map(((e,t)=>n+t))};const j_=(e,t)=>{if(t.length!==2){return undefined}if(!e.edges_vertices){e.edges_vertices=[]}const n=e.edges_vertices.length;Vt(e,"edges").forEach((t=>{e[t][n]=[]}));e.edges_vertices[n]=t;if(e.edges_assignment){e.edges_assignment[n]="U"}if(e.edges_foldAngle){e.edges_foldAngle[n]=0}if(e.vertices_edges){t.forEach((t=>{e.vertices_edges[t]=e.vertices_edges[t].filter((e=>e!==n));e.vertices_edges[t].push(n)}))}if(e.vertices_vertices){const n=[t[1],t[0]];t.forEach(((t,s)=>{e.vertices_vertices[t]=e.vertices_vertices[t].filter((e=>e!==n[s]));e.vertices_vertices[t].push(n[s])}))}return n};const F_=(e,{vector:t,origin:n},s=E)=>{const r=Bc(e,{vector:t,origin:n},s).map((e=>e.point)).filter(Boolean);const o=r.map((e=>I(e,n))).map((e=>D(e,t)));const c=dn(o);const a=c.map((e=>$(z(t,e),n)));const i=Array.from(Array(a.length-1)).map(((e,t)=>[a[t],a[t+1]])).map((t=>Su(e,t[0],t[1],s)));return i};const S_=(e,t,n,s=E)=>{e.faces_vertices[t].map((t=>e.vertices_coords[t])).map((e=>n.map((t=>lt(e,t,s)))));e.faces_vertices[t].map((t=>e.vertices_coords[t])).map(((e,t,n)=>[e,n[(t+1)%n.length]])).map((e=>Dn(...e))).map((e=>n.map((t=>Rr(e,t,vt,s)))))};const C_=(e,t,n=E)=>{const s=U(t[1],t[0]);const r=t[0];const o=ac(e,t,n);const c=o.map((t=>e.faces_vertices[t].map((t=>e.vertices_coords[t])))).map((e=>bu(e,{vector:s,origin:r},dt,ht,n)));const a=[];o.forEach(((e,t)=>{if(c[t]){a[e]=c[t]}}));return a};const V_=(e,t,n=E)=>{const s=C_(e,t,n);console.log("facesSegment",s);const r=s.map(((t,s)=>S_(e,s,t,n)));return r};const P_=e=>{const t={vertices:[],edges:[],faces:[]};let n=0;let s=0;let r=0;e.vertices_coords.forEach(((e,s)=>{t.vertices[s]=n++}));e.edges_vertices.forEach(((e,n)=>{t.edges[n]=s++}));e.faces_vertices.forEach(((e,n)=>{t.faces[n]=r++}));jn(e,"vertices",t.vertices);jn(e,"edges",t.edges);jn(e,"faces",t.faces);return e};const T_=({vertices_coords:e,faces_vertices:t},n,s)=>{const r=Jr({vertices_coords:e,faces_vertices:t},n,dt);switch(r.length){case 0:return undefined;case 1:return r[0]}if(!s){return r[0]}const o=R(n,N(s,.01));const c=r.map((n=>t[n].map((t=>e[t]))));const a=r.filter(((e,t)=>Ur(c[t],o,ut)));switch(a.length){case 0:return r.filter(((e,t)=>Ur(c[t],o,dt))).shift();case 1:return a[0];default:return a[0]}};const z_=({vertices_coords:e,edges_vertices:t,edges_foldAngle:n,edges_assignment:s,faces_vertices:r,faces_edges:o,faces_faces:c},{vector:a,origin:i},f="V",l=E)=>{if(!o){o=or({edges_vertices:t,faces_vertices:r})}const d=T_({vertices_coords:e,faces_vertices:r},i,a);const u=qt(f);const m=ma({vertices_coords:e,edges_vertices:t,edges_foldAngle:n,edges_assignment:s,faces_vertices:r,faces_faces:c},d);const p=Ic({vertices_coords:m,faces_vertices:r});if(!p[d]){p.forEach(((e,t)=>{p[t]=!e}))}const g=Bc({vertices_coords:m,edges_vertices:t},{vector:a,origin:i},l).map(((e,t)=>e.point===undefined?undefined:{...e,edge:t}));const _=t.map((t=>e[t[0]]));const h=er({vertices_coords:e,edges_vertices:t});const v=[];o.map((e=>e.map((e=>g[e])).filter((e=>e!==undefined)))).forEach(((e,t)=>{switch(e.length){case 0:case 1:break;default:v[t]=e;break}}));const b=(e,t)=>Math.abs(e.b-t.b)<l*2;const y=[];v.map((e=>e.sort(((e,t)=>e.b-t.b)))).map((e=>fo(e,b).map((t=>t.map((t=>e[t])))))).forEach(((e,t)=>{if(e.length===2){y[t]=[e[0][0],e[e.length-1][0]]}if(e.length>2){console.log("repeatFoldLine, non-convex polygons.")}}));return y.map(((e,t)=>({edges:e.map((e=>e.edge)),assignment:p[t]?f:u,points:e.map((e=>R(N(h[e.edge],e.a),_[e.edge])))})))};const N_={count:cn,countImplied:ps,clean:br,populate:Po,remove:Nn,replace:Cn,removePlanarVertex:zu,removePlanarEdge:Tu,splitEdge:Qo,splitFace:lc,flatFold:Yc,normalize:P_,repeatFold:z_,addVertex:k_,addVertices:O_,addNonPlanarEdge:j_,addPlanarLine:F_,addPlanarSegment:Su,addPlanarSegmentNew:V_,planarize:So,...ea,...Md,...eg,...y,...Jt,...da,...Ou,...Mr,...rg,...dg,...mg,...dr,...Fn,...Kr,...Cs,...qd,..._g,...bg,...xg,..._c,...yo,...jg,...Bd,...sa,...Tg,...nn,...kc,...Ug,...vs,...Ec,...rn,...xo,...Tn,...pa,...In,...js,...vr,...pr,...Mo,...Oo,...__,...Ac,...Cc,...Uc,...Pc,...$c,...b_,...A_,...fc,...w_};const B_=e=>e.concat(e.slice(0,-1).reverse());const $_=(e,t)=>{let n=[0];for(let s=1;s<e.length;s+=1){switch(t(e[n[0]],e[s])){case 0:n.push(s);break;case 1:n=[s];break}}return n};const R_=(e,t=E)=>{if(!e||!e.length){return undefined}const n=(e,n)=>ft(e[0],n[0],t);const s=$_(e,n);let r=0;for(let t=1;t<s.length;t+=1){if(e[s[t]][1]<e[s[r]][1]){r=t}}return s[r]};const L_=(e,t=E)=>{const n=R_(e,t);if(n===undefined){return[]}const s=e.map((t=>U(t,e[n]))).map((e=>P(e))).map((e=>q([0,1],e)));const r=s.map(((e,t)=>({a:e,i:t}))).sort(((e,t)=>e.a-t.a)).map((e=>e.i)).filter((e=>e!==n));return[[n]].concat(lo(r.map((e=>s[e])),t).map((e=>e.map((e=>r[e])))).map((t=>t.length===1?t:t.map((t=>({i:t,len:ne(e[t],e[n])}))).sort(((e,t)=>e.len-t.len)).map((e=>e.i)))))};const I_=(e=[],t=false,n=E)=>{if(e.length<2){return[]}const s=L_(e,n).map((e=>e.length===1?e:B_(e))).flat();s.push(s[0]);const r=[s[0]];let o=1;const c={"-1":()=>r.pop(),1:e=>{r.push(e);o+=1},undefined:()=>{o+=1}};c[0]=t?c["1"]:c["-1"];while(o<s.length){if(r.length<2){r.push(s[o]);o+=1;continue}const t=r[r.length-2];const a=r[r.length-1];const i=s[o];const f=fs(...[t,a,i].map((t=>e[t])),n);c[f](i)}r.pop();return r};const U_=Object.freeze({__proto__:null,convexHull:I_,convexHullRadialSortPoints:L_});const Q_=(e,t,n)=>{const s=e.map(((e,t)=>({vector:n[t],origin:e}))).map(((e,t,n)=>eo(e,n[(t+1)%n.length],_t,_t).point));const r=t.map(((e,t)=>zr(e,s[t],(e=>e))));if(e.length===3){return e.map((e=>({type:"skeleton",points:[e,s[0]]}))).concat([{type:"perpendicular",points:[r[0],s[0]]}])}const o=s.map(((e,t)=>te(e,r[t])));let c=0;o.forEach(((e,t)=>{if(e<o[c]){c=t}}));const a=[{type:"skeleton",points:[e[c],s[c]]},{type:"skeleton",points:[e[(c+1)%e.length],s[c]]},{type:"perpendicular",points:[r[c],s[c]]}];const i=Kn(re(t[(c+t.length-1)%t.length].vector),t[(c+1)%t.length].vector);const f=c===e.length-1;e.splice(c,2,s[c]);t.splice(c,1);n.splice(c,2,i);if(f){e.splice(0,1);n.splice(0,1);t.push(t.shift())}return a.concat(Q_(e,t,n))};const D_=e=>{const t=e.map(((e,t,n)=>[e,n[(t+1)%n.length]])).map((e=>({vector:I(e[1],e[0]),origin:e[0]})));const n=e.map(((e,t,n)=>[(t-1+n.length)%n.length,t,(t+1)%n.length].map((e=>n[e])))).map((e=>[I(e[0],e[1]),I(e[2],e[1])])).map((e=>Kn(...e)));return Q_([...e],t,n)};const q_=Object.freeze({__proto__:null,straightSkeleton:D_});const W_=(e,t,n=E)=>{for(let s=0;s<e.length;s+=1){if(e[s]<t.min[s]-n||e[s]>t.max[s]+n){return false}}return true};const G_=(e,t,n=E)=>{const s=Math.min(e.min.length,t.min.length);for(let r=0;r<s;r+=1){if(t.min[r]<e.min[r]-n||t.max[r]>e.max[r]+n){return false}}return true};const H_=Object.freeze({__proto__:null,enclosingBoundingBoxes:G_,pointInBoundingBox:W_});const J_=(e,t)=>{const n=e.map(((e,n)=>{const s=Rr(t,e,mt);return{point:s?e:null,at_index:n}})).filter((e=>e.point!=null));const s=e.map(((e,t,n)=>({vector:I(e,n[(t+1)%n.length]),origin:n[(t+1)%n.length]}))).map(((e,n)=>({point:eo(t,e,pt,vt).point,at_index:n}))).filter((e=>e.point!=null));if(s.length===2){const t=s.slice().sort(((e,t)=>e.at_index-t.at_index));const n=e.slice(t[1].at_index+1).concat(e.slice(0,t[0].at_index+1));n.push(t[0].point);n.push(t[1].point);const r=e.slice(t[0].at_index+1,t[1].at_index+1);r.push(t[1].point);r.push(t[0].point);return[n,r]}if(s.length===1&&n.length===1){n[0].type="v";s[0].type="e";const t=n.concat(s).sort(((e,t)=>e.at_index-t.at_index));const r=e.slice(t[1].at_index+1).concat(e.slice(0,t[0].at_index+1));if(t[0].type==="e"){r.push(t[0].point)}r.push(t[1].point);const o=e.slice(t[0].at_index+1,t[1].at_index+1);if(t[1].type==="e"){o.push(t[1].point)}o.push(t[0].point);return[r,o]}if(n.length===2){const t=n.slice().sort(((e,t)=>e.at_index-t.at_index));const s=e.slice(t[1].at_index).concat(e.slice(0,t[0].at_index+1));const r=e.slice(t[0].at_index,t[1].at_index+1);return[s,r]}return[e.slice()]};const Z_=Object.freeze({__proto__:null,splitConvexPolygon:J_});const Y_={...w,...Gn,...bt,..._e,...Fe,...Ge,...f_,...u_,...U_,...Vr,...$r,...ys,...at,...ls,...q_,...Cg,...H_,...Wr,...io,...Eu,...Z_};const X_=e=>{const t=e.map((e=>e.toUpperCase()));const n=t.filter((e=>e==="M")).length;const s=t.filter((e=>e==="V")).length;return n>s?t.indexOf("V"):t.indexOf("M")};const K_=(e,t,n=0)=>{const s=X_(t);if(s===-1){return undefined}const r=e[(s+1)%e.length];const o=e[(s+2)%e.length];const c=Math.max(-Math.PI,Math.min(Math.PI,n));const a=-Math.cos(r)*Math.cos(o)+Math.sin(r)*Math.sin(o)*Math.cos(Math.PI-c);const i=Math.cos(Math.PI-c)-Math.sin(Math.PI-c)**2*Math.sin(r)*Math.sin(o)/(1-a);const f=-Math.acos(i)+Math.PI;return s%2===0?[f,c,f,c].map(((e,t)=>s===t?-e:e)):[c,f,c,f].map(((e,t)=>s===t?-e:e))};const eh=Object.freeze({__proto__:null,foldDegree4:K_});const th=({vertices_coords:e,vertices_vertices:t,vertices_edges:n,vertices_faces:s,edges_vertices:r,edges_foldAngle:o,edges_vector:c,faces_vertices:a},i=E)=>{if(!t){t=Ns({vertices_coords:e,vertices_edges:n,vertices_faces:s,edges_vertices:r,faces_vertices:a})}if(!n){n=Ps({edges_vertices:r,vertices_vertices:t})}if(!s){s=Rs({vertices_coords:e,vertices_vertices:t,faces_vertices:a})}const f=Qs({vertices_coords:e,vertices_vertices:t,vertices_edges:n,vertices_faces:s,edges_vertices:r,edges_vector:c,faces_vertices:a});return e.map(((e,t)=>{if(s[t].includes(undefined)||s[t].includes(null)){return true}const r=f[t].map((e=>Math.atan2(e[1],e[0])));const c=n[t].map((e=>o[e])).map((e=>e*A));const a=r.map((e=>Ue(e)));const l=a.map((e=>Be(e)));const d=c.map((e=>Le(e)));const u=f[t].map(((e,t)=>ze(a[t],ze(d[t],l[t]))));let m=Ce;u.forEach((e=>{m=ze(m,e)}));return Array.from(Array(9)).map(((e,t)=>Math.abs(m[t]-Ce[t])<i)).reduce(((e,t)=>e&&t),true)}))};const nh=Object.freeze({__proto__:null,verticesFoldable:th});const sh={U:true,u:true};const rh=e=>e.map(((e,t)=>t)).filter((t=>sh[e[t]]));const oh=e=>{const t=rh(e);const n=Array.from(Array(2**t.length)).map(((e,t)=>t.toString(2))).map((e=>Array(t.length-e.length+1).join("0")+e)).map((e=>Array.from(e).map((e=>e==="0"?"V":"M"))));const s=n.map((n=>{const s=e.slice();t.forEach(((e,t)=>{s[e]=n[t]}));return s}));const r=e.filter((e=>kt[e])).length;if(r>0){return s}const o=s.map((e=>e.filter((e=>e==="M"||e==="m")).length));const c=s.map((e=>e.filter((e=>e==="V"||e==="v")).length));return s.filter(((e,t)=>Math.abs(o[t]-c[t])===2))};const ch=Object.freeze({__proto__:null,maekawaSolver:oh});const ah={...eh,...nh,...Iu,...ch,...qu};const ih=(e,t,n)=>{const s=e.createShader(n);e.shaderSource(s,t);e.compileShader(s);if(!e.getShaderParameter(s,e.COMPILE_STATUS)){throw new Error(e.getShaderInfoLog(s))}return s};const fh=(e,t,n)=>{const s=e.createProgram();e.attachShader(s,t);e.attachShader(s,n);e.linkProgram(s);if(!e.getProgramParameter(s,e.LINK_STATUS)){throw new Error(e.getProgramInfoLog(s))}e.deleteShader(t);e.deleteShader(n);return s};const lh=(e,t,n)=>{const s=ih(e,t,e.VERTEX_SHADER);const r=ih(e,n,e.FRAGMENT_SHADER);return fh(e,s,r)};const dh=(e,t)=>{const s=[null,"webgl","webgl2"];const r=window.devicePixelRatio||1;e.width=e.clientWidth*r;e.height=e.clientHeight*r;if(t){return{gl:e.getContext(s[t]),version:t}}const o=e.getContext(s[2]);if(o){return{gl:o,version:2}}const c=e.getContext(s[1]);if(c){return{gl:c,version:1}}throw new Error(n.noWebGL)};const uh=(e,t)=>{if(!e){return}const n=window.devicePixelRatio||1;const s=[t.clientWidth,t.clientHeight].map((e=>e*n));if(t.width!==s[0]||t.height!==s[1]){t.width=s[0];t.height=s[1]}e.viewport(0,0,e.canvas.width,e.canvas.height)};const mh=(e,t="perspective",n=45)=>{if(!e){return Qg}const s=.1;const r=20;const o=-100;const c=100;const a=[e.clientWidth,e.clientHeight];const i=Math.min(...a);const f=[0,1].map((e=>(a[e]-i)/i/2));const l=f.map((e=>e+.5));return t==="orthographic"?a_(l[1],l[0],-l[1],-l[0],o,c):c_(n*(Math.PI/180),a[0]/a[1],s,r)};const ph=e=>{if(!e){return Qg}const t=ra(e);if(!t){return Qg}const n=Math.max(...t.span);if(n===0){return Qg}const s=de(3,G(t.min,t.max));const r=[n,0,0,0,0,n,0,0,0,0,n,0,...s,1];return Jg(r)||Qg};const gh=Object.freeze({__proto__:null,makeModelMatrix:ph,makeProjectionMatrix:mh,rebuildViewport:uh});const _h=(e,t,n,s)=>{switch(n){case"uniformMatrix4fv":e[n](t,false,s);break;default:e[n](t,s);break}};const hh=(e,t,n,s={})=>{e.useProgram(n.program);n.flags.forEach((t=>e.enable(t)));const r=e.getProgramParameter(n.program,e.ACTIVE_UNIFORMS);for(let t=0;t<r;t+=1){const r=e.getActiveUniform(n.program,t).name;const o=s[r];if(o){const t=e.getUniformLocation(n.program,r);_h(e,t,o.func,o.value)}}n.vertexArrays.forEach((t=>{e.bindBuffer(e.ARRAY_BUFFER,t.buffer);e.bufferData(e.ARRAY_BUFFER,t.data,e.STATIC_DRAW);e.vertexAttribPointer(t.location,t.length,t.type,false,0,0);e.enableVertexAttribArray(t.location)}));n.elementArrays.forEach((n=>{e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n.buffer);e.bufferData(e.ELEMENT_ARRAY_BUFFER,n.data,e.STATIC_DRAW);e.drawElements(n.mode,n.data.length,t===2?e.UNSIGNED_INT:e.UNSIGNED_SHORT,n.buffer)}));n.flags.forEach((t=>e.disable(t)))};const vh=(e,t)=>{t.vertexArrays.forEach((t=>e.disableVertexAttribArray(t.location)));t.vertexArrays.forEach((t=>e.deleteBuffer(t.buffer)));t.elementArrays.forEach((t=>e.deleteBuffer(t.buffer)));e.deleteProgram(t.program)};const bh=Object.freeze({__proto__:null,deallocProgram:vh,drawProgram:hh});const yh={B:[.5,.5,.5],b:[.5,.5,.5],V:[.2,.4,.6],v:[.2,.4,.6],M:[.75,.25,.15],m:[.75,.25,.15],F:[.3,.3,.3],f:[.3,.3,.3],J:[.3,.2,0],j:[.3,.2,0],C:[.5,.8,.1],c:[.5,.8,.1],U:[.6,.25,.9],u:[.6,.25,.9]};const Eh={B:[0,0,0],b:[0,0,0],V:[.2,.5,.8],v:[.2,.5,.8],M:[.75,.25,.15],m:[.75,.25,.15],F:[.75,.75,.75],f:[.75,.75,.75],J:[1,.75,.25],j:[1,.75,.25],C:[.5,.8,.1],c:[.5,.8,.1],U:[.6,.25,.9],u:[.6,.25,.9]};const Mh=e=>e!==undefined&&e.constructor===Array?e.slice(0,3):ci(e).slice(0,3).map((e=>e/255));const Ah=({vertices_coords:e,edges_assignment:t,faces_vertices:n,faces_edges:s,faces_normal:r},o={})=>{const c=e.map((e=>[...e].concat(Array(3-e.length).fill(0))));const a=Ss({vertices_coords:c,faces_vertices:n,faces_normal:r});const i=c.map(((e,t)=>t%3)).map((e=>[e===0?1:0,e===1?1:0,e===2?1:0]));const f=s.map((e=>e.map((e=>t[e])).map((e=>e==="J"||e==="j"))));if(!o.showTrianglulation){for(let e=0;e<f.length;e+=1){if(f[e][0]){i[e*3+0][2]=i[e*3+1][2]=100}if(f[e][1]){i[e*3+1][0]=i[e*3+2][0]=100}if(f[e][2]){i[e*3+0][1]=i[e*3+2][1]=100}}}return{vertices_coords:c,vertices_normal:a,vertices_barycentric:i}};const xh=(e,t)=>{if(!e||!e.vertices_coords||!e.edges_vertices){return[]}const n=t&&t.dark?yh:Eh;const s={...n,...t};const r=e.vertices_coords.map((e=>[...e].concat(Array(3-e.length).fill(0))));const o=e.edges_vertices.flatMap((e=>e.map((e=>r[e])))).flatMap((e=>[e,e,e,e]));const c=er(e);const a=e.edges_assignment?e.edges_assignment.flatMap((e=>Array(8).fill(s[e]))):e.edges_vertices.flatMap((()=>Array(8).fill(s.U)));const i=c.flatMap((e=>[e,e,e,e,e,e,e,e]));const f=e.edges_vertices.flatMap((()=>[[1,0],[0,1],[-1,0],[0,-1],[1,0],[0,1],[-1,0],[0,-1]]));return{vertices_coords:o,vertices_color:a,verticesEdgesVector:i,vertices_vector:f}};const wh=Object.freeze({__proto__:null,makeFacesVertexData:Ah,makeThickEdgesVertexData:xh});const kh=(e,t,{vertices_coords:n,edges_vertices:s,edges_assignment:r,faces_vertices:o,faces_edges:c,faces_normal:a}={},i={})=>{if(!n||!o){return[]}if(!c){c=or({edges_vertices:s,faces_vertices:o})}const{vertices_coords:f,vertices_normal:l,vertices_barycentric:d}=Ah({vertices_coords:n,edges_assignment:r,faces_vertices:o,faces_edges:c,faces_normal:a},i);return[{location:e.getAttribLocation(t,"v_position"),buffer:e.createBuffer(),type:e.FLOAT,length:f.length?f[0].length:3,data:new Float32Array(f.flat())},{location:e.getAttribLocation(t,"v_normal"),buffer:e.createBuffer(),type:e.FLOAT,length:l.length?l[0].length:3,data:new Float32Array(l.flat())},{location:e.getAttribLocation(t,"v_barycentric"),buffer:e.createBuffer(),type:e.FLOAT,length:3,data:new Float32Array(d.flat())}].filter((e=>e.location!==-1))};const Oh=(e,t=1,n={})=>{if(!n||!n.vertices_coords||!n.faces_vertices){return[]}return[{mode:e.TRIANGLES,buffer:e.createBuffer(),data:t===2?new Uint32Array(n.faces_vertices.flat()):new Uint16Array(n.faces_vertices.flat())}]};const jh=(e,t,n,s={})=>{if(!n||!n.vertices_coords||!n.edges_vertices){return[]}const{vertices_coords:r,vertices_color:o,verticesEdgesVector:c,vertices_vector:a}=xh(n,s.assignment_color);return[{location:e.getAttribLocation(t,"v_position"),buffer:e.createBuffer(),type:e.FLOAT,length:r.length?r[0].length:3,data:new Float32Array(r.flat())},{location:e.getAttribLocation(t,"v_color"),buffer:e.createBuffer(),type:e.FLOAT,length:o.length?o[0].length:3,data:new Float32Array(o.flat())},{location:e.getAttribLocation(t,"edge_vector"),buffer:e.createBuffer(),type:e.FLOAT,length:c.length?c[0].length:3,data:new Float32Array(c.flat())},{location:e.getAttribLocation(t,"vertex_vector"),buffer:e.createBuffer(),type:e.FLOAT,length:a.length?a[0].length:3,data:new Float32Array(a.flat())}].filter((e=>e.location!==-1))};const Fh=(e,t=1,n={})=>{if(!n||!n.edges_vertices){return[]}const s=n.edges_vertices.map(((e,t)=>t*8)).flatMap((e=>[e+0,e+1,e+4,e+4,e+1,e+5,e+1,e+2,e+5,e+5,e+2,e+6,e+2,e+3,e+6,e+6,e+3,e+7,e+3,e+0,e+7,e+7,e+0,e+4]));return[{mode:e.TRIANGLES,buffer:e.createBuffer(),data:t===2?new Uint32Array(s):new Uint16Array(s)}]};const Sh=Object.freeze({__proto__:null,makeFoldedElementArrays:Oh,makeFoldedVertexArrays:kh,makeThickEdgesElementArrays:Fh,makeThickEdgesVertexArrays:jh});const Ch=5e-6;const Vh=(e,t=Ch)=>{const n=_a(e);if(!n.edges_assignment){const e=cn.edges(n)||ps.edges(n);n.edges_assignment=Array(e).fill("U")}let s=[];if(n.faceOrders){s=Ud(n)}else if(n.faces_layer){s=Qd(n)}const r=Ig(n);const o=yr(n);if(r.faces){const e=kn(r.faces.map);e.forEach(((e,n)=>{const r=s[e];if(!r){return}o.faces_vertices[n].forEach((e=>{const n=z(r.vector,r.layer*t);o.vertices_coords[e]=$(de(3,o.vertices_coords[e]),n)}))}))}return o};const Ph=(e,{projectionMatrix:t,modelViewMatrix:n,frontColor:s,backColor:r,outlineColor:o,strokeWidth:c,opacity:a})=>({u_matrix:{func:"uniformMatrix4fv",value:Gg(t||Qg,n||Qg)},u_projection:{func:"uniformMatrix4fv",value:t||Qg},u_modelView:{func:"uniformMatrix4fv",value:n||Qg},u_frontColor:{func:"uniform3fv",value:Mh(s||"gray")},u_backColor:{func:"uniform3fv",value:Mh(r||"white")},u_outlineColor:{func:"uniform3fv",value:Mh(o||"black")},u_strokeWidth:{func:"uniform1f",value:c!==undefined?c:.05},u_opacity:{func:"uniform1f",value:a!==undefined?a:1}});const Th=`#version 300 es\nuniform mat4 u_modelView;\nuniform mat4 u_matrix;\nuniform vec3 u_frontColor;\nuniform vec3 u_backColor;\nin vec3 v_position;\nin vec3 v_normal;\nout vec3 front_color;\nout vec3 back_color;\nvoid main () {\n\tgl_Position = u_matrix * vec4(v_position, 1);\n\tvec3 light = abs(normalize((vec4(v_normal, 1) * u_modelView).xyz));\n\tfloat brightness = 0.5 + light.x * 0.15 + light.z * 0.35;\n\tfront_color = u_frontColor * brightness;\n\tback_color = u_backColor * brightness;\n}\n`;const zh=`#version 300 es\nuniform mat4 u_matrix;\nuniform mat4 u_projection;\nuniform mat4 u_modelView;\nuniform float u_strokeWidth;\nin vec3 v_position;\nin vec3 v_color;\nin vec3 edge_vector;\nin vec2 vertex_vector;\nout vec3 blend_color;\nvoid main () {\n\tvec3 edge_norm = normalize(edge_vector);\n\t// axis most dissimilar to edge_vector\n\tvec3 absNorm = abs(edge_norm);\n\tvec3 xory = absNorm.x < absNorm.y ? vec3(1,0,0) : vec3(0,1,0);\n\tvec3 axis = absNorm.x > absNorm.z && absNorm.y > absNorm.z ? vec3(0,0,1) : xory;\n\t// two perpendiculars. with edge_vector these make basis vectors\n\tvec3 one = cross(axis, edge_norm);\n\tvec3 two = cross(one, edge_norm);\n\tvec3 displaceNormal = normalize(\n\t\tone * vertex_vector.x + two * vertex_vector.y\n\t);\n\tvec3 displace = displaceNormal * (u_strokeWidth * 0.5);\n\tgl_Position = u_matrix * vec4(v_position + displace, 1);\n\tblend_color = v_color;\n}\n`;const Nh=`#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\nuniform float u_opacity;\nin vec3 front_color;\nin vec3 back_color;\nin vec3 outline_color;\nin vec3 barycentric;\nout vec4 outColor;\nfloat edgeFactor(vec3 barycenter) {\n\tvec3 d = fwidth(barycenter);\n\tvec3 a3 = smoothstep(vec3(0.0), d*3.5, barycenter);\n\treturn min(min(a3.x, a3.y), a3.z);\n}\nvoid main () {\n\tgl_FragDepth = gl_FragCoord.z;\n\tvec3 color = gl_FrontFacing ? front_color : back_color;\n\t// vec4 color4 = gl_FrontFacing\n\t// \t? vec4(front_color, u_opacity)\n\t// \t: vec4(back_color, u_opacity);\n\t// vec4 outline4 = vec4(outline_color, 1);\n\t// outColor = vec4(mix(vec3(0.0), color, edgeFactor(barycentric)), u_opacity);\n\toutColor = vec4(mix(outline_color, color, edgeFactor(barycentric)), u_opacity);\n\t// outColor = mix(outline4, color4, edgeFactor(barycentric));\n}\n`;const Bh=`#version 100\nprecision mediump float;\nuniform float u_opacity;\nvarying vec3 barycentric;\nvarying vec3 front_color;\nvarying vec3 back_color;\nvarying vec3 outline_color;\nvoid main () {\n\tvec3 color = gl_FrontFacing ? front_color : back_color;\n\t// vec3 boundary = vec3(0.0, 0.0, 0.0);\n\tvec3 boundary = outline_color;\n\t// gl_FragDepth = 0.5;\n\tgl_FragColor = any(lessThan(barycentric, vec3(0.02)))\n\t\t? vec4(boundary, u_opacity)\n\t\t: vec4(color, u_opacity);\n}\n`;const $h=`#version 100\nattribute vec3 v_position;\nattribute vec3 v_normal;\nuniform mat4 u_projection;\nuniform mat4 u_modelView;\nuniform mat4 u_matrix;\nuniform vec3 u_frontColor;\nuniform vec3 u_backColor;\nvarying vec3 normal_color;\nvarying vec3 front_color;\nvarying vec3 back_color;\nvoid main () {\n\tgl_Position = u_matrix * vec4(v_position, 1);\n\tvec3 light = abs(normalize((vec4(v_normal, 1) * u_modelView).xyz));\n\tfloat brightness = 0.5 + light.x * 0.15 + light.z * 0.35;\n\tfront_color = u_frontColor * brightness;\n\tback_color = u_backColor * brightness;\n}\n`;const Rh=`#version 100\nattribute vec3 v_position;\nattribute vec3 v_color;\nattribute vec3 edge_vector;\nattribute vec2 vertex_vector;\nuniform mat4 u_matrix;\nuniform mat4 u_projection;\nuniform mat4 u_modelView;\nuniform float u_strokeWidth;\nvarying vec3 blend_color;\nvoid main () {\n\tvec3 edge_norm = normalize(edge_vector);\n\t// axis most dissimilar to edge_vector\n\tvec3 absNorm = abs(edge_norm);\n\tvec3 xory = absNorm.x < absNorm.y ? vec3(1,0,0) : vec3(0,1,0);\n\tvec3 axis = absNorm.x > absNorm.z && absNorm.y > absNorm.z ? vec3(0,0,1) : xory;\n\t// two perpendiculars. with edge_vector these make basis vectors\n\tvec3 one = cross(axis, edge_norm);\n\tvec3 two = cross(one, edge_norm);\n\tvec3 displaceNormal = normalize(\n\t\tone * vertex_vector.x + two * vertex_vector.y\n\t);\n\tvec3 displace = displaceNormal * (u_strokeWidth * 0.5);\n\tgl_Position = u_matrix * vec4(v_position + displace, 1);\n\tblend_color = v_color;\n}\n`;const Lh=`#version 100\nprecision mediump float;\nuniform float u_opacity;\nvarying vec3 front_color;\nvarying vec3 back_color;\nvoid main () {\n\tvec3 color = gl_FrontFacing ? front_color : back_color;\n\tgl_FragColor = vec4(color, u_opacity);\n}\n`;const Ih=`#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\nin vec3 blend_color;\nout vec4 outColor;\n \nvoid main() {\n\toutColor = vec4(blend_color.rgb, 1);\n}\n`;const Uh=`#version 100\nattribute vec3 v_position;\nattribute vec3 v_normal;\nattribute vec3 v_barycentric;\nuniform mat4 u_projection;\nuniform mat4 u_modelView;\nuniform mat4 u_matrix;\nuniform vec3 u_frontColor;\nuniform vec3 u_backColor;\nuniform vec3 u_outlineColor;\nvarying vec3 normal_color;\nvarying vec3 barycentric;\nvarying vec3 front_color;\nvarying vec3 back_color;\nvarying vec3 outline_color;\nvoid main () {\n\tgl_Position = u_matrix * vec4(v_position, 1);\n\tbarycentric = v_barycentric;\n\tvec3 light = abs(normalize((vec4(v_normal, 1) * u_modelView).xyz));\n\tfloat brightness = 0.5 + light.x * 0.15 + light.z * 0.35;\n\tfront_color = u_frontColor * brightness;\n\tback_color = u_backColor * brightness;\n\toutline_color = u_outlineColor;\n}\n`;const Qh=`#version 300 es\nuniform mat4 u_modelView;\nuniform mat4 u_matrix;\nuniform vec3 u_frontColor;\nuniform vec3 u_backColor;\nuniform vec3 u_outlineColor;\nin vec3 v_position;\nin vec3 v_normal;\nin vec3 v_barycentric;\nin float v_rawEdge;\nout vec3 front_color;\nout vec3 back_color;\nout vec3 outline_color;\nout vec3 barycentric;\n// flat out int rawEdge;\nflat out int provokedVertex;\nvoid main () {\n\tgl_Position = u_matrix * vec4(v_position, 1);\n\tprovokedVertex = gl_VertexID;\n\tbarycentric = v_barycentric;\n\t// rawEdge = int(v_rawEdge);\n\tvec3 light = abs(normalize((vec4(v_normal, 1) * u_modelView).xyz));\n\tfloat brightness = 0.5 + light.x * 0.15 + light.z * 0.35;\n\tfront_color = u_frontColor * brightness;\n\tback_color = u_backColor * brightness;\n\toutline_color = u_outlineColor;\n}\n`;const Dh=`#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\nuniform float u_opacity;\nin vec3 front_color;\nin vec3 back_color;\nout vec4 outColor;\nvoid main () {\n\tgl_FragDepth = gl_FragCoord.z;\n\tvec3 color = gl_FrontFacing ? front_color : back_color;\n\toutColor = vec4(color, u_opacity);\n}\n`;const qh=`#version 100\nprecision mediump float;\nvarying vec3 blend_color;\nvoid main () {\n\tgl_FragColor = vec4(blend_color.rgb, 1);\n}\n`;const Wh=(e,t=1,n={},s={})=>{const r=Vh(n,s.layerNudge);const o=t===1?lh(e,$h,Lh):lh(e,Th,Dh);return{program:o,vertexArrays:kh(e,o,r,s),elementArrays:Oh(e,t,r),flags:[e.DEPTH_TEST],makeUniforms:Ph}};const Gh=(e,t=1,n={},s={})=>{const r=t===1?lh(e,Rh,qh):lh(e,zh,Ih);return{program:r,vertexArrays:jh(e,r,n,s),elementArrays:Fh(e,t,n),flags:[e.DEPTH_TEST],makeUniforms:Ph}};const Hh=(e,t=1,n={},s={})=>{const r=Vh(n,s.layerNudge);const o=t===1?lh(e,Uh,Bh):lh(e,Qh,Nh);return{program:o,vertexArrays:kh(e,o,r,s),elementArrays:Oh(e,t,r),flags:[e.DEPTH_TEST],makeUniforms:Ph}};const Jh=Object.freeze({__proto__:null,foldedFormEdges:Gh,foldedFormFaces:Wh,foldedFormFacesOutlined:Hh});const Zh=(e,t=1,n={},s={})=>{const r=[];if(s.faces!==false){if(s.outlines===false){r.push(Wh(e,t,n,s))}else{r.push(Hh(e,t,n,s))}}if(s.edges===true){r.push(Gh(e,t,n,s))}return r};const Yh=e=>e.map((e=>[0,1].map((t=>e[t]||0))));const Xh=(e,t)=>{if(!e||!e.vertices_coords||!e.edges_vertices){return[]}const n=t&&t.dark?yh:Eh;const s={...n,...t};const r=Yh(e.edges_vertices.flatMap((t=>t.map((t=>e.vertices_coords[t])))).flatMap((e=>[e,e])));const o=Yh(er(e));const c=e.edges_assignment?e.edges_assignment.flatMap((e=>[s[e],s[e],s[e],s[e]])):e.edges_vertices.flatMap((()=>[s.U,s.U,s.U,s.U]));const a=o.flatMap((e=>[e,e,e,e]));const i=e.edges_vertices.flatMap((()=>[[1,0],[-1,0],[-1,0],[1,0]]));return{vertices_coords:r,vertices_color:c,verticesEdgesVector:a,vertices_vector:i}};const Kh=Object.freeze({__proto__:null,makeCPEdgesVertexData:Xh});const ev=(e,t,n,s)=>{if(!n||!n.vertices_coords||!n.edges_vertices){return[]}const{vertices_coords:r,vertices_color:o,verticesEdgesVector:c,vertices_vector:a}=Xh(n,s);return[{location:e.getAttribLocation(t,"v_position"),buffer:e.createBuffer(),type:e.FLOAT,length:2,data:new Float32Array(r.flat())},{location:e.getAttribLocation(t,"v_color"),buffer:e.createBuffer(),type:e.FLOAT,length:o.length?o[0].length:2,data:new Float32Array(o.flat())},{location:e.getAttribLocation(t,"edge_vector"),buffer:e.createBuffer(),type:e.FLOAT,length:c.length?c[0].length:2,data:new Float32Array(c.flat())},{location:e.getAttribLocation(t,"vertex_vector"),buffer:e.createBuffer(),type:e.FLOAT,length:a.length?a[0].length:2,data:new Float32Array(a.flat())}].filter((e=>e.location!==-1))};const tv=(e,t=1,n={})=>{if(!n||!n.edges_vertices){return[]}const s=n.edges_vertices.map(((e,t)=>t*4)).flatMap((e=>[e+0,e+1,e+2,e+2,e+3,e+0]));return[{mode:e.TRIANGLES,buffer:e.createBuffer(),data:t===2?new Uint32Array(s):new Uint16Array(s)}]};const nv=e=>e.map((e=>[0,1].map((t=>e[t]||0))));const sv=(e,t,n)=>{if(!n||!n.vertices_coords){return[]}return[{location:e.getAttribLocation(t,"v_position"),buffer:e.createBuffer(),type:e.FLOAT,length:2,data:new Float32Array(nv(n.vertices_coords).flat())}].filter((e=>e.location!==-1))};const rv=(e,t=1,n={})=>{if(!n||!n.vertices_coords||!n.faces_vertices){return[]}return[{mode:e.TRIANGLES,buffer:e.createBuffer(),data:t===2?new Uint32Array(Ng(n).flat()):new Uint16Array(Ng(n).flat())}]};const ov=Object.freeze({__proto__:null,makeCPEdgesElementArrays:tv,makeCPEdgesVertexArrays:ev,makeCPFacesElementArrays:rv,makeCPFacesVertexArrays:sv});const cv=(e,{projectionMatrix:t,modelViewMatrix:n,cpColor:s,strokeWidth:r})=>({u_matrix:{func:"uniformMatrix4fv",value:Gg(t||Qg,n||Qg)},u_projection:{func:"uniformMatrix4fv",value:t||Qg},u_modelView:{func:"uniformMatrix4fv",value:n||Qg},u_cpColor:{func:"uniform3fv",value:Mh(s||"white")},u_strokeWidth:{func:"uniform1f",value:r||.05}});const av=`#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\nin vec3 blend_color;\nout vec4 outColor;\nvoid main() {\n\toutColor = vec4(blend_color.rgb, 1);\n}\n`;const iv=`#version 100\nprecision mediump float;\nvarying vec3 blend_color;\nvoid main () {\n\tgl_FragColor = vec4(blend_color.rgb, 1);\n}\n`;const fv=`#version 300 es\nuniform mat4 u_matrix;\nuniform float u_strokeWidth;\nin vec2 v_position;\nin vec3 v_color;\nin vec2 edge_vector;\nin vec2 vertex_vector;\nout vec3 blend_color;\nvoid main () {\n\tfloat sign = vertex_vector[0];\n\tfloat halfWidth = u_strokeWidth * 0.5;\n\tvec2 side = normalize(vec2(edge_vector.y * sign, -edge_vector.x * sign)) * halfWidth;\n\tgl_Position = u_matrix * vec4(side + v_position, 0, 1);\n\tblend_color = v_color;\n}\n`;const lv=`#version 100\nuniform mat4 u_matrix;\nuniform float u_strokeWidth;\nattribute vec2 v_position;\nattribute vec3 v_color;\nattribute vec2 edge_vector;\nattribute vec2 vertex_vector;\nvarying vec3 blend_color;\nvoid main () {\n\tfloat sign = vertex_vector[0];\n\tfloat halfWidth = u_strokeWidth * 0.5;\n\tvec2 side = normalize(vec2(edge_vector.y * sign, -edge_vector.x * sign)) * halfWidth;\n\tgl_Position = u_matrix * vec4(side + v_position, 0, 1);\n\tblend_color = v_color;\n}\n`;const dv=`#version 100\nuniform mat4 u_matrix;\nuniform vec3 u_cpColor;\nattribute vec2 v_position;\nvarying vec3 blend_color;\nvoid main () {\n\tgl_Position = u_matrix * vec4(v_position, 0, 1);\n\tblend_color = u_cpColor;\n}\n`;const uv=`#version 300 es\nuniform mat4 u_matrix;\nuniform vec3 u_cpColor;\nin vec2 v_position;\nout vec3 blend_color;\nvoid main () {\n\tgl_Position = u_matrix * vec4(v_position, 0, 1);\n\tblend_color = u_cpColor;\n}\n`;const mv=(e,t={},n=undefined)=>{const s=lh(e,dv,iv);return{program:s,vertexArrays:sv(e,s,t),elementArrays:rv(e,1,t),flags:[],makeUniforms:cv}};const pv=(e,t={},n=undefined)=>{const s=lh(e,lv,iv);return{program:s,vertexArrays:ev(e,s,t,n),elementArrays:tv(e,1,t),flags:[],makeUniforms:cv}};const gv=(e,t={},n=undefined)=>{const s=lh(e,uv,av);return{program:s,vertexArrays:sv(e,s,t),elementArrays:rv(e,2,t),flags:[],makeUniforms:cv}};const _v=(e,t={},n=undefined)=>{const s=lh(e,fv,av);return{program:s,vertexArrays:ev(e,s,t,n),elementArrays:tv(e,2,t),flags:[],makeUniforms:cv}};const hv=Object.freeze({__proto__:null,cpEdgesV1:pv,cpEdgesV2:_v,cpFacesV1:mv,cpFacesV2:gv});const vv=(e,t=1,n={},s=undefined)=>{switch(t){case 1:return[mv(e,n,s),pv(e,n,s)];case 2:default:return[gv(e,n,s),_v(e,n,s)]}};const bv=Object.assign(Object.create(null),{createProgram:lh,initialize:dh,foldedForm:Zh,creasePattern:vv},gh,bh,Sh,wh,Jh,ov,Kh,hv);const yv=({vertices_coords:e,edges_vertices:t})=>{const n=t.map((t=>t.map((t=>e[t])))).map((e=>te(...e)));const s=n.reduce(((e,t)=>Math.min(e,t)),Infinity);return s===Infinity?undefined:s};const Ev=({vertices_coords:e,edges_vertices:t})=>{const n=yv({vertices_coords:e,edges_vertices:t});if(n){return Math.max(n*1e-4,1e-10)}const s=ra({vertices_coords:e});return s&&s.span?Math.max(1e-6*Math.max(...s.span),1e-10):1e-6};const Mv=e=>kn(kn(e).reverse());const Av=(e,t)=>{const n=[];const s=Ic(e);const r=e.edges_faces?e.edges_faces:Gs(e);r.forEach(((e,r)=>{if(e.length===1){n[r]="B"}if(e.length===2){const o=e.map((e=>s[e]));if(o[0]===o[1]){n[r]="F";return}const c=e.map((e=>t[e]));const a=c[0]<c[1];const i=o[0]?a:!a;n[r]=i?"V":"M"}}));return n};const xv=e=>{const t=[];e.forEach((e=>{t[e[0]]=undefined;t[e[1]]=undefined}));const n=t.map((()=>[]));e.forEach((([e,t,s])=>{n[e][t]=s;n[t][e]=-s}));return n};const wv=Object.freeze({__proto__:null,faceOrdersToMatrix:xv,facesLayerToEdgesAssignments:Av,flipFacesLayer:Mv,makeEpsilon:Ev});const kv={taco_taco:e=>[[e[0],e[2]],[e[1],e[3]],[e[1],e[2]],[e[0],e[3]],[e[0],e[1]],[e[2],e[3]]],taco_tortilla:e=>[[e[0],e[2]],[e[0],e[1]],[e[1],e[2]]],tortilla_tortilla:e=>[[e[0],e[2]],[e[1],e[3]]],transitivity:e=>[[e[0],e[1]],[e[1],e[2]],[e[2],e[0]]]};const Ov=e=>e[0]<e[1]?`${e[0]} ${e[1]}`:`${e[1]} ${e[0]}`;const jv={taco_taco:e=>[Ov([e[0],e[2]]),Ov([e[1],e[3]]),Ov([e[1],e[2]]),Ov([e[0],e[3]]),Ov([e[0],e[1]]),Ov([e[2],e[3]])],taco_tortilla:e=>[Ov([e[0],e[2]]),Ov([e[0],e[1]]),Ov([e[1],e[2]])],tortilla_tortilla:e=>[Ov([e[0],e[2]]),Ov([e[1],e[3]])],transitivity:e=>[Ov([e[0],e[1]]),Ov([e[1],e[2]]),Ov([e[2],e[0]])]};const Fv={0:0,1:1,2:-1};const Sv=(e,t)=>{const n=Object.keys(e);const s=n.map((e=>e.split(" ").map((e=>parseInt(e,10)))));s.forEach(((s,r)=>{const o=Fv[e[n[r]]];const c=!t[s[1]]?-o:o;s.push(c)}));return s};const Cv=Object.freeze({__proto__:null,constraintToFacePairs:kv,constraintToFacePairsStrings:jv,solverSolutionToFaceOrders:Sv});const Vv=({taco_taco:e,taco_tortilla:t,tortilla_tortilla:n,transitivity:s})=>{const r={};r.taco_taco=e.map((e=>[e[0][0],e[1][0],e[0][1],e[1][1]]));r.taco_tortilla=t.map((e=>[e.taco[0],e.tortilla,e.taco[1]]));r.tortilla_tortilla=n.map((e=>[e[0][0],e[0][1],e[1][0],e[1][1]]));r.transitivity=s.map((e=>[e[0],e[1],e[2]]));return r};const Pv=e=>{const t={};Object.keys(e).forEach((e=>{t[e]={}}));Object.keys(e).forEach((n=>{e[n].forEach(((e,s)=>jv[n](e).forEach((e=>{if(t[n][e]===undefined){t[n][e]=[]}t[n][e].push(s)}))))}));return t};const Tv=({vertices_coords:e,edges_vertices:t,edges_faces:n,faces_center:s})=>{const r=t.map((t=>e[t[0]]));const o=t.map((t=>U(e[t[1]],e[t[0]])));return n.map(((e,t)=>e.map((e=>K(U(s[e],r[t]),o[t]))).map((e=>Math.sign(e)))))};const zv=({vertices_coords:e,edges_vertices:t,faces_center:n},s,r)=>{const o=s.map((n=>t[n[0]].map((t=>e[t]))));const c=o.map((e=>e[0]));const a=o.map((e=>U(e[1],e[0])));const i=r.map((e=>e.map((e=>e.map((e=>n[e]))))));return i.map(((e,t)=>e.map((e=>e.map((e=>K(U(e,c[t]),a[t]))).map((e=>Math.sign(e)))))))};const Nv=e=>{if(e[0]===1&&e[1]===-1||e[0]===-1&&e[1]===1){return"both"}if(e[0]===1&&e[1]===1){return"right"}if(e[0]===-1&&e[1]===-1){return"left"}return undefined};const Bv=e=>e[0]===e[1]&&e[0]!=="both";const $v=e=>e[0]===e[1]&&e[0]==="both";const Rv=e=>e[0]!==e[1]&&(e[0]==="both"||e[1]==="both");const Lv=(e,t,n)=>{const s=t[0]==="left"||t[1]==="left"?-1:1;const r=t[0]==="both"?[...e[1]]:[...e[0]];const o=t[0]==="both"?0:1;const c=n[o][0]===s?e[o][0]:e[o][1];return{taco:r,tortilla:c}};const Iv=(e,t)=>{if(e===undefined){return undefined}return t[0][0]===t[1][0]?e:[e[0],[e[1][1],e[1][0]]]};const Uv=(e,t,n)=>{const s=t.map((e=>e.length===2&&e[0]!==e[1])).map(((e,t)=>e?t:undefined)).filter((e=>e!==undefined));const r=[];s.forEach((e=>{r[e]=n[e]}));const o=r.map(((t,n)=>t.map((t=>[e[n],[t,t]])))).reduce(((e,t)=>e.concat(t)),[]);return o};const Qv=({vertices_coords:e,edges_vertices:t,edges_faces:n,faces_vertices:s,faces_center:r,edges_vector:o},c=E)=>{if(!r){r=lr({vertices_coords:e,faces_vertices:s})}const a=Tv({vertices_coords:e,edges_vertices:t,edges_faces:n,faces_center:r});const i=v_({vertices_coords:e,edges_vertices:t,edges_vector:o},c);const f=M_({vertices_coords:e,edges_vertices:t,edges_faces:n,faces_vertices:s},c);const l=Kc(i).filter((e=>e.map((e=>n[e].length>1)).reduce(((e,t)=>e&&t),true)));const d=l.map((e=>e.map((e=>n[e]))));const u=zv({vertices_coords:e,edges_vertices:t,faces_center:r},l,d);const m=u.map((e=>e.map(Nv)));const p=m.map(((e,t)=>Bv(e)?d[t]:undefined)).filter((e=>e!==undefined));const g=m.map(((e,t)=>$v(e)?d[t]:undefined)).map(((e,t)=>Iv(e,u[t]))).filter((e=>e!==undefined));const _=Uv(n,a,f);const h=g.concat(_);const v=m.map(((e,t)=>Rv(e)?Lv(d[t],m[t],u[t]):undefined)).filter((e=>e!==undefined));const b=f.map(((e,t)=>a[t].length>1&&a[t][0]===a[t][1]?e:[]));const y=b.map(((e,t)=>({taco:n[t],tortillas:e}))).filter((e=>e.tortillas.length));const M=y.flatMap((e=>e.tortillas.map((t=>({taco:[...e.taco],tortilla:t})))));const A=v.concat(M);return{taco_taco:p,tortilla_tortilla:h,taco_tortilla:A}};const Dv=({faces_polygon:e},t,n=E)=>{const s=t.map((()=>[]));t.forEach(((e,t)=>e.forEach((e=>{s[t][e]=true;s[e][t]=true}))));const r=[];t.forEach(((t,s)=>t.forEach((t=>{const o=yu(e[s],e[t],n);if(o){if(!r[s]){r[s]=[]}if(!r[t]){r[t]=[]}r[s][t]=o;r[t][s]=o}}))));const o=[];for(let t=0;t<r.length-1;t+=1){if(!r[t]){continue}for(let c=t+1;c<r.length;c+=1){if(!r[t][c]){continue}for(let a=c+1;a<r.length;a+=1){if(t===a||c===a){continue}if(!s[t][a]||!s[c][a]){continue}const i=yu(r[t][c],e[a],n);if(i){o.push([t,c,a].sort(((e,t)=>e-t)))}}}}return o};const qv=(e,{taco_taco:t,taco_tortilla:n})=>{const s={};t.map((e=>[e[0][0],e[0][1],e[1][0],e[1][1]].sort(((e,t)=>e-t)))).forEach((e=>[`${e[0]} ${e[1]} ${e[2]}`,`${e[0]} ${e[1]} ${e[3]}`,`${e[0]} ${e[2]} ${e[3]}`,`${e[1]} ${e[2]} ${e[3]}`].forEach((e=>{s[e]=true}))));n.map((e=>[e.taco[0],e.taco[1],e.tortilla].sort(((e,t)=>e-t)).join(" "))).forEach((e=>{s[e]=true}));return e.filter((e=>s[e.join(" ")]===undefined))};const Wv=Object.freeze({__proto__:null,filterTransitivity:qv,makeTransitivity:Dv});const Gv=({vertices_coords:e,edges_vertices:t,edges_faces:n,faces_vertices:s,faces_edges:r,edges_vector:o},c=E)=>{const a=Ic({vertices_coords:e,faces_vertices:s});const i=ar({vertices_coords:e,faces_vertices:s},c);a.map(((e,t)=>e?undefined:t)).filter((e=>e!==undefined)).forEach((e=>i[e].reverse()));const f=x_({vertices_coords:e,faces_vertices:s},c);const{taco_taco:l,taco_tortilla:d,tortilla_tortilla:u}=Qv({vertices_coords:e,edges_vertices:t,edges_faces:n,faces_vertices:s,faces_edges:r,edges_vector:o},c);const m=Dv({faces_polygon:i},f,c);const p=qv(m,{taco_taco:l,taco_tortilla:d});const g=Kc(f).map((e=>e.join(" ")));const _=Vv({taco_taco:l,taco_tortilla:d,tortilla_tortilla:u,transitivity:p});const h=Pv(_);return{constraints:_,lookup:h,facePairs:g,faces_winding:a}};const Hv=Object.freeze({__proto__:null,setup:Gv});const Jv=({edges_faces:e,edges_assignment:t},n,s)=>{const r={0:0,1:2,2:1};const o={M:1,m:1,V:2,v:2};const c={};n.forEach((e=>{c[e]=true}));const a={};e.forEach(((e,n)=>{const i=t[n];const f=o[i];if(e.length<2||f===undefined){return}const l=s[e[0]];const d=l?f:r[f];const u=`${e[0]} ${e[1]}`;const m=`${e[1]} ${e[0]}`;if(u in c){a[u]=d}if(m in c){a[m]=r[d]}}));return a};const Zv=["111112","111121","111222","112111","121112","121222","122111","122212","211121","211222","212111","212221","221222","222111","222212","222221"];const Yv=["112","121","212","221"];const Xv=["11","22"];const Kv=["112","121","122","211","212","221"];const eb=(e,t,n)=>{const s=Array.from(n).map((e=>parseInt(e,10)));if(s.filter((e=>e===0)).length!==t){return}e[t][n]=false;let r=false;for(let n=0;n<s.length;n+=1){const o=[];if(s[n]!==0){continue}for(let r=1;r<=2;r+=1){s[n]=r;if(e[t-1][s.join("")]!==false){o.push([n,r])}}s[n]=0;if(o.length>0&&r===false){r=[]}if(o.length===1){r.push(o[0])}}if(r!==false&&r.length===0){r=true}e[t][n]=r};const tb=e=>{const t=e[0].length;const n=Array.from(Array(t+1)).map((()=>({})));Array.from(Array(2**t)).map(((e,t)=>t.toString(2))).map((e=>Array.from(e).map((e=>parseInt(e,10)+1)).join(""))).map((e=>`11111${e}`.slice(-t))).forEach((e=>{n[0][e]=false}));e.forEach((e=>{n[0][e]=true}));Array.from(Array(t)).map(((e,t)=>t+1)).map((e=>Array.from(Array(3**t)).map(((e,t)=>t.toString(3))).map((e=>`000000${e}`.slice(-t))).forEach((t=>eb(n,e,t)))));let s=[];Array.from(Array(t+1)).map(((e,n)=>t-n)).forEach((e=>{const t=[];Object.keys(n[e]).forEach((s=>{let r=n[e][s];if(r.constructor===Array){r=r[0]}t.push([s,r])}));s=s.concat(t)}));s.sort(((e,t)=>parseInt(e[0],10)-parseInt(t[0],10)));const r={};s.forEach((e=>{r[e[0]]=Object.freeze(e[1])}));return Object.freeze(r)};const nb={taco_taco:tb(Zv),taco_tortilla:tb(Yv),tortilla_tortilla:tb(Xv),transitivity:tb(Kv)};const sb=Object.freeze(Object.keys(nb));const rb=(e,t,...n)=>{const s={0:0,1:2,2:1};const r=kv[e](t);const o=r.map((e=>e[1]<e[0]));const c=r.map(((e,t)=>o[t]?`${e[1]} ${e[0]}`:`${e[0]} ${e[1]}`));const a=c.map(((e,t)=>{for(let r=0;r<n.length;r+=1){if(n[r][e]){return o[t]?s[n[r][e]]:n[r][e]}}return 0})).join("");if(nb[e][a]===true||nb[e][a]===false){return nb[e][a]}const i=nb[e][a];const f=c[i[0]];const l=o[i[0]]?s[i[1]]:i[1];return[f,l]};const ob=(e,t,n)=>{const s={};sb.forEach((r=>{const o=n.flatMap((e=>t[r][e]));s[r]=an(o).filter((t=>e[r][t]))}));return s};const cb=(e,t,n,...s)=>{let r=n;const o={};do{const n=ob(e,t,r);const c={};for(let t=0;t<sb.length;t+=1){const r=sb[t];const a=n[r];for(let t=0;t<a.length;t+=1){const n=rb(r,e[r][a[t]],...s,o);if(n===true){continue}if(n===false){throw new Error(`invalid ${r} ${a[t]}:${e[r][a[t]]}`)}if(o[n[0]]){if(o[n[0]]!==n[1]){throw new Error(`conflict ${r} ${a[t]}:${e[r][a[t]]}`)}}else{const[e,t]=n;c[e]=true;o[n[0]]=t}}}r=Object.keys(c)}while(r.length);return o};const ab=(e,t,n)=>{const s=Object.keys(t);const r={};e.forEach((e=>{r[e]=true}));let o=0;const c=[];while(o<e.length){if(!r[e[o]]){o+=1;continue}const a=[];const i=[e[o]];const f={[e[o]]:true};do{const e=i.pop();delete r[e];a.push(e);const o={};s.forEach((s=>{const r=n[s][e];if(!r){return}r.map((e=>t[s][e])).map((e=>jv[s](e).forEach((e=>{o[e]=true}))))}));const c=Object.keys(o).filter((e=>r[e])).filter((e=>!f[e]));i.push(...c);c.forEach((e=>{f[e]=true}))}while(i.length);o+=1;c.push(a)}return c};const ib=(e,t,n,...s)=>{if(!n.length){return[]}const r=n[0];const o=[];const c=[];[1,2].forEach((a=>{let i;try{i=cb(e,t,[r],...s,{[r]:a})}catch(e){return}i[r]=a;if(Object.keys(i).length===n.length){o.push(i)}else{c.push(i)}}));const a=c.map((r=>ib(e,t,n.filter((e=>!(e in r))),...s,r)));return o.map((e=>[...s,e])).concat(...a)};const fb=({constraints:e,lookup:t,facePairs:s,orders:r})=>{let o;try{o=cb(e,t,Object.keys(r),r)}catch(e){throw new Error(n.noLayerSolution,{cause:e})}const c=s.filter((e=>!(e in r))).filter((e=>!(e in o)));let a;try{a=ab(c,e,t).map((n=>ib(e,t,n,r,o)))}catch(e){throw new Error(n.noLayerSolution,{cause:e})}const i={...r,...o};const f=a.map((e=>e.map((e=>Object.assign({},...e)))));return{root:i,branches:f}};const lb=e=>{const t=e.reduce(((e,t)=>e*t),1);const n=e.slice();for(let e=n.length-2;e>=0;e-=1){n[e]*=n[e+1]}n.push(1);n.shift();return Array.from(Array(t)).map(((t,s)=>e.map(((e,t)=>Math.floor(s/n[t])%e))))};const db={count:function(){return this.branches.map((e=>e.length))},faceOrders:function(...e){return Sv(this.compile(...e),this.faces_winding)},facesLayer:function(...e){return kn(this.linearize(...e).reverse())},compile:function(...e){const t=Array(this.branches.length).fill(0).map(((t,n)=>e[n]!=null?e[n]:t));const n=this.branches?this.branches.map(((e,n)=>e[t[n]])):[];return Object.assign({},this.root,...n)},directedPairs:function(...e){const t=this.compile(...e);return Object.keys(t).map((e=>t[e]===1?e.split(" "):e.split(" ").reverse())).map((e=>e.map((e=>parseInt(e,10)))))},linearize:function(...e){return Nd(this.directedPairs(...e))},allSolutions:function(){return lb(this.count()).map((e=>this.compile(...e)))},allFacesLayers:function(){return lb(this.count()).map((e=>this.facesLayer(...e)))}};const ub=()=>({root:{},branches:[],faces_winding:[]});const mb=({vertices_coords:e,edges_vertices:t,edges_faces:n,edges_assignment:s,faces_vertices:r,faces_edges:o,edges_vector:c},a)=>{if(!e||!t||!r){return Object.assign(Object.create(db),ub())}if(!o){o=or({edges_vertices:t,faces_vertices:r})}if(!n){n=Ws({edges_vertices:t,faces_edges:o})}if(a===undefined){a=Ev({vertices_coords:e,edges_vertices:t})}const{constraints:i,lookup:f,facePairs:l,faces_winding:d}=Gv({vertices_coords:e,edges_vertices:t,edges_faces:n,faces_vertices:r,faces_edges:o,edges_vector:c},a);const u=Jv({edges_faces:n,edges_assignment:s},l,d);const{root:m,branches:p}=fb({constraints:i,lookup:f,facePairs:l,orders:u});return Object.assign(Object.create(db),{root:m,branches:p,faces_winding:d})};const pb=(e,t,n=E)=>{const s=e[0]<e[1]?e:[e[1],e[0]];const r=t[0]<t[1]?t:[t[1],t[0]];const o=Math.min(s[1],r[1])-Math.max(s[0],r[0]);return o>n};const gb=({vertices_coords:e,edges_vertices:t},n,s,r=E)=>{const o=n.map((n=>t[n].map((t=>e[t]))));const c=o.map((e=>e.map((e=>D(e,s)))));const a=pb(...c,r);return a};const _b=(e,t)=>{if(e.orders){e.orders=e.orders.flatMap((e=>Sv(e,t)))}if(e.leaves){e.leaves=e.leaves.map((e=>Sv(e,t)))}if(e.partitions){e.partitions.forEach((e=>_b(e,t)))}if(e.node){e.node.forEach((e=>_b(e,t)))}return e};const hb=Object.freeze({__proto__:null,doEdgesOverlap:gb,doRangesOverlap:pb,reformatSolution:_b});const vb=({vertices_coords:e,edges_vertices:t},n=E)=>{const{lines:s,edges_line:r}=ko({vertices_coords:e,edges_vertices:t},n);const o=r.map((e=>s[e].vector));const c=Ks({vertices_coords:e,edges_vertices:t}).map(((e,t)=>e.map((e=>D(o[t],e)))));return kn(r).map((e=>e.constructor===Array?e:[e])).flatMap((e=>un(e).filter((e=>pb(...e.map((e=>c[e])))))))};const bb=({vertices_coords:e,edges_vertices:t,edges_faces:n,edges_foldAngle:s,faces_center:r},o,c,a,i=E)=>{const f=s.map(Ft);const l=vb({vertices_coords:e,edges_vertices:t},i).map((e=>e[0]<e[1]?e:e.slice().reverse())).filter((e=>!(f[e[0]]&&f[e[1]]))).filter((e=>e.map((e=>n[e].length===2)).reduce(((e,t)=>e&&t),true))).filter((e=>e.map((e=>o[e]!==undefined)).reduce(((e,t)=>e&&t),true))).filter((e=>Array.from(new Set(e.flatMap((e=>o[e])))).length!==4));const d=l.map((e=>e.map((e=>o[e]))));const u=d.map((e=>Array.from(new Set(e.flat()))));const m=d.map(((e,t)=>{const n={};e.flat().forEach((e=>{n[e]=[]}));e.forEach(((e,s)=>e.forEach((e=>n[e].push(l[t][s])))));return n}));const p=l.map((e=>e.map((e=>n[e]))));const g=p.map(((e,t)=>{const n={};u[t].forEach((e=>{n[e]=[]}));e.flat().forEach((e=>n[c[e]].push(e)));return n}));const _=Ks({vertices_coords:e,edges_vertices:t});const h=u.map(((e,t)=>{const n=_[l[t][0]];const s={};e.forEach((e=>{s[e]=n.map((t=>qg(a[e],t))).map((e=>[e[0],e[1]]))}));return s}));const v=g.map(((e,t)=>{const n={};u[t].forEach((s=>{const o=h[t][s][0];n[s]=e[s].map((e=>K(U(r[e],o),U(h[t][s][1],o)))).map((e=>Math.sign(e)))}));return n}));const b=v.map(((e,t)=>{const n={};u[t].forEach((t=>{n[t]=e[t].reduce(((n,s)=>n&&s===e[t][0]),true)}));return n}));const y=l.map(((e,t)=>{const n={};Object.keys(m[t]).forEach((e=>{n[e]={edges:m[t][e],faces:g[t][e],facesSides:v[t][e],facesSameSide:b[t][e]}}));return{edges:e,sets:n}}));const M=y.filter((e=>{const t=Object.values(e.sets).map((e=>e.faces.length===2)).reduce(((e,t)=>e&&t),true);const n=Object.values(e.sets).map((e=>e.facesSameSide)).reduce(((e,t)=>e&&t),true);return t&&n}));const A=y.filter((e=>{const t=Object.values(e.sets).length===3;const n=Object.values(e.sets).map((e=>e.facesSameSide)).reduce(((e,t)=>e&&t),true);return t&&n}));const x=y.filter((e=>{const t=Object.values(e.sets).map((e=>e.faces.length===2)).reduce(((e,t)=>e&&t),true);const n=Object.values(e.sets).map((e=>e.facesSameSide));const s=n[0]!==n[1];return t&&s}));const w=y.filter((e=>{const t=Object.values(e.sets).filter((e=>e.faces.length===3)).shift();const s=t!==undefined;if(!s){return false}const r=t.facesSides.reduce(((e,t)=>e+t),0);const o=Math.abs(r)===1;if(!o){return false}const c=t.faces.filter(((e,n)=>t.facesSides[n]===r));const a=t.edges.map((e=>n[e].map((e=>c.includes(e))).reduce(((e,t)=>e&&t),true))).reduce(((e,t)=>e||t),false);const i=!a;return s&&o&&i}));if(w.length){console.log("This model contains the third case",w)}return{tortillaTortillaEdges:M,solvable1:A,solvable2:x,solvable3:[]}};const yb=({edges_faces:e},t,n,s)=>{const r=t.map((e=>e.edges)).map((t=>t.map((t=>e[t].slice()))));r.forEach(((e,t)=>{if(n[e[0][0]]!==n[e[1][0]]){r[t][1].reverse()}}));r.map((e=>[e[0][0],e[0][1]])).map((e=>e.map((e=>s[e])))).map(((e,t)=>e[0]!==e[1]?t:undefined)).filter((e=>e!==undefined)).forEach((e=>{const t=r[e][0][1];r[e][0][1]=r[e][1][1];r[e][1][1]=t}));return r};const Eb=(e,t,n=E)=>{const s=t.map((t=>Ur(e,t,ut,n))).reduce(((e,t)=>e||t),false);if(s){return true}const r=bu(e,{vector:U(t[1],t[0]),origin:t[0]},ut,vt,n);return r!==undefined};const Mb=({vertices_coords:e,edges_vertices:t,edges_faces:n,edges_foldAngle:s},r,o,c,a,i,f,l,d=E)=>{const u=c.slice();u.forEach(((e,t)=>{if(e.length<2){delete u[t]}}));const m=n.map((e=>{const t={};e.forEach((e=>{t[e]=true}));return t}));const p=l.map((e=>e.filter((e=>u[e]!==undefined)).map((e=>u[e]))));l.map(((e,t)=>t)).filter((e=>p[e].length<2)).forEach((e=>delete p[e]));const g=p.map(((e,t)=>e.map((e=>e.filter((e=>m[t][e]))))));const _=p.map(((e,t)=>e.map((e=>e.filter((e=>!m[t][e]))))));const h=p.map(((n,s)=>t[s].map((t=>e[t]))));const v=_.map(((e,t)=>e.map((e=>e.map((e=>{const n=h[t].map((t=>qg(o[a[e]],t)));const s=n.map((e=>[e[0],e[1]]));return Eb(i[e],s,d)?e:undefined})).filter((e=>e!==undefined))))));const b=p.flatMap(((e,t)=>v[t].flatMap(((e,n)=>{const s=1-n;const r=g[t];return e.map((e=>({edge:t,faces:[r[n][0],r[s][0]],overlap:e,set:a[e]})))}))));const y=b.map((e=>[e.faces[0],e.overlap]));const M=y.map((e=>e[0]<e[1]));M.forEach(((e,t)=>{if(!e){y[t].reverse()}}));const A=b.map((e=>f[e.faces[0]]));const x=b.map((e=>s[e.edge])).map(Math.sign).map((e=>e===1));const w=b.map(((e,t)=>A[t]^x[t]));const k=w.map(((e,t)=>M[t]?e:1-e)).map((e=>e+1));const O={};y.forEach(((e,t)=>{O[e.join(" ")]=k[t]}));return O};const Ab=({edges_foldAngle:e,faces_winding:t},n,s)=>{const r=n.map((t=>t.map((t=>e[t]))));const o=s.map((e=>e.map((e=>t[e]))));const c=r.map(((e,t)=>e.map(((e,n)=>o[t][n]?e:-e))));const a=c.map((e=>e[0]>e[1]));const i=s.map((e=>e[0]<e[1]));const f=s.map(((e,t)=>a[t]^i[t]));const l={};const d=s.map(((e,t)=>i[t]?e:e.slice().reverse())).map((e=>e.join(" ")));f.map((e=>e+1)).forEach(((e,t)=>{l[d[t]]=e}));return l};const xb=({edges_foldAngle:e,faces_winding:t},n)=>{const s=n.map((e=>Object.values(e.sets).sort(((e,t)=>t.faces.length-e.faces.length)).shift()));const r=s.map((e=>e.edges));const o=s.map((e=>e.faces));return Ab({edges_foldAngle:e,faces_winding:t},r,o)};const wb=({edges_foldAngle:e,faces_winding:t},n)=>{const s=n.map((e=>Object.values(e.sets).filter((e=>e.facesSameSide)).shift()));const r=s.map((e=>e.edges));const o=s.map((e=>e.faces));return Ab({edges_foldAngle:e,faces_winding:t},r,o)};const kb=({edges_foldAngle:e,faces_winding:t},n)=>({});const Ob=({edges_foldAngle:e,faces_winding:t},n,s,r)=>{const o=xb({edges_foldAngle:e,faces_winding:t},n);const c=wb({edges_foldAngle:e,faces_winding:t},s);const a=kb({edges_foldAngle:e,faces_winding:t});return{...o,...c,...a}};const jb=(e,t,n)=>{const s=(e,t)=>{const n=qg(e,t);return[n[0],n[1]]};const r=e.vertices_coords.map((e=>de(3,e)));const o=t.map((t=>pc(e,t)));n.forEach(((e,t)=>{o[t].vertices_coords=o[t].vertices_coords.map(((t,n)=>s(e,r[n])))}));const c=e.edges_foldAngle.map(Ft).map(((e,t)=>!e?t:undefined)).filter((e=>e!==undefined));const a=Vt(e,"edges");o.forEach((e=>c.forEach((t=>a.forEach((n=>{delete e[n][t]}))))));return o};const Fb=Object.freeze({__proto__:null,graphGroupCopies:jb});const Sb=({edges_vertices:e,faces_edges:t},n)=>{const s=e.map((()=>({})));n.forEach(((e,n)=>t[n].forEach((t=>{s[t][e]=true}))));const r=s.map((e=>Object.keys(e).map((e=>parseInt(e,10))).sort(((e,t)=>e-t))));return r};const Cb=({vertices_coords:e,edges_vertices:t,edges_faces:n,edges_foldAngle:s,faces_edges:r,faces_winding:o,faces_center:c},a,i,f,l,d,u,m)=>{const p=u.map((e=>f[e[0]]));const g=kn(p).map((e=>e.constructor===Array?e:[e]));const _=g.map((e=>e.map((e=>d[e]))));const h=Sb({edges_vertices:t,faces_edges:r},f);h.map(((e,t)=>e.length!==2?t:undefined)).filter((e=>e!==undefined)).forEach((e=>delete h[e]));const{tortillaTortillaEdges:v,solvable1:b,solvable2:y,solvable3:E}=bb({vertices_coords:e,edges_vertices:t,edges_faces:n,edges_foldAngle:s,faces_center:c},h,f,i,m);const M=yb({edges_faces:n},v,f,o);const A=Mb({vertices_coords:e,edges_vertices:t,edges_faces:n,edges_foldAngle:s},_,i,a,f,l,o,h,m);const x=Ob({edges_foldAngle:s,faces_winding:o},b,y);const w={...A,...x};return{tortillas3D:M,orders:w}};const Vb=({vertices_coords:e,edges_vertices:t,edges_faces:n,edges_assignment:s,edges_foldAngle:r,faces_vertices:o,faces_edges:c,faces_faces:a},i=E)=>{if(!c){c=or({edges_vertices:t,faces_vertices:o})}if(!n){n=Ws({edges_vertices:t,faces_edges:c})}if(!a){a=cr({faces_vertices:o})}if(!r&&s){r=Ys({edges_assignment:s})}if(!s){s=Js({edges_foldAngle:r})}const{sets_faces:f,sets_transformXY:l,faces_set:d,faces_winding:u}=g_({vertices_coords:e,faces_vertices:o,faces_faces:a},i);const m=jb({vertices_coords:e,edges_vertices:t,edges_faces:n,edges_assignment:s,edges_foldAngle:r,faces_vertices:o,faces_edges:c,faces_faces:a},f,l);const p=hn(...m.map((e=>ar(e,i))));u.map(((e,t)=>e?undefined:t)).filter((e=>e!==undefined)).forEach((e=>p[e].reverse()));const g=hn(...m.map((e=>x_(e,i))));const _=p.map((e=>Y(...e)));m.forEach((e=>{e.faces_center=e.faces_vertices.map(((e,t)=>_[t]))}));const h=m.map((e=>Qv(e,i)));const v=h.flatMap((e=>e.taco_taco));const b=h.flatMap((e=>e.taco_tortilla));const y=h.flatMap((e=>e.tortilla_tortilla));const M=Dv({faces_polygon:p},g,i);const A=qv(M,{taco_taco:v,taco_tortilla:b});const x=Kc(g);const w=x.map((e=>e.join(" ")));const{tortillas3D:k,orders:O}=Cb({vertices_coords:e,edges_vertices:t,edges_faces:n,edges_foldAngle:r,faces_edges:c,faces_winding:u,faces_center:_},f,l,d,p,w,x,i);y.push(...k);const j=Vv({taco_taco:v,taco_tortilla:b,tortilla_tortilla:y,transitivity:A});const F=Pv(j);m.map((e=>Jv(e,w,u))).forEach((e=>Object.assign(O,e)));return{constraints:j,lookup:F,facePairs:w,faces_winding:u,orders:O}};const Pb=Object.freeze({__proto__:null,setup:Vb});const Tb=()=>({root:{},branches:[],faces_winding:[]});const zb=({vertices_coords:e,edges_vertices:t,edges_faces:n,edges_assignment:s,edges_foldAngle:r,faces_vertices:o,faces_edges:c,faces_faces:a},i)=>{if(!e||!t||!o){return Object.assign(Object.create(db),Tb())}if(i===undefined){i=Ev({vertices_coords:e,edges_vertices:t})}const{constraints:f,lookup:l,facePairs:d,faces_winding:u,orders:m}=Vb({vertices_coords:e,edges_vertices:t,edges_faces:n,edges_assignment:s,edges_foldAngle:r,faces_vertices:o,faces_edges:c,faces_faces:a},i);const{root:p,branches:g}=fb({constraints:f,lookup:l,facePairs:d,orders:m});return Object.assign(Object.create(db),{root:p,branches:g,faces_winding:u})};const Nb=(e,t,n)=>{const s=e.map((e=>e?(e[0]+e[1])/2:undefined));const r=[];e.forEach(((o,c)=>{if(!o){return}if(!t&&c===e.length-1){return}const a=o[1];const i=a-n*2;const f=a+n*2;const l=[c,(c+1)%e.length];const d=l.map((e=>s[e])).map((e=>e>a));const u=(!d[0]&&!d[1])*1+(d[0]&&d[1])*2;const m=r.filter((e=>e.min<a&&e.max>a)).shift();const p={faces:l,taco_type:u};if(m){m.pairs.push(p)}else{r.push({min:i,max:f,pairs:[p]})}}));return r.map((e=>e.pairs)).filter((e=>e.length>1)).map((e=>({both:e.filter((e=>e.taco_type===0)).map((e=>e.faces)),left:e.filter((e=>e.taco_type===1)).map((e=>e.faces)),right:e.filter((e=>e.taco_type===2)).map((e=>e.faces))})))};const Bb=(e,t,n)=>t<n?e.slice(t+1,n):e.slice(n+1,t);const $b=(e,t,n=true,s=E)=>{const r=kn(t);const o=e.map((e=>e?e[1]:undefined));const c=e.map((e=>e?Math.min(...e):undefined)).map((e=>e+s));const a=e.map((e=>e?Math.max(...e):undefined)).map((e=>e-s));const i=r.length+(n?0:-1);for(let e=0;e<i;e+=1){const n=(e+1)%r.length;if(r[e]===r[n]){continue}const s=Bb(t,r[e],r[n]).flat();const i=s.map((t=>o[e]<c[t])).reduce(((e,t)=>e&&t),true);const f=s.map((t=>o[e]>a[t])).reduce(((e,t)=>e&&t),true);if(!i&&!f){return false}}return true};const Rb=e=>{const t=fn(e);const n={};let s=0;for(let e=0;e<t.length;e+=1){if(n[t[e]]===undefined){s+=1;n[t[e]]=s}else if(n[t[e]]!==undefined){if(n[t[e]]!==s){return false}s-=1;n[t[e]]=undefined}}return true};const Lb=(e,t)=>e.map((e=>t[e])).filter((e=>e!==undefined));const Ib=(e,t,n,s,r)=>{const o=t.flat();if(!$b(e,t,s,r)){return false}for(let e=0;e<n.length;e+=1){const t=Lb(o,n[e]);if(!Rb(t)){return false}}return true};const Ub={V:true,v:true,M:true,m:true};const Qb=e=>{let t=0;const n=e.slice(1);return[false].concat(n.map((e=>Ub[e]?++t:t)).map((e=>e%2===1)))};const Db={V:1,v:1,M:-1,m:-1};const qb=(e,t)=>t%2===0?Db[e]||0:-(Db[e]||0);const Wb=e=>{let t=0;return e.slice(1).concat([e[0]]).map((e=>{const n=qb(e,t);t+=Db[e]===undefined?0:1;return n}))};const Gb=(e,t)=>{const n=Qb(t).map(((t,n)=>e[n]*(t?-1:1)));const s=e.map((()=>undefined));s[0]=[0,n[0]];for(let r=1;r<e.length;r+=1){if(t[r]==="B"||t[r]==="b"){break}const o=(r-1+e.length)%e.length;const c=s[o][1];s[r]=[c,c+n[r]]}return s};const Hb={B:true,b:true};const Jb=(e,t,n=E)=>{const s=Gb(e,t);const r=Wb(t);const o=t.map((e=>!Hb[e])).reduce(((e,t)=>e&&t),true);if(o){const e=s[0][0];const t=s[s.length-1][1];if(Math.abs(e-t)>n){return[]}}const c=Nb(s,o,n).map((e=>[e.left,e.right].map(kn).filter((e=>e.length>1)))).reduce(((e,t)=>e.concat(t)),[]);const a=(t=[0],i=0,f=0)=>{const l=i+1;const d=r[i];const u=i>=e.length-1;const m=o&&u;if(!Ib(s,t,c,m,n)){return[]}if(m){const e=kn(t);const n=e[0];const s=e[i];if(d>0&&s>n){return[]}if(d<0&&s<n){return[]}}if(u){return[t]}if(d===0){t[f]=[l].concat(t[f]);return a(t,l,f)}const p=d===1?Array.from(Array(t.length-f)).map(((e,t)=>f+t+1)):Array.from(Array(f+1)).map(((e,t)=>t));const g=p.map((()=>_a(t)));g.forEach(((e,t)=>e.splice(p[t],0,l)));return g.map(((e,t)=>a(e,l,p[t]))).reduce(((e,t)=>e.concat(t)),[])};return a().map(kn)};const Zb=(e,t,n)=>{if(t==null){t=e.map((()=>"U"))}const s=oh(t);const r=s.map((t=>Jb(e,t,n)));return s.map(((e,t)=>t)).filter((e=>r[e].length>0)).map((e=>({assignment:s[e],layer:r[e]})))};Object.assign(mb,{table:nb,makeTacosAndTortillas:Qv,...Wv,...wv,...Cv,...Hv,layer3d:zb,...Pb,...hb,...Fb,singleVertexSolver:Jb,singleVertexAssignmentSolver:Zb,foldStripWithAssignments:Gb});const Yb=(e,t,n={})=>{if(e===undefined){return undefined}const s=U(e[1],e[0]);const r=j(s);const o=q(s,[1,0]);const c=(ct(t)?.span||[1,1]).slice(0,2);const a=Math.min(...c);return{segment:e,head:{width:a*.1,height:a*.15},bend:o>0?.3:-.3,padding:r*.05}};const Xb=(e,t)=>{const n=bu(e,t);return n===undefined?undefined:H(...n)};const Kb=({vector:e,origin:t},n)=>be(je(e,t),n);const ey=(e,t,n)=>{const s=n===undefined?Xb(e,t):n;const r=oe(t.vector);const o=bu(e,{vector:r,origin:s}).map((e=>ne(s,e))).sort(((e,t)=>e-t)).shift();const c=N(P(r),o);return[R(s,re(c)),R(s,c)]};const ty=(e,t,n)=>{const s=n.map((e=>H(e[0],e[1])));const r=H(...s);const o={vector:e.vector.rotate90(),origin:r};return t.map((e=>eo(e,o).point))};const ny=(e,t,n,s)=>{const r=e.map((e=>e.vector));const o=r.map(re);const c=r.concat(o).map((e=>({vector:e,origin:t})));const a=c.map((e=>q(e.vector,n.vector)));const i=c.map((e=>K(e.vector,n.vector)));const f=c.filter(((e,t)=>a[t]>0&&i[t]>0)).shift();const l=c.filter(((e,t)=>a[t]>0&&i[t]<0)).shift();const d=c.filter(((e,t)=>a[t]<0&&i[t]>0)).shift();const u=c.filter(((e,t)=>a[t]<0&&i[t]<0)).shift();const m=[f,l,d,u].map((e=>ao(s,e,ht,gt).shift().shift()));const p=m.map((e=>ne(e,t)));const g=p[0]<p[1]?m[0]:m[1];const _=p[0]<p[1]?R(l.origin,N(P(l.vector),p[0])):R(f.origin,N(P(f.vector),p[1]));const h=p[2]<p[3]?m[2]:m[3];const v=p[2]<p[3]?R(u.origin,N(P(u.vector),p[2])):R(d.origin,N(P(d.vector),p[3]));return[[g,_],[h,v]]};const sy=({vertices_coords:e},t,n)=>{const s=I_(e).map((t=>e[t]));const r=ey(s,t);if(r===undefined){return undefined}return Yb(r,s,n)};const ry=({vertices_coords:e},t,n,s)=>{const r=I_(e).map((t=>e[t]));return hm(t,n).map((e=>ey(r,e))).map((e=>Yb(e,r,s)))};const oy=({vertices_coords:e},t,n,s)=>{const r=I_(e).map((t=>e[t]));return[Yb([t,n],r,s)]};const cy=({vertices_coords:e},t,n,s)=>{const r=I_(e).map((t=>e[t]));const o=Em(t,n);const c=[t,n].map((e=>bu(r,e))).filter((e=>e!==undefined));if(c.length!==2){return o.map((t=>sy({vertices_coords:e},t,s)))}const a=c.map((e=>Dn(...e)));const i=eo(...a,ht,ht).point;return!i?[ty(o.filter((e=>e!==undefined)).shift(),[t,n],c)]:o.map((e=>ny([t,n],i,e,r)))};const ay=({vertices_coords:e},t,n,s)=>{const r=I_(e).map((t=>e[t]));const o=Am(t,n).shift();const c=eo(o,t).point;const a=ey(r,o,c);return[Yb(a,r,s)]};const iy=({vertices_coords:e},t,n,s,r)=>{const o=I_(e).map((t=>e[t]));return wm(t,n,s).map((e=>[s,Kb(e,s)])).map((e=>Yb(e,o,r)))};const fy=({vertices_coords:e},t,n,s,r,o)=>{const c=I_(e).map((t=>e[t]));return Om(t,n,s,r).flatMap((e=>[s,r].map((t=>[t,Kb(e,t)])))).map((e=>Yb(e,c,o)))};const ly=({vertices_coords:e},t,n,s,r)=>{const o=I_(e).map((t=>e[t]));return Fm(t,n,s).flatMap((e=>[[s,Kb(e,s)],ey(o,e,eo(e,n).point)])).map((e=>Yb(e,o,r)))};const dy=Object.freeze({__proto__:null,axiom1Arrows:ry,axiom2Arrows:oy,axiom3Arrows:cy,axiom4Arrows:ay,axiom5Arrows:iy,axiom6Arrows:fy,axiom7Arrows:ly,simpleArrow:sy});const uy={...dy,segmentToArrow:Yb};Object.assign(um,N_);const my={graph:um,cp:mm,axiom:Hm,convert:Dp,general:Jp,math:Y_,singleVertex:ah,svg:ld,webgl:bv,diagram:uy,layer:mb};sd.ear=my;Object.defineProperty(my,"window",{enumerable:false,set:e=>{ld.window=o(e)}});export{my as default};