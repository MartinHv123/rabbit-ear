const e=typeof window!=="undefined"&&typeof window.document!=="undefined";const t=typeof process!=="undefined"&&process.versions!=null&&process.versions.node!=null;const s={planarize:"graph could not planarize",manifold:"valid manifold required",graphCycle:"cycle not allowed",planarBoundary:"planar boundary detection error, bad graph",circularEdge:"circular edges not allowed",replaceModifyParam:"replace() index < value. indices parameter modified",replaceUndefined:"replace() generated undefined",flatFoldAngles:"foldAngles cannot be determined from flat-folded faces without an assignment",noWebGL:"WebGl not Supported",convexFace:"only convex faces are supported",window:"window not set; if using node/deno include package @xmldom/xmldom and set ear.window = xmldom",nonConvexTriangulation:"non-convex triangulation requires vertices_coords",backendStylesheet:"svgToFold found <style> in <svg>. rendering will be incomplete unless run in a major browser.",noLayerSolution:"LayerSolver bad input. no solution possible"};const n={window:undefined};const r=e=>(new e.DOMParser).parseFromString("<!DOCTYPE html><title>.</title>","text/html");const c=e=>{if(!e.document){e.document=r(e)}n.window=e;return n.window};if(e){n.window=window}const o=()=>{if(n.window===undefined){throw new Error(s.window)}return n.window};const a=1e-6;const i=180/Math.PI;const f=Math.PI/180;const l=Math.PI*2;const d=Object.freeze({__proto__:null,D2R:f,EPSILON:a,R2D:i,TWO_PI:l});const u=(e,t)=>e+(t||0);const m=e=>Math.sqrt(e.map((e=>e*e)).reduce(u,0));const g=e=>Math.sqrt(e[0]*e[0]+e[1]*e[1]);const p=e=>Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);const _=e=>e.map((e=>e*e)).reduce(u,0);const v=e=>{const t=m(e);return t===0?e:e.map((e=>e/t))};const h=e=>{const t=g(e);return t===0?e:[e[0]/t,e[1]/t]};const b=e=>{const t=p(e);return t===0?e:[e[0]/t,e[1]/t,e[2]/t]};const y=(e,t)=>e.map((e=>e*t));const E=(e,t)=>[e[0]*t,e[1]*t];const A=(e,t)=>[e[0]*t,e[1]*t,e[2]*t];const x=(e,t)=>e.map(((e,s)=>e+(t[s]||0)));const M=(e,t)=>[e[0]+t[0],e[1]+t[1]];const w=(e,t)=>[e[0]+t[0],e[1]+t[1],e[2]+t[2]];const k=(e,t)=>e.map(((e,s)=>e-(t[s]||0)));const O=(e,t)=>[e[0]-t[0],e[1]-t[1]];const j=(e,t)=>[e[0]-t[0],e[1]-t[1],e[2]-t[2]];const F=(e,t)=>e.map(((s,n)=>e[n]*t[n])).reduce(u,0);const C=(e,t)=>e[0]*t[0]+e[1]*t[1];const S=(e,t)=>e[0]*t[0]+e[1]*t[1]+e[2]*t[2];const P=(e,t)=>e.map(((e,s)=>(e+t[s])/2));const V=(e,t)=>E(M(e,t),.5);const N=(e,t)=>A(w(e,t),.5);const z=function(){if(arguments.length===0){return undefined}const e=arguments[0].length>0?arguments[0].length:0;const t=Array(e).fill(0);Array.from(arguments).forEach((e=>t.forEach(((s,n)=>{t[n]+=e[n]||0}))));return t.map((e=>e/arguments.length))};const T=(...e)=>{if(!e||!e.length){return undefined}const t=1/e.length;return e.reduce(((e,t)=>M(e,t)),[0,0]).map((e=>e*t))};const $=(e,t,s=0)=>{const n=1-s;return e.map(((e,r)=>e*n+(t[r]||0)*s))};const B=(e,t)=>e[0]*t[1]-e[1]*t[0];const L=(e,t)=>[e[1]*t[2]-e[2]*t[1],e[2]*t[0]-e[0]*t[2],e[0]*t[1]-e[1]*t[0]];const I=(e,t)=>Math.sqrt(e.map(((s,n)=>(e[n]-t[n])**2)).reduce(u,0));const R=(e,t)=>{const s=e[0]-t[0];const n=e[1]-t[1];return Math.sqrt(s*s+n*n)};const U=(e,t)=>{const s=e[0]-t[0];const n=e[1]-t[1];const r=e[2]-t[2];return Math.sqrt(s*s+n*n+r*r)};const q=e=>e.map((e=>-e));const D=e=>[-e[1],e[0]];const W=e=>[e[1],-e[0]];const G=(e,t=a)=>e.map((e=>Math.abs(e))).reduce(u,0)<t;const H=(e,t,s=a)=>1-Math.abs(F(e,t))<s;const J=(e,t,s=a)=>H(v(e),v(t),s);const Q=(e,t,s=a)=>Math.abs(B(e,t))<s;const Z=(e,t)=>t.length===e?t:Array(e).fill(0).map(((e,s)=>t[s]?t[s]:e));const Y=(e,t)=>[e,t].map((s=>Z(Math.max(e.length,t.length),s)));const X=(e=[1,0])=>{const t=h(e);return[t,D(t)]};const K=(e=[1,0,0])=>{const t=b(e);const s=[[1,0,0],[0,1,0],[0,0,1]].map((e=>L(e,t)));const n=s.map(p).map(((e,t)=>({n:e,i:t}))).sort(((e,t)=>t.n-e.n)).map((e=>e.i)).shift();const r=b(s[n]);return[t,r,L(t,r)]};const ee=e=>e.length===2?X(e):K(e);const te=Object.freeze({__proto__:null,add:x,add2:M,add3:w,average:z,average2:T,basisVectors:ee,basisVectors2:X,basisVectors3:K,cross2:B,cross3:L,degenerate:G,distance:I,distance2:R,distance3:U,dot:F,dot2:C,dot3:S,flip:q,lerp:$,magSquared:_,magnitude:m,magnitude2:g,magnitude3:p,midpoint:P,midpoint2:V,midpoint3:N,normalize:v,normalize2:h,normalize3:b,parallel:J,parallel2:Q,parallelNormalized:H,resize:Z,resizeUp:Y,rotate270:W,rotate90:D,scale:y,scale2:E,scale3:A,subtract:k,subtract2:O,subtract3:j});const se=[1,0,0,1];const ne=se.concat(0,0);const re=(e,t)=>[e[0]*t[0]+e[2]*t[1]+e[4],e[1]*t[0]+e[3]*t[1]+e[5]];const ce=(e,t,s)=>({vector:[e[0]*t[0]+e[2]*t[1],e[1]*t[0]+e[3]*t[1]],origin:[e[0]*s[0]+e[2]*s[1]+e[4],e[1]*s[0]+e[3]*s[1]+e[5]]});const oe=(e,t)=>[e[0]*t[0]+e[2]*t[1],e[1]*t[0]+e[3]*t[1],e[0]*t[2]+e[2]*t[3],e[1]*t[2]+e[3]*t[3],e[0]*t[4]+e[2]*t[5]+e[4],e[1]*t[4]+e[3]*t[5]+e[5]];const ae=e=>e[0]*e[3]-e[1]*e[2];const ie=e=>{const t=ae(e);if(Math.abs(t)<1e-12||Number.isNaN(t)||!Number.isFinite(e[4])||!Number.isFinite(e[5])){return undefined}return[e[3]/t,-e[1]/t,-e[2]/t,e[0]/t,(e[2]*e[5]-e[3]*e[4])/t,(e[1]*e[4]-e[0]*e[5])/t]};const fe=(e=0,t=0)=>se.concat(e,t);const le=(e=[1,1],t=[0,0])=>[e[0],0,0,e[1],e[0]*-t[0]+t[0],e[1]*-t[1]+t[1]];const de=(e=1,t=[0,0])=>le([e,e],t);const ue=(e,t=[0,0])=>{const s=Math.cos(e);const n=Math.sin(e);return[s,n,-n,s,t[0],t[1]]};const me=(e,t=[0,0])=>{const s=Math.atan2(e[1],e[0]);const n=Math.cos(s);const r=Math.sin(s);const c=Math.cos(-s);const o=Math.sin(-s);const a=n*c+r*o;const i=n*-o+r*c;const f=r*c+-n*o;const l=r*-o+-n*c;const d=t[0]+a*-t[0]+-t[1]*f;const u=t[1]+i*-t[0]+-t[1]*l;return[a,i,f,l,d,u]};const ge=Object.freeze({__proto__:null,determinant2:ae,identity2x2:se,identity2x3:ne,invertMatrix2:ie,makeMatrix2Reflect:me,makeMatrix2Rotate:ue,makeMatrix2Scale:le,makeMatrix2Translate:fe,makeMatrix2UniformScale:de,multiplyMatrices2:oe,multiplyMatrix2Line2:ce,multiplyMatrix2Vector2:re});const pe=Object.freeze([1,0,0,0,1,0,0,0,1]);const _e=Object.freeze(pe.concat(0,0,0));const ve=e=>_e.map(((t,s)=>Math.abs(t-e[s])<a)).reduce(((e,t)=>e&&t),true);const he=(e,t)=>[e[0]*t[0]+e[3]*t[1]+e[6]*t[2]+e[9],e[1]*t[0]+e[4]*t[1]+e[7]*t[2]+e[10],e[2]*t[0]+e[5]*t[1]+e[8]*t[2]+e[11]];const be=(e,t,s)=>({vector:[e[0]*t[0]+e[3]*t[1]+e[6]*t[2],e[1]*t[0]+e[4]*t[1]+e[7]*t[2],e[2]*t[0]+e[5]*t[1]+e[8]*t[2]],origin:[e[0]*s[0]+e[3]*s[1]+e[6]*s[2]+e[9],e[1]*s[0]+e[4]*s[1]+e[7]*s[2]+e[10],e[2]*s[0]+e[5]*s[1]+e[8]*s[2]+e[11]]});const ye=(e,t)=>[e[0]*t[0]+e[3]*t[1]+e[6]*t[2],e[1]*t[0]+e[4]*t[1]+e[7]*t[2],e[2]*t[0]+e[5]*t[1]+e[8]*t[2],e[0]*t[3]+e[3]*t[4]+e[6]*t[5],e[1]*t[3]+e[4]*t[4]+e[7]*t[5],e[2]*t[3]+e[5]*t[4]+e[8]*t[5],e[0]*t[6]+e[3]*t[7]+e[6]*t[8],e[1]*t[6]+e[4]*t[7]+e[7]*t[8],e[2]*t[6]+e[5]*t[7]+e[8]*t[8],e[0]*t[9]+e[3]*t[10]+e[6]*t[11]+e[9],e[1]*t[9]+e[4]*t[10]+e[7]*t[11]+e[10],e[2]*t[9]+e[5]*t[10]+e[8]*t[11]+e[11]];const Ee=e=>e[0]*e[4]*e[8]-e[0]*e[7]*e[5]-e[3]*e[1]*e[8]+e[3]*e[7]*e[2]+e[6]*e[1]*e[5]-e[6]*e[4]*e[2];const Ae=e=>{const t=Ee(e);if(Math.abs(t)<1e-12||Number.isNaN(t)||!Number.isFinite(e[9])||!Number.isFinite(e[10])||!Number.isFinite(e[11])){return undefined}const s=[e[4]*e[8]-e[7]*e[5],-e[1]*e[8]+e[7]*e[2],e[1]*e[5]-e[4]*e[2],-e[3]*e[8]+e[6]*e[5],e[0]*e[8]-e[6]*e[2],-e[0]*e[5]+e[3]*e[2],e[3]*e[7]-e[6]*e[4],-e[0]*e[7]+e[6]*e[1],e[0]*e[4]-e[3]*e[1],-e[3]*e[7]*e[11]+e[3]*e[8]*e[10]+e[6]*e[4]*e[11]-e[6]*e[5]*e[10]-e[9]*e[4]*e[8]+e[9]*e[5]*e[7],e[0]*e[7]*e[11]-e[0]*e[8]*e[10]-e[6]*e[1]*e[11]+e[6]*e[2]*e[10]+e[9]*e[1]*e[8]-e[9]*e[2]*e[7],-e[0]*e[4]*e[11]+e[0]*e[5]*e[10]+e[3]*e[1]*e[11]-e[3]*e[2]*e[10]-e[9]*e[1]*e[5]+e[9]*e[2]*e[4]];const n=1/t;return s.map((e=>e*n))};const xe=(e=0,t=0,s=0)=>pe.concat(e,t,s);const Me=(e,t,s,n,r)=>{const c=Math.cos(e);const o=Math.sin(e);const a=pe.concat([0,0,0]);a[s*3+s]=c;a[s*3+n]=(r?+1:-1)*o;a[n*3+s]=(r?-1:+1)*o;a[n*3+n]=c;const i=[0,1,2].map((e=>t[e]||0));const f=pe.concat(q(i));const l=pe.concat(i);return ye(l,ye(a,f))};const we=(e,t=[0,0,0])=>Me(e,t,1,2,true);const ke=(e,t=[0,0,0])=>Me(e,t,0,2,false);const Oe=(e,t=[0,0,0])=>Me(e,t,0,1,true);const je=(e,t=[0,0,1],s=[0,0,0])=>{const n=[0,1,2].map((e=>s[e]||0));const[r,c,o]=Z(3,v(t));const a=Math.cos(e);const i=Math.sin(e);const f=1-a;const l=pe.concat(-n[0],-n[1],-n[2]);const d=pe.concat(n[0],n[1],n[2]);return ye(d,ye([f*r*r+a,f*c*r+o*i,f*o*r-c*i,f*r*c-o*i,f*c*c+a,f*o*c+r*i,f*r*o+c*i,f*c*o-r*i,f*o*o+a,0,0,0],l))};const Fe=(e=[1,1,1],t=[0,0,0])=>[e[0],0,0,0,e[1],0,0,0,e[2],e[0]*-t[0]+t[0],e[1]*-t[1]+t[1],e[2]*-t[2]+t[2]];const Ce=(e=1,t=[0,0,0])=>Fe([e,e,e],t);const Se=(e,t=[0,0])=>{const s=me(e,t);return[s[0],s[1],0,s[2],s[3],0,0,0,1,s[4],s[5],0]};const Pe=Object.freeze({__proto__:null,determinant3:Ee,identity3x3:pe,identity3x4:_e,invertMatrix3:Ae,isIdentity3x4:ve,makeMatrix3ReflectZ:Se,makeMatrix3Rotate:je,makeMatrix3RotateX:we,makeMatrix3RotateY:ke,makeMatrix3RotateZ:Oe,makeMatrix3Scale:Fe,makeMatrix3Translate:xe,makeMatrix3UniformScale:Ce,multiplyMatrices3:ye,multiplyMatrix3Line3:be,multiplyMatrix3Vector3:he});const Ve=e=>e!=null&&typeof e[Symbol.iterator]==="function";const Ne=function(){switch(arguments.length){case 0:return Array.from(arguments);case 1:return Ve(arguments[0])&&typeof arguments[0]!=="string"?Ne(...arguments[0]):[arguments[0]];default:return Array.from(arguments).map((e=>Ve(e)?[...Ne(e)]:e))}};const ze=function(){switch(arguments.length){case 0:return Array.from(arguments);case 1:return Ve(arguments[0])&&typeof arguments[0]!=="string"?ze(...arguments[0]):[arguments[0]];default:return Array.from(arguments).map((e=>Ve(e)?[...ze(e)]:e)).flat()}};const Te=function(){let e=ze(arguments);const t=e[0];if(typeof t==="object"&&t!==null&&!Number.isNaN(t.x)){e=["x","y","z"].map((e=>t[e])).filter((e=>e!==undefined))}return e.filter((e=>typeof e==="number"))};const $e=function(){return Ne(arguments).map((e=>Te(e)))};const Be=function(){const e=Ne(arguments);return e.length===4?[[0,1],[2,3]].map((t=>t.map((t=>e[t])))):e.map((e=>Te(e)))};const Le=(e,t=[])=>({vector:e,origin:t});const Ie=function(){const e=Ne(arguments);if(e.length===0||e[0]==null){return Le([],[])}if(e[0].constructor===Object&&e[0].vector!==undefined){return Le(e[0].vector,e[0].origin||[])}return typeof e[0]==="number"?Le(Te(e)):Le(...e.map((e=>Te(e))))};const Re=Object.freeze({__proto__:null,getArrayOfVectors:$e,getLine:Ie,getSegment:Be,getVector:Te});const Ue=e=>Array.from(Array(Math.floor(e))).map(((t,s)=>l*(s/e)));const qe=(e,t)=>e.map((e=>[t*Math.cos(e),t*Math.sin(e)]));const De=(e=3,t=1)=>qe(Ue(e),t);const We=(e=3,t=1)=>{const s=Math.PI/e;const n=Ue(e).map((e=>e+s));return qe(n,t)};const Ge=(e=3,t=1)=>De(e,t/Math.cos(Math.PI/e));const He=(e=3,t=1)=>We(e,t/Math.cos(Math.PI/e));const Je=(e=3,t=1)=>De(e,t/2/Math.sin(Math.PI/e));const Qe=(e=3,t=1)=>We(e,t/2/Math.sin(Math.PI/e));const Ze=(e,t=a)=>{const s=e.map(((e,t,s)=>[e,s[(t+1)%s.length]])).map((e=>k(e[1],e[0])));const n=s.map(((e,t,s)=>[e,s[(t+s.length-1)%s.length]])).map((e=>!J(e[1],e[0],t)));return e.filter(((e,t)=>n[t]))};const Ye=(e,t,s)=>{const n=t[0]-e[0];const r=t[1]-e[1];const c=s[0]-e[0];const o=s[1]-e[1];const i=n*(e[0]+t[0])+r*(e[1]+t[1]);const f=c*(e[0]+s[0])+o*(e[1]+s[1]);const l=2*(n*(s[1]-t[1])-r*(s[0]-t[0]));if(Math.abs(l)<a){const n=Math.min(e[0],t[0],s[0]);const r=Math.min(e[1],t[1],s[1]);const c=(Math.max(e[0],t[0],s[0])-n)*.5;const o=(Math.max(e[1],t[1],s[1])-r)*.5;return{origin:[n+c,r+o],radius:Math.sqrt(c*c+o*o)}}const d=[(o*i-r*f)/l,(n*f-c*i)/l];const u=d[0]-e[0];const m=d[1]-e[1];return{origin:d,radius:Math.sqrt(u*u+m*m)}};const Xe=e=>.5*e.map(((e,t,s)=>[e,s[(t+1)%s.length]])).map((e=>B(...e))).reduce(((e,t)=>e+t),0);const Ke=e=>{const t=1/(6*Xe(e));return e.map(((e,t,s)=>[e,s[(t+1)%s.length]])).map((e=>E(M(...e),B(...e)))).reduce(((e,t)=>M(e,t)),[0,0]).map((e=>e*t))};const et=(e,t=0)=>{if(!e||!e.length){return undefined}const s=Array(e[0].length).fill(Infinity);const n=Array(e[0].length).fill(-Infinity);e.filter((e=>e!==undefined)).forEach((e=>e.forEach(((e,r)=>{if(e<s[r]){s[r]=e-t}if(e>n[r]){n[r]=e+t}}))));const r=n.map(((e,t)=>e-s[t]));return{min:s,max:n,span:r}};const tt=Object.freeze({__proto__:null,boundingBox:et,centroid:Ke,circumcircle:Ye,makePolygonCircumradius:De,makePolygonCircumradiusSide:We,makePolygonInradius:Ge,makePolygonInradiusSide:He,makePolygonNonCollinear:Ze,makePolygonSideLength:Je,makePolygonSideLengthSide:Qe,signedArea:Xe});const st=(e,t,s=a)=>Math.abs(e-t)<s;const nt=(e,t,s=a)=>st(e,t,s)?0:Math.sign(e-t);const rt=(e,t,s=a)=>{for(let n=0;n<Math.max(e.length,t.length);n+=1){if(!st(e[n]||0,t[n]||0,s)){return false}}return true};const ct=(e,t=a)=>e>-t;const ot=(e,t=a)=>e>t;const at=()=>true;const it=()=>true;const ft=ct;const lt=ot;const dt=(e,t=a)=>e>-t&&e<1+t;const ut=(e,t=a)=>e>t&&e<1-t;const mt=Object.freeze({__proto__:null,epsilonCompare:nt,epsilonEqual:st,epsilonEqualVectors:rt,exclude:ot,excludeL:it,excludeR:lt,excludeS:ut,include:ct,includeL:at,includeR:ft,includeS:dt});const gt={file:["file_spec","file_creator","file_author","file_title","file_description","file_classes","file_frames"],frame:["frame_author","frame_title","frame_description","frame_attributes","frame_classes","frame_unit","frame_parent","frame_inherit"],graph:["vertices_coords","vertices_vertices","vertices_faces","edges_vertices","edges_faces","edges_assignment","edges_foldAngle","edges_length","faces_vertices","faces_edges","vertices_edges","edges_edges","faces_faces"],orders:["edgeOrders","faceOrders"]};const pt=["singleModel","multiModel","animation","diagrams"];const _t=["creasePattern","foldedForm","graph","linkage"];const vt=["2D","3D","abstract","manifold","nonManifold","orientable","nonOrientable","selfTouching","nonSelfTouching","selfIntersecting","nonSelfIntersecting"];const ht=Object.freeze({__proto__:null,foldFileClasses:pt,foldFrameAttributes:vt,foldFrameClasses:_t,foldKeys:gt});const bt={vertices:"vertex",edges:"edge",faces:"face"};const yt={vertex:"vertices",edge:"edges",face:"faces"};const Et=Array.from("BbMmVvFfJjCcUu");const At={B:"boundary",M:"mountain",V:"valley",F:"flat",J:"join",C:"cut",U:"unassigned"};Object.keys(At).forEach((e=>{At[e.toLowerCase()]=At[e]}));const xt={B:0,b:0,M:-180,m:-180,V:180,v:180,F:0,f:0,J:0,j:0,C:0,c:0,U:0,u:0};const Mt={B:false,b:false,M:true,m:true,V:true,v:true,F:false,f:false,J:false,j:false,C:false,c:false,U:true,u:true};const wt={B:true,b:true,M:false,m:false,V:false,v:false,F:false,f:false,J:false,j:false,C:true,c:true,U:false,u:false};const kt=e=>xt[e]||0;const Ot=e=>{if(e>a){return"V"}if(e<-a){return"M"}return"U"};const jt=e=>st(0,e)||st(-180,e)||st(180,e);const Ft=({edges_foldAngle:e})=>{if(!e){return true}for(let t=0;t<e.length;t+=1){if(!jt(e[t])){return false}}return true};const Ct=(e,t)=>Object.keys(e).filter((e=>t(e)));const St=(e,t)=>Ct(e,(e=>e.substring(0,t.length+1)===`${t}_`));const Pt=(e,t)=>Ct(e,(e=>e.substring(e.length-t.length-1,e.length)===`_${t}`));const Vt=(e,t)=>{const s=St(e,t);if(s.length===0){return[]}const n=Math.max(...s.map((t=>e[t].length)));const r=Array.from(Array(n)).map((()=>({})));s.forEach((t=>r.forEach(((s,n)=>{r[n][t]=e[t][n]}))));return r};const Nt=(e,t,s)=>{const n=St(e,t);if(n.length===0){return undefined}const r={};n.forEach((t=>{r[t]=e[t][s]}));return r};const zt=Object.freeze([].concat(gt.file).concat(gt.frame).concat(gt.graph).concat(gt.orders));const Tt=(e={})=>Object.keys(e).length===0?0:zt.filter((t=>e[t])).length/Object.keys(e).length;const $t=({frame_classes:e,file_classes:t})=>e&&e.includes("foldedForm")||t&&t.includes("foldedForm");const Bt=({vertices_coords:e})=>{if(e[0]!==undefined){return e[0].length}const t=e.filter((()=>true)).shift();if(!t){return undefined}return t.length};const Lt=({edges_vertices:e,edges_foldAngle:t,edges_assignment:s})=>{if(s===undefined){return t===undefined?e.map((()=>true)):t.map((e=>e<-a||e>a))}return s.map((e=>Mt[e]))};const It={M:"V",m:"v",V:"M",v:"m"};const Rt=e=>It[e]||e;const Ut=e=>{if(e.edges_assignment){e.edges_assignment=e.edges_assignment.map((e=>It[e]?It[e]:e))}if(e.edges_foldAngle){e.edges_foldAngle=e.edges_foldAngle.map((e=>-e))}return e};const qt=(e={})=>{const t={};gt.file.filter((e=>e!=="file_frames")).filter((t=>e[t]!==undefined)).forEach((s=>{t[s]=e[s]}));return t};const Dt=Object.freeze({__proto__:null,assignmentCanBeFolded:Mt,assignmentFlatFoldAngle:xt,assignmentIsBoundary:wt,edgeAssignmentToFoldAngle:kt,edgeFoldAngleIsFlat:jt,edgeFoldAngleToAssignment:Ot,edgesAssignmentNames:At,edgesAssignmentValues:Et,edgesFoldAngleAreAllFlat:Ft,filterKeysWithPrefix:St,filterKeysWithSuffix:Pt,getDimension:Bt,getFileMetadata:qt,invertAssignment:Rt,invertAssignments:Ut,isFoldObject:Tt,isFoldedForm:$t,makeEdgesIsFolded:Lt,pluralize:yt,singularize:bt,transposeGraphArrayAtIndex:Nt,transposeGraphArrays:Vt});const Wt=function(e,t){Pt(e,"coords").forEach((s=>{e[s]=e[s].map((e=>Z(3,e))).map((e=>he(t,e)))}));Pt(e,"matrix").forEach((s=>{e[s]=e[s].map((e=>ye(e,t)))}));return e};const Gt=(e,...t)=>{const s=t.flat();const n=s.length===1?[s[0],s[0],s[0]]:[1,1,1].map(((e,t)=>s[t]===undefined?e:s[t]));const r=Fe(n);return Wt(e,r)};const Ht=(e,...t)=>{const s=Te(...t);const n=Z(3,s);const r=xe(...n);return Wt(e,r)};const Jt=(e,t,s,n)=>Wt(e,je(t,s,n));const Qt=(e,t,...s)=>{const n=Te(...s);const r=Z(3,n);const c=Oe(t,r);return Wt(e,c)};const Zt=function(e){if(!e.vertices_coords){return e}const t=et(e.vertices_coords);const s=Math.max(...t.span);const n=s===0?1:1/s;const r=t.min;e.vertices_coords=e.vertices_coords.map((e=>k(e,r))).map((e=>e.map((e=>e*n))));return e};const Yt=Object.freeze({__proto__:null,rotate:Jt,rotateZ:Qt,scale:Gt,transform:Wt,translate:Ht,unitize:Zt});const Xt=({vertices_coords:e},t=a)=>{if(!e){return[]}const s=Bt({vertices_coords:e});const n=Array.from(Array(s));const r=[];const c=[];const o=e.map(((e,t)=>({i:t,d:e[0]}))).sort(((e,t)=>e.d-t.d)).map((e=>e.i));let i=0;const f=n.map((()=>[0,0]));const l=t=>n.map(((s,n)=>e[t][n]>f[n][0]&&e[t][n]<f[n][1])).reduce(((e,t)=>e&&t),true);const d=n=>{const r=n[n.length-1];while(e[r][0]-e[n[i]][0]>t){i+=1}const c=n.slice(i,n.length).map((t=>e[t]));f[0]=[c[0][0]-t,c[c.length-1][0]+t];for(let e=1;e<s;e+=1){const s=c.map((t=>t[e]));f[e]=[Math.min(...s)-t,Math.max(...s)+t]}};while(c.length!==e.length){const t=[];const s=o.shift();t.push(s);c.push(s);i=0;d(t);let n=0;while(n<o.length&&e[o[n]][0]<f[0][1]){if(l(o[n])){const e=o.splice(n,1).shift();t.push(e);c.push(e);d(t)}else{n+=1}}r.push(t)}return r};const Kt=Object.freeze({__proto__:null,getVerticesClusters:Xt});const es=(...e)=>Math.max(0,...e.filter((e=>e!==undefined)).map((e=>e.length)));const ts=(e,t)=>es(...St(e,t).map((t=>e[t])));ts.vertices=({vertices_coords:e,vertices_faces:t,vertices_vertices:s})=>es(e,t,s);ts.edges=({edges_vertices:e,edges_edges:t,edges_faces:s})=>es(e,t,s);ts.faces=({faces_vertices:e,faces_edges:t,faces_faces:s})=>es(e,t,s);const ss=e=>e.concat(e.slice(0,-1).reverse());const ns=(...e)=>{const t=[];e.forEach((e=>e.forEach(((e,s)=>{t[s]=e}))));return t};const rs=(e,t)=>{t.sort(((e,t)=>e-t));return[e.slice(t[1]).concat(e.slice(0,t[0]+1)),e.slice(t[0],t[1]+1)]};const cs=e=>Array.from(new Set(e));const os=e=>{const t={};e.forEach((e=>{if(t[e]===undefined){t[e]=0}t[e]+=1}));return e.filter((e=>t[e]>1))};const as=e=>{const t={};e.forEach((e=>{t[e]=true}));return Object.keys(t).map(parseFloat)};const is=(e,t=a)=>{const s=e.slice().sort(((e,t)=>e-t));if(s.length<2){return s}const n=[true];for(let e=1;e<s.length;e+=1){n[e]=!st(s[e],s[e-1],t)}return s.filter(((e,t)=>n[t]))};const fs=e=>{const t=Array(e.length*(e.length-1)/2);let s=0;for(let n=0;n<e.length-1;n+=1){for(let r=n+1;r<e.length;r+=1,s+=1){t[s]=[e[n],e[r]]}}return t};const ls=(e,t)=>{const s=t===undefined?e.map(((e,t)=>({i:t,value:e}))):e.map(((e,s)=>({i:s,value:t(e)})));let n;let r=Infinity;for(let e=0;e<s.length;e+=1){if(s[e].value<r){n=e;r=s[e].value}}return n};const ds=Object.freeze({__proto__:null,arrayMinimum:ls,chooseTwoPairs:fs,epsilonUniqueSortedNumbers:is,mirrorArray:ss,nonUniqueElements:os,splitCircularArray:rs,uniqueElements:cs,uniqueSortedNumbers:as,zipperArrays:ns});const us=(e,t,n)=>{const r=ts(e,t);let c=false;Object.entries(n).filter((([e,t])=>e<t)).forEach((([e,t])=>{c=true;delete n[e];n[t]=e}));if(c){console.warn(s.replaceModifyParam)}const o=Object.keys(n).map((e=>parseInt(e,10)));const a=as(o);const i=[];for(let e=0,t=0,c=0;e<r;e+=1,t+=1){while(e===a[c]){i[e]=i[n[a[c]]];if(i[e]===undefined){throw new Error(s.replaceUndefined)}e+=1;c+=1}if(e<r){i[e]=t}}Pt(e,t).forEach((t=>e[t].forEach(((s,n)=>e[t][n].forEach(((s,r)=>{e[t][n][r]=i[s]}))))));a.reverse();St(e,t).forEach((t=>a.forEach((s=>e[t].splice(s,1)))));return i};const ms=(e,t)=>Xt(e,t).filter((e=>e.length>1));const gs=(e,t=a)=>{const s=[];const n=[];const r=Xt(e,t).filter((e=>e.length>1));r.forEach((e=>{if(Math.min(...e)!==e[0]){e.sort(((e,t)=>e-t))}for(let t=1;t<e.length;t+=1){s[e[t]]=e[0];n.push(e[t])}}));r.map((t=>t.map((t=>e.vertices_coords[t])))).map((e=>z(...e))).forEach(((t,s)=>{e.vertices_coords[r[s][0]]=t}));return{map:us(e,"vertices",s),remove:n}};const ps=Object.freeze({__proto__:null,duplicateVertices:ms,removeDuplicateVertices:gs});const _s=(e,t,s)=>{const n=ts(e,t);const r=as(s);const c=[];for(let e=0,t=0,s=0;e<n;e+=1,t+=1){while(e===r[s]){c[e]=undefined;e+=1;s+=1}if(e<n){c[e]=t}}Pt(e,t).forEach((t=>e[t].forEach(((s,n)=>e[t][n].forEach(((s,r)=>{e[t][n][r]=c[s]}))))));r.reverse();St(e,t).forEach((t=>r.forEach((s=>e[t].splice(s,1)))));Pt(e,t).forEach((t=>e[t].forEach(((s,n)=>{e[t][n]=e[t][n].filter((e=>e!==undefined))}))));return c};const vs=({vertices_coords:e,edges_vertices:t})=>{if(!e||!t){return[]}let s=e.length;const n=Array(s).fill(false);t.forEach((e=>{e.filter((e=>!n[e])).forEach((e=>{n[e]=true;s-=1}))}));return n.map(((e,t)=>e?undefined:t)).filter((e=>e!==undefined))};const hs=({vertices_coords:e,faces_vertices:t})=>{if(!e||!t){return[]}let s=e.length;const n=Array(s).fill(false);t.forEach((e=>{e.filter((e=>!n[e])).forEach((e=>{n[e]=true;s-=1}))}));return n.map(((e,t)=>e?undefined:t)).filter((e=>e!==undefined))};const bs=({vertices_coords:e,edges_vertices:t,faces_vertices:s})=>{if(!e){return[]}let n=e.length;const r=Array(n).fill(false);if(t){t.forEach((e=>{e.filter((e=>!r[e])).forEach((e=>{r[e]=true;n-=1}))}))}if(s){s.forEach((e=>{e.filter((e=>!r[e])).forEach((e=>{r[e]=true;n-=1}))}))}return r.map(((e,t)=>e?undefined:t)).filter((e=>e!==undefined))};const ys=(e,t)=>{if(!t){t=bs(e)}return{map:_s(e,"vertices",t),remove:t}};const Es=Object.freeze({__proto__:null,edgeIsolatedVertices:vs,faceIsolatedVertices:hs,isolatedVertices:bs,removeIsolatedVertices:ys});const As=e=>Math.atan2(e[1],e[0]);const xs=e=>[Math.cos(e),Math.sin(e)];const Ms=(e,t)=>({vector:k(t,e),origin:e});const ws=({vector:e,origin:t})=>{const s=m(e);const n=D(e);const r=F(t,n)/s;return{normal:y(n,1/s),distance:r}};const ks=({normal:e,distance:t})=>({vector:W(e),origin:y(e,t)});const Os=Object.freeze({__proto__:null,angleToVector:xs,pointsToLine:Ms,uniqueLineToVecLine:ks,vecLineToUniqueLine:ws,vectorToAngle:As});const js=(e,t,s)=>{while(s<t){s+=l}while(e>t){e-=l}while(e<t){e+=l}return e<s};const Fs=(e,t)=>{while(e<0){e+=l}while(t<0){t+=l}while(e>l){e-=l}while(t>l){t-=l}const s=e-t;return s>=0?s:l-(t-e)};const Cs=(e,t)=>{while(e<0){e+=l}while(t<0){t+=l}while(e>l){e-=l}while(t>l){t-=l}const s=t-e;return s>=0?s:l-(e-t)};const Ss=(e,t)=>{const s=t[0]*e[0]+t[1]*e[1];const n=t[0]*e[1]-t[1]*e[0];let r=Math.atan2(n,s);if(r<0){r+=l}return r};const Ps=(e,t)=>{const s=e[0]*t[0]+e[1]*t[1];const n=e[0]*t[1]-e[1]*t[0];let r=Math.atan2(n,s);if(r<0){r+=l}return r};const Vs=(e,t)=>xs(As(e)-Ss(e,t)/2);const Ns=(e,t)=>xs(As(e)+Ps(e,t)/2);const zs=(e,t,s)=>{const n=Fs(e,t)/s;return Array.from(Array(s-1)).map(((t,s)=>e+n*(s+1)))};const Ts=(e,t,s)=>{const n=Cs(e,t)/s;return Array.from(Array(s-1)).map(((t,s)=>e+n*(s+1)))};const $s=(e,t,s)=>{const n=Math.atan2(e[1],e[0]);const r=Math.atan2(t[1],t[0]);return zs(n,r,s).map(xs)};const Bs=(e,t,s)=>{const n=Math.atan2(e[1],e[0]);const r=Math.atan2(t[1],t[0]);return Ts(n,r,s).map(xs)};const Ls=e=>{const t=e.map(((e,t)=>t)).sort(((t,s)=>e[t]-e[s]));return t.slice(t.indexOf(0),t.length).concat(t.slice(0,t.indexOf(0)))};const Is=e=>Ls(e.map(As));const Rs=e=>Ls(e).map((t=>e[t])).map(((e,t,s)=>[e,s[(t+1)%s.length]])).map((e=>Cs(e[0],e[1])));const Us=e=>Rs(e.map(As));const qs=(e,t,s,n=a)=>{const r=h(O(t,e));const c=h(O(s,e));const o=B(r,c);if(!st(o,0,n)){return Math.sign(o)}return st(R(e,t)+R(t,s),R(e,s))?0:undefined};const Ds=Object.freeze({__proto__:null,clockwiseAngle2:Ss,clockwiseAngleRadians:Fs,clockwiseBisect2:Vs,clockwiseSubsect2:$s,clockwiseSubsectRadians:zs,counterClockwiseAngle2:Ps,counterClockwiseAngleRadians:Cs,counterClockwiseBisect2:Ns,counterClockwiseOrder2:Is,counterClockwiseOrderRadians:Ls,counterClockwiseSectors2:Us,counterClockwiseSectorsRadians:Rs,counterClockwiseSubsect2:Bs,counterClockwiseSubsectRadians:Ts,isCounterClockwiseBetween:js,threePointTurnDirection:qs});const Ws=e=>{let t=-1;e.filter((e=>e!==undefined)).forEach((e=>e.forEach((e=>e.forEach((e=>{if(e>t){t=e}}))))));return t};const Gs=e=>{let t=-1;e.forEach((e=>{if(e[0]>t){t=e[0]}if(e[1]>t){t=e[1]}}));return t};const Hs={edges:"edgeOrders",faces:"faceOrders"};const Js=(e,t)=>Math.max(Ws(Pt(e,t).map((t=>e[t]))),e[Hs[t]]?Gs(e[Hs[t]]):-1)+1;Js.vertices=e=>Js(e,"vertices");Js.edges=e=>Js(e,"edges");Js.faces=e=>Js(e,"faces");const Qs=({vertices_vertices:e,vertices_sectors:t},s,n,r={})=>{const c={};const o={vertices:[s],edges:[],angles:[]};let a=s;let i=n;while(true){const s=e[i];const n=s.indexOf(a);const f=(n+s.length-1)%s.length;const l=s[f];const d=`${i} ${l}`;if(c[d]){Object.assign(r,c);o.vertices.pop();return o}c[d]=true;if(r[d]){return undefined}o.vertices.push(i);o.edges.push(d);if(t){o.angles.push(t[i][f])}a=i;i=l}};const Zs=({vertices_vertices:e,vertices_sectors:t})=>{const s={vertices_vertices:e,vertices_sectors:t};const n={};return e.map(((e,t)=>e.map((e=>Qs(s,t,e,n))).filter((e=>e!==undefined)))).flat()};const Ys=e=>e.filter((e=>e.angles.map((e=>Math.PI-e)).reduce(((e,t)=>e+t),0)>0));const Xs=Object.freeze({__proto__:null,counterClockwiseWalk:Qs,filterWalkedBoundaryFace:Ys,planarVertexWalk:Zs});const Ks=(e,t=[1,0,0],s=[0,0,0])=>{const n=Z(3,e);const r=j(n,Z(3,s));const c=b(Z(3,t));const o=S(c,r);const a=A(c,o);return j(n,a)};const en=Object.freeze({__proto__:null,projectPointOnPlane:Ks});const tn=(e,t,s)=>e.map(((e,n)=>({i:n,n:s(e,t)}))).sort(((e,t)=>e.n-t.n)).map((e=>e.i));const sn=(e,t)=>tn(e,t,F);const nn=e=>{const t=[e=>e[0]>=0&&e[1]>=0,e=>e[0]<0&&e[1]>=0,e=>e[0]<0&&e[1]<0,e=>e[0]>=0&&e[1]<0];const s=[(t,s)=>e[s][0]-e[t][0],(t,s)=>e[s][0]-e[t][0],(t,s)=>e[t][0]-e[s][0],(t,s)=>e[t][0]-e[s][0]];const n=e.map((e=>t.map(((t,s)=>t(e)?s:undefined)).filter((e=>e!==undefined)).shift()));const r=[[],[],[],[]];n.forEach(((e,t)=>{r[e].push(t)}));return r.flatMap(((e,t)=>e.sort(s[t])))};const rn=(e,t=[1,0,0],s=[0,0,0])=>{const n=K(t);const r=[n[1],n[2],n[0]];const c=e.map((e=>Ks(e,t,s)));const o=c.map((e=>k(e,s)));const a=o.map((e=>[F(e,r[0]),F(e,r[1])]));const i=a.map(h);return nn(i)};const cn=Object.freeze({__proto__:null,radialSortPointIndices3:rn,radialSortUnitVectors2:nn,sortAgainstItem:tn,sortPointsAlongVector:sn});const on=({vertices_coords:e},t,s)=>t.map((t=>e[t])).map((t=>k(t,e[s]))).map((e=>Math.atan2(e[1],e[0]))).map((e=>e>-a?e:e+Math.PI*2)).map(((e,t)=>({a:e,i:t}))).sort(((e,t)=>e.a-t.a)).map((e=>e.i)).map((e=>t[e]));const an=({vertices_coords:e},t,s)=>sn(t.map((t=>e[t])),s).map((e=>t[e]));const fn=Object.freeze({__proto__:null,sortVerticesAlongVector:an,sortVerticesCounterClockwise:on});const ln=({vertices_coords:e,faces_vertices:t})=>t.map((t=>t.map((t=>e[t])))).map((e=>{let t;let s;let n=0;do{t=k(e[(n+1)%e.length],e[n]);s=k(e[(n+2)%e.length],e[n]);n+=1}while(n<e.length&&J(t,s));return b(L(Z(3,t),Z(3,s)))}));const dn=({vertices_coords:e,faces_vertices:t,faces_normal:s})=>{const n=(e,t)=>{e[0]+=t[0];e[1]+=t[1];e[2]+=t[2]};if(!s){s=ln({vertices_coords:e,faces_vertices:t})}const r=e.map((()=>[0,0,0]));t.forEach(((e,t)=>e.forEach((e=>n(r[e],s[t])))));return r.map((e=>b(e)))};const un=Object.freeze({__proto__:null,makeFacesNormal:ln,makeVerticesNormal:dn});const mn=({edges_vertices:e})=>{const t=[];e.forEach(((e,s)=>e.forEach((e=>{if(t[e]===undefined){t[e]=[]}t[e].push(s)}))));return t};const gn=({edges_vertices:e,vertices_vertices:t})=>{const s=En({edges_vertices:e});return t.map(((e,t)=>e.map((e=>s[`${t} ${e}`]))))};const pn=({vertices_coords:e,vertices_edges:t,edges_vertices:s})=>{if(!t){t=mn({edges_vertices:s})}const n=t.map(((e,t)=>e.map((e=>s[e].filter((e=>e!==t)))).reduce(((e,t)=>e.concat(t)),[])));return e===undefined?n:n.map(((t,s)=>on({vertices_coords:e},t,s)))};const _n=({vertices_coords:e,vertices_faces:t,faces_vertices:s})=>{if(!t){t=bn({vertices_coords:e,faces_vertices:s})}const n=t.map((e=>e.map((e=>s[e]))));const r=n.map(((e,t)=>e.map((e=>e.indexOf(t)))));const c=n.map(((e,t)=>e.map(((e,s)=>[(r[t][s]+e.length-1)%e.length,r[t][s],(r[t][s]+1)%e.length]))));const o=c.map(((e,t)=>e.map(((e,s)=>e.map((e=>n[t][s][e]))))));const a=o.map((e=>{const t=e.map((e=>[[0,1],[1,2]].map((t=>t.map((t=>e[t])).join(" ")))));const s={};const n={};t.forEach(((e,t)=>{s[e[0]]=t;n[e[1]]=t}));return{facesVerts:t,to:n,from:s}}));return a.map((e=>{const t=Object.keys(e.to);const s=t.map((e=>e.split(" ").reverse().join(" ")));const n=t.filter(((t,n)=>!(s[n]in e.from)));if(n.length>2){console.warn("vertices_vertices found an unsolvable vertex");return[]}const r=n.length?n:[t[0]];const c=[];const o={};for(let t=0;t<r.length;t+=1){const s=r[t];const n=[s];o[s]=true;let a=false;do{const t=n[n.length-1];const s=e.to[t];if(!(s in e.facesVerts)){break}let r;if(e.facesVerts[s][0]===t){r=e.facesVerts[s][1]}if(e.facesVerts[s][1]===t){r=e.facesVerts[s][0]}if(r===undefined){return"not found"}const c=r.split(" ").reverse().join(" ");n.push(r);a=c in o;if(!a){n.push(c)}o[r]=true;o[c]=true}while(!a);const i=n.filter(((e,t)=>t%2===0)).map((e=>e.split(" ")[1])).map((e=>parseInt(e,10)));c.push(...i)}return c}))};const vn=e=>{if(!e.vertices_coords||!e.vertices_coords.length){return[]}const t=e.vertices_coords.filter((()=>true)).shift().length;switch(t){case 3:return _n(e);default:return pn(e)}};const hn=({vertices_edges:e,edges_vertices:t})=>{if(!e){e=mn({edges_vertices:t})}return e.map(((e,s)=>e.flatMap((e=>t[e].filter((e=>e!==s))))))};const bn=({vertices_coords:e,vertices_edges:t,faces_vertices:s})=>{const n=e||t;if(!s){return(n||[]).map((()=>[]))}const r=n!==undefined?n.map((()=>[])):Array.from(Array(Js.vertices({faces_vertices:s}))).map((()=>[]));s.forEach(((e,t)=>{const s=[];e.forEach((e=>{s[e]=t}));s.forEach(((e,t)=>r[t].push(e)))}));return r};const yn=({vertices_coords:e,vertices_vertices:t,faces_vertices:s})=>{if(!s){return e.map((()=>[]))}if(!t){return bn({vertices_coords:e,faces_vertices:s})}const n=xn({faces_vertices:s});return t.map(((e,t)=>e.map(((e,s,n)=>[n[(s+1)%n.length],t,e].join(" "))))).map((e=>e.map((e=>n[e]))))};const En=({edges_vertices:e})=>{const t={};e.map((e=>e.join(" "))).forEach(((e,s)=>{t[e]=s}));e.map((e=>`${e[1]} ${e[0]}`)).forEach(((e,s)=>{t[e]=s}));return t};const An=({edges_vertices:e})=>{const t={};e.map((e=>e.join(" "))).forEach(((e,s)=>{t[e]=s}));return t};const xn=({faces_vertices:e})=>{const t={};e.forEach(((e,s)=>e.map(((t,s)=>[0,1,2].map((t=>(s+t)%e.length)).map((t=>e[t])).join(" "))).forEach((e=>{t[e]=s}))));return t};const Mn=({vertices_coords:e,vertices_vertices:t,vertices_edges:s,vertices_faces:n,edges_vertices:r,edges_vector:c,faces_vertices:o})=>{if(!c){c=zn({vertices_coords:e,edges_vertices:r})}if(!t){t=vn({vertices_coords:e,vertices_edges:s,vertices_faces:n,edges_vertices:r,faces_vertices:o})}const a=An({edges_vertices:r});return t.map(((e,s)=>t[s].map((e=>{const t=a[`${s} ${e}`];const n=a[`${e} ${s}`];if(t!==undefined){return c[t]}if(n!==undefined){return q(c[n])}}))))};const wn=({vertices_coords:e,vertices_vertices:t,edges_vertices:s,edges_vector:n})=>Mn({vertices_coords:e,vertices_vertices:t,edges_vertices:s,edges_vector:n}).map((e=>e.length===1?[l]:Us(e)));const kn=({edges_vertices:e,vertices_edges:t})=>e.map(((e,s)=>{const n=t[e[0]].filter((e=>e!==s));const r=t[e[1]].filter((e=>e!==s));return n.concat(r)}));const On=({edges_vertices:e,faces_edges:t})=>{const s=e!==undefined?e.map((()=>[])):Array.from(Array(Js.edges({faces_edges:t}))).map((()=>[]));t.forEach(((e,t)=>{const n=[];e.forEach((e=>{n[e]=t}));n.forEach(((e,t)=>s[t].push(e)))}));return s};const jn=({vertices_coords:e,edges_vertices:t,edges_vector:s,faces_vertices:n,faces_edges:r,faces_center:c})=>{if(!t||!n&&!r){return On({faces_edges:r})}if(!n){n=Ln({edges_vertices:t,faces_edges:r})}if(!r){r=In({edges_vertices:t,faces_vertices:n})}if(!s){s=zn({vertices_coords:e,edges_vertices:t})}const o=t.map((t=>e[t[0]]));if(!c){c=Wn({vertices_coords:e,faces_vertices:n})}const a=t.map((()=>[]));r.forEach(((e,t)=>{const s=[];e.forEach((e=>{s[e]=t}));s.forEach(((e,t)=>a[t].push(e)))}));a.forEach(((e,t)=>{const n=e.map((e=>c[e])).map((e=>O(e,o[t]))).map((e=>B(e,s[t])));e.sort(((e,t)=>n[e]-n[t]))}));return a};const Fn={M:-180,m:-180,V:180,v:180};const Cn=({edges_foldAngle:e})=>e.map((e=>{if(e===0){return"F"}return e<0?"M":"V"}));const Sn=({edges_vertices:e,edges_foldAngle:t,edges_faces:s,faces_vertices:n,faces_edges:r})=>{if(e&&!s){if(!r&&n){r=In({edges_vertices:e,faces_vertices:n})}if(r){s=On({edges_vertices:e,faces_edges:r})}}if(t){return s?t.map(((e,t)=>{if(s[t].length<2){return"B"}if(e===0){return"F"}return e<0?"M":"V"})):Cn({edges_foldAngle:t})}return e.map((()=>"U"))};const Pn=({edges_assignment:e})=>e.map((e=>Fn[e]||0));const Vn=({vertices_coords:e,edges_vertices:t,edges_faces:n,edges_assignment:r,faces_vertices:c,faces_edges:o,faces_normal:a,faces_center:i})=>{if(!n){if(!o){o=In({edges_vertices:t,faces_vertices:c})}n=On({edges_vertices:t,faces_edges:o})}if(!a){a=ln({vertices_coords:e,faces_vertices:c})}if(!i){i=Wn({vertices_coords:e,faces_vertices:c})}return n.map(((e,t)=>{if(e.length>2){throw new Error(s.manifold)}if(e.length<2){return 0}const n=a[e[0]];const c=a[e[1]];const o=v(k(i[e[1]],i[e[0]]));let f=Math.sign(F(n,o));if(f===0){if(r&&r[t]){if(r[t]==="F"||r[t]==="F"){f=0}if(r[t]==="M"||r[t]==="m"){f=-1}if(r[t]==="V"||r[t]==="v"){f=1}}else{throw new Error(s.flatFoldAngles)}}return Math.acos(F(n,c))*(180/Math.PI)*f}))};const Nn=({vertices_coords:e,edges_vertices:t})=>t.map((t=>t.map((t=>e[t]))));const zn=({vertices_coords:e,edges_vertices:t})=>Nn({vertices_coords:e,edges_vertices:t}).map((e=>k(e[1],e[0])));const Tn=({vertices_coords:e,edges_vertices:t})=>zn({vertices_coords:e,edges_vertices:t}).map((e=>m(e)));const $n=({vertices_coords:e,edges_vertices:t,edges_coords:s},n=0)=>{if(!s){s=Nn({vertices_coords:e,edges_vertices:t})}return s.map((e=>et(e,n)))};const Bn=({vertices_coords:e,vertices_vertices:t,vertices_edges:s,vertices_sectors:n,edges_vertices:r,edges_vector:c})=>{if(!t){t=vn({vertices_coords:e,edges_vertices:r,vertices_edges:s})}if(!n){n=wn({vertices_coords:e,vertices_vertices:t,edges_vertices:r,edges_vector:c})}const o=En({edges_vertices:r});const a=Ys(Zs({vertices_vertices:t,vertices_sectors:n})).map((e=>({...e,edges:e.edges.map((e=>o[e]))})));return{faces_vertices:a.map((e=>e.vertices)),faces_edges:a.map((e=>e.edges)),faces_sectors:a.map((e=>e.angles))}};const Ln=({edges_vertices:e,faces_edges:t})=>t.map((t=>t.map((t=>e[t])).map(((e,t,s)=>{const n=s[(t+1)%s.length];return e[0]===n[0]||e[0]===n[1]?e[1]:e[0]}))));const In=({edges_vertices:e,faces_vertices:t})=>{const s=En({edges_vertices:e});return t.map((e=>e.map(((e,t,s)=>[e,s[(t+1)%s.length]].join(" "))))).map((e=>e.map((e=>s[e]))))};const Rn=({faces_vertices:e})=>{const t=e.map((()=>[]));const s={};e.forEach(((e,t)=>e.forEach(((n,r,c)=>{let o=c[(r+1)%e.length];if(o<n){[n,o]=[o,n]}const a=`${n} ${o}`;if(s[a]===undefined){s[a]={}}s[a][t]=true}))));Object.values(s).map((e=>Object.keys(e))).filter((e=>e.length>1)).forEach((e=>{t[e[0]].push(parseInt(e[1],10));t[e[1]].push(parseInt(e[0],10))}));return t};const Un=({vertices_coords:e,faces_vertices:t},s)=>t.map((t=>t.map((t=>e[t])))).map((e=>Ze(e,s)));const qn=({vertices_coords:e,faces_vertices:t})=>t.map((t=>t.map((t=>e[t]))));const Dn=({vertices_coords:e,faces_vertices:t})=>t.map((t=>t.map((t=>e[t])))).map((e=>Ke(e)));const Wn=({vertices_coords:e,faces_vertices:t})=>{const s=e.filter((()=>true)).shift();if(!s){return t.map((()=>[]))}const n=s.length;return t.map((t=>t.map((t=>e[t])).reduce(((e,t)=>x(e,t)),Array(n).fill(0)).map((e=>e/t.length))))};const Gn=Object.freeze({__proto__:null,makeEdgesAssignment:Sn,makeEdgesAssignmentSimple:Cn,makeEdgesBoundingBox:$n,makeEdgesCoords:Nn,makeEdgesEdges:kn,makeEdgesFaces:jn,makeEdgesFacesUnsorted:On,makeEdgesFoldAngle:Pn,makeEdgesFoldAngleFromFaces:Vn,makeEdgesLength:Tn,makeEdgesVector:zn,makeFacesCenter2D:Dn,makeFacesConvexCenter:Wn,makeFacesEdgesFromVertices:In,makeFacesFaces:Rn,makeFacesPolygon:Un,makeFacesPolygonQuick:qn,makeFacesVerticesFromEdges:Ln,makePlanarFaces:Bn,makeVerticesEdges:gn,makeVerticesEdgesUnsorted:mn,makeVerticesFaces:yn,makeVerticesFacesUnsorted:bn,makeVerticesSectors:wn,makeVerticesToEdge:An,makeVerticesToEdgeBidirectional:En,makeVerticesToFace:xn,makeVerticesVertices:vn,makeVerticesVertices2D:pn,makeVerticesVerticesFromFaces:_n,makeVerticesVerticesUnsorted:hn,makeVerticesVerticesVector:Mn});const Hn=({edges_vertices:e})=>{if(!e){return[]}const t=[];const s={};for(let n=0;n<e.length;n+=1){const r=`${e[n][0]} ${e[n][1]}`;const c=`${e[n][1]} ${e[n][0]}`;if(s[r]!==undefined){t[n]=s[r]}else{s[r]=n;s[c]=n}}return t};const Jn=(e,t)=>{if(!t){t=Hn(e)}const s=Object.keys(t).map((e=>parseInt(e,10)));const n=us(e,"edges",t);if(s.length){if(e.vertices_edges||e.vertices_vertices||e.vertices_faces){e.vertices_edges=mn(e);e.vertices_vertices=vn(e);e.vertices_edges=gn(e);e.vertices_faces=yn(e)}}return{map:n,remove:s}};const Qn=Object.freeze({__proto__:null,duplicateEdges:Hn,removeDuplicateEdges:Jn});const Zn=({edges_vertices:e})=>{if(!e){return[]}const t=[];for(let s=0;s<e.length;s+=1){if(e[s][0]===e[s][1]){t.push(s)}}return t};const Yn=(e,t,s)=>{const n={};s.forEach((e=>{n[e]=true}));Pt(e,t).forEach((t=>e[t].forEach(((s,r)=>{for(let c=s.length-1;c>=0;c-=1){if(n[s[c]]===true){e[t][r].splice(c,1)}}}))))};const Xn=(e,t)=>{if(!t){t=Zn(e)}if(t.length){Yn(e,"edges",t)}return{map:_s(e,"edges",t),remove:t}};const Kn=Object.freeze({__proto__:null,circularEdges:Zn,removeCircularEdges:Xn});const er=(...e)=>{if(e.length===0){return[]}const t=e[0].map(((e,t)=>t));e.forEach((e=>t.forEach(((s,n)=>{t[n]=e[s]}))));return t};const tr=(...e)=>{if(e.length===0){return[]}const t=e[0].map(((e,t)=>[t]));e.forEach((e=>{t.forEach(((s,n)=>s.forEach(((s,r)=>{t[n][r]=e[s]}))));t.forEach(((e,s)=>{t[s]=e.reduce(((e,t)=>e.concat(t)),[]).filter((e=>e!==undefined))}))}));return t};const sr=(...e)=>{if(e.length===0){return[]}let t=e[0].map(((e,t)=>t));e.forEach((e=>{const s=e.map((e=>t[e]));t=s}));return t};const nr=(...e)=>{if(e.length===0){return[]}let t=e[0].reduce(((e,t)=>e.concat(t)),[]).map(((e,t)=>[t]));e.forEach((e=>{const s=[];e.forEach(((e,n)=>{if(typeof e==="number"){s[n]=t[e]}else{s[n]=e.map((e=>t[e])).reduce(((e,t)=>e.concat(t)),[])}}));t=s}));return t};const rr=e=>{const t=[];const s=(e,s)=>{if(t[e]!==undefined){if(typeof t[e]==="number"){t[e]=[t[e],s]}else{t[e].push(s)}}else{t[e]=s}};e.forEach(((e,t)=>{if(e==null){return}if(typeof e==="number"){s(e,t)}if(e.constructor===Array){e.forEach((e=>s(e,t)))}}));return t};const cr=e=>{const t=[];const s=(e,s)=>{if(t[e]===undefined){t[e]=[]}t[e].push(s)};e.forEach(((e,t)=>{if(e==null){return}if(typeof e==="number"){s(e,t)}if(e.constructor===Array){e.forEach((e=>s(e,t)))}}));return t};const or=e=>{const t=[];e.forEach(((e,s)=>{t[e]=s}));return t};const ar=(e,t,s=[])=>{Pt(e,t).forEach((t=>e[t].forEach(((n,r)=>e[t][r].forEach(((n,c)=>{e[t][r][c]=s[n]}))))));const n=or(s);St(e,t).forEach((t=>{e[t]=n.map((s=>e[t][s]))}))};const ir=Object.freeze({__proto__:null,invertMap:rr,invertMapArray:cr,invertSimpleMap:or,mergeBackmaps:nr,mergeNextmaps:tr,mergeSimpleBackmaps:sr,mergeSimpleNextmaps:er,remapComponent:ar});const fr=(e,t)=>{const s=gs(e,t);const n=Xn(e);const r=Jn(e);const c=ys(e);const o=or(s.map);const a=c.remove.map((e=>o[e]));const i=or(n.map);const f=r.remove.map((e=>i[e]));return{vertices:{map:er(s.map,c.map),remove:s.remove.concat(a)},edges:{map:er(n.map,r.map),remove:n.remove.concat(f)}}};const lr=({vertices_coords:e,edges_vertices:t,edges_assignment:s,edges_foldAngle:n,faces_vertices:r,faces_edges:c})=>{if(!r){return undefined}let o=0;let a=0;const i={faces_vertices:r.map((e=>e.map((()=>a++))))};if(!e){return i}i.vertices_coords=structuredClone(r.flatMap((t=>t.map((t=>e[t])))));if(!t){return i}if(!c){c=In({edges_vertices:t,faces_vertices:r})}i.edges_vertices=c.flatMap((e=>e.map(((e,t,s)=>t===s.length-1?[o,++o-s.length]:[o,++o]))));const f=c.flatMap((e=>e));if(s){i.edges_assignment=structuredClone(f.map((e=>s[e])))}if(n){i.edges_foldAngle=structuredClone(f.map((e=>n[e])))}return i};const dr=({vertices_coords:e,edges_vertices:t,edges_assignment:s,edges_foldAngle:n})=>{if(!t){return undefined}let r=0;const c={edges_vertices:t.map((e=>e.map((()=>r++))))};if(s){c.edges_assignment=s}if(n){c.edges_foldAngle=n}if(e){c.vertices_coords=structuredClone(t.flatMap((t=>t.map((t=>e[t])))))}return c};const ur=Object.freeze({__proto__:null,explodeEdges:dr,explodeFaces:lr});const mr=e=>e;const gr=e=>e<-a?0:e;const pr=e=>{if(e<-a){return 0}if(e>1+a){return 1}return e};const _r=(e,t,s,n=false,r=a)=>{const c=[e,s].map((e=>rt(t,e,r))).reduce(((e,t)=>e||t),false);if(c){return n}const o=[[e,t],[t,s]].map((e=>k(e[1],e[0]))).map((e=>v(e)));return st(1,F(...o),a)};const vr=(e,t,s)=>{const n=$(e.vector,t.vector,s);const r=$(e.origin,t.origin,s);return{vector:n,origin:r}};const hr=(e,t,s,n=a)=>{const r=F(e.vector,t.vector);const c=B(e.vector,t.vector);const o=B(O(t.origin,e.origin),t.vector);const i=o/c;const f=[e.vector,t.vector].map((e=>v(e)));const l=c>-n?[[e.vector,t.vector],[q(t.vector),e.vector]]:[[t.vector,e.vector],[q(e.vector),t.vector]];const d=l.map((e=>Bs(e[0],e[1],s)));const u=Math.abs(B(...f))<n;const m=u?undefined:M(e.origin,E(e.vector,i));const g=Array.from(Array(s-1));const p=u?g.map(((n,r)=>$(e.origin,t.origin,(r+1)/s))):g.map((()=>m));const _=d.map((e=>e.map(((e,t)=>({vector:e,origin:[...p[t]]})))));if(u){_[r>-n?1:0]=[]}return _};const br=(e,t,s=a)=>{const n=hr(e,t,2,s).map((e=>e[0]));n.forEach(((e,t)=>{if(e===undefined){delete n[t]}}));return n};const yr=Object.freeze({__proto__:null,bisectLines2:br,clampLine:mr,clampRay:gr,clampSegment:pr,collinearBetween:_r,lerpLines:vr,pleat:hr});const Er=(e,t)=>{const s=ls(e,(e=>R(e,t)));return s===undefined?undefined:e[s]};const Ar=(e,t)=>{const s=ls(e,(e=>I(e,t)));return s===undefined?undefined:e[s]};const xr=({vector:e,origin:t},s,n=mr,r=a)=>{t=Z(e.length,t);s=Z(e.length,s);const c=_(e);const o=k(s,t);const i=F(e,o);const f=i/c;const l=n(f,r);return x(t,y(e,l))};const Mr=(e,t)=>e.map(((e,t,s)=>k(s[(t+1)%s.length],e))).map(((t,s)=>({vector:t,origin:e[s]}))).map((e=>xr(e,t,pr))).map(((e,s)=>({point:e,edge:s,distance:I(e,t)}))).sort(((e,t)=>e.distance-t.distance)).shift();const wr=({radius:e,origin:t},s)=>x(t,y(v(k(s,t)),e));const kr=Object.freeze({__proto__:null,nearestPoint:Ar,nearestPoint2:Er,nearestPointOnCircle:wr,nearestPointOnLine:xr,nearestPointOnPolygon:Mr});const Or=({vector:e,origin:t},s,n=at,r=a)=>{const c=O(s,t);const o=_(e);const i=Math.sqrt(o);if(i<r){return false}const f=B(c,e.map((e=>e/i)));const l=C(c,e)/o;return Math.abs(f)<r&&n(l,r/i)};const jr=(e,t,s=at,n=at,r=a)=>{const c=B(e.vector,t.vector);const o=-c;const i=O(t.origin,e.origin);const f=[-i[0],-i[1]];if(Math.abs(c)<r){if(Math.abs(B(i,e.vector))>r){return false}const c=f;const o=M(c,e.vector);const a=V(c,o);const l=i;const d=M(l,t.vector);const u=V(l,d);const m=C(e.vector,e.vector);const g=C(t.vector,t.vector);const p=C(c,t.vector)/g;const _=C(o,t.vector)/g;const v=C(a,t.vector)/g;const h=C(l,e.vector)/m;const b=C(d,e.vector)/m;const y=C(u,e.vector)/m;return s(h,r)||s(b,r)||n(p,r)||n(_,r)||s(y,r)||n(v,r)}const l=B(i,t.vector)/c;const d=B(f,e.vector)/o;return s(l,r/g(e.vector))&&n(d,r/g(t.vector))};const Fr=({radius:e,origin:t},s,n=ot,r=a)=>n(e-R(t,s),r);const Cr=(e,t,s=ot,n=a)=>e.map(((e,t,s)=>[e,s[(t+1)%s.length]])).map((e=>B(h(O(e[1],e[0])),O(t,e[0])))).map((e=>s(e,n))).map(((e,t,s)=>e===s[0])).reduce(((e,t)=>e&&t),true);const Sr=(e,t,s=ot,n=a)=>{const r=e.map(((e,t,s)=>[e,s[(t+1)%s.length]])).map((([e,s])=>[O(s,e),O(t,e)])).map((([e,t])=>B(e,t)));const c=Math.sign(r.reduce(((e,t)=>e+t),0));const o=r.map((e=>e*c)).map((e=>s(e,n))).map(((e,t,s)=>e===s[0])).reduce(((e,t)=>e&&t),true);return{overlap:o,t:r}};const Pr=(e,t,s=a)=>{for(let n=0;n<2;n+=1){const r=n===0?e:t;const c=n===0?t:e;for(let e=0;e<r.length;e+=1){const t=r[e];const n=D(O(r[(e+1)%r.length],r[e]));const o=c.map((e=>O(e,t))).map((e=>C(n,e)));const a=r[(e+2)%r.length];const i=C(n,O(a,t));const f=i>0;const l=o.map((e=>f?e<s:e>-s)).reduce(((e,t)=>e&&t),true);if(l){return false}}}return true};const Vr=(e,t,s=a)=>{const n=Math.min(e.min.length,t.min.length);for(let r=0;r<n;r+=1){if(e.min[r]>t.max[r]+s||e.max[r]<t.min[r]-s){return false}}return true};const Nr=Object.freeze({__proto__:null,overlapBoundingBoxes:Vr,overlapCirclePoint:Fr,overlapConvexPolygonPoint:Cr,overlapConvexPolygonPointNew:Sr,overlapConvexPolygons:Pr,overlapLineLine:jr,overlapLinePoint:Or});const zr=({vertices_coords:e},t)=>{if(!e){return undefined}const s=Bt({vertices_coords:e});if(s===undefined){return undefined}const n=Z(s,t);const r=e.map(((e,t)=>({d:I(n,e),i:t}))).sort(((e,t)=>e.d-t.d)).shift();return r?r.i:undefined};const Tr=({vertices_coords:e,edges_vertices:t},s)=>{if(!e||!t){return undefined}const n=t.map((t=>t.map((t=>e[t])))).map((e=>xr({vector:k(e[1],e[0]),origin:e[0]},s,pr)));return ls(n,(e=>I(e,s)))};const $r=({vertices_coords:e,faces_vertices:t},s,n=ot)=>!e||!t?[]:t.map(((t,s)=>({face:t.map((t=>e[t])),i:s}))).filter((e=>Cr(e.face,s,n))).map((e=>e.i));const Br=({vertices_coords:e,faces_vertices:t},s)=>{const n=$r({vertices_coords:e,faces_vertices:t},s);return n.length?n.shift():undefined};const Lr=(e,t)=>{const s=Br(e,t);if(s!==undefined){return s}if(e.edges_faces){const s=Tr(e,t);if(s===undefined){return undefined}const n=e.edges_faces[s];if(n.length===1){return n[0]}if(n.length>1){const s=Wn({vertices_coords:e.vertices_coords,faces_vertices:n.map((t=>e.faces_vertices[t]))});const r=s.map((e=>I(e,t)));let c=0;for(let e=0;e<r.length;e+=1){if(r[e]<r[c]){c=e}}return n[c]}}return undefined};const Ir=(e,...t)=>{const s={vertices:zr,edges:Tr,faces:Lr};const n=Te(...t);const r=Object.create(null);["vertices","edges","faces"].forEach((t=>{Object.defineProperty(r,bt[t],{enumerable:true,get:()=>s[t](e,n)});St(e,t).forEach((s=>Object.defineProperty(r,s,{enumerable:true,get:()=>e[s][r[bt[t]]]})))}));return r};const Rr=Object.freeze({__proto__:null,faceContainingPoint:Br,facesContainingPoint:$r,nearest:Ir,nearestEdge:Tr,nearestFace:Lr,nearestVertex:zr});const Ur=(e,t)=>{let s=[0];for(let n=1;n<e.length;n+=1){switch(t(e[s[0]],e[n])){case 0:s.push(n);break;case 1:s=[n];break}}return s};const qr=(e,t)=>{if(!e.length){return[]}const s=e.map(((e,t)=>t));const n=[[s[0]]];for(let r=1;r<s.length;r+=1){const c=s[r];if(c===undefined){continue}const o=n.length-1;const a=n[o][n[o].length-1];if(t(e[a],e[c])){n[o].push(c)}else{n.push([c])}}return n};const Dr=(e,t=a)=>{const s=e.map(((e,t)=>({v:e,i:t}))).sort(((e,t)=>e.v-t.v)).map((e=>e.i));const n=s.map((t=>e[t]));const r=(e,s)=>Math.abs(e-s)<t;return qr(n,r).map((e=>e.map((e=>s[e]))))};const Wr=(e,t=a)=>{const s=[[0]];for(let n=1;n<e.length;n+=1){let r=false;for(let c=0;c<s.length;c+=1){const o=s[c][0];if(J(e[n],e[o],t)){s[c].push(n);r=true;break}}if(!r){s.push([n])}}return s};const Gr=Object.freeze({__proto__:null,clusterParallelVectors:Wr,clusterScalars:Dr,clusterSortedGeneric:qr,minimumCluster:Ur});const Hr=({vertices_coords:e,faces_vertices:t},s=0)=>t.map((t=>[t.reduce(((t,n)=>e[t][s]<e[n][s]?t:n)),t.reduce(((t,n)=>e[t][s]>e[n][s]?t:n))]));const Jr=({vertices_coords:e},t=0,s=a)=>Dr(e.map((e=>e[t])),s).map((s=>({vertices:s,t:s.reduce(((s,n)=>s+e[n][t]),0)/s.length})));const Qr=(e,{edges_vertices:t,vertices_edges:s},n=a)=>{if(!s){s=mn({edges_vertices:t})}const r=t.map((t=>t.map((t=>e[t]))));const c=r.map((e=>st(...e,n)));const o=r.map((([e,t])=>Math.sign(e-t)));const i=t.map((([e,t],s)=>c[s]?{[e]:0,[t]:0}:{[e]:o[s],[t]:-o[s]}));return Dr(e,n).map((e=>e.filter((e=>s[e])))).filter((e=>e.length)).map((t=>({vertices:t,t:t.reduce(((t,s)=>t+e[s]),0)/t.length,start:cs(t.flatMap((e=>s[e].filter((t=>i[t][e]<=0))))),end:cs(t.flatMap((e=>s[e].filter((t=>i[t][e]>=0)))))})))};const Zr=({vertices_coords:e,edges_vertices:t,vertices_edges:s},n=0,r=a)=>Qr(e.map((e=>e[n])),{edges_vertices:t,vertices_edges:s},r);const Yr=({vertices_coords:e,faces_vertices:t},s=0,n=a)=>Qr(e.map((e=>e[s])),{edges_vertices:Hr({vertices_coords:e,faces_vertices:t},s)},n);const Xr=({vertices_coords:e,edges_vertices:t,faces_vertices:s},n=0,r=a)=>{const c=e.map((e=>e[n]));const o=Hr({vertices_coords:e,faces_vertices:s},n);const i=mn({edges_vertices:t});const f=mn({edges_vertices:o});const l=t.map((e=>e.map((e=>c[e]))));const d=o.map((e=>e.map((e=>c[e]))));const u=l.map((e=>st(...e,r)));const m=d.map((e=>st(...e,r)));const g=l.map((([e,t])=>Math.sign(e-t)));const p=d.map((([e,t])=>Math.sign(e-t)));const _=t.map((([e,t],s)=>u[s]?{[e]:0,[t]:0}:{[e]:g[s],[t]:-g[s]}));const v=s.map((([e,t],s)=>m[s]?{[e]:0,[t]:0}:{[e]:p[s],[t]:-p[s]}));return Dr(c,r).map((e=>({vertices:e,t:e.reduce(((e,t)=>e+c[t]),0)/e.length,edges:{start:cs(e.filter((e=>i[e]!==undefined)).flatMap((e=>i[e].filter((t=>_[t][e]<=0))))),end:cs(e.filter((e=>i[e]!==undefined)).flatMap((e=>i[e].filter((t=>_[t][e]>=0)))))},faces:{start:cs(e.filter((e=>f[e]!==undefined)).flatMap((e=>f[e].filter((t=>v[t][e]<=0))))),end:cs(e.filter((e=>f[e]!==undefined)).flatMap((e=>f[e].filter((t=>v[t][e]>=0)))))}})))};const Kr=Object.freeze({__proto__:null,sweep:Xr,sweepEdges:Zr,sweepFaces:Yr,sweepValues:Qr,sweepVertices:Jr});const ec=({edges_vertices:e},t,s)=>s.map((s=>e[s][0]===t?e[s][1]:e[s][0]));const tc=Object.freeze({__proto__:null,getOtherVerticesInEdges:ec});const sc=({vertices_coords:e,vertices_edges:t,edges_vertices:s},n,r=a)=>{if(!e||!s){return false}if(!t){t=mn({edges_vertices:s})}const c=t[n];if(c===undefined||c.length!==2){return false}const o=ec({edges_vertices:s},n,c);const i=[o[0],n,o[1]].map((t=>e[t]));return _r(...i,false,r)};const nc=Object.freeze({__proto__:null,isVertexCollinear:sc});const rc=({vertices_coords:e,edges_vertices:t},s=a)=>{if(!e||!t||!t.length){return{edges_line:[],lines:[]}}const n=Nn({vertices_coords:e,edges_vertices:t});const r=n.map((e=>k(e[1],e[0]))).map(v);const c=r.map(((e,t)=>({vector:e,origin:n[t][0]})));const o=c.map((e=>xr(e,[0,0,0],(e=>e),s)));const i=o.map((e=>m(e)));const f=Dr(i,s);const l=f.map((e=>e.map((e=>r[e])))).map((e=>Wr(e,s))).map(((e,t)=>e.map((e=>e.map((e=>f[t][e]))))));const d=l.map((n=>n.map((n=>{if(Math.abs(i[n[0]])<s){return[n]}const r=c[n[0]].vector;const o=n.map((s=>e[t[s][0]])).map((e=>Ks(e,r)));const a=rn(o,r);const f=(e,t)=>rt(o[e],o[t],s);const l=e=>e.map((e=>a[e])).map((e=>n[e]));const d=qr(a,f);if(d.length===1){return d.map(l)}const u=d[0][0];const m=d[d.length-1];const g=m[m.length-1];const p=[u,g].map((e=>a[e]));if(f(...p)){const e=d.pop();d[0]=e.concat(d[0])}return d.map(l)}))));const u=d.flatMap((e=>e.flatMap((e=>e.map((e=>e[0])).map((e=>({vector:r[e],origin:o[e]})))))));const g=[];let p=0;d.forEach((e=>e.forEach((e=>e.forEach((e=>{e.forEach((e=>{g[e]=p}));p+=1}))))));return{lines:u,edges_line:g}};const cc=Object.freeze({__proto__:null,getEdgesLine:rc});const oc=(e,t,s=a)=>{const n=B(e.vector,t.vector);if(Math.abs(n)<s){return undefined}const r=-n;const c=O(t.origin,e.origin);const o=[-c[0],-c[1]];return[B(c,t.vector)/n,B(o,e.vector)/r]};const ac=(e,t,s=a)=>{const n=(e,t)=>e>t[0]-s&&e<t[1]+s;const r=e.map((()=>[]));for(let c=0;c<e.length-1;c+=1){for(let o=c+1;o<e.length;o+=1){const a=oc(e[c],e[o],s);if(a===undefined){continue}const[i,f]=a;if(!n(i,t[c])||!n(f,t[o])){continue}r[c].push(i);r[o].push(f)}}return r};const ic=(e,t,s=a)=>{const n=[];let r=0;let c=0;while(r<e.length&&c<t.length){if(st(e[r],t[c],s)){r+=1;continue}if(e[r]>t[c]){c+=1;continue}if(t[c]>e[r]){n.push(e[r]);r+=1;continue}}return n};const fc=({edges_vertices:e,vertices_edges:t},s)=>{const n=t[s].sort(((e,t)=>e-t));const r=n.flatMap((t=>e[t])).filter((e=>e!==s)).slice(0,2);e[n[0]]=r;e[n[1]]=undefined;r.forEach((e=>{const s=t[e].indexOf(n[1]);if(s===-1){return}t[e][s]=n[0]}));return n[1]};const lc=({vertices_coords:e,edges_vertices:t,edges_assignment:s,edges_foldAngle:n},r=a)=>{const{lines:c,edges_line:o}=rc({vertices_coords:e,edges_vertices:t});const i=rr(o).map((e=>e.constructor===Array?e:[e]));const f=t.map((t=>t.map((t=>e[t])))).map(((e,t)=>e.map((e=>C(O(e,c[o[t]].origin),c[o[t]].vector)))));const l=i.map((e=>e.flatMap((e=>f[e])))).map((e=>is(e,r)));const d=l.map((e=>[e[0],e[e.length-1]]));const u=ac(c,d,r).map((e=>is(e,r))).map(((e,t)=>ic(e,l[t],r)));const m=i.map((e=>e.flatMap((e=>f[e]))));const g=i.map((e=>{const t=[];e.forEach(((e,s)=>{t[e]=[s*2,s*2+1]}));return t}));const p=i.map(((e,t)=>Qr(m[t],{edges_vertices:g[t]},r)));const _=p.map((e=>e.map((e=>e.t))));const v=p.map((e=>{const t={};const s=e.map((e=>{e.start.forEach((e=>{t[e]=true}));e.end.forEach((e=>{delete t[e]}));return Object.keys(t).map((e=>parseInt(e,10)))}));s.pop();return s}));u.forEach(((e,t)=>{const s=_[t];const n=v[t];let c=0;let o=0;while(c<e.length&&o<s.length-1){if(st(s[o],e[c],r)){throw new Error("bad algorithm")}if(e[c]>s[o+1]){o+=1;continue}s.splice(o+1,0,e[c]);n.splice(o+1,0,n[o]);c+=1}}));const h=_.flatMap(((e,t)=>e.map((e=>M(c[t].origin,E(c[t].vector,e))))));let b=0;const y=v.map((e=>{const t=e.map((()=>[b,++b]));b+=1;return t})).flatMap(((e,t)=>e.filter(((e,s)=>v[t][s].length))));const A={vertices_coords:h,edges_vertices:y};if(s||n){const e=v.flatMap((e=>e.filter((e=>e.length))));if(s){A.edges_assignment=e.map((e=>s[e[0]]))}if(n){A.edges_foldAngle=e.map((e=>n[e[0]]))}}ys(A,vs(A));gs(A,r*10);Xn(A);A.vertices_edges=mn(A);const x=A.vertices_edges.map(((e,t)=>e.length===2?t:undefined)).filter((e=>e!==undefined)).filter((e=>sc(A,e,r))).reverse();const w=x.map((e=>fc(A,e)));_s(A,"edges",w);_s(A,"vertices",x);const k=Hn(A);if(k.length){Jn(A,k)}if(Zn(A).length){console.error("planarize: found circular edges. place 3.")}delete A.vertices_edges;return A};const dc=e=>{const t=e.edges_vertices.length;if(!e.edges_assignment){e.edges_assignment=[]}if(!e.edges_foldAngle){e.edges_foldAngle=[]}if(e.edges_assignment.length>e.edges_foldAngle.length){for(let t=e.edges_foldAngle.length;t<e.edges_assignment.length;t+=1){e.edges_foldAngle[t]=kt(e.edges_assignment[t])}}if(e.edges_foldAngle.length>e.edges_assignment.length){for(let t=e.edges_assignment.length;t<e.edges_foldAngle.length;t+=1){e.edges_assignment[t]=Ot(e.edges_foldAngle[t])}}for(let s=e.edges_assignment.length;s<t;s+=1){e.edges_assignment[s]="U";e.edges_foldAngle[s]=0}};const uc=(e,t)=>{if(t===undefined&&!e.faces_vertices&&!e.faces_edges){t=true}if(t&&e.vertices_coords){const t=Bn(e);e.faces_vertices=t.faces_vertices;e.faces_edges=t.faces_edges;return}if(e.faces_vertices&&e.faces_edges){return}if(e.faces_vertices&&!e.faces_edges){e.faces_edges=In(e)}else if(e.faces_edges&&!e.faces_vertices){e.faces_vertices=Ln(e)}else{e.faces_vertices=[];e.faces_edges=[]}};const mc=(e,t)=>{if(typeof e!=="object"){return e}if(!e.edges_vertices){return e}e.vertices_edges=mn(e);e.vertices_vertices=vn(e);e.vertices_edges=gn(e);dc(e);uc(e,t);e.vertices_faces=yn(e);e.edges_faces=On(e);e.faces_faces=Rn(e);return e};const gc=({vertices_vertices:e},t,s)=>{if(!e){return}e[t]=[...s];s.forEach(((s,n,r)=>{const c=r[(n+1)%r.length];const o=e[s].indexOf(c);e[s][o]=t}))};const pc=({vertices_coords:e,vertices_vertices:t,vertices_sectors:s},n)=>{if(!s){return}s[n]=t[n].length===1?[l]:Us(t[n].map((t=>O(e[t],e[n]))))};const _c=({vertices_edges:e},t,s,n,r)=>{if(!e){return}e[s]=[...r];n.map((s=>e[s].indexOf(t))).forEach(((t,s)=>{e[n[s]][t]=r[s]}))};const vc=({vertices_faces:e},t,s)=>{if(!e){return}e[t]=[...s]};const hc=({edges_faces:e},t,s)=>{if(!e){return}t.forEach((t=>{e[t]=[...s]}))};const bc=({faces_vertices:e},t,s,n)=>{if(!e){return}n.map((t=>e[t])).forEach((e=>e.map(((e,t,n)=>{const r=(t+1)%n.length;return e===s[0]&&n[r]===s[1]||e===s[1]&&n[r]===s[0]?r:undefined})).filter((e=>e!==undefined)).sort(((e,t)=>t-e)).forEach((s=>e.splice(s,0,t)))))};const yc=({edges_vertices:e,faces_vertices:t,faces_edges:s},n)=>{const r=En({edges_vertices:e});n.map((e=>t[e].map(((e,t,s)=>[e,s[(t+1)%s.length]])).map((e=>r[e.join(" ")])))).forEach(((e,t)=>{s[n[t]]=e}))};const Ec=({vertices_faces:e,edges_vertices:t,edges_faces:s,faces_edges:n,faces_vertices:r},c)=>{if(s&&s[c]){return s[c]}const o=t[c];if(e!==undefined){const t=[];for(let s=0;s<e[o[0]].length;s+=1){for(let n=0;n<e[o[1]].length;n+=1){if(e[o[0]][s]===e[o[1]][n]){if(e[o[0]][s]===undefined){continue}t.push(e[o[0]][s])}}}return t}if(n){const e=[];for(let t=0;t<n.length;t+=1){for(let s=0;s<n[t].length;s+=1){if(n[t][s]===c){e.push(t)}}}return e}if(r){console.warn("todo: findAdjacentFacesToEdge")}};const Ac=(e,t,s)=>{const n=e.edges_vertices[t];const r=[{edges_vertices:[n[0],s]},{edges_vertices:[s,n[1]]}];r.forEach((s=>["edges_assignment","edges_foldAngle"].filter((s=>e[s]&&e[s][t]!==undefined)).forEach((n=>{s[n]=e[n][t]}))));return r};const xc=(e,t,s,n=a)=>{if(e.edges_vertices.length<t){return{}}const r=e.edges_vertices[t];if(!s){s=P(...r.map((t=>e.vertices_coords[t])))}const c=r.map((t=>e.vertices_coords[t])).map((e=>I(e,s)<n));if(c[0]){return{vertex:r[0],edges:{}}}if(c[1]){return{vertex:r[1],edges:{}}}const o=e.vertices_coords.length;e.vertices_coords[o]=s;const i=[0,1].map((t=>t+e.edges_vertices.length));Ac(e,t,o).forEach(((t,s)=>Object.keys(t).forEach((n=>{e[n][i[s]]=t[n]}))));gc(e,o,r);pc(e,o);_c(e,t,o,r,i);const f=Ec(e,t);if(f){vc(e,o,f);hc(e,i,f);bc(e,o,r,f);yc(e,f)}const l=_s(e,"edges",[t]);i.forEach(((e,t)=>{i[t]=l[i[t]]}));l.splice(-2);l[t]=i;return{vertex:o,edges:{map:l,new:i,remove:t}}};const Mc=({vertices_coords:e},t,s)=>{const n=t.map((t=>e[t])).reverse();return{edges_vertices:[...t],edges_foldAngle:0,edges_assignment:"U",edges_length:I(...n),edges_vector:k(...n),edges_faces:[s,s]}};const wc=(e,t,s)=>{const n=e.edges_vertices.length;const r=Mc(e,s,t);Object.keys(r).filter((t=>e[t]!==undefined)).forEach((t=>{e[t][n]=r[t]}));return n};const kc=({edges_vertices:e,faces_vertices:t,faces_edges:s},n,r)=>{const c=r.map((e=>t[n].indexOf(e)));const o=rs(t[n],c).map((e=>({faces_vertices:e})));if(s){const t=En({edges_vertices:e});o.map((e=>e.faces_vertices.map(((e,t,s)=>`${e} ${s[(t+1)%s.length]}`)).map((e=>t[e])))).forEach(((e,t)=>{o[t].faces_edges=e}))}return o};const Oc=(e,t,s)=>{const n=[0,1].map((t=>e.faces_vertices.length+t));kc(e,t,s).forEach(((t,s)=>Object.keys(t).forEach((r=>{e[r][n[s]]=t[r]}))));return n};const jc=(e,{vertices:t,edges:s})=>{let n;const r=s.map((t=>{const s=xc(e,n?n[t.edge]:t.edge,t.coords);n=n?tr(n,s.edges.map):s.edges.map;return s}));t.push(...r.map((e=>e.vertex)));let c;r.forEach((e=>{e.edges.remove=c?c[e.edges.remove]:e.edges.remove;const t=or(e.edges.map);c=c?nr(c,t):t}));return{vertices:t,edges:{map:n,remove:r.map((e=>e.edges.remove))}}};const Fc=({vertices_coords:e,vertices_vertices:t,edges_vertices:s},n)=>{const r=s[n][0];const c=s[n][1];t[r]=on({vertices_coords:e},t[r].concat(c),r);t[c]=on({vertices_coords:e},t[c].concat(r),c)};const Cc=({edges_vertices:e,vertices_edges:t,vertices_vertices:s},n)=>{if(!t||!s){return}const r=e[n];r.map((e=>s[e])).map(((e,t)=>e.indexOf(r[(t+1)%r.length]))).forEach(((e,s)=>t[r[s]].splice(e,0,n)))};const Sc=(e,t,n)=>{const r={};n.forEach((t=>e.faces_vertices[t].forEach((e=>{if(!r[e]){r[e]=[]}r[e].push(t)}))));e.faces_vertices[t].forEach((n=>{const c=e.vertices_faces[n].indexOf(t);const o=r[n];if(c===-1||!o){throw new Error(s.convexFace)}e.vertices_faces[n].splice(c,1,...o)}))};const Pc=(e,t,n,r)=>{const c={};r.forEach((t=>e.faces_edges[t].forEach((e=>{if(!c[e]){c[e]=[]}c[e].push(t)}))));const o=[...e.faces_edges[t],n];o.forEach((n=>{const r=c[n];const o=[];for(let s=0;s<e.edges_faces[n].length;s+=1){if(e.edges_faces[n][s]===t){o.push(s)}}if(o.length===0||!r){throw new Error(s.convexFace)}o.reverse().forEach((t=>e.edges_faces[n].splice(t,1)));const a=o[o.length-1];e.edges_faces[n].splice(a,0,...r)}))};const Vc=({faces_vertices:e,faces_faces:t},s,n)=>{const r=t[s];const c=n.map((t=>e[t]));const o=r.map((t=>{const s=e[t];const r=[0,0];for(let e=0;e<c.length;e+=1){let t=0;for(let n=0;n<s.length;n+=1){if(c[e].indexOf(s[n])!==-1){t+=1}}r[e]=t}if(r[0]>=2){return n[0]}if(r[1]>=2){return n[1]}}));n.forEach(((e,s,r)=>{t[e]=[r[(s+1)%n.length]]}));r.forEach(((e,n)=>{for(let r=0;r<t[e].length;r+=1){if(t[e][r]===s){t[e][r]=o[n];t[o[n]].push(e)}}}))};const Nc=(e,t,s=at,n=at,r=a)=>{const c=B(h(e.vector),h(t.vector));if(Math.abs(c)<r){return{a:undefined,b:undefined,point:undefined}}const o=B(e.vector,t.vector);const i=-o;const f=[t.origin[0]-e.origin[0],t.origin[1]-e.origin[1]];const l=[-f[0],-f[1]];const d=B(f,t.vector)/o;const u=B(l,e.vector)/i;if(s(d,r/g(e.vector))&&n(u,r/g(t.vector))){return{a:d,b:u,point:M(e.origin,E(e.vector,d))}}return{a:undefined,b:undefined,point:undefined}};const zc=(e,t,s=ct,n=at,r=a)=>{const c=t.vector[0]**2+t.vector[1]**2;const o=Math.sqrt(c);const i=o===0?t.vector:t.vector.map((e=>e/o));const f=D(i);const l=O(t.origin,e.origin);const d=B(l,i);if(Math.abs(d)>e.radius+r){return undefined}const u=Math.sqrt(e.radius**2-d**2);const m=(t,s)=>e.origin[s]-f[s]*d+i[s]*t;const g=Math.abs(e.radius-Math.abs(d))<r?[u].map((e=>[e,e].map(m))):[-u,u].map((e=>[e,e].map(m)));const p=g.map((e=>e.map(((e,s)=>e-t.origin[s])))).map((e=>e[0]*t.vector[0]+t.vector[1]*e[1])).map((e=>e/c));return g.filter(((e,t)=>n(p[t],r)))};const Tc=e=>{if(e>=1)return 0;if(e<=-1)return Math.PI;return Math.acos(e)};const $c=(e,t,s)=>{const n=t[0]-e[0];const r=t[1]-e[1];const c=n*Math.cos(s)+r*Math.sin(s);const o=r*Math.cos(s)-n*Math.sin(s);return[e[0]+c,e[1]+o]};const Bc=(e,t,s=ct,n=ct,r=a)=>{const c=e.radius<t.radius?e.radius:t.radius;const o=e.radius<t.radius?t.radius:e.radius;const i=e.radius<t.radius?e.origin:t.origin;const f=e.radius<t.radius?t.origin:e.origin;const l=[i[0]-f[0],i[1]-f[1]];const d=Math.sqrt(l[0]**2+l[1]**2);if(d<r){return undefined}const u=l.map(((e,t)=>e/d*o+f[t]));if(Math.abs(o+c-d)<r||Math.abs(o-(c+d))<r){return[u]}if(d+c<o||o+c<d){return undefined}const m=Tc((c*c-d*d-o*o)/(-2*d*o));const g=$c(f,u,+m);const p=$c(f,u,-m);return[g,p]};const Lc=e=>{for(let t=1;t<e.length;t+=1){if(!rt(e[0],e[t])){return[e[0],e[t]]}}return undefined};const Ic=(e,{vector:t,origin:s},n=dt,r=at,c=a)=>{const o=e.map(((e,t,s)=>[e,s[(t+1)%s.length]])).map((e=>Nc({vector:O(e[1],e[0]),origin:e[0]},{vector:t,origin:s},n,r,c).point)).filter((e=>e!==undefined));switch(o.length){case 0:return undefined;case 1:return[o];default:return Lc(o)||[o[0]]}};const Rc=(e,{vector:t,origin:s},n=dt,r=it,c=a)=>{const o=Ic(e,{vector:t,origin:s},n,r,c);let i;switch(r){case lt:i=ft;break;case ut:i=dt;break;default:return o}const f=Ic(e,{vector:t,origin:s},dt,i,c);if(f===undefined){return undefined}const l=Lc(f);if(l===undefined){switch(r){case lt:return Cr(e,s,ot,.001)?f:undefined;case ut:return Cr(e,M(s,t),ot,.001)||Cr(e,s,ot,.001)?f:undefined;case it:return undefined;default:return undefined}}return Cr(e,V(...l),ot,.001)?l:o};const Uc=Object.freeze({__proto__:null,intersectCircleCircle:Bc,intersectCircleLine:zc,intersectConvexPolygonLine:Rc,intersectLineLine:Nc});const qc=()=>0;const Dc=(e,t)=>e<-t?-1:0;const Wc=(e,t)=>e<-t?-1:e>1+t?1:0;const Gc=({vertices_coords:e,faces_vertices:t},{vector:s,origin:n},r=qc,c=a)=>{const o=C(s,s);const i=h(s);const f=e.map((e=>O(e,n))).map((e=>h(e))).map((e=>B(i,e))).map((e=>Math.abs(e)<c?0:Math.sign(e)));const l=e.map((e=>O(e,n))).map((e=>C(e,s))).map((e=>e/o)).map((e=>r(e,c)));const d=t.map((e=>e.map((e=>f[e])).map(((e,t,s)=>e===s[0])).reduce(((e,t)=>e&&t),true))).map((e=>!e));const u=t.map((e=>e.map((e=>l[e])).map(((e,t,s)=>e===s[0])).reduce(((e,t)=>e&&t),true))).map((e=>!e)).map(((e,s)=>e||l[t[s][0]]===0));return t.map(((e,t)=>t)).filter((e=>d[e]&&u[e]))};const Hc=(e,{vector:t,origin:s},n=a)=>Gc(e,{vector:t,origin:s},qc,n);const Jc=(e,{vector:t,origin:s},n=a)=>Gc(e,{vector:t,origin:s},Dc,n);const Qc=(e,t,s=a)=>{const n=O(t[1],t[0]);const r=t[0];return Gc(e,{vector:n,origin:r},Wc,s)};const Zc=({vertices_coords:e,edges_vertices:t,faces_vertices:s,faces_edges:n},r,{vector:c,origin:o},i=a)=>{const f=s[r].map((t=>e[t])).map((e=>Or({vector:c,origin:o},e,(()=>true),i))).map(((e,t)=>e?t:undefined)).filter((e=>e!==undefined));const l=f.map((e=>s[r][e]));const d=f.concat(f.map((e=>e+s[r].length))).map(((e,t,s)=>s[t+1]-e===1)).reduce(((e,t)=>e||t),false);if(d){return undefined}if(l.length>1){return{vertices:l,edges:[]}}const u=n[r].map((s=>t[s].map((t=>e[t])))).map((e=>Nc({vector:c,origin:o},{vector:O(e[1],e[0]),origin:e[0]},at,ut,i).point)).map(((e,t)=>({coords:e,edge:n[r][t]}))).filter((e=>e.coords!==undefined)).filter((e=>!l.map((s=>t[e.edge].includes(s))).reduce(((e,t)=>e||t),false)));return u.length+l.length===2?{vertices:l,edges:u}:undefined};const Yc=Object.freeze({__proto__:null,facesLineTypeOverlap:Gc,getFacesLineOverlap:Hc,getFacesRayOverlap:Jc,getFacesSegmentOverlap:Qc,intersectConvexFaceLine:Zc});const Xc=(e,t,s,n)=>{const r=Zc(e,t,s,n);if(r===undefined){return undefined}const c=jc(e,r);c.edges.new=wc(e,t,c.vertices);Fc(e,c.edges.new);Cc(e,c.edges.new);const o=Oc(e,t,c.vertices);Sc(e,t,o);Pc(e,t,c.edges.new,o);Vc(e,t,o);const a=_s(e,"faces",[t]);o.forEach(((e,t)=>{o[t]=a[o[t]]}));a.splice(-2);a[t]=o;c.faces={map:a,new:o,remove:t};return c};const Kc=(e,t)=>{const s={};t.forEach((e=>{s[e]=true}));const n=[];t.forEach((t=>{n[t]=e[t].filter((e=>s[e]))}));return n};const eo=(e,t={})=>{const s={vertices:[],edges:[],faces:[],...t};const n=Object.keys(s);const r={...e};gt.graph.forEach((e=>delete r[e]));delete r.file_frames;const c={};n.forEach((e=>{c[e]={}}));n.forEach((e=>s[e].forEach((t=>{c[e][t]=true}))));const o={};n.forEach((t=>{St(e,t).forEach((e=>{o[e]={}}));Pt(e,t).forEach((e=>{o[e]={}}))}));n.forEach((t=>{St(e,t).forEach((e=>{o[e].prefix=t}));Pt(e,t).forEach((e=>{o[e].suffix=t}))}));Object.keys(o).forEach((e=>{r[e]=[]}));Object.keys(o).forEach((t=>{const{prefix:n,suffix:a}=o[t];if(n&&a){s[n].forEach((s=>{r[t][s]=e[t][s].filter((e=>c[a][e]))}))}else if(n){s[n].forEach((s=>{r[t][s]=e[t][s]}))}else if(a){r[t]=e[t].map((e=>e.filter((e=>c[a][e]))))}else{r[t]=e[t]}}));return r};const to=(e,t={})=>{const s={vertices:[],edges:[],faces:[],...t};const n={vertices:{},edges:{},faces:{}};s.vertices.forEach((e=>{n.vertices[e]=true}));s.edges.forEach((e=>{n.edges[e]=true}));s.edges.forEach((t=>e.edges_vertices[t].forEach((e=>{n.vertices[e]=true}))));s.faces.forEach((e=>{n.faces[e]=true}));s.faces.forEach((t=>e.faces_vertices[t].forEach((e=>{n.vertices[e]=true}))));e.faces_vertices.map(((e,t)=>t)).filter((t=>e.faces_vertices[t].map((e=>n.vertices[e])).reduce(((e,t)=>e&&t),true))).forEach((e=>{n.faces[e]=true}));e.edges_vertices.map(((e,t)=>t)).filter((t=>e.edges_vertices[t].map((e=>n.vertices[e])).reduce(((e,t)=>e&&t),true))).forEach((e=>{n.edges[e]=true}));return eo(e,{vertices:Object.keys(n.vertices),edges:Object.keys(n.edges),faces:Object.keys(n.faces)})};const so=(e,t)=>{let s=[];if(e.faces_vertices){s=as(t.flatMap((t=>e.faces_vertices[t])))}let n=[];if(e.faces_edges){n=as(t.flatMap((t=>e.faces_edges[t])))}else if(e.edges_vertices){const t={};s.forEach((e=>{t[e]=true}));n=e.edges_vertices.map(((e,s)=>t[e[0]]&&t[e[1]]?s:undefined)).filter((e=>e!==undefined))}return eo(e,{vertices:s,edges:n,faces:t})};const no=(e,t=[])=>{const s={vertices:[],edges:[]};t.forEach((e=>{s.vertices[e]=true}));if(e.vertices_edges){s.vertices.forEach(((t,n)=>e.vertices_edges[n].forEach((e=>{s.edges[e]=true}))))}if(e.edges_vertices){s.edges.forEach(((t,n)=>e.edges_vertices[n].forEach((e=>{s.vertices[e]=true}))))}return eo(e,{vertices:s.vertices.map(((e,t)=>e?t:undefined)).filter((e=>e!==undefined)),edges:s.edges.map(((e,t)=>e?t:undefined)).filter((e=>e!==undefined))})};const ro=Object.freeze({__proto__:null,selfRelationalArraySubset:Kc,subgraph:to,subgraphExclusive:eo,subgraphWithFaces:so,subgraphWithVertices:no});const co=e=>{const t={vertices:ts.vertices(e),edges:ts.edges(e),faces:ts.faces(e)};const s={vertices:Js.vertices(e),edges:Js.edges(e),faces:Js.faces(e)};return{vertices:t.vertices>=s.vertices,edges:t.edges>=s.edges,faces:t.faces>=s.faces}};const oo=(e,t)=>{const s=Hn(e);const n=Zn(e);const r=bs(e);const c=ms(e,t);const o=co(e);const a=s.length===0&&n.length===0&&r.length===0&&o.vertices&&o.edges&&o.faces;const i=a?"valid":"problematic";return{summary:i,vertices:{isolated:r,duplicate:c,references:o.vertices},edges:{circular:n,duplicate:s,references:o.edges},faces:{references:o.faces}}};const ao=e=>{const t=[];const s=(n,r)=>{if(t[n]!==undefined){return 0}t[n]=r;e[n].forEach((e=>s(e,r)));return 1};for(let t=0,n=0;t<e.length;t+=1){if(!(t in e)){continue}n+=s(t,n)}return t};const io=e=>{const t=[];const s=[];e.forEach(((e,n)=>e.forEach((e=>{if(n<e){s.push([n,e])}if(n===e&&!t[n]){t[n]=true;s.push([n,e])}}))));return s};const fo=Object.freeze({__proto__:null,connectedComponents:ao,connectedComponentsPairs:io});const lo=e=>{const t=e.edges_vertices||[];const s=e.faces_vertices||[];const n=e.vertices_edges?e.vertices_edges:mn({edges_vertices:t});const r=e.vertices_vertices?e.vertices_vertices:hn({vertices_edges:n,edges_vertices:t});const c=e.vertices_faces?e.vertices_faces:bn({vertices_edges:n,faces_vertices:s});const o=cr(ao(r));const a=o.map((e=>e.flatMap((e=>n[e])))).map(cs);const i=o.map((e=>e.flatMap((e=>c[e])))).map(cs);return Array.from(Array(o.length)).map(((e,t)=>({vertices:o[t]||[],edges:a[t]||[],faces:i[t]||[]})))};const uo=e=>{const t=lo(e);const s=St(e,"vertices");const n=St(e,"edges");const r=St(e,"faces");return t.map((({vertices:t,edges:c,faces:o})=>{const a={};s.forEach((s=>{a[s]=[];t.forEach((t=>{a[s][t]=e[s][t]}))}));n.forEach((t=>{a[t]=[];c.forEach((s=>{a[t][s]=e[t][s]}))}));r.forEach((t=>{a[t]=[];o.forEach((s=>{a[t][s]=e[t][s]}))}));return a}))};const mo=Object.freeze({__proto__:null,disjointGraphs:uo,disjointGraphsIndices:lo});const go=({vertices_coords:e},t)=>et(e,t);const po=({edges_vertices:e,edges_assignment:t=[]})=>cs(e.filter(((e,s)=>wt[t[s]])).flat());const _o=()=>({vertices:[],edges:[],polygon:[]});const vo=({vertices_coords:e,vertices_edges:t,edges_vertices:s,edges_assignment:n})=>{if(!n||!s){return _o()}if(!t){t=mn({edges_vertices:s})}const r=n.map((e=>e==="B"||e==="b"));const c=[];const o=[];let a=-1;for(let e=0;e<r.length;e+=1){if(r[e]){a=e;break}}if(a===-1){return _o()}r[a]=false;c.push(a);o.push(s[a][0]);let i=s[a][1];while(o[0]!==i){o.push(i);a=t[i].filter((e=>r[e])).shift();if(a===undefined){return _o()}if(s[a][0]===i){[,i]=s[a]}else{[i]=s[a]}r[a]=false;c.push(a)}return{vertices:o,edges:c,polygon:e?o.map((t=>e[t])):[]}};const ho=({vertices_coords:e,vertices_edges:t,vertices_vertices:s,edges_vertices:n})=>{if(!s){s=pn({vertices_coords:e,vertices_edges:t,edges_vertices:n})}const r=En({edges_vertices:n});const c=[];const o=[];const a={vertices:o,edges:c};let i=-Infinity;let f=-1;e.forEach(((e,t)=>{if(e[0]>i){i=e[0];f=t}}));if(f===-1){return a}o.push(f);const l=e[f];const d=s[f];if(!d){return a}const u=d.map((t=>e[t])).map((e=>[e[0]-l[0],e[1]-l[1]])).map((e=>Math.atan2(e[1],e[0]))).map((e=>e<0?e+Math.PI*2:e)).map(((e,t)=>({a:e,i:t}))).sort(((e,t)=>e.a-t.a)).shift().i;const m=d[u];const g=f<m?`${f} ${m}`:`${m} ${f}`;const p=r[g];c.push(p);let _=f;let v=m;const h={[`${_} ${v}`]:true};while(true){const e=s[v];const t=e.indexOf(_);const n=(t+1)%e.length;const i=e[n];const f=v<i?`${v} ${i}`:`${i} ${v}`;const l=r[f];if(h[`${v} ${i}`]){if(l!==c[0]){console.warn("bad boundary")}return a}h[`${v} ${i}`]=true;o.push(v);c.push(l);_=v;v=i}};const bo=({vertices_coords:e,vertices_edges:t,vertices_vertices:s,edges_vertices:n})=>{if(!s){s=pn({vertices_coords:e,vertices_edges:t,edges_vertices:n})}return uo({vertices_coords:e,vertices_vertices:s,edges_vertices:n}).map(ho)};const yo=Object.freeze({__proto__:null,boundary:vo,boundaryVertices:po,boundingBox:go,planarBoundaries:bo,planarBoundary:ho});const Eo=(e,t)=>{const s={};t.forEach((e=>{s[e]=true}));const n=e.map((e=>!!s[e]));const r=[];const c=n.indexOf(false);const o={};for(let t=c+1;t<n.length;t+=1){if(n[t]&&!o[e[t]]){r.push(e[t]);o[e[t]]=true}}for(let t=0;t<c;t+=1){if(n[t]&&!o[e[t]]){r.push(e[t]);o[e[t]]=true}}return r};const Ao=Object.freeze({__proto__:null,getFaceFaceSharedVertices:Eo});const xo=(e=[],t=0)=>{if(e.length===0){return[]}const s=[];const n={};e.forEach(((e,t)=>{n[t]=true}));do{const r=t!==undefined?t:parseInt(Object.keys(n).shift(),10);t=undefined;const c=[];delete n[r];let o=[{index:r}];do{c.push(o);const t=o.flatMap((t=>e[t.index].filter((e=>n[e])).map((e=>({index:e,parent:t.index})))));const s={};t.forEach(((e,t)=>{if(!n[e.index]){s[t]=true}delete n[e.index]}));o=t.filter(((e,t)=>!s[t]))}while(o.length);s.push(c)}while(Object.keys(n).length);return s};const Mo=(e,t)=>xo(e,t).shift();const wo=Object.freeze({__proto__:null,minimumSpanningTree:Mo,minimumSpanningTrees:xo});const ko=({vertices_coords:e,vertices_faces:t,faces_vertices:s},n)=>{if(!t){t=yn({faces_vertices:s})}const r=t.map((e=>e.filter((e=>e!=null)).shift())).map((e=>e===undefined?ne:n[e]));return e.map(((e,t)=>re(r[t],e)))};const Oo={U:true,u:true};const jo=({vertices_coords:e,edges_vertices:t,edges_foldAngle:s,edges_assignment:n,faces_vertices:r,faces_faces:c},o=0)=>{if(!n&&s){n=Cn({edges_foldAngle:s})}if(!s){if(n){s=Pn({edges_assignment:n})}else{s=Array(t.length).fill(0)}}if(!c){c=Rn({faces_vertices:r})}const a=En({edges_vertices:t});const i=r.map((()=>_e));xo(c,o).forEach((t=>t.slice(1).forEach((t=>t.forEach((t=>{const c=Eo(r[t.index],r[t.parent]).slice(0,2);const o=c.map((t=>e[t]));const f=c.join(" ");const l=a[f];const d=Oo[n[l]]?Math.PI:s[l]*Math.PI/180;const u=je(d,k(...Y(o[1],o[0])),o[0]);i[t.index]=ye(i[t.parent],u)}))))));return i};const Fo=({vertices_coords:e,edges_vertices:t,edges_foldAngle:s,edges_assignment:n,faces_vertices:r,faces_faces:c},o=0)=>{if(!s){if(n){s=Pn({edges_assignment:n})}else{s=Array(t.length).fill(0)}}if(!c){c=Rn({faces_vertices:r})}const a=Lt({edges_vertices:t,edges_foldAngle:s,edges_assignment:n});const i=En({edges_vertices:t});const f=r.map((()=>ne));xo(c,o).forEach((t=>t.slice(1).forEach((t=>t.forEach((t=>{const s=Eo(r[t.index],r[t.parent]).slice(0,2);const n=s.map((t=>e[t]));const c=s.join(" ");const o=i[c];const l=O(n[1],n[0]);const d=n[0];const u=a[o]?me(l,d):ne;f[t.index]=oe(f[t.parent],u)}))))));return f};const Co=Object.freeze({__proto__:null,makeFacesMatrix:jo,makeFacesMatrix2:Fo,multiplyVerticesFacesMatrix2:ko});const So=({vertices_coords:e,vertices_faces:t,edges_vertices:s,edges_foldAngle:n,edges_assignment:r,faces_vertices:c,faces_faces:o,faces_matrix:a},i)=>{if(!e||!e.length){return[]}if(!c||!c.length){return e}a=jo({vertices_coords:e,edges_vertices:s,edges_foldAngle:n,edges_assignment:r,faces_vertices:c,faces_faces:o},i);if(!t){t=yn({faces_vertices:c})}const f=t.map((e=>e.filter((e=>e!=null)).shift())).map((e=>e===undefined?_e:a[e]));return e.map((e=>Z(3,e))).map(((e,t)=>he(f[t],e)))};const Po=({vertices_coords:e,edges_vertices:t,edges_foldAngle:s,edges_assignment:n,faces_vertices:r,faces_faces:c},o=0)=>{if(!e||!e.length){return[]}if(!r||!r.length){return e}if(!c){c=Rn({faces_vertices:r})}const a=Lt({edges_vertices:t,edges_foldAngle:s,edges_assignment:n});const i=[];const f=[];const l=En({edges_vertices:t});xo(c,o).forEach((s=>{const n=s.shift();if(!n||!n.length){return}const c=n[0];f[c.index]=false;r[c.index].forEach((t=>{i[t]=[...e[t]]}));s.forEach((s=>s.forEach((s=>{const n=Eo(r[s.index],r[s.parent]).slice(0,2).join(" ");const c=l[n];const o=t[c].map((e=>i[e]));if(o[0]===undefined||o[1]===undefined){return}const d=t[c].map((t=>e[t]));const u=d[0];const m=h(O(d[1],d[0]));const g=D(m);f[s.index]=a[c]?!f[s.parent]:f[s.parent];const p=h(O(o[1],o[0]));const _=o[0];const v=f[s.index]?W(p):D(p);r[s.index].filter((e=>i[e]===undefined)).forEach((t=>{const s=O(e[t],u);const n=F(s,g);const r=F(s,m);const c=E(p,r);const o=E(v,n);const a=M(M(_,c),o);i[t]=a}))}))))}));return i};const Vo=Object.freeze({__proto__:null,makeVerticesCoordsFlatFolded:Po,makeVerticesCoordsFolded:So});const No=function(e){let t;let s;if(typeof e!=="object"){return e}if(!e){return e}if(Object.prototype.toString.apply(e)==="[object Array]"){t=[];for(s=0;s<e.length;s+=1){t[s]=No(e[s])}return t}t={};for(s in e){if(e.hasOwnProperty(s)){t[s]=No(e[s])}}return t};const zo=typeof structuredClone==="function"?structuredClone:No;const To="class";const $o="function";const Bo="undefined";const Lo="boolean";const Io="number";const Ro="string";const Uo="object";const qo="svg";const Do="path";const Wo="id";const Go="style";const Ho="viewBox";const Jo="transform";const Qo="points";const Zo="stroke";const Yo="fill";const Xo="none";const Ko="arrow";const ea="head";const ta="tail";const sa=typeof window!==Bo&&typeof window.document!==Bo;typeof process!==Bo&&process.versions!=null&&process.versions.node!=null;const na={window:"window not set; svg.window = @xmldom/xmldom"};const ra={window:undefined};const ca=e=>(new e.DOMParser).parseFromString("<!DOCTYPE html><title>.</title>","text/html");const oa=e=>{if(!e.document){e.document=ca(e)}ra.window=e;return ra.window};if(sa){ra.window=window}const aa=()=>{if(ra.window===undefined){throw na.window}return ra.window};const ia="http://www.w3.org/2000/svg";const fa={presentation:["color","color-interpolation","cursor","direction","display","fill","fill-opacity","fill-rule","font-family","font-size","font-size-adjust","font-stretch","font-style","font-variant","font-weight","image-rendering","letter-spacing","opacity","overflow","paint-order","pointer-events","preserveAspectRatio","shape-rendering","stroke","stroke-dasharray","stroke-dashoffset","stroke-linecap","stroke-linejoin","stroke-miterlimit","stroke-opacity","stroke-width","tabindex","transform-origin","user-select","vector-effect","visibility"],animation:["accumulate","additive","attributeName","begin","by","calcMode","dur","end","from","keyPoints","keySplines","keyTimes","max","min","repeatCount","repeatDur","restart","to","values"],effects:["azimuth","baseFrequency","bias","color-interpolation-filters","diffuseConstant","divisor","edgeMode","elevation","exponent","filter","filterRes","filterUnits","flood-color","flood-opacity","in","in2","intercept","k1","k2","k3","k4","kernelMatrix","lighting-color","limitingConeAngle","mode","numOctaves","operator","order","pointsAtX","pointsAtY","pointsAtZ","preserveAlpha","primitiveUnits","radius","result","seed","specularConstant","specularExponent","stdDeviation","stitchTiles","surfaceScale","targetX","targetY","type","xChannelSelector","yChannelSelector"],text:["dx","dy","alignment-baseline","baseline-shift","dominant-baseline","lengthAdjust","method","overline-position","overline-thickness","rotate","spacing","startOffset","strikethrough-position","strikethrough-thickness","text-anchor","text-decoration","text-rendering","textLength","underline-position","underline-thickness","word-spacing","writing-mode"],gradient:["gradientTransform","gradientUnits","spreadMethod"]};const la={svg:["svg"],defs:["defs"],header:["desc","filter","metadata","style","script","title","view"],cdata:["cdata"],group:["g"],visible:["circle","ellipse","line","path","polygon","polyline","rect","arc","arrow","curve","parabola","roundRect","wedge","origami"],text:["text"],invisible:["marker","symbol","clipPath","mask"],patterns:["linearGradient","radialGradient","pattern"],childrenOfText:["textPath","tspan"],gradients:["stop"],filter:["feBlend","feColorMatrix","feComponentTransfer","feComposite","feConvolveMatrix","feDiffuseLighting","feDisplacementMap","feDistantLight","feDropShadow","feFlood","feFuncA","feFuncB","feFuncG","feFuncR","feGaussianBlur","feImage","feMerge","feMergeNode","feMorphology","feOffset","fePointLight","feSpecularLighting","feSpotLight","feTile","feTurbulence"]};const da={svg:[Ho],line:["x1","y1","x2","y2"],rect:["x","y","width","height"],circle:["cx","cy","r"],ellipse:["cx","cy","rx","ry"],polygon:[Qo],polyline:[Qo],path:["d"],text:["x","y"],mask:[Wo],symbol:[Wo],clipPath:[Wo,"clip-rule"],marker:[Wo,"markerHeight","markerUnits","markerWidth","orient","refX","refY"],linearGradient:["x1","x2","y1","y2"],radialGradient:["cx","cy","r","fr","fx","fy"],stop:["offset","stop-color","stop-opacity"],pattern:["patternContentUnits","patternTransform","patternUnits"]};const ua=[{nodes:[qo,"defs","g"].concat(la.visible,la.text),attr:fa.presentation},{nodes:["filter"],attr:fa.effects},{nodes:la.childrenOfText.concat("text"),attr:fa.text},{nodes:la.filter,attr:fa.effects},{nodes:la.gradients,attr:fa.gradient}];ua.forEach((e=>e.nodes.forEach((t=>{if(!da[t]){da[t]=[]}da[t].push(...e.attr)}))));const ma=[la.header,la.invisible,la.patterns].flat();const ga=[la.group,la.visible,la.text].flat();const pa={svg:[["svg","defs"],ma,ga].flat(),defs:ma,filter:la.filter,g:ga,text:la.childrenOfText,marker:ga,symbol:ga,clipPath:ga,mask:ga,linearGradient:la.gradients,radialGradient:la.gradients};const _a=Object.values(la).flat();const va={black:"#000000",silver:"#c0c0c0",gray:"#808080",white:"#ffffff",maroon:"#800000",red:"#ff0000",purple:"#800080",fuchsia:"#ff00ff",green:"#008000",lime:"#00ff00",olive:"#808000",yellow:"#ffff00",navy:"#000080",blue:"#0000ff",teal:"#008080",aqua:"#00ffff",orange:"#ffa500",aliceblue:"#f0f8ff",antiquewhite:"#faebd7",aquamarine:"#7fffd4",azure:"#f0ffff",beige:"#f5f5dc",bisque:"#ffe4c4",blanchedalmond:"#ffebcd",blueviolet:"#8a2be2",brown:"#a52a2a",burlywood:"#deb887",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",cornflowerblue:"#6495ed",cornsilk:"#fff8dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",darkkhaki:"#bdb76b",darkmagenta:"#8b008b",darkolivegreen:"#556b2f",darkorange:"#ff8c00",darkorchid:"#9932cc",darkred:"#8b0000",darksalmon:"#e9967a",darkseagreen:"#8fbc8f",darkslateblue:"#483d8b",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",darkturquoise:"#00ced1",darkviolet:"#9400d3",deeppink:"#ff1493",deepskyblue:"#00bfff",dimgray:"#696969",dimgrey:"#696969",dodgerblue:"#1e90ff",firebrick:"#b22222",floralwhite:"#fffaf0",forestgreen:"#228b22",gainsboro:"#dcdcdc",ghostwhite:"#f8f8ff",gold:"#ffd700",goldenrod:"#daa520",greenyellow:"#adff2f",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",indianred:"#cd5c5c",indigo:"#4b0082",ivory:"#fffff0",khaki:"#f0e68c",lavender:"#e6e6fa",lavenderblush:"#fff0f5",lawngreen:"#7cfc00",lemonchiffon:"#fffacd",lightblue:"#add8e6",lightcoral:"#f08080",lightcyan:"#e0ffff",lightgoldenrodyellow:"#fafad2",lightgray:"#d3d3d3",lightgreen:"#90ee90",lightgrey:"#d3d3d3",lightpink:"#ffb6c1",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",lightskyblue:"#87cefa",lightslategray:"#778899",lightslategrey:"#778899",lightsteelblue:"#b0c4de",lightyellow:"#ffffe0",limegreen:"#32cd32",linen:"#faf0e6",magenta:"#ff00ff",mediumaquamarine:"#66cdaa",mediumblue:"#0000cd",mediumorchid:"#ba55d3",mediumpurple:"#9370db",mediumseagreen:"#3cb371",mediumslateblue:"#7b68ee",mediumspringgreen:"#00fa9a",mediumturquoise:"#48d1cc",mediumvioletred:"#c71585",midnightblue:"#191970",mintcream:"#f5fffa",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",navajowhite:"#ffdead",oldlace:"#fdf5e6",olivedrab:"#6b8e23",orangered:"#ff4500",orchid:"#da70d6",palegoldenrod:"#eee8aa",palegreen:"#98fb98",paleturquoise:"#afeeee",palevioletred:"#db7093",papayawhip:"#ffefd5",peachpuff:"#ffdab9",peru:"#cd853f",pink:"#ffc0cb",plum:"#dda0dd",powderblue:"#b0e0e6",rosybrown:"#bc8f8f",royalblue:"#4169e1",saddlebrown:"#8b4513",salmon:"#fa8072",sandybrown:"#f4a460",seagreen:"#2e8b57",seashell:"#fff5ee",sienna:"#a0522d",skyblue:"#87ceeb",slateblue:"#6a5acd",slategray:"#708090",slategrey:"#708090",snow:"#fffafa",springgreen:"#00ff7f",steelblue:"#4682b4",tan:"#d2b48c",thistle:"#d8bfd8",tomato:"#ff6347",turquoise:"#40e0d0",violet:"#ee82ee",wheat:"#f5deb3",whitesmoke:"#f5f5f5",yellowgreen:"#9acd32"};const ha=e=>Math.round(e*100)/100;const ba=(e,t,s,n)=>{const r=t/100;const c=s/100;const o=t=>(t+e/30)%12;const a=r*Math.min(c,1-c);const i=e=>c-a*Math.max(-1,Math.min(o(e)-3,Math.min(9-o(e),1)));return n===undefined?[i(0)*255,i(8)*255,i(4)*255]:[i(0)*255,i(8)*255,i(4)*255,n]};const ya=(e,t)=>{const s=Array.from(Array(t.length)).map(((t,s)=>e[s]||"0"));return e.length<=4?t.map((e=>s[e])).join(""):s.join("")};const Ea=e=>{const t=e.replace(/#(?=\S)/g,"");const s=t.length===4||t.length===8;const n=s?ya(t,[0,0,1,1,2,2,3,3]):ya(t,[0,0,1,1,2,2]);const r=parseInt(n,16);return s?[r>>24&255,r>>16&255,r>>8&255,ha((r&255)/256)]:[r>>16&255,r>>8&255,r&255]};const Aa=(e,t,s,n)=>{const r=e=>`00${Math.max(0,Math.min(Math.round(e),255)).toString(16)}`.slice(-2);const c=`#${[e,t,s].map(r).join("")}`;return n===undefined?c:`${c}${r(n*255)}`};const xa=Object.freeze({__proto__:null,hexToRgb:Ea,hslToRgb:ba,rgbToHex:Aa});const Ma=e=>{const t=e.match(/\(([^\)]+)\)/g);if(t==null||!t.length){return[]}return t[0].substring(1,t[0].length-1).split(/[\s,]+/).map(parseFloat)};const wa=e=>{if(va[e]){return Ea(va[e])}if(e[0]==="#"){return Ea(e)}if(e.substring(0,4)==="rgba"||e.substring(0,3)==="rgb"){const t=Ma(e);[0,1,2].filter((e=>t[e]===undefined)).forEach((e=>{t[e]=0}));return t}if(e.substring(0,4)==="hsla"||e.substring(0,3)==="hsl"){const t=Ma(e);[0,1,2].filter((e=>t[e]===undefined)).forEach((e=>{t[e]=0}));return ba(...t)}return undefined};const ka=e=>{if(va[e]){return va[e].toUpperCase()}if(e[0]==="#"){return Aa(...Ea(e))}if(e.substring(0,4)==="rgba"||e.substring(0,3)==="rgb"){return Aa(...Ma(e))}if(e.substring(0,4)==="hsla"||e.substring(0,3)==="hsl"){const t=Ma(e);[0,1,2].filter((e=>t[e]===undefined)).forEach((e=>{t[e]=0}));const s=ba(...t);if(t.length===4){s.push(t[3])}return Aa(...s)}return undefined};const Oa=Object.freeze({__proto__:null,parseColorToHex:ka,parseColorToRgb:wa});const ja={cssColors:va,...xa,...Oa};const Fa=(e,t)=>[e[0]+t[0],e[1]+t[1]];const Ca=(e,t)=>[e[0]-t[0],e[1]-t[1]];const Sa=(e,t)=>[e[0]*t,e[1]*t];const Pa=e=>e[0]**2+e[1]**2;const Va=e=>Math.sqrt(Pa(e));const Na=(e,t)=>Pa(Ca(e,t));const za=(e,t)=>Math.sqrt(Na(e,t));const Ta=(e,t)=>[Math.cos(e)*t,Math.sin(e)*t];const $a=(e,t)=>[e[0]*t[0]+e[2]*t[1],e[1]*t[0]+e[3]*t[1],e[0]*t[2]+e[2]*t[3],e[1]*t[2]+e[3]*t[3],e[0]*t[4]+e[2]*t[5]+e[4],e[1]*t[4]+e[3]*t[5]+e[5]];const Ba=Object.freeze({__proto__:null,svg_add2:Fa,svg_distance2:za,svg_distanceSq2:Na,svg_magnitude2:Va,svg_magnitudeSq2:Pa,svg_multiplyMatrices2:$a,svg_polar_to_cart:Ta,svg_scale2:Sa,svg_sub2:Ca});const La=function(e){const t=e.match(/(\w+\((\-?\d+\.?\d*e?\-?\d*,?\s*)+\))+/g);if(!t){return[]}const s=t.map((e=>e.match(/[\w\.\-]+/g)));return s.map((e=>({transform:e.shift(),parameters:e.map((e=>parseFloat(e)))})))};const Ia=function(e){switch(e.length){case 1:return[1,0,0,1,e[0],0];case 2:return[1,0,0,1,e[0],e[1]];default:console.warn(`improper translate, ${e}`)}return undefined};const Ra=function(e){const t=Math.cos(e[0]/(180*Math.PI));const s=Math.sin(e[0]/(180*Math.PI));switch(e.length){case 1:return[t,s,-s,t,0,0];case 3:return[t,s,-s,t,-e[1]*t+e[2]*s+e[1],-e[1]*s-e[2]*t+e[2]];default:console.warn(`improper rotate, ${e}`)}return undefined};const Ua=function(e){switch(e.length){case 1:return[e[0],0,0,e[0],0,0];case 2:return[e[0],0,0,e[1],0,0];default:console.warn(`improper scale, ${e}`)}return undefined};const qa=function(e){return[1,0,Math.tan(e[0]/(180*Math.PI)),1,0,0]};const Da=function(e){return[1,Math.tan(e[0]/(180*Math.PI)),0,1,0,0]};const Wa=function(e,t){switch(e){case"translate":return Ia(t);case"rotate":return Ra(t);case"scale":return Ua(t);case"skewX":return qa(t);case"skewY":return Da(t);case"matrix":return t;default:console.warn(`unknown transform type ${e}`)}return undefined};const Ga=function(e){return La(e).map((e=>Wa(e.transform,e.parameters))).filter((e=>e!==undefined)).reduce(((e,t)=>$a(e,t)),[1,0,0,1,0,0])};const Ha=Object.freeze({__proto__:null,parseTransform:La,transformStringToMatrix:Ga});const Ja=(e,t="text/xml")=>{const s=(new(aa().DOMParser)).parseFromString(e,t);return s?s.documentElement:null};const Qa=e=>{let t=e;while(t.parentNode!=null){t=t.parentNode}return t};const Za=(e,t)=>{if((e.nodeName||"")===t){return e}return e.parentNode?Za(e.parentNode,t):undefined};const Ya=(e,...t)=>{const s={};const n=e.getAttribute("class");const r=n?n.split(" "):[];r.push(...t);r.forEach((e=>{s[e]=true}));const c=Object.keys(s).join(" ");e.setAttribute("class",c)};const Xa=(e,...t)=>{if(!e||!t.length){return undefined}return e.classList?e.classList.add(...t):Ya(e,...t)};const Ka=e=>e.childNodes==null||!e.childNodes.length?[e]:Array.from(e.childNodes).flatMap((e=>Ka(e)));const ei={svg:["viewBox","xmlns","version"],line:["x1","y1","x2","y2"],rect:["x","y","width","height"],circle:["cx","cy","r"],ellipse:["cx","cy","rx","ry"],polygon:["points"],polyline:["points"],path:["d"]};const ti=e=>{const t=e.attributes;if(t==null){return[]}const s=Array.from(t);return ei[e.nodeName]?s.filter((t=>!ei[e.nodeName].includes(t.name))):s};const si=e=>{const t={};e.forEach((e=>{t[e.nodeName]=e.value}));return t};const ni=(e,t)=>{const s=si(ti(t));if(!s.transform&&!e.transform){return{...e,...s}}const n=s.transform||"";const r=e.transform||"";const c=Ga(n);const o=Ga(r);const a=$a(o,c);const i=`matrix(${a.join(", ")})`;return{...e,...s,transform:i}};const ri=(e,t={})=>e.childNodes==null||!e.childNodes.length?[{element:e,attributes:t}]:Array.from(e.childNodes).flatMap((e=>ri(e,ni(t,e))));const ci=Object.freeze({__proto__:null,addClass:Xa,findElementTypeInParents:Za,flattenDomTree:Ka,flattenDomTreeWithStyle:ri,getRootParent:Qa,xmlStringToElement:Ja});const oi=e=>(new(aa().DOMParser)).parseFromString("<root></root>","text/xml").createCDATASection(e);const ai=/[MmLlSsQqLlHhVvCcSsQqTtAaZz]/g;const ii=/-?[0-9]*\.?\d+/g;const fi={m:"move",l:"line",v:"vertical",h:"horizontal",a:"ellipse",c:"curve",s:"smoothCurve",q:"quadCurve",t:"smoothQuadCurve",z:"close"};Object.keys(fi).forEach((e=>{const t=fi[e];fi[e.toUpperCase()]=t.charAt(0).toUpperCase()+t.slice(1)}));const li=(e,t)=>[e[0]+(t[0]||0),e[1]+(t[1]||0)];const di=(e,t,s=[0,0])=>{const n=e.toUpperCase();let r=e===n?[0,0]:s;if(e==="V"){r=[s[0],0]}if(e==="H"){r=[0,s[1]]}switch(n){case"V":return li(r,[0,t[0]]);case"H":return li(r,[t[0],0]);case"M":case"L":case"T":return li(r,t);case"A":return li(r,[t[5],t[6]]);case"C":return li(r,[t[4],t[5]]);case"S":case"Q":return li(r,[t[2],t[3]]);case"Z":return undefined;default:return r}};const ui=e=>{const t=[];let s;while((s=ai.exec(e))!==null){t.push(s)}return t.map(((t,s,n)=>[t[0],t.index,s===n.length-1?e.length-1:n[(s+1)%n.length].index-1])).map((t=>{const s=t[0];const n=e.substring(t[1]+1,t[2]+1);const r=n.match(ii);const c=r?r.map(parseFloat):[];return{command:s,values:c}}))};const mi=e=>{let t=[0,0];const s=ui(e);if(!s.length){return s}s.forEach(((e,n)=>{s[n].end=di(e.command,e.values,t);s[n].start=n===0?t:s[n-1].end;t=s[n].end}));const n=s[s.length-1];const r=s.filter((e=>e.command.toUpperCase()!=="M"&&e.command.toUpperCase()!=="Z")).shift();if(n.command.toUpperCase()==="Z"){n.end=[...r.start]}return s};const gi=Object.freeze({__proto__:null,parsePathCommands:ui,parsePathCommandsWithEndpoints:mi,pathCommandNames:fi});const pi=(...e)=>e.filter((e=>typeof e===Io)).concat(e.filter((e=>typeof e===Uo&&e!==null)).map((e=>{if(typeof e.x===Io){return[e.x,e.y]}if(typeof e[0]===Io){return[e[0],e[1]]}return undefined})).filter((e=>e!==undefined)).reduce(((e,t)=>e.concat(t)),[]));const _i=function(e,t,s,n,r=0){const c=1;const o=s/c-s;const a=e-o-r;const i=t-o-r;const f=s+o*2+r*2;const l=n+o*2+r*2;return[a,i,f,l].join(" ")};const vi=(...e)=>{const t=pi(...e.flat());if(t.length===2){t.unshift(0,0)}return t.length===4?_i(...t):undefined};const hi=(e,...t)=>{const s=t.length===1&&typeof t[0]===Ro?t[0]:vi(...t);if(s){e.setAttribute(Ho,s)}return e};const bi=function(e){const t=e.getAttribute(Ho);return t==null?undefined:t.split(" ").map((e=>parseFloat(e)))};const yi=function(e,t,s){const n=e.createSVGPoint();n.x=t;n.y=s;const r=n.matrixTransform(e.getScreenCTM().inverse());return[r.x,r.y]};const Ei=({vertices_coords:e})=>{if(!e){return undefined}const t=[Infinity,Infinity];const s=[-Infinity,-Infinity];e.forEach((e=>[0,1].forEach((n=>{t[n]=Math.min(e[n],t[n]);s[n]=Math.max(e[n],s[n])}))));return[t[0],t[1],s[0]-t[0],s[1]-t[1]].join(" ")};const Ai=Object.freeze({__proto__:null,convertToViewBox:yi,foldToViewBox:Ei,getViewBox:bi,setViewBox:hi});const xi={...Ba,...ci,makeCDATASection:oi,...gi,...Ha,...Ai};const Mi=function(e){const t=bi(e);if(t!==undefined){return t}if(typeof e.getBoundingClientRect===$o){const t=e.getBoundingClientRect();return[t.x,t.y,t.width,t.height]}return[]};const wi="svg-background-rectangle";const ki=function(e,t){let s=Array.from(e.childNodes).filter((e=>e.getAttribute(To)===wi)).shift();if(s==null){s=aa().document.createElementNS(ia,"rect");Mi(e).forEach(((e,t)=>s.setAttribute(da.rect[t],e)));s.setAttribute(To,wi);s.setAttribute(Zo,Xo);e.insertBefore(s,e.firstChild)}s.setAttribute(Yo,t);return e};const Oi=e=>{const t=e.getAttribute(Jo);return t==null||t===""?undefined:t};const ji={clearTransform:e=>{e.removeAttribute(Jo);return e}};["translate","rotate","scale","matrix"].forEach((e=>{ji[e]=(t,...s)=>{t.setAttribute(Jo,[Oi(t),`${e}(${s.join(" ")})`].filter((e=>e!==undefined)).join(" "));return t}}));const Fi=e=>e.replace(/([-_][a-z])/gi,(e=>e.toUpperCase().replace("-","").replace("_","")));const Ci=e=>e.replace(/([a-z0-9])([A-Z])/g,"$1-$2").replace(/([A-Z])([A-Z])(?=[a-z])/g,"$1-$2").toLowerCase();const Si=e=>e.charAt(0).toUpperCase()+e.slice(1);const Pi=e=>{while(e.lastChild){e.removeChild(e.lastChild)}return e};const Vi=(e,t)=>{if(t&&t.appendChild){t.appendChild(e)}return e};const Ni=(e,t)=>{Object.keys(t).forEach((s=>e.setAttribute(Ci(s),t[s])));return e};const zi=Object.freeze({__proto__:null,appendTo:Vi,removeChildren:Pi,setAttributes:Ni});const Ti=function(e,t){const s=bi(e);if(s!==undefined){hi(e,...[-t,-t,t*2,t*2].map(((e,t)=>s[t]+e)))}return e};const $i=function(e,t){const s=e.getElementsByTagName(t);return s.length?s[0]:null};const Bi=function(e,t){let s=$i(e,Go);if(s==null){s=aa().document.createElementNS(ia,Go);s.setTextContent=e=>{s.textContent="";s.appendChild(oi(e));return s};e.insertBefore(s,e.firstChild)}s.textContent="";s.appendChild(oi(t));return s};const Li=e=>{Array.from(e.attributes).filter((e=>e.name!=="xmlns"&&e.name!=="version")).forEach((t=>e.removeAttribute(t.name)));return Pi(e)};const Ii={clear:Li,size:hi,setViewBox:hi,getViewBox:bi,padding:Ti,background:ki,getWidth:e=>Mi(e)[2],getHeight:e=>Mi(e)[3],stylesheet:function(e,t){return Bi.call(this,e,t)},...ji,...zi};const Ri={move:["mousemove","touchmove"],press:["mousedown","touchstart"],release:["mouseup","touchend"],leave:["mouseleave","touchcancel"]};const Ui=(e,t)=>Object.values(Ri).flat().forEach((s=>{t[s].forEach((t=>e.removeEventListener(s,t)));t[s]=[]}));const qi=(e,t,s)=>Object.defineProperty(e,t,{get:()=>s,enumerable:true,configurable:true});const Di=function(e){const t=[];Object.keys(Ri).forEach((e=>{Ri[e].forEach((e=>{t[e]=[]}))}));const s=s=>Ri[s].forEach((s=>t[s].forEach((t=>e.removeEventListener(s,t)))));Object.keys(Ri).forEach((n=>{Object.defineProperty(e,`on${Si(n)}`,{set:r=>{if(!e.addEventListener){return}if(r==null){s(n);return}Ri[n].forEach((s=>{const n=t=>{const s=t.touches!=null?t.touches[0]:t;if(s!==undefined){const{clientX:n,clientY:r}=s;const[c,o]=yi(e,n,r);qi(t,"x",c);qi(t,"y",o)}r(t)};t[s].push(n);e.addEventListener(s,n)}))},enumerable:true})}));Object.defineProperty(e,"off",{value:()=>Ui(e,t)})};const Wi=()=>Math.random().toString(36).replace(/[^a-z]+/g,"").concat("aaaaa").substr(0,5);const Gi=function(e){let t;let s=0;let n;const r={};const c=()=>{if(aa().cancelAnimationFrame){aa().cancelAnimationFrame(n)}Object.keys(r).forEach((e=>delete r[e]))};const o=e=>{c();if(!e||!aa().requestAnimationFrame){return}t=performance.now();s=0;const o=Wi();r[o]=c=>{const a=(c-t)*.001;e({time:a,frame:s});s+=1;if(r[o]){n=aa().requestAnimationFrame(r[o])}};n=aa().requestAnimationFrame(r[o])};Object.defineProperty(e,"play",{set:o,enumerable:true});Object.defineProperty(e,"stop",{value:c,enumerable:true})};const Hi=e=>e&&e.parentNode?e.parentNode.removeChild(e):undefined;const Ji=[["cx","cy"],["x","y"]];const Qi=function(e,t={}){const s=[0,0];const n={selected:false,svg:undefined,updatePosition:e=>e};const r=()=>{if(!n.svg){return}if(!n.svg.parentNode){e.appendChild(n.svg)}Ji.filter((e=>n.svg[e[0]]!=null)).forEach((e=>e.forEach(((e,t)=>{n.svg.setAttribute(e,s[t])}))))};const c=new Proxy(s,{set:(e,t,s)=>{e[t]=s;r();return true}});const o=function(...e){pi(...e.flat()).forEach(((e,t)=>{s[t]=e}));r();if(typeof s.delegate===$o){s.delegate.apply(s.pointsContainer,[c,s.pointsContainer])}};s.delegate=undefined;s.setPosition=o;s.onMouseMove=e=>n.selected?o(n.updatePosition(e)):undefined;s.onMouseUp=()=>{n.selected=false};s.distance=e=>Math.sqrt(Na(e,s));["x","y"].forEach(((e,t)=>Object.defineProperty(s,e,{get:()=>s[t],set:e=>{s[t]=e}})));[qo,"updatePosition","selected"].forEach((e=>Object.defineProperty(s,e,{get:()=>n[e],set:t=>{n[e]=t}})));Object.defineProperty(s,"remove",{value:()=>{Hi(n.svg);s.delegate=undefined}});return c};const Zi=function(e,t,s){let n;let r;const c=Array.from(Array(t)).map((()=>Qi(e,s)));const o=e=>typeof r===$o?r.call(c,e,n,c):undefined;c.forEach((e=>{e.delegate=o;e.pointsContainer=c}));const a=function(e){if(!(c.length>0)){return}n=c.map(((t,s)=>({i:s,d:Na(t,[e.x,e.y])}))).sort(((e,t)=>e.d-t.d)).shift().i;c[n].selected=true};const i=function(e){c.forEach((t=>t.onMouseMove(e)))};const f=function(){c.forEach((e=>e.onMouseUp()));n=undefined};e.onPress=a;e.onMove=i;e.onRelease=f;Object.defineProperty(c,"selectedIndex",{get:()=>n});Object.defineProperty(c,"selected",{get:()=>c[n]});Object.defineProperty(c,"add",{value:t=>{c.push(Qi(e,t))}});c.removeAll=()=>{while(c.length>0){c.pop().remove()}};const l={onChange:(e,t)=>{r=e;if(t===true){const t=c.length-1;e.call(c,c[t],t,c)}},position:e=>c.forEach(((t,s)=>t.setPosition(e.call(c,t,s,c)))),svg:e=>c.forEach(((t,s)=>{t.svg=e.call(c,t,s,c)}))};Object.keys(l).forEach((e=>{c[e]=function(){if(typeof arguments[0]===$o){l[e](...arguments)}return c}}));c.parent=function(e){if(e!=null&&e.appendChild!=null){c.forEach((t=>{e.appendChild(t.svg)}))}return c};return c};const Yi=e=>{e.controls=(...t)=>Zi.call(e,e,...t)};const Xi={svg:{args:(...e)=>[vi(pi(...e))].filter((e=>e!=null)),methods:Ii,init:(...e)=>{const t=aa().document.createElementNS(ia,"svg");t.setAttribute("version","1.1");t.setAttribute("xmlns",ia);e.filter((e=>e!=null)).filter((e=>e.appendChild)).forEach((e=>e.appendChild(t)));Di(t);Gi(t);Yi(t);return t}}};const Ki=function(e){if(e==null){return""}if(typeof e===Ro){return e.slice(0,3)==="url"?e:`url(#${e})`}if(e.getAttribute!=null){const t=e.getAttribute(Wo);return`url(#${t})`}return""};const ef={};["clip-path","mask","symbol","marker-end","marker-mid","marker-start"].forEach((e=>{ef[Fi(e)]=(t,s)=>{t.setAttribute(e,Ki(s));return t}}));const tf={g:{methods:{...ji,...ef,...zi}}};const sf=(e,t)=>{e.setAttribute(da.circle[2],t);return e};const nf=(e,t,s)=>{[...pi(...[t,s].flat()).slice(0,2)].forEach(((t,s)=>e.setAttribute(da.circle[s],t)));return e};const rf=(e,t,s,n)=>[e,t,za([e,t],[s,n])];const cf={circle:{args:(e,t,s,n)=>{const r=pi(...[e,t,s,n].flat());switch(r.length){case 0:case 1:return[,,...r];case 2:case 3:return r;default:return rf(...r)}},methods:{radius:sf,setRadius:sf,origin:nf,setOrigin:nf,center:nf,setCenter:nf,position:nf,setPosition:nf,...ji,...ef,...zi}}};const of=(e,t,s)=>{[,,t,s].forEach(((t,s)=>e.setAttribute(da.ellipse[s],t)));return e};const af=(e,t,s)=>{[...pi(...[t,s].flat()).slice(0,2)].forEach(((t,s)=>e.setAttribute(da.ellipse[s],t)));return e};const ff={ellipse:{args:(e,t,s,n)=>{const r=pi(...[e,t,s,n].flat()).slice(0,4);switch(r.length){case 0:case 1:case 2:return[,,...r];default:return r}},methods:{radius:of,setRadius:of,origin:af,setOrigin:af,center:af,setCenter:af,position:af,setPosition:af,...ji,...ef,...zi}}};const lf=e=>e!=null&&typeof e[Symbol.iterator]===$o;const df=function(){switch(arguments.length){case 0:return Array.from(arguments);case 1:return lf(arguments[0])&&typeof arguments[0]!==Ro?df(...arguments[0]):[arguments[0]];default:return Array.from(arguments).map((e=>lf(e)?[...df(e)]:e))}};const uf=(...e)=>pi(...df(...e)).slice(0,4);const mf=(e,...t)=>{uf(...t).forEach(((t,s)=>e.setAttribute(da.line[s],t)));return e};const gf={line:{args:uf,methods:{setPoints:mf,...ji,...ef,...zi}}};const pf=e=>{const t=e.getAttribute("d");return t==null?"":t};const _f=e=>{e.removeAttribute("d");return e};const vf=(e,t,...s)=>{e.setAttribute("d",`${pf(e)}${t}${s.flat().join(" ")}`);return e};const hf=e=>ui(pf(e));const bf={addCommand:vf,appendCommand:vf,clear:_f,getCommands:hf,get:hf,getD:e=>e.getAttribute("d"),...ji,...ef,...zi};Object.keys(fi).forEach((e=>{bf[fi[e]]=(t,...s)=>vf(t,e,...s)}));const yf={path:{methods:bf}};const Ef=(e,t,s)=>{[,,t,s].forEach(((t,s)=>e.setAttribute(da.rect[s],t)));return e};const Af=(e,t,s)=>{[...pi(...[t,s].flat()).slice(0,2)].forEach(((t,s)=>e.setAttribute(da.rect[s],t)));return e};const xf=function(e){[0,1].forEach((t=>{if(e[2+t]<0){if(e[0+t]===undefined){e[0+t]=0}e[0+t]+=e[2+t];e[2+t]=-e[2+t]}}));return e};const Mf={rect:{args:(e,t,s,n)=>{const r=pi(...[e,t,s,n].flat()).slice(0,4);switch(r.length){case 0:case 1:case 2:case 3:return xf([,,...r]);default:return xf(r)}},methods:{origin:Af,setOrigin:Af,center:Af,setCenter:Af,size:Ef,setSize:Ef,...ji,...ef,...zi}}};const wf={style:{init:e=>{const t=aa().document.createElementNS(ia,"style");t.setAttribute("type","text/css");t.textContent="";t.appendChild(oi(e));return t},methods:{setTextContent:(e,t)=>{e.textContent="";e.appendChild(oi(t));return e}}}};const kf={text:{args:(e,t,s)=>pi(...[e,t,s].flat()).slice(0,2),init:(e,t,s,n)=>{const r=aa().document.createElementNS(ia,"text");const c=[e,t,s,n].filter((e=>typeof e===Ro)).shift();r.appendChild(aa().document.createTextNode(c||""));return r},methods:{...ji,...ef,appendTo:Vi,setAttributes:Ni}}};const Of=function(){return Array.from(arguments).filter((e=>typeof e===Ro||e instanceof String)).shift()||Wi()};const jf=(...e)=>[Of(...e)];const Ff={mask:{args:jf,methods:{...ji,...ef,...zi}},clipPath:{args:jf,methods:{...ji,...ef,...zi}},symbol:{args:jf,methods:{...ji,...ef,...zi}},marker:{args:jf,methods:{size:hi,setViewBox:hi,...ji,...ef,...zi}}};const Cf=e=>{const t=e.getAttribute(Qo);return t==null?"":t};const Sf=function(){return Array.from(Array(Math.floor(arguments.length/2))).map(((e,t)=>`${arguments[t*2+0]},${arguments[t*2+1]}`)).join(" ")};const Pf=(...e)=>[Sf(...pi(...df(...e)))];const Vf=(e,...t)=>{e.setAttribute(Qo,Pf(...t)[0]);return e};const Nf=(e,...t)=>{e.setAttribute(Qo,[Cf(e),Pf(...t)[0]].filter((e=>e!=="")).join(" "));return e};const zf=function(...e){return e.length===1&&typeof e[0]===Ro?[e[0]]:Pf(...e)};const Tf={polyline:{args:zf,methods:{setPoints:Vf,addPoint:Nf,...ji,...ef,...zi}},polygon:{args:zf,methods:{setPoints:Vf,addPoint:Nf,...ji,...ef,...zi}}};const $f=(e,t,s,n,r,c=false)=>{if(r==null){return""}const o=Ta(n,s);const a=Ta(r,s);const i=[a[0]-o[0],a[1]-o[1]];const f=o[0]*a[1]-o[1]*a[0];const l=o[0]*a[0]+o[1]*a[1];const d=Math.atan2(f,l)>0?0:1;let u=c?`M ${e},${t} l ${o[0]},${o[1]} `:`M ${e+o[0]},${t+o[1]} `;u+=["a ",s,s,0,d,1,i[0],i[1]].join(" ");if(c){u+=" Z"}return u};const Bf=(e,t,s,n,r)=>[$f(e,t,s,n,r,false)];const Lf={arc:{nodeName:Do,attributes:["d"],args:Bf,methods:{setArc:(e,...t)=>e.setAttribute("d",Bf(...t)),...ji}}};const If=[ta,ea];const Rf=e=>e.join(",");const Uf=e=>"M"+e.map((e=>e.join(","))).join("L")+"Z";const qf=function(e){let t=[[0,1],[2,3]].map((t=>t.map((t=>e.points[t]||0))));let s=Ca(t[1],t[0]);let n=Fa(t[0],Sa(s,.5));const r=Va(s);const c=If.map((t=>e[t].visible?(1+e[t].padding)*e[t].height*2.5:0)).reduce(((e,t)=>e+t),0);if(r<c){const e=r===0?[c,0]:Sa(s,c/r);t=[Ca,Fa].map((t=>t(n,Sa(e,.5))));s=Ca(t[1],t[0])}let o=[s[1],-s[0]];let a=Fa(n,Sa(o,e.bend));const i=t.map((e=>Ca(a,e)));const f=i.map((e=>Va(e)));const l=i.map(((e,t)=>f[t]===0?e:Sa(e,1/f[t])));const d=l.map((e=>Sa(e,-1)));const u=d.map((e=>[e[1],-e[0]]));const m=If.map(((t,s)=>e[t].padding?e[t].padding:e.padding?e.padding:0));const g=If.map(((t,s)=>e[t].height*(e[t].visible?1:0))).map(((e,t)=>e+m[t]));const p=t.map(((e,t)=>Fa(e,Sa(l[t],g[t]))));s=Ca(p[1],p[0]);o=[s[1],-s[0]];n=Fa(p[0],Sa(s,.5));a=Fa(n,Sa(o,e.bend));const _=p.map(((t,s)=>Fa(t,Sa(Ca(a,t),e.pinch))));const v=If.map(((t,s)=>[Fa(p[s],Sa(d[s],e[t].height)),Fa(p[s],Sa(u[s],e[t].width/2)),Fa(p[s],Sa(u[s],-e[t].width/2))]));return{line:`M${Rf(p[0])}C${Rf(_[0])},${Rf(_[1])},${Rf(p[1])}`,tail:Uf(v[0]),head:Uf(v[1])}};const Df=(e,t,s)=>{if(typeof t===Lo){e.options[s].visible=t}else if(typeof t===Uo){Object.assign(e.options[s],t);if(t.visible==null){e.options[s].visible=true}}else if(t==null){e.options[s].visible=true}};const Wf=(e,t={},s=ea)=>{const n=e.getElementsByClassName(`${Ko}-${s}`)[0];Object.keys(t).map((e=>({key:e,fn:n[Fi(e)]}))).filter((e=>typeof e.fn===$o&&e.key!=="class")).forEach((e=>e.fn(t[e.key])));Object.keys(t).filter((e=>e==="class")).forEach((e=>n.classList.add(t[e])))};const Gf=e=>{const t=qf(e.options);Object.keys(t).map((t=>({path:t,element:e.getElementsByClassName(`${Ko}-${t}`)[0]}))).filter((e=>e.element)).map((e=>{e.element.setAttribute("d",t[e.path]);return e})).filter((t=>e.options[t.path])).forEach((t=>t.element.setAttribute("visibility",e.options[t.path].visible?"visible":"hidden")));return e};const Hf=(e,...t)=>{e.options.points=pi(...df(...t)).slice(0,4);return Gf(e)};const Jf=(e,t)=>{e.options.bend=t;return Gf(e)};const Qf=(e,t)=>{e.options.pinch=t;return Gf(e)};const Zf=(e,t)=>{e.options.padding=t;return Gf(e)};const Yf=(e,t)=>{Df(e,t,ea);Wf(e,t,ea);return Gf(e)};const Xf=(e,t)=>{Df(e,t,ta);Wf(e,t,ta);return Gf(e)};const Kf=e=>e.getElementsByClassName(`${Ko}-line`)[0];const el=e=>e.getElementsByClassName(`${Ko}-${ea}`)[0];const tl=e=>e.getElementsByClassName(`${Ko}-${ta}`)[0];const sl={setPoints:Hf,points:Hf,bend:Jf,pinch:Qf,padding:Zf,head:Yf,tail:Xf,getLine:Kf,getHead:el,getTail:tl,...ji};const nl=()=>({visible:false,width:8,height:10,padding:0});const rl=()=>({head:nl(),tail:nl(),bend:0,padding:0,pinch:.618,points:[]});const cl=Object.keys(rl());const ol=(...e)=>{for(let t=0;t<e.length;t+=1){if(typeof e[t]!==Uo){continue}const s=Object.keys(e[t]);for(let n=0;n<s.length;n+=1){if(cl.includes(s[n])){return e[t]}}}return undefined};const al=function(...e){const t=aa().document.createElementNS(ia,"g");t.setAttribute(To,Ko);const s=["line",ta,ea].map((e=>{const s=aa().document.createElementNS(ia,Do);s.setAttribute(To,`${Ko}-${e}`);t.appendChild(s);return s}));s[0].setAttribute(Go,"fill:none;");s[1].setAttribute(Zo,Xo);s[2].setAttribute(Zo,Xo);t.options=rl();sl.setPoints(t,...e);const n=ol(...e);if(n){Object.keys(n).filter((e=>sl[e])).forEach((e=>sl[e](t,n[e])))}return t};const il={arrow:{nodeName:"g",attributes:[],args:()=>[],methods:sl,init:al}};const fl=(e=[],t=0,s=.5)=>{const n=[e[0]||0,e[1]||0];const r=[e[2]||0,e[3]||0];const c=Ca(r,n);const o=Fa(n,Sa(c,.5));const a=[c[1],-c[0]];const i=Fa(o,Sa(a,t));const f=Fa(n,Sa(Ca(i,n),s));const l=Fa(r,Sa(Ca(i,r),s));return`M${n[0]},${n[1]}C${f[0]},${f[1]} ${l[0]},${l[1]} ${r[0]},${r[1]}`};const ll=(...e)=>[fl(pi(...e.flat()))];const dl=e=>e.slice(1).split(/[, ]+/).map((e=>parseFloat(e)));const ul=e=>e.match(/[Cc][(0-9), .-]+/).map((e=>dl(e)));const ml=e=>e.match(/[Mm][(0-9), .-]+/).map((e=>dl(e)));const gl=e=>{const t=ml(e).shift();const s=ul(e).shift();const n=t?[t[t.length-2],t[t.length-1]]:[0,0];const r=s?[s[s.length-2],s[s.length-1]]:[0,0];return[...n,...r]};const pl=(e,...t)=>{const s=pi(...t.flat()).slice(0,4);e.setAttribute("d",fl(s,e._bend,e._pinch));return e};const _l=(e,t)=>{e._bend=t;return pl(e,...gl(e.getAttribute("d")))};const vl=(e,t)=>{e._pinch=t;return pl(e,...gl(e.getAttribute("d")))};const hl={setPoints:pl,bend:_l,pinch:vl,...ji};const bl={curve:{nodeName:Do,attributes:["d"],args:ll,methods:hl}};const yl=(e,t,s,n,r)=>[$f(e,t,s,n,r,true)];const El={wedge:{nodeName:Do,args:yl,attributes:["d"],methods:{setArc:(e,...t)=>e.setAttribute("d",yl(...t)),...ji}}};const Al={};const xl=(e,...t)=>{const s=aa().document.createElementNS(ia,"g");Al.ear.convert.foldToSvg.render(e,s,...t);return s};const Ml={...ji,...ef,...zi};const wl={origami:{nodeName:"g",init:xl,args:()=>[],methods:Ml}};const kl={...Xi,...tf,...cf,...ff,...gf,...yf,...Mf,...wf,...kf,...Ff,...Tf,...Lf,...il,...bl,...El,...wl};const Ol=(...e)=>e;const jl=(e,t,...s)=>{const n=kl[e]&&kl[e].nodeName?kl[e].nodeName:e;const{init:r,args:c,methods:o}=kl[e]||{};const a=da[n]||[];const i=pa[n]||[];const f=r?r(...s):aa().document.createElementNS(ia,n);if(t){t.appendChild(f)}const l=c||Ol;l(...s).forEach(((e,t)=>{f.setAttribute(da[n][t],e)}));if(o){Object.keys(o).forEach((e=>Object.defineProperty(f,e,{value:function(){return o[e](f,...arguments)}})))}a.forEach((e=>{const t=Fi(e);if(f[t]){return}Object.defineProperty(f,t,{value:function(){f.setAttribute(e,...arguments);return f}})}));i.forEach((e=>{if(f[e]){return}const t=function(){return jl(e,f,...arguments)};Object.defineProperty(f,e,{value:t})}));return f};const Fl=(...e)=>{const t=jl(qo,null,...e);const s=()=>e.filter((e=>typeof e===$o)).forEach((e=>e.call(t,t)));if(aa().document.readyState==="loading"){aa().document.addEventListener("DOMContentLoaded",s)}else{s()}return t};Object.assign(Fl,{NS:ia,nodes_attributes:da,nodes_children:pa,extensions:kl,...ja,...xi});_a.forEach((e=>{Fl[e]=(...t)=>jl(e,null,...t)}));Object.defineProperty(Fl,"window",{enumerable:false,set:oa});const Cl=e=>[e.min,e.span].flatMap((e=>[e[0],e[1]])).join(" ");const Sl=e=>{const t=go(e);return t===undefined?"":Cl(t)};const Pl=({vertices_coords:e,edges_vertices:t,edges_length:s},n=.1)=>{if(!e||!t){return undefined}if(!s){s=Tn({vertices_coords:e,edges_vertices:t})}const r=s.slice().sort(((e,t)=>e-t));const c=Math.max(0,Math.min(Math.floor(r.length*n),r.length-1));return r[c]};const Vl={min:[0,0],span:[1,1]};const Nl=1/100;const zl=(e,{vmax:t}={})=>{if(!t){const s=go(e)||Vl;t=Math.max(...s.span)}const s=Pl(e,.1);return s?s*Nl*10:t*Nl};const Tl=(e,t={})=>{const s=t&&t.vertices?t.vertices:{};const n=Fl.g();if(!e||!e.vertices_coords){return n}e.vertices_coords.map((e=>Fl.circle(e[0],e[1],.01))).forEach((e=>n.appendChild(e)));n.setAttributeNS(null,"fill","none");Object.keys(s).forEach((e=>n.setAttributeNS(null,e,s[e])));return n};const $l={B:"black",M:"crimson",V:"royalblue",F:"lightgray",J:"gold",C:"limegreen",U:"orchid"};Object.keys($l).forEach((e=>{$l[e.toLowerCase()]=$l[e]}));const Bl=4;const Ll={M:[1,0,0],V:[0,0,1],J:[1,1,0],U:[1,0,1],C:[0,1,0]};const Il=(e=0,t=0,s=0)=>{const n=A([e,t,s],1/255);const r=p(n);if(r<.05){return"B"}const c=n.reduce(((e,t)=>e+t),0)/3;const o=U(n,[c,c,c]);const a=Object.keys(Ll).map((e=>({key:e,dist:U(n,Ll[e])}))).sort(((e,t)=>e.dist-t.dist)).shift();if(a.dist<o*Bl){return a.key}return r<.1?"B":"F"};const Rl=Object.freeze({__proto__:null,assignmentColor:$l,rgbToAssignment:Il});const Ul={};const ql={stroke:"black"};const Dl={};const Wl={};Object.keys($l).forEach((e=>{Wl[e]={stroke:$l[e]}}));const Gl=(e,t,s)=>e.setAttribute(`data-${t}`,s);const Hl=e=>{const t={u:[],c:[],j:[],f:[],v:[],m:[],b:[]};const s=e.edges_assignment.map((e=>e.toLowerCase()));e.edges_vertices.map(((e,t)=>s[t]||"u")).forEach(((e,s)=>t[e].push(s)));return t};const Jl=({vertices_coords:e,edges_vertices:t})=>{if(!e||!t){return[]}return t.map((t=>t.map((t=>e[t]))))};const Ql=e=>`M${e[0][0]} ${e[0][1]}L${e[1][0]} ${e[1][1]}`;const Zl=e=>Jl(e).map((e=>Ql(e))).join("");const Yl=({vertices_coords:e,edges_vertices:t,edges_assignment:s})=>{if(!e||!t){return{}}if(!s){return{u:Zl({vertices_coords:e,edges_vertices:t})}}const n=Hl({vertices_coords:e,edges_vertices:t,edges_assignment:s});Object.keys(n).forEach((s=>{n[s]=Zl({vertices_coords:e,edges_vertices:n[s].map((e=>t[e]))})}));Object.keys(n).forEach((e=>{if(n[e]===""){delete n[e]}}));return n};const Xl=({vertices_coords:e,edges_vertices:t,edges_assignment:s})=>{const n=Yl({vertices_coords:e,edges_vertices:t,edges_assignment:s});Object.keys(n).forEach((e=>{const t=Fl.path(n[e]);Xa(t,At[e]);n[e]=t}));return n};const Kl=(e,t={})=>Object.keys(t).forEach((s=>e.setAttributeNS(null,s,t[s])));const ed=(e,t={})=>{const s=t&&t.edges?t.edges:{};const n=Fl.g();if(!e){return n}const r=$t(e);const c=JSON.parse(JSON.stringify(r?Ul:ql));const o=JSON.parse(JSON.stringify(r?Dl:Wl));const a={};if(s.stroke){a.stroke=s.stroke}Object.assign(c,a);Object.keys(o).forEach((e=>{o[e]={...o[e],...a}}));const i=Xl(e);Object.keys(i).forEach((e=>{Xa(i[e],At[e]);Kl(i[e],o[e]);Kl(i[e],s[e]);Kl(i[e],s[At[e]]);n.appendChild(i[e]);Object.defineProperty(n,At[e],{get:()=>i[e]})}));Kl(n,c);Object.keys(i).forEach((e=>Gl(i[e],"assignment",e)));Object.keys(i).forEach((e=>Gl(i[e],"foldAngle",xt[e])));return n};const td=e=>Math.abs(e)/180;const sd=(e,t={})=>{const s=t&&t.edges?t.edges:{};const n=Fl.g();if(!e){return n}const r=$t(e);const c=JSON.parse(JSON.stringify(r?Ul:ql));const o=JSON.parse(JSON.stringify(r?Dl:Wl));const a={};if(s.stroke){a.stroke=s.stroke}Object.assign(c,a);Et.forEach((e=>{if(o[e]===undefined){o[e]={}}o[e]={...o[e],...a}}));const i={};Array.from(new Set(Et.map((e=>e.toLowerCase())))).forEach((e=>{const t=Fl.g();n.appendChild(t);Xa(t,At[e]);Kl(t,o[e]);Kl(t,s[At[e]]);Object.defineProperty(n,At[e],{get:()=>t});i[e]=t}));const f=e.edges_vertices.map((t=>t.map((t=>e.vertices_coords[t])))).map((e=>Fl.line(e[0][0],e[0][1],e[1][0],e[1][1])));if(e.edges_foldAngle){e.edges_foldAngle.forEach(((e,t)=>Gl(f[t],"foldAngle",e)))}if(e.edges_assignment){e.edges_assignment.forEach(((e,t)=>Gl(f[t],"assignment",e)))}if(e.edges_foldAngle){f.forEach(((t,s)=>{const n=e.edges_foldAngle[s];if(n===0||n===180||n===-180){return}t.setAttributeNS(null,"opacity",td(n))}))}const l=(e.edges_assignment?e.edges_assignment:Sn(e)).map((e=>e.toLowerCase()));f.forEach(((e,t)=>i[l[t]].appendChild(e)));Kl(n,c);return n};const nd=(e,t)=>Ft(e)?ed(e,t):sd(e,t);const rd=e=>e.map((e=>e[0]*e[4]-e[1]*e[3])).map((e=>e>=0));const cd=e=>e.map((e=>e[0]*e[3]-e[1]*e[2])).map((e=>e>=0));const od=({vertices_coords:e,faces_vertices:t})=>t.map((t=>t.map((t=>e[t])).map(((e,t,s)=>[e,s[(t+1)%s.length]])).map((e=>(e[1][0]-e[0][0])*(e[1][1]+e[0][1]))).reduce(((e,t)=>e+t),0))).map((e=>e<0));const ad=Object.freeze({__proto__:null,makeFacesWinding:od,makeFacesWindingFromMatrix:rd,makeFacesWindingFromMatrix2:cd});const id=e=>{const t=as(e.flat());const s=[];t.forEach((e=>{s[e]=[]}));e.forEach((e=>{s[e[1]].push(e[0])}));const n=[];const r={};const c=e=>{if(r[e]){return}r[e]=true;s[e].forEach(c);n.push(e)};t.forEach(c);return n};const fd=Object.freeze({__proto__:null,topologicalSort:id});const ld=(e,t)=>{const s={};t.forEach((e=>{s[e]=true}));return e.filter((e=>s[e[0]]&&s[e[1]]))};const dd=({faceOrders:e,faces_normal:t},s)=>{if(!e||!e.length){return[]}if(!t){throw new Error("linearizeFaceOrders: faces_normal required")}const n=as(e.flatMap((e=>[e[0],e[1]])));const r=s!==undefined&&n.includes(s)?t[s]:t[n[0]];const c=[];n.forEach((e=>{c[e]=F(t[e],r)>0}));const o=e.map((e=>e[2]===-1^!c[e[1]]?[e[0],e[1]]:[e[1],e[0]]));return id(o)};const ud=({faces_vertices:e},t)=>{if(!e){return t}const s=e.map(((e,t)=>t)).filter((e=>t[e]==null));return s.concat(rr(t))};const md=({vertices_coords:e,faces_vertices:t,faceOrders:s,faces_layer:n,faces_normal:r},c)=>{if(!r){r=ln({vertices_coords:e,faces_vertices:t})}if(s){return ud({faces_vertices:t},rr(dd({faceOrders:s,faces_normal:r},c)))}if(n){return ud({faces_vertices:t},n)}return t.map(((e,t)=>t)).filter((()=>true))};const gd=({vertices_coords:e,faces_vertices:t,faceOrders:s,faces_normal:n})=>{if(!n){n=ln({vertices_coords:e,faces_vertices:t})}const r=ao(hn({edges_vertices:s.map((e=>[e[0],e[1]]))}));const c=cr(r);const o=c.map((e=>ld(s,e))).map((e=>dd({faceOrders:e,faces_normal:n})));const a=c.map((e=>n[e[0]]));const i=[];o.forEach(((e,t)=>e.forEach(((e,s)=>{i[e]={vector:a[t],layer:s}}))));return i};const pd=({faces_layer:e})=>{const t=[];const s=rr(e);s.forEach(((e,s)=>{t[e]={vector:[0,0,1],layer:s}}));return t};const _d=({vertices_coords:e,faces_vertices:t,faceOrders:s,faces_normal:n})=>{if(!n){n=ln({vertices_coords:e,faces_vertices:t})}return rr(dd({faceOrders:s,faces_normal:n}))};const vd=Object.freeze({__proto__:null,faceOrdersSubset:ld,linearize2DFaces:md,linearizeFaceOrders:dd,makeFacesLayer:_d,nudgeFacesWithFaceOrders:gd,nudgeFacesWithFacesLayer:pd});const hd={back:{fill:"white"},front:{fill:"#ddd"}};const bd={back:{opacity:.1},front:{opacity:.1}};const yd={};const Ed={stroke:"black","stroke-linejoin":"bevel"};const Ad={stroke:"none",fill:"black","stroke-linejoin":"bevel"};const xd={fill:"none"};const Md=(e,t,s)=>e.setAttribute(`data-${t}`,s);const wd=(e,t={})=>Object.keys(t).forEach((s=>e.setAttributeNS(null,s,t[s])));const kd=(e,t,s,n={})=>{const r=n&&n.faces?n.faces:{};const c=$t(e);const o=!!(e.faceOrders||e.faces_layer);const a=[["front"],["back"]];const i=od(e);i.map((e=>e?a[0]:a[1])).forEach(((e,s)=>{Xa(t[s],e);Md(t[s],"side",e);wd(t[s],c?o?hd[e]:bd[e]:yd[e]);wd(t[s],r[e])}));md(e).forEach((e=>s.appendChild(t[e])));Object.defineProperty(s,"front",{get:()=>t.filter(((e,t)=>i[t]))});Object.defineProperty(s,"back",{get:()=>t.filter(((e,t)=>!i[t]))});wd(s,c?o?Ed:Ad:xd);return s};const Od=(e,t)=>{const s=Fl.g();if(!e||!e.vertices_coords||!e.faces_vertices){return s}const n=e.faces_vertices.map((t=>t.map((t=>[0,1].map((s=>e.vertices_coords[t][s])))))).map((e=>Fl.polygon(e)));n.forEach(((e,t)=>e.setAttributeNS(null,"index",t)));s.setAttributeNS(null,"fill","white");return kd(e,n,s,t)};const jd=function(e,t){const s=Fl.g();if(!e||"faces_edges"in e===false||"edges_vertices"in e===false||"vertices_coords"in e===false){return s}const n=e["faces_edges"].map((t=>t.map((t=>e["edges_vertices"][t])).map(((e,t,s)=>{const n=s[(t+1)%s.length];return e[1]===n[0]||e[1]===n[1]?e[0]:e[1]})).map((t=>[0,1].map((s=>e["vertices_coords"][t][s])))))).map((e=>Fl.polygon(e)));n.forEach(((e,t)=>e.setAttributeNS(null,"index",t)));s.setAttributeNS(null,"fill","white");return kd(e,n,s,t)};const Fd=(e,t)=>{if(e&&e["faces_vertices"]){return Od(e,t)}if(e&&e["faces_edges"]){return jd(e,t)}return Fl.g()};const Cd={fill:"none"};const Sd={stroke:"black",fill:"white"};const Pd=(e,t={})=>Object.keys(t).forEach((s=>e.setAttributeNS(null,s,t[s])));const Vd=(e,t={})=>{const s=t&&t.boundaries?t.boundaries:{};const n=Fl.g();if(!e){return n}const r=vo(e).polygon;if(!r.length){return n}const c=Fl.polygon(r);Xa(c,"boundary");n.appendChild(c);Pd(n,$t(e)?Cd:Sd);Object.keys(s).forEach((e=>n.setAttributeNS(null,e,s[e])));return n};const Nd={vertices:Tl,edges:nd,faces:Fd,boundaries:Vd,edgesPaths:ed,edgesLines:sd,facesVerticesPolygon:Od,facesEdgesPolygon:jd};const zd=1/50;const Td={min:[0,0],span:[1,1]};const $d=["boundaries","faces","edges","vertices"];const Bd=(e,t)=>{for(let s=0;s<e.childNodes.length;s+=1){e.childNodes[s].setAttributeNS(null,"r",t)}};const Ld=(e,t,s,n)=>{const r=t[3]&&t[3].childNodes.length;if(!(n.strokeWidth||n.viewBox||r)){return}const c=go(s)||Td;const o=Math.max(...c.span);const a=Za(e,"svg");if(a&&n.viewBox){const e=Cl(c);a.setAttributeNS(null,"viewBox",e)}if(a&&n.padding){const e=a.getAttribute("viewBox");if(e!=null){const t=n.padding*o;const s=e.split(" ").map((e=>parseFloat(e)));const r=[-t,-t,t*2,t*2].map(((e,t)=>s[t]+e)).join(" ");a.setAttributeNS(null,"viewBox",r)}}if(n.strokeWidth||n["stroke-width"]){const t=n.strokeWidth?n.strokeWidth:n["stroke-width"];const r=typeof t==="number"?o*t:zl(s);e.setAttributeNS(null,"stroke-width",r)}if(r){const e=n.vertices&&n.vertices.radius!=null?n.vertices.radius:n.radius;const s=typeof e==="string"?parseFloat(e):e;const r=typeof s==="number"&&!Number.isNaN(s)?o*s:o*zd;Bd(t[3],r)}};const Id=(e,t={})=>$d.map((s=>t[s]===false?Fl.g():Nd[s](e,t))).map(((e,t)=>{Xa(e,$d[t]);return e}));const Rd=(e,t,s={})=>{if(!$t(e)){if(s.faces===undefined){s.faces=false}}const n=Id(e,s);n.filter((e=>e.childNodes.length>0)).forEach((e=>t.appendChild(e)));Ld(t,n,e,s);Xa(t,...[e.file_classes||[],e.frame_classes||[]].flat());return t};const Ud=(e,t={})=>{const s=Rd(typeof e==="string"?JSON.parse(e):e,Fl.svg(),{viewBox:true,strokeWidth:true,...t});return t&&t.string?(new(o().XMLSerializer)).serializeToString(s):s};Object.assign(Ud,{...Nd,render:Rd,getViewBox:Sl,getStrokeWidth:zl,boundingBoxToViewBox:Cl});const qd=e=>{const t=["file_title","file_author","file_description","frame_title","frame_author","frame_description"];return t.filter((t=>e[t])).map((t=>`# ${t.split("_")[1]}: ${e[t]}`)).join("\n")};const Dd=e=>{const t=typeof e==="string"?JSON.parse(e):e;const s=qd(t);const n=(t.vertices_coords||[]).map((e=>e.join(" "))).map((e=>`v ${e}`)).join("\n");const r=(t.faces_vertices||[]).map((e=>e.map((e=>e+1)).join(" "))).map((e=>`f ${e}`)).join("\n");const c=[s,n,r].filter((e=>e!=="")).join("\n");return`${c}\n`};const Wd={};Wd.prototype=Object.create(Object.prototype);Wd.prototype.constructor=Wd;Object.entries({clean:fr,validate:oo,populate:mc,subgraph:to,boundary:vo,boundingBox:go,nearest:Ir,splitEdge:xc,splitFace:Xc,invertAssignments:Ut,svg:Ud,obj:Dd,...ur,...Yt}).forEach((([e,t])=>{Wd.prototype[e]=function(){return t(this,...arguments)}}));Wd.prototype.clone=function(){return Object.assign(Object.create(Object.getPrototypeOf(this)),zo(this))};Wd.prototype.folded=function(){const e=this.faces_matrix2?ko(this,this.faces_matrix2):So(this,...arguments);return{...this,vertices_coords:e,frame_classes:["foldedForm"]}};Wd.prototype.flatFolded=function(){const e=this.faces_matrix2?ko(this,this.faces_matrix2):Po(this,...arguments);return{...this,vertices_coords:e,frame_classes:["foldedForm"]}};const Gd=(e,t,s,n)=>{t.forEach((t=>{e.edges_assignment[t]=s;e.edges_foldAngle[t]=n}));return t};Wd.prototype.setValley=function(e=[],t=180){return Gd(this,e,"V",Math.abs(t))};Wd.prototype.setMountain=function(e=[],t=-180){return Gd(this,e,"M",-Math.abs(t))};Wd.prototype.setFlat=function(e=[]){return Gd(this,e,"F",0)};Wd.prototype.setUnassigned=function(e=[]){return Gd(this,e,"U",0)};Wd.prototype.setCut=function(e=[]){return Gd(this,e,"C",0)};const Hd=Wd.prototype;const Jd=({vector:e,origin:t},{min:s,max:n,span:r})=>Kd();const Qd=(e,t,s,n,r=dt,c=a)=>{const o=B(h(e),h(s));if(Math.abs(o)<c){return undefined}const i=B(e,s);const f=-i;const l=O(n,t);const d=q(l);const u=B(l,s)/i;const m=B(d,e)/f;if(r(m,c/g(s))){return u}return undefined};const Zd=(e,t,s)=>M(t,E(e,s));const Yd=(e,t,s,n,r)=>e.map(((e,t,s)=>[O(s[(t+1)%s.length],e),e])).map((e=>Qd(t,s,e[0],e[1],n,r))).filter((e=>e!==undefined)).sort(((e,t)=>e-t));const Xd=(e,t,s)=>{let n=0;let r=e.length-1;while(n<r){if(t(e[n+1]-e[n],s)){break}n+=1}while(r>n){if(t(e[r]-e[r-1],s)){break}r-=1}if(n>=r){return undefined}return[e[n],e[r]]};const Kd=(e,{vector:t,origin:s},n=ct,r=at,c=a)=>{const o=Yd(e,t,s,dt,c);if(o.length<2){return undefined}const i=c*2/g(t);const f=Xd(o,n,i);if(f===undefined){return undefined}const l=e=>{if(r(e)){return e}return e<.5?0:1};const d=f.map(l);if(Math.abs(d[0]-d[1])<c*2/g(t)){return undefined}const u=Zd(t,s,(d[0]+d[1])/2);return Cr(e,u,n,c)?d.map((e=>Zd(t,s,e))):undefined};const eu=(e,t,s=a)=>{const n=(e,t,n)=>(n[0]-t[0])*(e[1]-t[1])>(n[1]-t[1])*(e[0]-t[0])+s;const r=(e,t,s,n)=>{const r=O(e,t);const c=O(n,s);const o=B(e,t);const a=B(n,s);const i=1/B(r,c);return E(O(E(c,o),E(r,a)),i)};let c=e;let o=t[t.length-1];for(let e=0;e<t.length;e+=1){const s=t[e];const a=c;c=[];let i=a[a.length-1];for(let e=0;e<a.length;e+=1){const t=a[e];if(n(t,o,s)){if(!n(i,o,s)){c.push(r(o,s,t,i))}c.push(t)}else if(n(i,o,s)){c.push(r(o,s,t,i))}i=t}o=s}return c.length===0?undefined:c};const tu=Object.freeze({__proto__:null,clipLineConvexPolygon:Kd,clipLineInBoundingBox:Jd,clipPolygonPolygon:eu});const su=(e,{vector:t,origin:s},n)=>{if(e.length<2){return e}const r=e.map((e=>O(e[1],e[0]))).map((e=>C(e,t)<n));e.map(((e,t)=>t)).filter((e=>r[e])).forEach((t=>{e[t]=[e[t][1],e[t][0]]}));const c=h(t);const o=e.map((e=>e.map((e=>C(O(e,s),c))))).sort(((e,t)=>e[0]-t[0]));const a=[[o[0][0],o[0][1]]];for(let e=1;e<o.length;e+=1){const t=o[e];if(t[0]-n<a[a.length-1][1]+n){a[a.length-1][1]=Math.max(t[1],a[a.length-1][1])}else{a.push([t])}}return a.map((e=>e.map((e=>M(s,E(c,e))))))};const nu=(e,t,s,n=at,r=a)=>{const c=t.map((t=>e.faces_vertices[t].map((t=>e.vertices_coords[t])))).map((e=>Kd(e,s,ct,n,r))).filter((e=>e!==undefined));return su(c,s,r)};const ru=(e,t,s=a)=>{const n=Hc(e,t,s);return nu(e,n,t,at,s)};const cu=(e,t,s=a)=>{const n=Jc(e,t,s);return nu(e,n,t,ft,s)};const ou=(e,t,s=a)=>{const n=O(t[1],t[0]);const r=t[0];const c=Qc(e,t,s);return nu(e,c,{vector:n,origin:r},dt,s)};const au=function(e,t){const s=vo(e).vertices.map((t=>e.vertices_coords[t]));const n=t.vector?t.vector:O(t[1],t[0]);const r=t.origin?t.origin:t[0];const c=t.domain?t.domain:at;return Kd(s,{vector:n,origin:r},ct,c)};const iu=Object.freeze({__proto__:null,clip:au,clipLine:ru,clipRay:cu,clipSegment:ou});const fu=({vertices_coords:e},{vector:t,origin:s},n=a)=>{const r=v(t);const c=e=>{const t=k(e,s);const c=m(t);if(Math.abs(c)<n){return true}const o=t.map((e=>e/c));const a=Math.abs(F(o,r));return Math.abs(1-a)<n};return e.map(c).map(((e,t)=>({a:e,i:t}))).filter((e=>e.a)).map((e=>e.i))};const lu=Object.freeze({__proto__:null,getVerticesCollinearToLine:fu});const du=({vertices_coords:e,edges_vertices:t,vertices_edges:s},{vector:n,origin:r},c=a)=>{if(!s){s=mn({edges_vertices:t})}const o=fu({vertices_coords:e},{vector:n,origin:r},c);const i=t.map((()=>0));o.forEach((e=>s[e].forEach((e=>{i[e]+=1}))));return i.map(((e,t)=>({count:e,i:t}))).filter((e=>e.count===2)).map((e=>e.i))};const uu=({vertices_coords:e,edges_vertices:t},{min:s,max:n},r=a)=>{const c=Nn({vertices_coords:e,edges_vertices:t});const o=s.map((e=>e-r));const i=n.map((e=>e+r));return t.map(((e,t)=>t)).filter((e=>!(c[e][0][0]<o[0]&&c[e][1][0]<o[0]))).filter((e=>!(c[e][0][0]>i[0]&&c[e][1][0]>i[0]))).filter((e=>!(c[e][0][1]<o[1]&&c[e][1][1]<o[1]))).filter((e=>!(c[e][0][1]>i[1]&&c[e][1][1]>i[1])))};const mu=({vertices_coords:e,edges_vertices:t},s,n,r=a)=>{const c=et([s,n]);const o=O(n,s);const i={vector:o,origin:s};const f=uu({vertices_coords:e,edges_vertices:t},c,r);const l=[];f.forEach((s=>{const n=t[s].map((t=>e[t]));const c=O(n[1],n[0]);const o={vector:c,origin:n[0]};const a=Nc(i,o,dt,dt,r).point;if(!a){return}l[s]=a}));return l};const gu=({vertices_coords:e,edges_vertices:t},{vector:s,origin:n},r=a,c=dt)=>t.map((t=>{const o=t.map((t=>e[t]));const a=O(o[1],o[0]);const i={vector:a,origin:o[0]};return Nc({vector:s,origin:n},i,at,c,r).point}));const pu=Object.freeze({__proto__:null,getEdgesCollinearToLine:du,getEdgesLineIntersection:gu,getEdgesRectOverlap:uu,getEdgesSegmentIntersection:mu});const _u=(e,t,s=a)=>{if(!e.vertices_coords){e.vertices_coords=[]}if(typeof t[0]==="number"){t=[t]}const n=t.map((t=>e.vertices_coords.map((e=>I(e,t)<s)).map(((e,t)=>e?t:undefined)).filter((e=>e!==undefined)).shift()));let r=e.vertices_coords.length;const c=t.filter(((e,t)=>n[t]===undefined));e.vertices_coords.push(...c);return n.map((e=>e===undefined?r++:e))};const vu=(e,t,s)=>{const n=Array.from(Array(t.length-1)).map(((e,s)=>[t[s],t[s+1]]));const r=n.map((e=>e.join(" "))).map((e=>s[e]===undefined));const c=n.filter(((e,t)=>r[t]));const o=Array.from(Array(c.length)).map(((t,s)=>e.edges_vertices.length+s));o.forEach(((t,s)=>{e.edges_vertices[t]=c[s]}));if(e.edges_assignment){o.forEach((t=>{e.edges_assignment[t]="U"}))}if(e.edges_foldAngle){o.forEach((t=>{e.edges_foldAngle[t]=0}))}for(let s=0;s<t.length;s+=1){const n=t[s];const c=r[s-1]?t[s-1]:undefined;const o=r[s]?t[s+1]:undefined;const a=[c,o].filter((e=>e!==undefined));const i=e.vertices_vertices[n]?e.vertices_vertices[n]:[];const f=i.concat(a);e.vertices_vertices[n]=on(e,f,t[s])}const a=En(e);for(let s=0;s<t.length;s+=1){const n=t[s];e.vertices_edges[n]=e.vertices_vertices[n].map((e=>a[`${n} ${e}`]))}t.map((t=>e.vertices_vertices[t].length===1?[l]:Us(e.vertices_vertices[t].map((s=>O(e.vertices_coords[s],e.vertices_coords[t])))))).forEach(((s,n)=>{e.vertices_sectors[t[n]]=s}));return o};const hu=(e,t,s,n=a)=>{if(!e.vertices_sectors){e.vertices_sectors=wn(e)}const r=[t,s].map((e=>[e[0],e[1]]));const c=O(r[1],r[0]);const o=mu(e,r[0],r[1],n);const i=o.map(((e,t)=>t)).filter(at);const f={};i.forEach((t=>e.edges_faces[t].forEach((e=>{f[e]=true}))));const l=Object.keys(f).map((e=>parseInt(e,10))).sort(((e,t)=>e-t));const d=i.reverse().map((t=>xc(e,t,o[t],n)));const u=d.map((e=>e.vertex));const m=_u(e,r,n);const g={};u.forEach((e=>{g[e]=true}));m.forEach((e=>{g[e]=true}));const p=Object.keys(g).map((e=>parseInt(e,10)));const _=an(e,p,c);const v=En(e);const h=vu(e,_,v);h.forEach((t=>{const s=e.edges_vertices[t];v[`${s[0]} ${s[1]}`]=t;v[`${s[1]} ${s[0]}`]=t}));const b=_.map((t=>e.vertices_vertices[t].map((e=>[[e,t],[t,e]])))).reduce(((e,t)=>e.concat(t)),[]).reduce(((e,t)=>e.concat(t)),[]);const y={};const E=b.map((t=>Qs(e,t[0],t[1],y))).filter((e=>e!==undefined));const A=Ys(E);_s(e,"faces",l);const x=A.map(((t,s)=>e.faces_vertices.length+s));if(e.faces_vertices){x.forEach(((t,s)=>{e.faces_vertices[t]=A[s].vertices}))}if(e.faces_edges){x.forEach(((t,s)=>{e.faces_edges[t]=A[s].edges.map((e=>v[e]))}))}if(e.faces_angles){x.forEach(((t,s)=>{e.faces_angles[t]=A[s].faces_angles}))}if(e.vertices_faces){e.vertices_faces=yn(e)}if(e.edges_faces){e.edges_faces=On(e)}if(e.faces_faces){e.faces_faces=Rn(e)}if(e.vertices_coords.length!==e.vertices_vertices.length||e.vertices_coords.length!==e.vertices_edges.length||e.vertices_coords.length!==e.vertices_faces.length){console.warn("vertices mismatch",JSON.parse(JSON.stringify(e)))}if(e.edges_vertices.length!==e.edges_faces.length||e.edges_vertices.length!==e.edges_assignment.length){console.warn("edges mismatch",JSON.parse(JSON.stringify(e)))}if(e.faces_vertices.length!==e.faces_edges.length||e.faces_vertices.length!==e.faces_faces.length){console.warn("faces mismatch",JSON.parse(JSON.stringify(e)))}return h};const bu=({vertices_vertices:e},t)=>{const s=[t[1],t[0]];t.map(((t,n)=>e[t].indexOf(s[n]))).forEach(((s,n)=>e[t[n]].splice(s,1)))};const yu=({vertices_edges:e},t,s)=>{s.map(((s,n)=>e[s].indexOf(t))).forEach(((t,n)=>e[s[n]].splice(t,1)))};const Eu=(e,t,s,n)=>{const r=t.map((t=>e.faces_edges[t].indexOf(s)));const c=[];t.forEach(((t,s)=>e.faces_vertices[t].forEach(((e,t,r)=>{const o=r[(t+1)%r.length];if(e===n[0]&&o===n[1]||e===n[1]&&o===n[0]){c[s]=t}}))));if(c[0]===undefined||c[1]===undefined){console.warn("removePlanarEdge error joining faces")}const o=t.map((t=>e.faces_edges[t].length));const a=t.map((t=>e.faces_vertices[t].length));const i=o.map((e=>e-1));const f=a.map((e=>e-1));const l=r.map(((e,t)=>(e+1)%o[t]));const d=c.map(((e,t)=>(e+1)%a[t]));const u=t.map(((t,s)=>Array.from(Array(i[s])).map(((e,t)=>(l[s]+t)%o[s])).map((s=>e.faces_edges[t][s]))));const m=t.map(((t,s)=>Array.from(Array(f[s])).map(((e,t)=>(d[s]+t)%a[s])).map((s=>e.faces_vertices[t][s]))));const g=t.map((t=>e.faces_faces[t])).reduce(((e,t)=>e.concat(t)),[]).filter((e=>e!==t[0]&&e!==t[1]));return{vertices:m[0].concat(m[1]),edges:u[0].concat(u[1]),faces:g}};const Au=(e,t)=>{const s=[...e.edges_vertices[t]].sort(((e,t)=>t-e));const n=[...e.edges_faces[t]];bu(e,s);yu(e,t,s);const r=s.map((t=>e.vertices_vertices[t].length===0));const c=s.filter(((e,t)=>r[t]));if(n.length===2&&n[0]!==n[1]){const r=e.faces_vertices.length;const c=Eu(e,n,t,s);e.faces_vertices.push(c.vertices);e.faces_edges.push(c.edges);e.faces_faces.push(c.faces);e.vertices_faces.forEach(((t,s)=>{let c=false;t.forEach(((o,a)=>{if(o===n[0]||o===n[1]){e.vertices_faces[s][a]=r;const n=c?[s,1]:[s,1,r];t.splice(...n);c=true}}))}));e.edges_faces.forEach(((t,s)=>t.forEach(((t,c)=>{if(t===n[0]||t===n[1]){e.edges_faces[s][c]=r}}))));e.faces_faces.forEach(((t,s)=>t.forEach(((t,c)=>{if(t===n[0]||t===n[1]){e.faces_faces[s][c]=r}}))));e.faces_vertices.forEach((t=>t.forEach((t=>{if(t===undefined){console.log("FOUND ONE before remove",e.faces_vertices)}}))));_s(e,"faces",n)}if(n.length===2&&n[0]===n[1]&&c.length){const s=n[0];e.faces_vertices[s]=e.faces_vertices[s].filter((e=>!c.includes(e))).filter(((e,t,s)=>e!==s[(t+1)%s.length]));e.faces_edges[s]=e.faces_edges[s].filter((e=>e!==t))}_s(e,"edges",[t]);_s(e,"vertices",c)};const xu=(e,t)=>{const s=e.vertices_edges[t];const n=as(e.vertices_faces[t].filter((e=>e!=null)));if(s.length!==2||n.length>2){console.warn("cannot remove non 2-degree vertex yet (e,f)",s,n);return}const r=ec(e,t,s);const c=r.slice().reverse();s.sort(((e,t)=>e-t));r.forEach((t=>{const n=e.vertices_edges[t].indexOf(s[1]);if(n===-1){return}e.vertices_edges[t][n]=s[0]}));r.forEach(((s,n)=>{const r=e.vertices_vertices[s].indexOf(t);if(r===-1){console.warn("removePlanarVertex unknown vertex issue");return}e.vertices_vertices[s][r]=c[n]}));e.edges_vertices[s[0]]=[...r];n.forEach((s=>{const n=e.faces_vertices[s].indexOf(t);if(n===-1){console.warn("removePlanarVertex unknown face_vertex issue");return}e.faces_vertices[s].splice(n,1)}));n.forEach((t=>{const n=e.faces_edges[t].indexOf(s[1]);if(n===-1){console.warn("removePlanarVertex unknown face_edge issue");return}e.faces_edges[t].splice(n,1)}));_s(e,"vertices",[t]);_s(e,"edges",[s[1]])};const Mu=e=>[0,1].map((t=>e.filter(((e,s)=>s%2===t)).reduce(((e,t)=>e+t),0)));const wu=e=>{const t=e.reduce(((e,t)=>e+t),0)/2;return Mu(e).map((e=>e-t))};const ku=e=>e.map(((e,t,s)=>[e,s[(t+1)%s.length]])).map((e=>Cs(...e))).map(((e,t,s)=>s.slice(t+1,s.length).concat(s.slice(0,t)))).map((e=>Mu(e).map((e=>Math.PI-e)))).map(((t,s)=>e[s]+t[0])).map(((t,s)=>js(t,e[s],e[(s+1)%e.length])?t:undefined));const Ou=e=>{const t=e.map((e=>Math.atan2(e[1],e[0])));return ku(t).map((e=>e===undefined?undefined:[Math.cos(e),Math.sin(e)]))};const ju=({vertices_coords:e,vertices_edges:t,edges_assignment:s,edges_vertices:n},r)=>{if(!t){t=mn({edges_vertices:n})}const c=s?t[r].filter((e=>Mt[s[e]])):t[r];if(c.length%2===0){return[]}const o=c.map((e=>n[e][0]===r?n[e]:[n[e][1],n[e][0]]));const a=o.map((t=>t.map((t=>e[t]))));const i=a.map((e=>O(e[1],e[0])));const f=Is(i).map((e=>i[e]));const l=Ou(f);const d=f.map(h);const u=l.filter((e=>e!==undefined)).filter((e=>!d.map((t=>C(e,t))).map((e=>Math.abs(1-e)<.001)).reduce(((e,t)=>e||t),false)));return u};const Fu=Object.freeze({__proto__:null,alternatingSum:Mu,alternatingSumDifference:wu,kawasakiSolutions:ju,kawasakiSolutionsRadians:ku,kawasakiSolutionsVectors:Ou});const Cu=({vertices_edges:e,edges_assignment:t})=>e.map((e=>e.map((e=>!Mt[t[e]])).reduce(((e,t)=>e&&t),true))).map(((e,t)=>e?t:undefined)).filter((e=>e!==undefined));const Su=({edges_vertices:e,vertices_edges:t,edges_assignment:s})=>{if(!t){t=mn({edges_vertices:e})}const n=t.map((e=>e.map((e=>xt[s[e]])).filter((e=>e!==0)).map(Math.sign).reduce(((e,t)=>e+t),0))).map((e=>e===2||e===-2));po({edges_vertices:e,edges_assignment:s}).forEach((e=>{n[e]=true}));Cu({vertices_edges:t,edges_assignment:s}).forEach((e=>{n[e]=true}));return n.map(((e,t)=>!e?t:undefined)).filter((e=>e!==undefined))};const Pu=({vertices_coords:e,vertices_vertices:t,vertices_edges:s,edges_vertices:n,edges_assignment:r},c=a)=>{if(!t){t=vn({vertices_coords:e,vertices_edges:s,edges_vertices:n})}if(!s){s=mn({edges_vertices:n})}const o=Mn({vertices_coords:e,vertices_vertices:t,edges_vertices:n}).map(((e,t)=>e.filter(((e,n)=>Mt[r[s[t][n]]])))).map((e=>e.length>1?Us(e):[0,0])).map((e=>Mu(e))).map((e=>Math.abs(e[0]-e[1])<c));po({edges_vertices:n,edges_assignment:r}).forEach((e=>{o[e]=true}));Cu({vertices_edges:s,edges_assignment:r}).forEach((e=>{o[e]=true}));return o.map(((e,t)=>!e?t:undefined)).filter((e=>e!==undefined))};const Vu=Object.freeze({__proto__:null,validateKawasaki:Pu,validateMaekawa:Su});const Nu={};Nu.prototype=Object.create(Hd);Nu.prototype.constructor=Nu;const zu=function(e){e.valley=t=>this.setValley(e,t);e.mountain=t=>this.setMountain(e,t);e.flat=()=>this.setFlat(e);e.unassigned=()=>this.setUnassigned(e);e.cut=()=>this.setCut(e);return e};const Tu=(e,t)=>{const s=au(e,t);if(!s){return undefined}const n=hu(e,s[0],s[1]);return zu.call(e,n)};Nu.prototype.line=function(...e){const t=Ie(...e);if(!t){return undefined}t.domain=at;return Tu(this,t)};Nu.prototype.ray=function(...e){const t=Ie(...e);if(!t){return undefined}t.domain=ft;return Tu(this,t)};Nu.prototype.segment=function(...e){const t=Ms(...Be(...e));if(!t){return undefined}t.domain=dt;return Tu(this,t)};Nu.prototype.polygon=function(...e){const t=$e(...e);if(!t){return undefined}const s=t.map(((e,t,s)=>[e,s[(t+1)%s.length]])).map((e=>Ms(...e))).map((e=>({...e,domain:dt}))).map((e=>au(this,e))).filter((e=>e!==undefined));if(!s){return undefined}const n=s.flatMap((e=>hu(this,e[0],e[1])));return zu.call(this,n)};Nu.prototype.removeEdge=function(e){const t=this.edges_vertices[e];Au(this,e);t.map((e=>sc(this,e))).map(((e,s)=>e?t[s]:undefined)).filter((e=>e!==undefined)).sort(((e,t)=>t-e)).forEach((e=>xu(this,e)));return true};Nu.prototype.validate=function(e){const t=oo(this,e);t.vertices.kawasaki=Pu(this,e);t.vertices.maekawa=Su(this);if(this.edges_foldAngle){t.edges.not_flat=this.edges_foldAngle.map(((e,t)=>jt(e)?undefined:t)).filter((e=>e!==undefined))}if(t.summary==="valid"){if(t.vertices.kawasaki.length||t.vertices.maekawa.length){t.summary="invalid"}else if(t.edges.not_flat.length){t.summary="not flat"}}return t};Nu.prototype.defer=false;const $u=Nu.prototype;const Bu=(e,t)=>{const s=[];const n=e.map(((e,t)=>t));const r=n.filter((e=>t[e]));const c=n.filter((e=>!t[e]));c.sort(((t,s)=>e[t]-e[s])).forEach(((e,t)=>{s[e]=t}));r.sort(((t,s)=>e[s]-e[t])).forEach(((e,t)=>{s[e]=c.length+t}));return s};const Lu=(e,t,s,n=a)=>{const r=$r(e,t);if(r.length===0){return undefined}if(r.length===1){return r[0]}return r[0]};const Iu=(e,t,s,n)=>{const r=O(s,t);const c=B(e,r);return n?c>0:c<0};const Ru=(e,t)=>!e.faces_vertices[t]?[0,0]:e.faces_vertices[t].map((t=>e.vertices_coords[t])).reduce(((e,t)=>[e[0]+t[0],e[1]+t[1]]),[0,0]).map((s=>s/e.faces_vertices[t].length));const Uu={F:true,f:true,U:true,u:true};const qu={M:"V",m:"V",V:"M",v:"M"};const Du=e=>qu[e]||e;const Wu=(e,t)=>({center:e.faces_center[t],matrix:e.faces_matrix2[t],winding:e.faces_winding[t],crease:e.faces_crease[t],side:e.faces_side[t],layer:e.faces_layer[t]});const Gu=(e,{vector:t,origin:s},n="V",r=a)=>{const c=Du(n);mc(e);if(!e.faces_layer){e.faces_layer=Array(e.faces_vertices.length).fill(0)}e.faces_center=e.faces_vertices.map(((t,s)=>Ru(e,s)));if(!e.faces_matrix2){e.faces_matrix2=Fo(e,Lu(e,s,t,r))}e.faces_winding=cd(e.faces_matrix2);e.faces_crease=e.faces_matrix2.map(ie).map((e=>ce(e,t,s)));e.faces_side=e.faces_vertices.map(((t,s)=>Iu(e.faces_crease[s].vector,e.faces_crease[s].origin,e.faces_center[s],e.faces_winding[s])));const o=ko(e,e.faces_matrix2);const i=du({vertices_coords:o,edges_vertices:e.edges_vertices},{vector:t,origin:s},r).filter((t=>Uu[e.edges_assignment[t]]));i.map((t=>e.edges_faces[t].find((e=>e!=null)))).map((t=>e.faces_winding[t])).map((e=>e?n:c)).forEach(((t,s)=>{e.edges_assignment[i[s]]=t;e.edges_foldAngle[i[s]]=kt(t)}));const f=Wu(e,0);const l=e.faces_vertices.map(((e,t)=>t)).reverse().map((t=>{const s=Wu(e,t);const o=Xc(e,t,s.crease,r);if(o===undefined){return undefined}e.edges_assignment[o.edges.new]=s.winding?n:c;e.edges_foldAngle[o.edges.new]=kt(e.edges_assignment[o.edges.new]);const a=o.faces.map[o.faces.remove];a.forEach((t=>{e.faces_center[t]=Ru(e,t);e.faces_side[t]=Iu(s.crease.vector,s.crease.origin,e.faces_center[t],s.winding);e.faces_layer[t]=s.layer}));return o})).filter((e=>e!==undefined));const d=tr(...l.map((e=>e.faces.map)));const u=tr(...l.map((e=>e.edges.map)).filter((e=>e!==undefined)));const m=l.map((e=>e.faces.remove)).reverse();e.faces_layer=Bu(e.faces_layer,e.faces_side);const g=d&&d[0]&&d[0].length===2;const p=g?d[0].filter((t=>e.faces_side[t])).shift():0;let _=f.matrix;if(n!==c){_=!g&&!e.faces_side[0]?f.matrix:oe(f.matrix,me(f.crease.vector,f.crease.origin))}e.faces_matrix2=Fo(e,p).map((e=>oe(_,e)));delete e.faces_center;delete e.faces_winding;delete e.faces_crease;delete e.faces_side;return{faces:{map:d,remove:m},edges:{map:u}}};const Hu={};Hu.prototype=Object.create(Hd);Hu.prototype.constructor=Hu;Hu.prototype.flatFold=function(){Gu(this,Ie(arguments));return this};const Ju=Hu.prototype;const Qu=1.1;const Zu="Rabbit Ear";const Yu=(e,t)=>[[0,0],[e,0],[e,t],[0,t]];const Xu=e=>mc({vertices_coords:e,edges_vertices:e.map(((e,t,s)=>[t,(t+1)%s.length])),edges_assignment:Array(e.length).fill("B")});const Ku=(e=1)=>Xu(Yu(e,e));const em=(e=1,t=1)=>Xu(Yu(e,t));const tm=(e=3,t=1)=>Xu(De(e,t));const sm=()=>mc({vertices_coords:[[0,0],[1,0],[1,Math.SQRT2-1],[1,1],[Math.SQRT2-1,1],[0,1]],edges_vertices:[[0,1],[1,2],[2,3],[3,4],[4,5],[5,0],[0,2],[0,4],[0,3]],edges_assignment:Array.from("BBBBBBVVF")});const nm=()=>mc({vertices_coords:[[0,0],[Math.SQRT1_2,0],[1,0],[1,1-Math.SQRT1_2],[1,1],[1-Math.SQRT1_2,1],[0,1],[0,Math.SQRT1_2],[.5,.5],[Math.SQRT1_2,1-Math.SQRT1_2],[1-Math.SQRT1_2,Math.SQRT1_2]],edges_vertices:[[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,0],[9,0],[9,2],[9,4],[10,0],[10,6],[10,4],[9,1],[10,7],[9,3],[10,5],[8,0],[8,9],[8,4],[8,10]],edges_assignment:Array.from("BBBBBBBBVVVVVVMMFFFFFF")});const rm=()=>mc({vertices_coords:[[0,0],[.5,0],[1,0],[1,.5],[1,1],[.5,1],[0,1],[0,.5],[.5,.5],[.5,(Math.sqrt(2)-1)/2],[(3-Math.sqrt(2))/2,.5],[.5,(3-Math.sqrt(2))/2],[(Math.sqrt(2)-1)/2,.5]],edges_vertices:[[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,0],[0,8],[2,8],[4,8],[6,8],[1,9],[9,8],[3,10],[10,8],[5,11],[11,8],[7,12],[12,8],[0,9],[9,2],[2,10],[10,4],[4,11],[11,6],[6,12],[12,0]],edges_assignment:Array.from("BBBBBBBBFMFMMVMVMVMVVVVVVVVV")});const cm=()=>mc({vertices_coords:[[0,0],[1-(Math.SQRT2-1),0],[1,0],[0,1],[0,1-(Math.SQRT2-1)],[.5,.5],[Math.SQRT1_2,Math.SQRT1_2],[1,1],[Math.SQRT1_2,1-Math.SQRT1_2],[1,Math.sqrt(2)-1],[1-Math.SQRT1_2,Math.SQRT1_2],[Math.sqrt(2)-1,1],[Math.SQRT1_2,1],[1,Math.SQRT1_2]],edges_vertices:[[0,1],[1,2],[3,4],[4,0],[0,5],[5,6],[6,7],[0,8],[8,9],[0,10],[10,11],[8,1],[10,4],[8,6],[6,12],[3,10],[10,5],[5,8],[8,2],[10,6],[6,13],[7,12],[12,11],[11,3],[11,6],[6,9],[2,9],[9,13],[13,7]],edges_assignment:Array.from("BBBBFFFVFVFMMVVVFFVVVBBBMMBBB")});const om=Object.freeze({__proto__:null,base1:cm,bird:rm,fish:nm,kite:sm,polygon:tm,rectangle:em,square:Ku});const am=(...e)=>mc(Object.assign(Object.create(Hd),{...e.reduce(((e,t)=>({...e,...t})),{}),file_spec:Qu,file_creator:Zu}));const im=(...e)=>mc(Object.assign(Object.create($u),{...e.length?e.reduce(((e,t)=>({...e,...t})),{}):Ku(),file_spec:Qu,file_creator:Zu,frame_classes:["creasePattern"]}));const fm=(...e)=>mc(Object.assign(Object.create(Ju),{...e.length?e.reduce(((e,t)=>({...e,...t})),{}):Ku(),file_spec:Qu,file_creator:Zu,frame_classes:["foldedForm"]}));am.prototype=Hd;am.prototype.constructor=am;im.prototype=$u;im.prototype.constructor=im;fm.prototype=Ju;fm.prototype.constructor=fm;Object.keys(om).forEach((e=>{am[e]=(...t)=>am(om[e](...t));im[e]=(...t)=>im(om[e](...t));fm[e]=(...t)=>fm(om[e](...t))}));const lm=(e,t)=>{const s=B(e.normal,t.normal);if(Math.abs(s)<a){return undefined}const n=e.distance*t.normal[1]-t.distance*e.normal[1];const r=t.distance*e.normal[0]-e.distance*t.normal[0];return[n/s,r/s]};const dm=(e,t)=>{const s=h(D(O(t,e)));return[{normal:s,distance:C(M(e,t),s)/2}]};const um=(e,t)=>{const s=h(O(t,e));return[{normal:s,distance:C(M(e,t),s)/2}]};const mm=(e,t)=>{const s=lm(e,t);return s===undefined?[{normal:e.normal,distance:(e.distance+t.distance*C(e.normal,t.normal))/2}]:[M,O].map((s=>h(s(e.normal,t.normal)))).map((e=>({normal:e,distance:C(s,e)})))};const gm=(e,t)=>{const s=D(e.normal);const n=C(t,s);return[{normal:s,distance:n}]};const pm=(e,t,s)=>{const n=C(t,e.normal);const r=e.distance-n;const c=R(t,s);if(r>c){return[]}const o=Math.sqrt(c*c-r*r);const i=E(e.normal,r);const f=M(t,i);const l=E(D(e.normal),o);const d=o<a?[f]:[M(f,l),O(f,l)];return d.map((e=>h(O(s,e)))).map((e=>({normal:e,distance:C(t,e)})))};const _m=e=>e<0?-((-e)**(1/3)):e**(1/3);const vm=(e,t,s,n,r)=>{switch(e){case 1:return[-r/n];case 2:{const e=n**2-4*s*r;if(e<-a){return[]}const t=-n/(2*s);if(e<a){return[t]}const c=Math.sqrt(e)/(2*s);return[t+c,t-c]}case 3:{const e=s/t;const c=n/t;const o=r/t;const i=(3*c-e**2)/9;const f=(9*e*c-27*o-2*e**3)/54;const l=i**3+f**2;const d=-e/3;if(l>0){const e=Math.sqrt(l);const t=_m(f+e);const s=_m(f-e);return[d+t+s]}if(Math.abs(l)<a){const e=f**(1/3);if(f<0){return[]}return[d+2*e,d-e]}const u=Math.sqrt(-l);const m=Math.atan2(u,f)/3;const g=(f**2-l)**(1/6);const p=g*Math.cos(m);const _=g*Math.sin(m);return[d+2*p,d-p-Math.sqrt(3)*_,d-p+Math.sqrt(3)*_]}default:return[]}};const hm=(e,t,s,n)=>{if(Math.abs(1-C(e.normal,s)/e.distance)<.02){return[]}const r=D(e.normal);const c=O(M(s,E(e.normal,e.distance)),E(n,2));const o=O(E(e.normal,e.distance),s);const i=C(n,t.normal)-t.distance;const f=2*C(o,r);const l=C(o,o);const d=C(M(c,o),r);const u=C(c,o);const m=C(r,t.normal);const g=C(o,t.normal);const p=m;const _=i+d*m+g;const v=i*f+u*m+d*g;const b=i*l+u*g;let y=0;if(Math.abs(v)>a){y=1}if(Math.abs(_)>a){y=2}if(Math.abs(p)>a){y=3}return vm(y,p,_,v,b).map((t=>M(E(e.normal,e.distance),E(r,t)))).map((e=>({p:e,normal:h(O(e,s))}))).map((e=>({normal:e.normal,distance:C(e.normal,V(e.p,s))})))};const bm=(e,t,s)=>{const n=D(e.normal);const r=C(n,t.normal);if(Math.abs(r)<a){return undefined}const c=C(s,n);const o=C(s,t.normal);const i=(t.distance+2*c*r-o)/(2*r);return[{normal:n,distance:i}]};const ym=(e,...t)=>[null,dm,um,mm,gm,pm,hm,bm][e](...t);const Em=Object.freeze({__proto__:null,normalAxiom:ym,normalAxiom1:dm,normalAxiom2:um,normalAxiom3:mm,normalAxiom4:gm,normalAxiom5:pm,normalAxiom6:hm,normalAxiom7:bm});const Am=(e,t)=>[{vector:h(O(...Y(t,e))),origin:e}];const xm=(e,t)=>[{vector:h(D(O(...Y(t,e)))),origin:V(e,t)}];const Mm=(e,t)=>br(e,t);const wm=(e,t)=>[{vector:D(h(e.vector)),origin:t}];const km=(e,t,s)=>(zc({radius:R(t,s),origin:t},e)||[]).map((e=>({vector:h(D(O(...Y(e,s)))),origin:V(s,e)})));const Om=(e,t,s,n)=>hm(ws(e),ws(t),s,n).map(ks);const jm=(e,t,s)=>{const n=Nc(e,{vector:t.vector,origin:s},at,at).point;return n===undefined?[]:[{vector:h(D(O(...Y(n,s)))),origin:V(s,n)}]};const Fm=(e,...t)=>[null,Am,xm,Mm,wm,km,Om,jm][e](...t);const Cm=Object.freeze({__proto__:null,axiom:Fm,axiom1:Am,axiom2:xm,axiom3:Mm,axiom4:wm,axiom5:km,axiom6:Om,axiom7:jm});const Sm=(e,t)=>{const s=me(e.vector,e.origin);return re(s,t)};const Pm=(e,t,s,n)=>[[s,n].map((t=>Cr(e,t,ct))).reduce(((e,t)=>e&&t),true)];const Vm=Pm;const Nm=(e,t,s,n)=>{const r=[s,n].map((t=>Kd(e,t,ct,at)));if(r[0]===undefined||r[1]===undefined){return[false,false]}const c=t.map((t=>t===undefined?undefined:Kd(e,t,ct,at)));const o=[0,1].map((e=>c[e]!==undefined));const a=t.map((e=>e===undefined?undefined:[Sm(e,r[0][0]),Sm(e,r[0][1])]));const i=a.map((e=>e===undefined?false:Or({vector:k(r[1][1],r[1][0]),origin:r[1][0]},e[0],dt)||Or({vector:k(r[1][1],r[1][0]),origin:r[1][0]},e[1],dt)||Or({vector:k(e[1],e[0]),origin:e[0]},r[1][0],dt)||Or({vector:k(e[1],e[0]),origin:e[0]},r[1][1],dt)));return[0,1].map((e=>i[e]===true&&o[e]===true))};const zm=(e,t,s,n)=>{const r=Nc(s,{vector:D(s.vector),origin:n},at,at).point;return[[n,r].filter((e=>e!==undefined)).map((t=>Cr(e,t,ct))).reduce(((e,t)=>e&&t),true)]};const Tm=(e,t,s,n,r)=>{if(t.length===0){return[]}const c=[n,r].map((t=>Cr(e,t,ct))).reduce(((e,t)=>e&&t),true);const o=t.map((e=>Sm(e,r))).map((t=>Cr(e,t,ct)));return o.map((e=>e&&c))};const $m=function(e,t,s,n,r,c){if(t.length===0){return[]}const o=[r,c].map((t=>Cr(e,t,ct))).reduce(((e,t)=>e&&t),true);if(!o){return t.map((()=>false))}const a=t.map((e=>Sm(e,r))).map((t=>Cr(e,t,ct)));const i=t.map((e=>Sm(e,c))).map((t=>Cr(e,t,ct)));return t.map(((e,t)=>a[t]&&i[t]))};const Bm=(e,t,s,n,r)=>{const c=Cr(e,r,ct);if(!t.length){return[false]}const o=Sm(t[0],r);const a=Cr(e,o,ct);const i=Rc(e,n,dt,at)!==undefined;const f=Nc(n,t[0],at,at).point;const l=f?Cr(e,f,ct):false;return[c&&a&&i&&l]};const Lm=(e,t,s,...n)=>[null,Pm,Vm,Nm,zm,Tm,$m,Bm][e](t,s,...n);const Im=Object.freeze({__proto__:null,validateAxiom:Lm,validateAxiom1:Pm,validateAxiom2:Vm,validateAxiom3:Nm,validateAxiom4:zm,validateAxiom5:Tm,validateAxiom6:$m,validateAxiom7:Bm});const Rm=e=>e.map((e=>typeof e==="object"&&e.vector?ks(e):e));const Um=(e,t,...s)=>{const n=Fm(e,...s);Lm(e,t,n,...s).map(((e,t)=>!e?t:undefined)).filter((e=>e!==undefined)).forEach((e=>delete n[e]));return n};const qm=(e,t,...s)=>{const n=ym(e,...s).map(ks);Lm(e,t,n,...Rm(s)).map(((e,t)=>!e?t:undefined)).filter((e=>e!==undefined)).forEach((e=>delete n[e]));return n};const Dm=Object.freeze({__proto__:null,axiomWithBoundary:Um,normalAxiomWithBoundary:qm});const Wm={...Cm,...Em,...Dm,...Im};const Gm=()=>{const e={};e.file_spec=Qu;e.file_creator=Zu;e.file_classes=["singleModel"];e.frame_classes=[];e.frame_attributes=[];e.vertices_coords=[];e.faces_vertices=[];return e};const Hm=e=>{if(!e.edges_foldAngle||!e.edges_foldAngle.length){return}let t=true;for(let s=0;s<e.edges_foldAngle.length;s+=1){if(e.edges_foldAngle[s]!==0&&e.edges_foldAngle[s]!==-180&&e.edges_foldAngle[s]!==180){t=false;break}}e.frame_classes.push(t?"creasePattern":"foldedForm");e.frame_attributes.push(t?"2D":"3D")};const Jm=e=>e.map(((e,t,s)=>[e,s[(t+1)%s.length]]));const Qm=({faces_vertices:e})=>{const t={};const s=[];e.flatMap(Jm).forEach((e=>{const n=[e.join(" "),`${e[1]} ${e[0]}`];if(n[0]in t||n[1]in t){return}s.push(e);t[n[0]]=true}));return s};const Zm=e=>e.slice(1).map((e=>parseInt(e,10)-1));const Ym=e=>e.slice(1).map((e=>parseFloat(e)));const Xm=e=>{const t=e.split("\n").map((e=>e.trim().split(/\s+/)));const s=Gm();for(let e=0;e<t.length;e+=1){switch(t[e][0].toLowerCase()){case"f":s.faces_vertices.push(Zm(t[e]));break;case"v":s.vertices_coords.push(Ym(t[e]));break}}s.faces_normal=ln(s);s.faces_center=Wn(s);s.edges_vertices=Qm(s);s.faces_edges=In(s);s.edges_faces=On(s);s.edges_foldAngle=Vn(s);s.edges_assignment=Sn(s);s.vertices_vertices=_n(s);delete s.faces_normal;delete s.faces_center;delete s.edges_faces;Hm(s);return s};const Km=(e,t)=>{const s=lc(e,t);s.vertices_vertices=vn(s);const n=Bn(s);s.faces_vertices=n.faces_vertices;s.faces_edges=n.faces_edges;delete s.vertices_edges;return s};const eg=({vertices_coords:e,edges_vertices:t})=>{const s=t.map((t=>t.map((t=>e[t])))).map((e=>I(...e))).filter((e=>e>1e-4));const n=s.reduce(((e,t)=>Math.min(e,t)),Infinity);return n===Infinity?undefined:n};const tg=({vertices_coords:e,edges_vertices:t})=>{const s=eg({vertices_coords:e,edges_vertices:t});const n=go({vertices_coords:e});const r=n&&n.span?Math.max(...n.span):1;const c=r*.01;const o=s/20;return s===undefined?c:Math.min(c,o)};const sg=(e,t,s="epsilon")=>{if(typeof t==="object"&&typeof t[s]==="number"){return t[s]}return typeof t==="number"?t:tg(e)};const ng=(e,t)=>e==null?null:Array.from(e.childNodes).filter((e=>e.attributes&&e.attributes.length)).filter((e=>Array.from(e.attributes).filter((e=>e.nodeValue===t)).shift()!==undefined)).shift();const rg=(e,t)=>{const s=ng(e,t);const n=s?Array.from(s.childNodes).shift():null;return n?n.textContent:undefined};const cg=e=>{const t=ng(e,"lines");const s=t?Array.from(t.childNodes).filter((e=>e.getAttribute)).filter((e=>e.getAttribute("class").split(" ").includes("oripa.OriLineProxy"))).shift():undefined;return s?Array.from(s.childNodes):[]};const og=e=>e.filter((e=>e.nodeName==="void")).filter((e=>e.childNodes)).map((e=>ng(e,"oripa.OriLineProxy"))).filter((e=>e)).map((e=>["type","x0","x1","y0","y1"].map((t=>ng(e,t))).map((e=>e?Array.from(e.childNodes):[])).map((e=>e.filter((e=>e.nodeName==="double"||e.nodeName==="int")).shift())).map((e=>e&&e.childNodes[0]?e.childNodes[0].data:"0")).map(parseFloat)));const ag=["F","B","M","V","U"];const ig=e=>{const t={};t.vertices_coords=e.flatMap((e=>[[e[1],e[3]],[e[2],e[4]]]));t.edges_vertices=e.map(((e,t)=>[t*2,t*2+1]));t.edges_assignment=e.map((e=>ag[e[0]]));t.edges_foldAngle=Pn(t);return t};const fg=e=>{const t=Ja(e,"text/xml");const s=Array.from(t.childNodes).filter((e=>e.getAttribute)).filter((e=>e.getAttribute("class").split(" ").includes("oripa.DataSet"))).shift();return ig(og(cg(s)))};const lg=(e,t)=>{const s={file_description:"memo",file_author:"originalAuthorName",file_title:"title"};Object.keys(s).forEach((t=>{s[t]=rg(e,s[t])}));Object.keys(s).filter((e=>s[e])).forEach((e=>{t[e]=s[e]}));t.file_classes=["singleModel"];t.frame_classes=["creasePattern"]};const dg=(e,t)=>{const s=Ja(e,"text/xml");const n=s&&s.childNodes?Array.from(s.childNodes):[];const r=n.filter((e=>e.getAttribute)).filter((e=>e.getAttribute("class").split(" ").includes("oripa.DataSet"))).shift();const c=ig(og(cg(r)));const o=sg(c,t);const a=Km(c,o);lg(r,a);return a};Object.assign(dg,{opxEdgeGraph:fg});const ug=function(e){const t=`${e}`.match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);return Math.max(0,(t[1]?t[1].length:0)-(t[2]?+t[2]:0))};const mg=function(e,t=15){const s=typeof e==="number"?e:parseFloat(e);if(Number.isNaN(s)){return e}const n=parseFloat(s.toFixed(t));if(ug(n)===Math.min(t,ug(s))){return s}return n};const gg=Object.freeze({__proto__:null,cleanNumber:mg});const pg=(e,t)=>{const s=ka(e).toUpperCase();return t&&t[s]?t[s]:Il(...wa(e))};const _g=(e,t)=>{switch(t){case"M":case"m":return-180*e;case"V":case"v":return 180*e;default:return 0}};const vg=(e,t)=>{const s=o().getComputedStyle!=null?o().getComputedStyle(e).stroke:"";if(s!==""&&s!=="none"){return s}if(t.stroke!==undefined){return t.stroke}return undefined};const hg=(e,t)=>{const s=o().getComputedStyle!=null?o().getComputedStyle(e).opacity:"";if(s!==""){const e=parseFloat(s);if(!Number.isNaN(e)){return e}}if(t.opacity!==undefined){const e=parseFloat(t.opacity);if(!Number.isNaN(e)){return e}}return undefined};const bg=Object.freeze({__proto__:null,colorToAssignment:pg,getEdgeOpacity:hg,getEdgeStroke:vg,opacityToFoldAngle:_g});const yg=(e,t)=>t.map((t=>e.getAttribute(t))).map((e=>e==null?0:e)).map(parseFloat);const Eg=e=>[yg(e,["x1","y1","x2","y2"])];const Ag=function(e){const[t,s,n,r]=yg(e,["x","y","width","height"]);return[[t,s,t+n,s],[t+n,s,t+n,s+r],[t+n,s+r,t,s+r],[t,s+r,t,s]]};const xg=e=>{const t=e.split(/[\s,]+/).map(parseFloat);return Array.from(Array(Math.floor(t.length/2))).map(((e,s)=>[t[s*2+0],t[s*2+1]]))};const Mg=e=>xg(e.getAttribute("points")||"").map(((e,t,s)=>[s[t][0],s[t][1],s[(t+1)%s.length][0],s[(t+1)%s.length][1]]));const wg=function(e){const t=Mg(e);t.pop();return t};const kg={L:true,V:true,H:true,Z:true};const Og=e=>mi(e.getAttribute("d")||"").filter((e=>kg[e.command.toUpperCase()])).map((e=>[e.start,e.end])).filter((e=>!rt(...e))).map((e=>e.flat()));const jg={line:Eg,rect:Ag,polygon:Mg,polyline:wg,path:Og};const Fg=(e,t)=>{const s=[[e[0],e[1]],[e[2],e[3]]];if(!t){return s}const n=Ga(t);return n?s.map((e=>re(n,e))):s};const Cg=e=>ri(e).filter((e=>jg[e.element.nodeName])).flatMap((e=>jg[e.element.nodeName](e.element).map((t=>Fg(t,e.attributes.transform))).map((t=>({...e,segment:t})))));const Sg=e=>{if(!o().document.body){return undefined}const t=o().document.createElement("div");t.setAttribute("display","none");o().document.body.appendChild(t);t.appendChild(e);return t};const Pg=e=>Ka(e).map((e=>e.nodeName==="style")).reduce(((e,t)=>e||t),false);const Vg=e=>{const n=typeof e==="string"?Ja(e,"image/svg+xml"):e;if(Pg(n)&&t){console.warn(s.backendStylesheet)}const r=Qa(n)===o().document?undefined:Sg(n);const c=Cg(n);c.map((e=>({data:{assignment:e.attributes["data-assignment"],foldAngle:e.attributes["data-foldAngle"]},stroke:vg(e.element,e.attributes),opacity:hg(e.element,e.attributes)}))).forEach(((e,t)=>{c[t]={...c[t],...e}}));if(r&&r.parentNode){r.parentNode.removeChild(r)}return c};const Ng=e=>{if(!e||!e.assignments){return undefined}const t={};Object.keys(e.assignments).forEach((s=>{const n=ka(s).toUpperCase();t[n]=e.assignments[s]}));return t};const zg=(e,t="#f0f",s=undefined)=>{if(e){return e}return pg(t,s)};const Tg=(e,t=1,s=undefined)=>{if(e){return parseFloat(e)}return _g(t,s)};const $g=(e,t)=>{const s=Ng(t);if(s){e.forEach((e=>{delete e.data.assignment;delete e.data.foldAngle}))}const n=e.map((e=>zg(e.data.assignment,e.stroke,s)));const r=e.map(((e,t)=>Tg(e.data.foldAngle,e.opacity,n[t])));return{edges_assignment:n,edges_foldAngle:r}};const Bg=(e,t)=>{const s=Vg(e);const{edges_assignment:n,edges_foldAngle:r}=$g(s,t);const c=t&&t.fast?e=>e:mg;const o=s.flatMap((e=>e.segment)).map((e=>e.map((e=>c(e,12)))));const a=s.map(((e,t)=>[t*2,t*2+1]));return{vertices_coords:o,edges_vertices:a,edges_assignment:n,edges_foldAngle:r}};const Lg=(e,t)=>{const s=Bg(e,t);const n=sg(s,t);const r=Km(s,n);const c=t&&t.fast?e=>e:mg;r.vertices_coords=r.vertices_coords.map((e=>e.map((e=>c(e,12)))));if(typeof t!=="object"||t.boundary!==false){r.edges_assignment.map(((e,t)=>t)).filter((e=>r.edges_assignment[e]==="B"||r.edges_assignment[e]==="b")).forEach((e=>{r.edges_assignment[e]="F"}));const{edges:e}=ho(r);e.forEach((e=>{r.edges_assignment[e]="B"}))}return{file_spec:1.1,file_creator:"Rabbit Ear",frame_classes:["creasePattern"],...r}};Object.assign(Lg,{...bg,svgSegments:Vg,svgEdgeGraph:Bg,planarizeGraph:Km,makeEpsilon:tg});const Ig={objToFold:Xm,opxToFold:dg,svgToFold:Lg,foldToSvg:Ud,foldToObj:Dd};const Rg=e=>e.replace(/([-_][a-z])/gi,(e=>e.toUpperCase().replace("-","").replace("_","")));const Ug=e=>e.replace(/([a-z0-9])([A-Z])/g,"$1-$2").replace(/([A-Z])([A-Z])(?=[a-z])/g,"$1-$2").toLowerCase();const qg=e=>e.charAt(0).toUpperCase()+e.slice(1);const Dg=Object.freeze({__proto__:null,capitalized:qg,toCamel:Rg,toKebab:Ug});const Wg={...ds,...Gr,...Re,...gg,...cn,...Dg};const Gg=e=>!e.file_frames?1:e.file_frames.length+1;const Hg=(e,t=1)=>{if(!e.file_frames||e.file_frames.length<t){return e}const n=["frame_parent","frame_inherit"];const r={visited_frames:[]};const c={};St(e,"file").filter((e=>e!=="file_frames")).forEach((t=>{c[t]=e[t]}));const o=(e,t,n)=>{if(r.visited_frames.indexOf(t)!==-1){throw new Error(s.graphCycle)}r.visited_frames.push(t);n=[t].concat(n);if(t===0){return n}if(e.file_frames[t-1].frame_inherit&&e.file_frames[t-1].frame_parent!=null){return o(e,e.file_frames[t-1].frame_parent,n)}return n};return o(e,t,[]).map((t=>{if(t===0){const t=e.file_frames;e.file_frames=null;const s=zo(e);e.file_frames=t;delete s.file_frames;n.forEach((e=>delete s[e]));return s}const s=zo(e.file_frames[t-1]);n.forEach((e=>delete s[e]));return s})).reduce(((e,t)=>Object.assign(e,t)),c)};const Jg=e=>{const t={...e};delete t.file_frames;return t};const Qg=e=>{if(!e){return[]}if(!e.file_frames||!e.file_frames.length){return[e]}return[Jg(e),...e.file_frames]};const Zg=(e,t)=>Array.from(Array(Gg(e))).map(((t,s)=>Hg(e,s))).filter((e=>e.frame_classes&&e.frame_classes.includes(t)));const Yg=Object.freeze({__proto__:null,countFrames:Gg,flattenFrame:Hg,getFramesAsFlatArray:Qg,getFramesByClassName:Zg});const Xg=({vertices_coords:e,edges_vertices:t},s)=>Ms(...t[s].map((t=>e[t])));const Kg=({vertices_coords:e},t,s)=>Am(e[t],e[s]);const ep=({vertices_coords:e},t,s)=>xm(e[t],e[s]);const tp=({vertices_coords:e,edges_vertices:t},s,n)=>Mm(...[s,n].map((s=>Xg({vertices_coords:e,edges_vertices:t},s))));const sp=({vertices_coords:e,edges_vertices:t},s,n)=>wm(Xg({vertices_coords:e,edges_vertices:t},s),e[n]);const np=({vertices_coords:e,edges_vertices:t},s,n,r)=>km(Xg({vertices_coords:e,edges_vertices:t},s),e[n],e[r]);const rp=({vertices_coords:e,edges_vertices:t},s,n,r,c)=>Om(Xg({vertices_coords:e,edges_vertices:t},s),Xg({vertices_coords:e,edges_vertices:t},n),e[r],e[c]);const cp=({vertices_coords:e,edges_vertices:t},s,n,r)=>jm(Xg({vertices_coords:e,edges_vertices:t},s),Xg({vertices_coords:e,edges_vertices:t},n),e[r]);const op=(e,...t)=>[null,Kg,ep,tp,sp,np,rp,cp][e](...t);const ap=Object.freeze({__proto__:null,axiom:op,axiom1:Kg,axiom2:ep,axiom3:tp,axiom4:sp,axiom5:np,axiom6:rp,axiom7:cp});const ip=({vertices_coords:e,edges_vertices:t},s,n=a)=>{const r=t=>t.map((t=>e[t])).map((e=>O(e,s.origin))).map((e=>B(s.vector,e))).sort(((e,t)=>Math.abs(t)-Math.abs(e))).map(Math.sign).shift();const c=gu({vertices_coords:e,edges_vertices:t},s,n,ut);const o={};du({vertices_coords:e,edges_vertices:t},s,n).forEach((e=>{o[e]=true}));return t.map(((e,t)=>{if(o[t]===true){return 2}if(c[t]!==undefined){return 0}return r(e)}))};const fp=({vertices_coords:e,edges_vertices:t,faces_vertices:s,faces_edges:n},r,c=a)=>{if(!n){n=In({edges_vertices:t,faces_vertices:s})}const o=ip({vertices_coords:e,edges_vertices:t},r,c);const i=n.map((e=>e.map((e=>o[e])).filter((e=>e!==2))));const f=i.map((e=>e.includes(0)));const l=i.map(((e,t)=>f[t]?false:e.reduce(((t,s)=>t&&s===e[0]),true)));return l.map(((e,t)=>e?i[t][0]:0))};const lp=({vertices_coords:e,edges_vertices:t,faces_vertices:s,faces_edges:n,faceOrders:r},c,o=a)=>{if(!r){throw new Error("faceOrders required")}const i=fp({vertices_coords:e,edges_vertices:t,faces_vertices:s,faces_edges:n},c,o);const f=[-1,1].map((e=>i.map(((e,t)=>({s:e,f:t}))).filter((t=>t.s===e||t.s===0)).map((e=>e.f))));const l=f.map((e=>ld(r,e)));console.log("facesSide",i);console.log("sidesFaces",f);console.log("sidesFaceOrders",l);const d=ln({vertices_coords:e,faces_vertices:s});const u=l.map((e=>dd({faceOrders:e,faces_normal:d})));console.log("sidesLayersFace",u)};const dp=Object.freeze({__proto__:null,getEdgesSide:ip,getFacesSide:fp,getFlapsThroughLine:lp});const up=({vertices_coords:e,edges_vertices:t,faces_vertices:s,faces_edges:n},r,c=[],o=at)=>{if(!e||!t||!s){return{vertices:[],edges:[]}}if(!n){n=In({edges_vertices:t,faces_vertices:s})}const a=t.map((t=>t.map((t=>e[t]))));a.forEach(((e,t)=>{if(e.includes(undefined)){delete a[t]}}));const i=a.map((e=>Ms(...e))).map((e=>Nc(e,r,dt,o)));const f={};const l={};i.forEach(((e,s)=>{if(e.a!==undefined){const n=st(e.a,0);const r=st(e.a,1);if(n){l[t[s][0]]=true}if(r){l[t[s][1]]=true}if(!n&&!r){f[s]=true}}}));const d=t.map((e=>!!(l[e[0]]&&l[e[1]])));const u=n.map((e=>e.filter((e=>d[e]))));const m=n.map((e=>e.filter((e=>f[e]))));const g=s.map((e=>e.filter((e=>l[e]))));const p=c.length?qn({vertices_coords:e,faces_vertices:s}).map((e=>c.map((t=>({...Sr(e,t),point:t}))))).map((e=>e.filter((e=>e.overlap)))):undefined;const _=s.map(((e,t)=>{if(u[t].length){return undefined}const s=m[t];const n=g[t];const r=p?p[t]:[];return s.length+n.length+r.length===2?{edges:s,vertices:n,points:r}:undefined}));Object.keys(_).filter((e=>_[e]===undefined)).forEach((e=>delete _[e]));const v={};_.filter((e=>e.edges)).forEach((({edges:e})=>e.forEach((e=>{v[e]=true}))));Object.keys(i).filter((e=>!v[e])).forEach((e=>delete i[e]));const h=d.map(((e,t)=>e?t:undefined)).filter((e=>e!==undefined));return{faces:_,edges:i,edges_overlapped:h}};const mp=(e,t)=>up(e,t,[],at);const gp=(e,t)=>up(e,t,[t.origin],ft);const pp=(e,t)=>up(e,Ms(...t),t,dt);const _p=Object.freeze({__proto__:null,intersectGraphLine:mp,intersectGraphRay:gp,intersectGraphSegment:pp});const vp=Object.keys(bt);const hp=(e,t)=>{const s={};vp.forEach((e=>{const n=St(t,e).shift();s[e]=n!==undefined?t[n]:[]}));const n={};vp.forEach((t=>{n[t]=ts(e,t)}));const r={vertices:[],edges:[],faces:[]};vp.forEach((e=>s[e].forEach(((t,s)=>{r[e][s]=n[e]++}))));const c=zo(t);vp.forEach((e=>ar(c,e,r[e])));Object.keys(c).filter((e=>c[e].constructor===Array)).filter((t=>!(t in e))).forEach((t=>{e[t]=[]}));Object.keys(c).filter((e=>c[e].constructor===Array)).forEach((t=>c[t].forEach(((s,n)=>{e[t][n]=s}))));const o={};const a={};vp.forEach((t=>{const s=St(e,t).shift();a[t]=s!==undefined?e[s]:[]}));vp.forEach((e=>{const t=a[e].map((()=>0));r[e].forEach((e=>{t[e]=1}));o[e]=cr(t)}));return o};const bp=Object.freeze({__proto__:null,join:hp});const yp=({vertices_coords:e,edges_vertices:t},s)=>Ms(...t[s].map((t=>e[t])));const Ep=({vertices_coords:e,edges_vertices:t},s,n,r,c)=>hr(...[s,n].map((s=>yp({vertices_coords:e,edges_vertices:t},s))),r,c);const Ap=Object.freeze({__proto__:null,pleat:Ep});const xp=(e,t=a)=>$n(e,t).map((t=>e.vertices_coords.map((e=>e[0]>t.min[0]&&e[1]>t.min[1]&&e[0]<t.max[0]&&e[1]<t.max[1]))));const Mp=({vertices_coords:e,edges_vertices:t,edges_coords:s},n=a)=>{const r=$n({vertices_coords:e,edges_vertices:t,edges_coords:s},n);const c=t.map((()=>[]));for(let e=0;e<t.length-1;e+=1){for(let s=e+1;s<t.length;s+=1){const t=(r[e].max[0]<r[s].min[0]||r[s].max[0]<r[e].min[0])&&(r[e].max[1]<r[s].min[1]||r[s].max[1]<r[e].min[1]);c[e][s]=!t;c[s][e]=!t}}for(let e=0;e<t.length;e+=1){c[e][e]=true}return c};const wp=Object.freeze({__proto__:null,getEdgesEdgesOverlapingSpans:Mp,getEdgesVerticesOverlappingSpan:xp});const kp=({normal:e,distance:t})=>t<0?{normal:q(e),distance:-t}:{normal:e,distance:t};const Op=(e,t=a)=>{const{lines:s}=rc(e,t);const n=s.map(ws).map(kp);const r=s.map((({vector:e,origin:t})=>me(e,t)));const c=r.map((e=>s.map((({vector:t,origin:s})=>ce(e,t,s)))));const o=c.map((e=>e.map((e=>e.vector[0]<0?{vector:q(e.vector),origin:e.origin}:e)))).map((e=>e.map(ws).map(kp))).map((e=>e.concat(n)));const i=o.map((e=>Dr(e.map((e=>e.distance)))));const f=i.map(((e,s)=>e.map((e=>e.map((e=>o[s][e].normal)))).map((e=>Wr(e,t)))));const l=f.map(((e,t)=>e.flatMap(((e,s)=>e.map((e=>e.map((e=>i[t][s][e]))))))));const d=l.map((e=>(e.length-s.length)/s.length));return d.map(((e,t)=>({error:e,i:t}))).map((e=>({line:s[e.i],error:e.error}))).sort(((e,t)=>e.error-t.error))};const jp=(e,t=a)=>Op(e,t)[0];const Fp=Object.freeze({__proto__:null,findSymmetryLine:jp,findSymmetryLines:Op});const Cp=e=>Array.from(Array(e.length-2)).map(((t,s)=>[e[0],e[s+1],e[s+2]]));const Sp=({faces_vertices:e})=>e.flatMap((e=>e.length<4?[e]:Cp(e)));const Pp=e=>e.length===3?[e]:Array.from(Array(Math.floor(e.length/3))).map(((t,s)=>[s*3+0,s*3+1,s*3+2].map((t=>e[t]))));const Vp=({vertices_coords:e,faces_vertices:t},n)=>{if(!e||!e.length){throw new Error(s.nonConvexTriangulation)}const r=e.filter((()=>true)).shift().length;return t.map((t=>t.flatMap((t=>e[t])))).map((e=>n(e,null,r))).map(((e,s)=>e.map((e=>t[s][e])))).flatMap((e=>Pp(e)))};const Np=e=>{if(!e.edges_vertices){e.edges_vertices=[]}const t=En(e);let s=e.edges_vertices.length;const n=[];e.faces_edges=e.faces_vertices.map((e=>e.map(((e,r,c)=>{const o=[e,c[(r+1)%c.length]];const a=o.join(" ");if(a in t){return t[a]}n.push(o);t[a]=s;t[o.reverse().join(" ")]=s;return s++}))));const r=n.length;e.edges_vertices.push(...n);if(e.edges_assignment){e.edges_assignment.push(...Array(r).fill("J"))}if(e.edges_foldAngle){e.edges_foldAngle.push(...Array(r).fill(0))}if(e.vertices_vertices){delete e.vertices_vertices}if(e.vertices_edges){delete e.vertices_edges}if(e.vertices_faces){delete e.vertices_faces}if(e.edges_faces){delete e.edges_faces}if(e.faces_faces){delete e.faces_faces}if(e.faceOrders){delete e.faceOrders}return e};const zp=({faces_vertices:e})=>{let t=0;return e.map((e=>Math.max(3,e.length))).map((e=>Array.from(Array(e-2)).map((()=>t++))))};const Tp=(e,t)=>{if(!e.faces_vertices){return{}}const s=e.edges_vertices?e.edges_vertices.length:0;const n=zp(e);e.faces_vertices=t?Vp(e,t):Sp(e);Np(e);const r=Array.from(Array(e.edges_vertices.length-s)).map(((e,t)=>s+t));return{faces:{map:n},edges:{new:r}}};const $p=Object.freeze({__proto__:null,triangulate:Tp,triangulateConvexFacesVertices:Sp,triangulateNonConvexFacesVertices:Vp});const Bp=Object.freeze([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);const Lp=e=>Bp.map(((t,s)=>Math.abs(t-e[s])<a)).reduce(((e,t)=>e&&t),true);const Ip=(e,t)=>[e[0]*t[0]+e[4]*t[1]+e[8]*t[2]+e[12],e[1]*t[0]+e[5]*t[1]+e[9]*t[2]+e[13],e[2]*t[0]+e[6]*t[1]+e[10]*t[2]+e[14]];const Rp=(e,t,s)=>({vector:[e[0]*t[0]+e[4]*t[1]+e[8]*t[2],e[1]*t[0]+e[5]*t[1]+e[9]*t[2],e[2]*t[0]+e[6]*t[1]+e[10]*t[2]],origin:[e[0]*s[0]+e[4]*s[1]+e[8]*s[2]+e[12],e[1]*s[0]+e[5]*s[1]+e[9]*s[2]+e[13],e[2]*s[0]+e[6]*s[1]+e[10]*s[2]+e[14]]});const Up=(e,t)=>[e[0]*t[0]+e[4]*t[1]+e[8]*t[2]+e[12]*t[3],e[1]*t[0]+e[5]*t[1]+e[9]*t[2]+e[13]*t[3],e[2]*t[0]+e[6]*t[1]+e[10]*t[2]+e[14]*t[3],e[3]*t[0]+e[7]*t[1]+e[11]*t[2]+e[15]*t[3],e[0]*t[4]+e[4]*t[5]+e[8]*t[6]+e[12]*t[7],e[1]*t[4]+e[5]*t[5]+e[9]*t[6]+e[13]*t[7],e[2]*t[4]+e[6]*t[5]+e[10]*t[6]+e[14]*t[7],e[3]*t[4]+e[7]*t[5]+e[11]*t[6]+e[15]*t[7],e[0]*t[8]+e[4]*t[9]+e[8]*t[10]+e[12]*t[11],e[1]*t[8]+e[5]*t[9]+e[9]*t[10]+e[13]*t[11],e[2]*t[8]+e[6]*t[9]+e[10]*t[10]+e[14]*t[11],e[3]*t[8]+e[7]*t[9]+e[11]*t[10]+e[15]*t[11],e[0]*t[12]+e[4]*t[13]+e[8]*t[14]+e[12]*t[15],e[1]*t[12]+e[5]*t[13]+e[9]*t[14]+e[13]*t[15],e[2]*t[12]+e[6]*t[13]+e[10]*t[14]+e[14]*t[15],e[3]*t[12]+e[7]*t[13]+e[11]*t[14]+e[15]*t[15]];const qp=e=>{const t=e[10]*e[15]-e[11]*e[14];const s=e[9]*e[15]-e[11]*e[13];const n=e[9]*e[14]-e[10]*e[13];const r=e[8]*e[15]-e[11]*e[12];const c=e[8]*e[14]-e[10]*e[12];const o=e[8]*e[13]-e[9]*e[12];return e[0]*(e[5]*t-e[6]*s+e[7]*n)-e[1]*(e[4]*t-e[6]*r+e[7]*c)+e[2]*(e[4]*s-e[5]*r+e[7]*o)-e[3]*(e[4]*n-e[5]*c+e[6]*o)};const Dp=e=>{const t=qp(e);if(Math.abs(t)<1e-12||Number.isNaN(t)||!Number.isFinite(e[12])||!Number.isFinite(e[13])||!Number.isFinite(e[14])){return undefined}const s=e[10]*e[15]-e[11]*e[14];const n=e[9]*e[15]-e[11]*e[13];const r=e[9]*e[14]-e[10]*e[13];const c=e[8]*e[15]-e[11]*e[12];const o=e[8]*e[14]-e[10]*e[12];const a=e[8]*e[13]-e[9]*e[12];const i=e[6]*e[15]-e[7]*e[14];const f=e[5]*e[15]-e[7]*e[13];const l=e[5]*e[14]-e[6]*e[13];const d=e[6]*e[11]-e[7]*e[10];const u=e[5]*e[11]-e[7]*e[9];const m=e[5]*e[10]-e[6]*e[9];const g=e[4]*e[15]-e[7]*e[12];const p=e[4]*e[14]-e[6]*e[12];const _=e[4]*e[11]-e[7]*e[8];const v=e[4]*e[10]-e[6]*e[8];const h=e[4]*e[13]-e[5]*e[12];const b=e[4]*e[9]-e[5]*e[8];const y=[+(e[5]*s-e[6]*n+e[7]*r),-(e[1]*s-e[2]*n+e[3]*r),+(e[1]*i-e[2]*f+e[3]*l),-(e[1]*d-e[2]*u+e[3]*m),-(e[4]*s-e[6]*c+e[7]*o),+(e[0]*s-e[2]*c+e[3]*o),-(e[0]*i-e[2]*g+e[3]*p),+(e[0]*d-e[2]*_+e[3]*v),+(e[4]*n-e[5]*c+e[7]*a),-(e[0]*n-e[1]*c+e[3]*a),+(e[0]*f-e[1]*g+e[3]*h),-(e[0]*u-e[1]*_+e[3]*b),-(e[4]*r-e[5]*o+e[6]*a),+(e[0]*r-e[1]*o+e[2]*a),-(e[0]*l-e[1]*p+e[2]*h),+(e[0]*m-e[1]*v+e[2]*b)];const E=1/t;return y.map((e=>e*E))};const Wp=Object.freeze([1,0,0,0,0,1,0,0,0,0,1,0]);const Gp=(e=0,t=0,s=0)=>[...Wp,e,t,s,1];const Hp=(e,t,s,n,r)=>{const c=Math.cos(e);const o=Math.sin(e);const a=[...Bp];a[s*4+s]=c;a[s*4+n]=(r?+1:-1)*o;a[n*4+s]=(r?-1:+1)*o;a[n*4+n]=c;const i=[0,1,2].map((e=>t[e]||0));const f=[...Bp];const l=[...Bp];[12,13,14].forEach(((e,t)=>{f[e]=-i[t];l[e]=i[t]}));return Up(l,Up(a,f))};const Jp=(e,t=[0,0,0])=>Hp(e,t,1,2,true);const Qp=(e,t=[0,0,0])=>Hp(e,t,0,2,false);const Zp=(e,t=[0,0,0])=>Hp(e,t,0,1,true);const Yp=(e,t=[0,0,1],s=[0,0,0])=>{const n=[0,1,2].map((e=>s[e]||0));const[r,c,o]=Z(3,v(t));const a=Math.cos(e);const i=Math.sin(e);const f=1-a;const l=Gp(-n[0],-n[1],-n[2]);const d=Gp(n[0],n[1],n[2]);return Up(d,Up([f*r*r+a,f*c*r+o*i,f*o*r-c*i,0,f*r*c-o*i,f*c*c+a,f*o*c+r*i,0,f*r*o+c*i,f*c*o-r*i,f*o*o+a,0,0,0,0,1],l))};const Xp=(e=[1,1,1],t=[0,0,0])=>[e[0],0,0,0,0,e[1],0,0,0,0,e[2],0,e[0]*-t[0]+t[0],e[1]*-t[1]+t[1],e[2]*-t[2]+t[2],1];const Kp=(e=1,t=[0,0,0])=>Xp([e,e,e],t);const e_=(e,t=[0,0])=>{const s=me(e,t);return[s[0],s[1],0,0,s[2],s[3],0,0,0,0,1,0,s[4],s[5],0,1]};const t_=(e,t,s,n)=>{const r=Math.tan(Math.PI*.5-.5*e);const c=1/(s-n);return[r/t,0,0,0,0,r,0,0,0,0,(s+n)*c,-1,0,0,s*n*c*2,0]};const s_=(e,t,s,n,r,c)=>[2/(t-n),0,0,0,0,2/(e-s),0,0,0,0,2/(r-c),0,(n+t)/(n-t),(s+e)/(s-e),(r+c)/(r-c),1];const n_=(e,t,s)=>{const n=b(j(e,t));const r=b(L(s,n));const c=b(L(n,r));return[r[0],r[1],r[2],0,c[0],c[1],c[2],0,n[0],n[1],n[2],0,e[0],e[1],e[2],1]};const r_=Object.freeze({__proto__:null,determinant4:qp,identity4x4:Bp,invertMatrix4:Dp,isIdentity4x4:Lp,makeLookAtMatrix4:n_,makeMatrix4ReflectZ:e_,makeMatrix4Rotate:Yp,makeMatrix4RotateX:Jp,makeMatrix4RotateY:Qp,makeMatrix4RotateZ:Zp,makeMatrix4Scale:Xp,makeMatrix4Translate:Gp,makeMatrix4UniformScale:Kp,makeOrthographicMatrix4:s_,makePerspectiveMatrix4:t_,multiplyMatrices4:Up,multiplyMatrix4Line3:Rp,multiplyMatrix4Vector3:Ip});const c_=(e,t)=>{const s=L(e,t);const n=[s[0],s[1],s[2],F(e,t)];n[3]+=m(n);return v(n)};const o_=e=>Up([e[3],e[2],-e[1],e[0],-e[2],e[3],e[0],e[1],e[1],-e[0],e[3],e[2],-e[0],-e[1],-e[2],e[3]],[e[3],e[2],-e[1],-e[0],-e[2],e[3],e[0],-e[1],e[1],-e[0],e[3],-e[2],e[0],e[1],e[2],e[3]]);const a_=Object.freeze({__proto__:null,matrix4FromQuaternion:o_,quaternionFromTwoVectors:c_});const i_=({vertices_coords:e,faces_vertices:t},s=a)=>{const n=ln({vertices_coords:e,faces_vertices:t});const r=t.map((()=>[]));for(let e=0;e<t.length-1;e+=1){for(let c=e+1;c<t.length;c+=1){if(e===c){continue}if(H(n[e],n[c],s)){r[e].push(c);r[c].push(e)}}}const c=ao(r);const o=rr(c).map((e=>typeof e==="number"?[e]:e));const i=o.map((e=>n[e[0]]));const f=[];o.forEach(((e,t)=>e.forEach((e=>{f[e]=S(n[e],i[t])>0}))));const l=t.map((t=>e[t[0]])).map((e=>Z(3,e)));const d=o.map(((e,t)=>e.map((e=>S(i[t],l[e])))));const u=d.map(((e,t)=>Dr(e).map((e=>e.map((e=>o[t][e]))))));const m=u.flatMap(((e,t)=>e.map((()=>[...i[t]]))));const g=u.flat();const p=g.map((e=>e[0])).map((e=>l[e])).map(((e,t)=>S(m[t],e))).map(((e,t)=>A(m[t],e)));const _=g.map(((e,t)=>({normal:m[t],origin:p[t]})));return g.map(((e,t)=>({faces:e,facesAligned:e.map((e=>f[e])),plane:_[t]})))};const f_=(e,t,s,n)=>{const r=e.vertices_coords.map((e=>Z(3,e)));const c=t.map((t=>t.faces.map(((s,n)=>t.facesAligned[n]?e.faces_vertices[s]:e.faces_vertices[s].slice().reverse())).map((e=>e.map((e=>r[e])))).map((e=>Ze(e,n)))));const o=[];const a=c.map(((e,t)=>e.map((e=>e.map((e=>Ip(s[t],e))).map((e=>[e[0],e[1]]))))));t.map((e=>e.faces)).forEach(((e,t)=>e.forEach(((e,s)=>{o[e]=a[t][s]}))));return o};const l_=({vertices_coords:e,faces_vertices:t,faces_faces:s},n=a)=>{if(!s){s=Rn({faces_vertices:t})}const r=i_({vertices_coords:e,faces_vertices:t},n);const c=[];r.forEach((e=>e.facesAligned.forEach(((t,s)=>{c[e.faces[s]]=t}))));const o=[0,0,1];const i=r.map((e=>e.plane.normal)).map((e=>{const t=F(e,o);return Math.abs(t+1)<.01?Yp(Math.PI,[1,0,0]):o_(c_(e,o))}));const f=f_({vertices_coords:e,faces_vertices:t},r,i,n);const l=r.map((e=>e.faces)).map((e=>Kc(s,e)));const d=l.map((e=>ao(e)));const u=d.map((e=>rr(e).map((e=>e.constructor===Array?e:[e]))));const m=d.map((e=>{const t=e.map(((e,t)=>t));return e.map((s=>t.filter((t=>e[t]!==s))))}));const g=t.map((()=>[]));m.forEach((e=>e.forEach(((e,t)=>{for(let s=0;s<e.length;s+=1){const r=e[s];const c=[t,r].map((e=>f[e]));const o=Pr(...c,n);if(o){g[t][r]=true;g[r][t]=true}}}))));const p=m.map((e=>e.map(((e,t)=>e.filter((e=>g[t][e]))))));const _=[];p.forEach(((e,t)=>{_[t]=[];e.forEach(((e,s)=>{const n=d[t][s];const r=e.map((e=>d[t][e]));if(!_[t][n]){_[t][n]=new Set}r.forEach((e=>{if(!_[t][e]){_[t][e]=new Set}}));r.forEach((e=>{_[t][n].add(e);_[t][e].add(n)}))}))}));_.forEach(((e,t)=>e.forEach(((e,s)=>{_[t][s]=[...e]}))));const v=_.map((e=>rr(ao(e)).map((e=>e.constructor===Array?e:[e]))));const h=v.flatMap(((e,t)=>e.map((()=>t))));const b=r.map(((e,t)=>v[t].map((e=>e.flatMap((e=>u[t][e]))))));const y=b.flatMap(((e,t)=>e.map((e=>({faces:e,facesAligned:e.map((e=>c[e])),plane:r[t].plane})))));const E=h.map((e=>r[e].plane));const A=h.map((e=>i[e]));const x=y.map((e=>e.faces));const M=rr(x);return{sets_faces:x,sets_plane:E,sets_transformXY:A,faces_set:M,faces_winding:c}};const d_=Object.freeze({__proto__:null,coplanarFacesGroups:i_,coplanarOverlappingFacesGroups:l_});const u_=({vertices_coords:e,edges_vertices:t,edges_vector:s},n=a)=>{if(!s){s=zn({vertices_coords:e,edges_vertices:t})}const r=s.map((e=>v(e)));const c=t.map((()=>[]));r.forEach(((e,t)=>{r.forEach(((e,s)=>{if(s>=t){return}if(1-Math.abs(F(r[t],r[s]))<n){c[t].push(s);c[s].push(t)}}))}));return c};const m_=({vertices_coords:e,edges_vertices:t,edges_vector:s},n)=>{if(!s){s=zn({vertices_coords:e,edges_vertices:t})}const r=t.map((t=>e[t[0]]));const c=s.map(((e,t)=>({vector:e,origin:r[t]})));return u_({vertices_coords:e,edges_vertices:t,edges_vector:s},.001).map(((e,t)=>e.filter((e=>jr(c[t],c[e],ut,ut,n)))))};const g_=Object.freeze({__proto__:null,makeEdgesEdgesParallelOverlap:m_});const p_=e=>e.map((e=>e.map(((e,t)=>e===true?t:undefined)).filter((e=>e!==undefined))));const __=({vertices_coords:e,edges_vertices:t,edges_coords:s,edges_boundingBox:n},r=a)=>{if(!s){s=Nn({vertices_coords:e,edges_vertices:t})}if(!n){n=$n({vertices_coords:e,edges_vertices:t,edges_coords:s})}const c=t.map(((e,t)=>t)).shift();const o=Array.from(Array(s.length)).map((()=>[]));if(c===undefined){return p_(o)}const i=n[c].min.length;for(let e=0;e<s.length-1;e+=1){if(!n[e]){continue}for(let t=e+1;t<s.length;t+=1){if(!n[t]){continue}let s=true;for(let c=0;c<i;c+=1){if(!st(n[e].min[c],n[t].min[c],r)||!st(n[e].max[c],n[t].max[c],r)){s=false}}o[e][t]=s;o[t][e]=s}}for(let e=0;e<s.length-1;e+=1){for(let t=e+1;t<s.length;t+=1){if(!o[e][t]){continue}const n=rt(s[e][0],s[t][0],r)&&rt(s[e][1],s[t][1],r);const c=rt(s[e][0],s[t][1],r)&&rt(s[e][1],s[t][0],r);const a=n||c;o[e][t]=a;o[t][e]=a}}return p_(o)};const v_=({vertices_coords:e,edges_vertices:t,edges_vector:s,edges_faces:n,faces_vertices:r},c=a)=>{if(!s){s=zn({vertices_coords:e,edges_vertices:t})}const o=t.map((t=>e[t[0]]));const i=t.map((()=>Array.from(Array(r.length))));n.forEach(((e,t)=>e.forEach((e=>{i[t][e]=false}))));const f=t.map((t=>t.map((t=>e[t]))));const l=r.map((t=>t.map((t=>e[t]))));od({vertices_coords:e,faces_vertices:r}).map(((e,t)=>!e?t:undefined)).filter((e=>e!==undefined)).forEach((e=>l[e].reverse()));const d=$n({edges_coords:f});const u=l.map((e=>et(e)));for(let e=0;e<i.length;e+=1){if(!d[e]){continue}for(let t=0;t<i[e].length;t+=1){if(i[e][t]===false){continue}if(!u[t]){continue}if(!Vr(u[t],d[e],c)){i[e][t]=false;continue}}}const m=__({vertices_coords:e,edges_vertices:t,edges_coords:f,edges_boundingBox:d});const g={};for(let e=0;e<i.length;e+=1){if(g[e]){continue}if(!f[e]){continue}for(let t=0;t<i[e].length;t+=1){if(i[e][t]!==undefined){continue}if(!l[t]){continue}const n=f[e].map((e=>Cr(l[t],e,ot,.001))).reduce(((e,t)=>e||t),false);if(n){i[e][t]=true;continue}const r=Rc(l[t],{vector:s[e],origin:o[e]},ut,ut,c);if(r){i[e][t]=true;continue}i[e][t]=false}m[e].forEach((t=>{i[t]=i[e].slice();g[t]=true}))}return i.map((e=>e.map(((e,t)=>e?t:undefined)).filter((e=>e!==undefined))))};const h_=Object.freeze({__proto__:null,getEdgesFacesOverlap:v_});const b_=({vertices_coords:e,faces_vertices:t},s=a)=>{const n=Un({vertices_coords:e,faces_vertices:t});const r=n.map((e=>et(e)));const c=[];const o=[];Yr({vertices_coords:e,faces_vertices:t},0,s).forEach((e=>{e.start.forEach((e=>{o[e]=true}));o.forEach(((t,o)=>e.start.forEach((e=>{if(o===e){return}if(!Vr(r[o],r[e],s)||!Pr(n[o],n[e],s)){return}if(!c[o]){c[o]=[]}if(!c[e]){c[e]=[]}c[o][e]=true;c[e][o]=true}))));e.end.forEach((e=>delete o[e]))}));return c.map((e=>Object.keys(e).map((e=>parseInt(e,10)))))};const y_=Object.freeze({__proto__:null,getFacesFacesOverlap:b_});const E_=(e,t)=>{if(!e.vertices_coords){e.vertices_coords=[]}const s=e.vertices_coords.length;St(e,"vertices").forEach((t=>{e[t][s]=[]}));e.vertices_coords[s]=t;return s};const A_=(e,t)=>{if(t.length!==2){return undefined}if(!e.edges_vertices){e.edges_vertices=[]}const s=e.edges_vertices.length;St(e,"edges").forEach((t=>{e[t][s]=[]}));e.edges_vertices[s]=t;if(e.edges_assignment){e.edges_assignment[s]="U"}if(e.edges_foldAngle){e.edges_foldAngle[s]=0}if(e.vertices_edges){t.forEach((t=>{e.vertices_edges[t]=e.vertices_edges[t].filter((e=>e!==s));e.vertices_edges[t].push(s)}))}if(e.vertices_vertices){const s=[t[1],t[0]];t.forEach(((t,n)=>{e.vertices_vertices[t]=e.vertices_vertices[t].filter((e=>e!==s[n]));e.vertices_vertices[t].push(s[n])}))}return s};const x_=(e,{vector:t,origin:s},n=a)=>{const r=gu(e,{vector:t,origin:s},n).filter(Boolean);const c=r.map((e=>k(e,s))).map((e=>F(e,t)));const o=is(c);const i=o.map((e=>x(y(t,e),s)));const f=Array.from(Array(i.length-1)).map(((e,t)=>[i[t],i[t+1]])).map((t=>hu(e,t[0],t[1],n)));return f};const M_=(e,t,s,n=a)=>{e.faces_vertices[t].map((t=>e.vertices_coords[t])).map((e=>s.map((t=>rt(e,t,n)))));e.faces_vertices[t].map((t=>e.vertices_coords[t])).map(((e,t,s)=>[e,s[(t+1)%s.length]])).map((e=>Ms(...e))).map((e=>s.map((t=>Or(e,t,ut,n)))))};const w_=(e,t,s=a)=>{const n=O(t[1],t[0]);const r=t[0];const c=Qc(e,t,s);const o=c.map((t=>e.faces_vertices[t].map((t=>e.vertices_coords[t])))).map((e=>Kd(e,{vector:n,origin:r},ct,dt,s)));const i=[];c.forEach(((e,t)=>{if(o[t]){i[e]=o[t]}}));return i};const k_=(e,t,s=a)=>{const n=w_(e,t,s);console.log("facesSegment",n);const r=n.map(((t,n)=>M_(e,n,t,s)));return r};const O_=(e,t,s)=>{const n=rr(s);Pt(e,t).forEach((t=>e[t].forEach(((n,r)=>e[t][r].forEach(((n,c)=>{e[t][r][c]=s[n]}))))));Pt(e,t).forEach((t=>e[t].forEach(((s,n)=>{e[t][n]=e[t][n].filter((e=>e!==undefined))}))));St(e,t).forEach((t=>{e[t]=n.map((s=>e[t][s]))}))};const j_=e=>{const t={vertices:[],edges:[],faces:[]};let s=0;let n=0;let r=0;e.vertices_coords.forEach(((e,n)=>{t.vertices[n]=s++}));e.edges_vertices.forEach(((e,s)=>{t.edges[s]=n++}));e.faces_vertices.forEach(((e,s)=>{t.faces[s]=r++}));O_(e,"vertices",t.vertices);O_(e,"edges",t.edges);O_(e,"faces",t.faces);return e};const F_=(e,t,s=at,n=at,r=a)=>{const c=B(h(e.vector),h(t.vector));if(Math.abs(c)<r){return undefined}const o=B(e.vector,t.vector);const i=-o;const f=[t.origin[0]-e.origin[0],t.origin[1]-e.origin[1]];const l=[-f[0],-f[1]];const d=B(f,t.vector)/o;const u=B(l,e.vector)/i;if(s(d,r/g(e.vector))&&n(u,r/g(t.vector))){return{point:M(e.origin,E(e.vector,d)),a:d,b:u}}return undefined};const C_=({vertices_coords:e,faces_vertices:t},s,n)=>{const r=$r({vertices_coords:e,faces_vertices:t},s,ct);switch(r.length){case 0:return undefined;case 1:return r[0]}const c=M(s,E(n,.01));const o=r.map((s=>t[s].map((t=>e[t]))));const a=r.filter(((e,t)=>Cr(o[t],c,ot)));switch(a.length){case 0:return r.filter(((e,t)=>Cr(o[t],c,ct))).shift();case 1:return a[0];default:return a[0]}};const S_=({vertices_coords:e,edges_vertices:t},{vector:s,origin:n},r=a,c=dt)=>t.map((t=>{const o=t.map((t=>e[t]));const a=O(o[1],o[0]);const i={vector:a,origin:o[0]};return F_(i,{vector:s,origin:n},c,at,r)}));const P_=({vertices_coords:e,edges_vertices:t,edges_foldAngle:s,edges_assignment:n,faces_vertices:r,faces_edges:c,faces_faces:o},{vector:i,origin:f},l="V",d=a)=>{if(!c){c=In({edges_vertices:t,faces_vertices:r})}const u=C_({vertices_coords:e,faces_vertices:r},f,i);const m=Rt(l);const g=Po({vertices_coords:e,edges_vertices:t,edges_foldAngle:s,edges_assignment:n,faces_vertices:r,faces_faces:o},u);const p=od({vertices_coords:g,faces_vertices:r});if(!p[u]){p.forEach(((e,t)=>{p[t]=!e}))}const _=S_({vertices_coords:g,edges_vertices:t},{vector:i,origin:f},d).map(((e,t)=>e===undefined?undefined:{...e,edge:t}));const v=t.map((t=>e[t[0]]));const h=zn({vertices_coords:e,edges_vertices:t});const b=[];c.map((e=>e.map((e=>_[e])).filter((e=>e!==undefined)))).forEach(((e,t)=>{switch(e.length){case 0:case 1:break;default:b[t]=e;break}}));const y=(e,t)=>Math.abs(e.b-t.b)<d*2;const A=[];b.map((e=>e.sort(((e,t)=>e.b-t.b)))).map((e=>qr(e,y).map((t=>t.map((t=>e[t])))))).forEach(((e,t)=>{if(e.length===2){A[t]=[e[0][0],e[e.length-1][0]]}if(e.length>2){console.log("repeatFoldLine, non-convex polygons.")}}));return A.map(((e,t)=>({edges:e.map((e=>e.edge)),assignment:p[t]?l:m,points:e.map((e=>M(E(h[e.edge],e.a),v[e.edge])))})))};const V_={count:ts,countImplied:Js,validate:oo,clean:fr,populate:mc,remove:_s,replace:us,removePlanarVertex:xu,removePlanarEdge:Au,splitEdge:xc,splitFace:Xc,flatFold:Gu,normalize:j_,repeatFold:P_,addVertex:E_,addNonPlanarEdge:A_,addPlanarLine:x_,addPlanarSegment:hu,addPlanarSegmentNew:k_,planarize:lc,...fo,...Rl,...Yg,...ht,...Dt,...ap,...yo,...iu,...ur,...dp,..._p,...bp,...Gn,...ir,...Rr,...un,...vd,...Ap,...wp,...ro,...Kr,...Fp,...fd,...mo,...Yt,...wo,...$p,...Xs,...Kt,...nc,...ps,...Vo,...Es,...fn,...Kn,...Qn,...tc,...cc,...d_,...Ao,...Co,...ad,...lu,...pu,...g_,...h_,...Yc,...y_};const N_=(e,t=a)=>{if(!e||!e.length){return undefined}const s=(e,s)=>nt(e[0],s[0],t);const n=Ur(e,s);let r=0;for(let t=1;t<n.length;t+=1){if(e[n[t]][1]<e[n[r]][1]){r=t}}return n[r]};const z_=(e,t=a)=>{const s=N_(e,t);if(s===undefined){return[]}const n=e.map((t=>O(t,e[s]))).map((e=>h(e))).map((e=>C([0,1],e)));const r=n.map(((e,t)=>({a:e,i:t}))).sort(((e,t)=>e.a-t.a)).map((e=>e.i)).filter((e=>e!==s));return[[s]].concat(Dr(r.map((e=>n[e])),t).map((e=>e.map((e=>r[e])))).map((t=>t.length===1?t:t.map((t=>({i:t,len:R(e[t],e[s])}))).sort(((e,t)=>e.len-t.len)).map((e=>e.i)))))};const T_=(e=[],t=false,s=a)=>{if(e.length<2){return[]}const n=z_(e,s).map((e=>e.length===1?e:ss(e))).flat();n.push(n[0]);const r=[n[0]];let c=1;const o={"-1":()=>r.pop(),1:e=>{r.push(e);c+=1},undefined:()=>{c+=1}};o[0]=t?o["1"]:o["-1"];while(c<n.length){if(r.length<2){r.push(n[c]);c+=1;continue}const t=r[r.length-2];const a=r[r.length-1];const i=n[c];const f=qs(...[t,a,i].map((t=>e[t])),s);o[f](i)}r.pop();return r};const $_=Object.freeze({__proto__:null,convexHull:T_,convexHullRadialSortPoints:z_,smallestVector2:N_});const B_=(e,t,s)=>{const n=e.map(((e,t)=>({vector:s[t],origin:e}))).map(((e,t,s)=>Nc(e,s[(t+1)%s.length],lt,lt).point));const r=t.map(((e,t)=>xr(e,n[t],(e=>e))));if(e.length===3){return e.map((e=>({type:"skeleton",points:[e,n[0]]}))).concat([{type:"perpendicular",points:[r[0],n[0]]}])}const c=n.map(((e,t)=>I(e,r[t])));let o=0;c.forEach(((e,t)=>{if(e<c[o]){o=t}}));const a=[{type:"skeleton",points:[e[o],n[o]]},{type:"skeleton",points:[e[(o+1)%e.length],n[o]]},{type:"perpendicular",points:[r[o],n[o]]}];const i=Vs(q(t[(o+t.length-1)%t.length].vector),t[(o+1)%t.length].vector);const f=o===e.length-1;e.splice(o,2,n[o]);t.splice(o,1);s.splice(o,2,i);if(f){e.splice(0,1);s.splice(0,1);t.push(t.shift())}return a.concat(B_(e,t,s))};const L_=e=>{const t=e.map(((e,t,s)=>[e,s[(t+1)%s.length]])).map((e=>({vector:k(e[1],e[0]),origin:e[0]})));const s=e.map(((e,t,s)=>[(t-1+s.length)%s.length,t,(t+1)%s.length].map((e=>s[e])))).map((e=>[k(e[0],e[1]),k(e[2],e[1])])).map((e=>Vs(...e)));return B_([...e],t,s)};const I_=(e,t,s=a)=>{for(let n=0;n<e.length;n+=1){if(e[n]<t.min[n]-s||e[n]>t.max[n]+s){return false}}return true};const R_=(e,t,s=a)=>{const n=Math.min(e.min.length,t.min.length);for(let r=0;r<n;r+=1){if(t.min[r]<e.min[r]-s||t.max[r]>e.max[r]+s){return false}}return true};const U_=Object.freeze({__proto__:null,enclosingBoundingBoxes:R_,pointInBoundingBox:I_});const q_=(e,t)=>{const s=e.map(((e,s)=>{const n=Or(t,e,at);return{point:n?e:null,at_index:s}})).filter((e=>e.point!=null));const n=e.map(((e,t,s)=>({vector:k(e,s[(t+1)%s.length]),origin:s[(t+1)%s.length]}))).map(((e,s)=>({point:Nc(t,e,it,ut).point,at_index:s}))).filter((e=>e.point!=null));if(n.length===2){const t=n.slice().sort(((e,t)=>e.at_index-t.at_index));const s=e.slice(t[1].at_index+1).concat(e.slice(0,t[0].at_index+1));s.push(t[0].point);s.push(t[1].point);const r=e.slice(t[0].at_index+1,t[1].at_index+1);r.push(t[1].point);r.push(t[0].point);return[s,r]}if(n.length===1&&s.length===1){s[0].type="v";n[0].type="e";const t=s.concat(n).sort(((e,t)=>e.at_index-t.at_index));const r=e.slice(t[1].at_index+1).concat(e.slice(0,t[0].at_index+1));if(t[0].type==="e"){r.push(t[0].point)}r.push(t[1].point);const c=e.slice(t[0].at_index+1,t[1].at_index+1);if(t[1].type==="e"){c.push(t[1].point)}c.push(t[0].point);return[r,c]}if(s.length===2){const t=s.slice().sort(((e,t)=>e.at_index-t.at_index));const n=e.slice(t[1].at_index).concat(e.slice(0,t[0].at_index+1));const r=e.slice(t[0].at_index,t[1].at_index+1);return[n,r]}return[e.slice()]};const D_=Object.freeze({__proto__:null,splitConvexPolygon:q_});const W_=e=>{if(typeof e!=="object"){return typeof e}if(e.radius!==undefined){return"circle"}if(e.min&&e.max&&e.span){return"box"}if(typeof e[0]==="number"){return"vector"}if(e.vector!==undefined&&e.origin!==undefined){return"line"}if(e[0]!==undefined&&e[0].length&&typeof e[0][0]==="number"){return e.length===2?"segment":"polygon"}return"object"};const G_=e=>e.charAt(0).toUpperCase()+e.slice(1);const H_={polygon:dt,circle:ct,line:at,ray:ft,segment:dt};const J_=(e,t,s=a)=>{const n=e=>e==="polygon"?"ConvexPolygon":G_(e);const r=[e,t].map(W_);const c=[r,r.slice().reverse()].map((e=>e.map(n).join(""))).map((e=>Uc[`intersect${e}`]));const o=[e.domain,t.domain].map(((e,t)=>e||H_[r[t]]));const i=[[e,t,...o],[t,e,...o.slice().reverse()]];const f=c.map(((e,t)=>({fn:e,params:i[t]}))).filter((e=>e.fn)).shift();return f?f.fn(...f.params,s):undefined};const Q_={...d,...Os,...mt,...te,...ge,...Pe,...r_,...a_,...$_,...yr,...kr,...en,...tt,...Ds,straightSkeleton:L_,...U_,...Nr,...Uc,...tu,...D_,intersect:J_};const Z_=e=>{const t=e.map((e=>e.toUpperCase()));const s=t.filter((e=>e==="M")).length;const n=t.filter((e=>e==="V")).length;return s>n?t.indexOf("V"):t.indexOf("M")};const Y_=(e,t,s=0)=>{const n=Z_(t);if(n===-1){return undefined}const r=e[(n+1)%e.length];const c=e[(n+2)%e.length];const o=Math.max(-Math.PI,Math.min(Math.PI,s));const a=-Math.cos(r)*Math.cos(c)+Math.sin(r)*Math.sin(c)*Math.cos(Math.PI-o);const i=Math.cos(Math.PI-o)-Math.sin(Math.PI-o)**2*Math.sin(r)*Math.sin(c)/(1-a);const f=-Math.acos(i)+Math.PI;return n%2===0?[f,o,f,o].map(((e,t)=>n===t?-e:e)):[o,f,o,f].map(((e,t)=>n===t?-e:e))};const X_=Object.freeze({__proto__:null,foldDegree4:Y_});const K_=({vertices_coords:e,vertices_vertices:t,vertices_edges:s,vertices_faces:n,edges_vertices:r,edges_foldAngle:c,edges_vector:o,faces_vertices:i},l=a)=>{if(!t){t=vn({vertices_coords:e,vertices_edges:s,vertices_faces:n,edges_vertices:r,faces_vertices:i})}if(!s){s=gn({edges_vertices:r,vertices_vertices:t})}if(!n){n=yn({vertices_coords:e,vertices_vertices:t,faces_vertices:i})}const d=Mn({vertices_coords:e,vertices_vertices:t,vertices_edges:s,vertices_faces:n,edges_vertices:r,edges_vector:o,faces_vertices:i});return e.map(((e,t)=>{if(n[t].includes(undefined)||n[t].includes(null)){return true}const r=d[t].map((e=>Math.atan2(e[1],e[0])));const o=s[t].map((e=>c[e])).map((e=>e*f));const a=r.map((e=>Oe(e)));const i=a.map((e=>Ae(e)));const u=o.map((e=>we(e)));const m=d[t].map(((e,t)=>ye(a[t],ye(u[t],i[t]))));let g=_e;m.forEach((e=>{g=ye(g,e)}));return Array.from(Array(9)).map(((e,t)=>Math.abs(g[t]-_e[t])<l)).reduce(((e,t)=>e&&t),true)}))};const ev=Object.freeze({__proto__:null,verticesFoldable:K_});const tv={U:true,u:true};const sv=e=>e.map(((e,t)=>t)).filter((t=>tv[e[t]]));const nv=e=>{const t=sv(e);const s=Array.from(Array(2**t.length)).map(((e,t)=>t.toString(2))).map((e=>Array(t.length-e.length+1).join("0")+e)).map((e=>Array.from(e).map((e=>e==="0"?"V":"M"))));const n=s.map((s=>{const n=e.slice();t.forEach(((e,t)=>{n[e]=s[t]}));return n}));const r=e.filter((e=>wt[e])).length;if(r>0){return n}const c=n.map((e=>e.filter((e=>e==="M"||e==="m")).length));const o=n.map((e=>e.filter((e=>e==="V"||e==="v")).length));return n.filter(((e,t)=>Math.abs(c[t]-o[t])===2))};const rv=Object.freeze({__proto__:null,maekawaSolver:nv});const cv={...X_,...ev,...Fu,...rv,...Vu};const ov=(e,t,s)=>{const n=e.createShader(s);e.shaderSource(n,t);e.compileShader(n);if(!e.getShaderParameter(n,e.COMPILE_STATUS)){throw new Error(e.getShaderInfoLog(n))}return n};const av=(e,t,s)=>{const n=e.createProgram();e.attachShader(n,t);e.attachShader(n,s);e.linkProgram(n);if(!e.getProgramParameter(n,e.LINK_STATUS)){throw new Error(e.getProgramInfoLog(n))}e.deleteShader(t);e.deleteShader(s);return n};const iv=(e,t,s)=>{const n=ov(e,t,e.VERTEX_SHADER);const r=ov(e,s,e.FRAGMENT_SHADER);return av(e,n,r)};const fv=(e,t)=>{const n=[null,"webgl","webgl2"];const r=window.devicePixelRatio||1;e.width=e.clientWidth*r;e.height=e.clientHeight*r;if(t){return{gl:e.getContext(n[t]),version:t}}const c=e.getContext(n[2]);if(c){return{gl:c,version:2}}const o=e.getContext(n[1]);if(o){return{gl:o,version:1}}throw new Error(s.noWebGL)};const lv=(e,t)=>{if(!e){return}const s=window.devicePixelRatio||1;const n=[t.clientWidth,t.clientHeight].map((e=>e*s));if(t.width!==n[0]||t.height!==n[1]){t.width=n[0];t.height=n[1]}e.viewport(0,0,e.canvas.width,e.canvas.height)};const dv=(e,t="perspective",s=45)=>{if(!e){return Bp}const n=.1;const r=20;const c=-100;const o=100;const a=[e.clientWidth,e.clientHeight];const i=Math.min(...a);const f=[0,1].map((e=>(a[e]-i)/i/2));const l=f.map((e=>e+.5));return t==="orthographic"?s_(l[1],l[0],-l[1],-l[0],c,o):t_(s*(Math.PI/180),a[0]/a[1],n,r)};const uv=e=>{if(!e){return Bp}const t=go(e);if(!t){return Bp}const s=Math.max(...t.span);if(s===0){return Bp}const n=Z(3,P(t.min,t.max));const r=[s,0,0,0,0,s,0,0,0,0,s,0,...n,1];return Dp(r)||Bp};const mv=Object.freeze({__proto__:null,makeModelMatrix:uv,makeProjectionMatrix:dv,rebuildViewport:lv});const gv=(e,t,s,n)=>{switch(s){case"uniformMatrix4fv":e[s](t,false,n);break;default:e[s](t,n);break}};const pv=(e,t,s,n={})=>{e.useProgram(s.program);s.flags.forEach((t=>e.enable(t)));const r=e.getProgramParameter(s.program,e.ACTIVE_UNIFORMS);for(let t=0;t<r;t+=1){const r=e.getActiveUniform(s.program,t).name;const c=n[r];if(c){const t=e.getUniformLocation(s.program,r);gv(e,t,c.func,c.value)}}s.vertexArrays.forEach((t=>{e.bindBuffer(e.ARRAY_BUFFER,t.buffer);e.bufferData(e.ARRAY_BUFFER,t.data,e.STATIC_DRAW);e.vertexAttribPointer(t.location,t.length,t.type,false,0,0);e.enableVertexAttribArray(t.location)}));s.elementArrays.forEach((s=>{e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,s.buffer);e.bufferData(e.ELEMENT_ARRAY_BUFFER,s.data,e.STATIC_DRAW);e.drawElements(s.mode,s.data.length,t===2?e.UNSIGNED_INT:e.UNSIGNED_SHORT,s.buffer)}));s.flags.forEach((t=>e.disable(t)))};const _v=(e,t)=>{t.vertexArrays.forEach((t=>e.disableVertexAttribArray(t.location)));t.vertexArrays.forEach((t=>e.deleteBuffer(t.buffer)));t.elementArrays.forEach((t=>e.deleteBuffer(t.buffer)));e.deleteProgram(t.program)};const vv=Object.freeze({__proto__:null,deallocProgram:_v,drawProgram:pv});const hv={B:[.5,.5,.5],b:[.5,.5,.5],V:[.2,.4,.6],v:[.2,.4,.6],M:[.75,.25,.15],m:[.75,.25,.15],F:[.3,.3,.3],f:[.3,.3,.3],J:[.3,.2,0],j:[.3,.2,0],C:[.5,.8,.1],c:[.5,.8,.1],U:[.6,.25,.9],u:[.6,.25,.9]};const bv={B:[0,0,0],b:[0,0,0],V:[.2,.5,.8],v:[.2,.5,.8],M:[.75,.25,.15],m:[.75,.25,.15],F:[.75,.75,.75],f:[.75,.75,.75],J:[1,.75,.25],j:[1,.75,.25],C:[.5,.8,.1],c:[.5,.8,.1],U:[.6,.25,.9],u:[.6,.25,.9]};const yv=e=>e!==undefined&&e.constructor===Array?e.slice(0,3):wa(e).slice(0,3).map((e=>e/255));const Ev=({vertices_coords:e,edges_assignment:t,faces_vertices:s,faces_edges:n,faces_normal:r},c={})=>{const o=e.map((e=>[...e].concat(Array(3-e.length).fill(0))));const a=dn({vertices_coords:o,faces_vertices:s,faces_normal:r});const i=o.map(((e,t)=>t%3)).map((e=>[e===0?1:0,e===1?1:0,e===2?1:0]));const f=n.map((e=>e.map((e=>t[e])).map((e=>e==="J"||e==="j"))));if(!c.showTrianglulation){for(let e=0;e<f.length;e+=1){if(f[e][0]){i[e*3+0][2]=i[e*3+1][2]=100}if(f[e][1]){i[e*3+1][0]=i[e*3+2][0]=100}if(f[e][2]){i[e*3+0][1]=i[e*3+2][1]=100}}}return{vertices_coords:o,vertices_normal:a,vertices_barycentric:i}};const Av=(e,t)=>{if(!e||!e.vertices_coords||!e.edges_vertices){return[]}const s=t&&t.dark?hv:bv;const n={...s,...t};const r=e.vertices_coords.map((e=>[...e].concat(Array(3-e.length).fill(0))));const c=e.edges_vertices.flatMap((e=>e.map((e=>r[e])))).flatMap((e=>[e,e,e,e]));const o=zn(e);const a=e.edges_assignment?e.edges_assignment.flatMap((e=>Array(8).fill(n[e]))):e.edges_vertices.flatMap((()=>Array(8).fill(n.U)));const i=o.flatMap((e=>[e,e,e,e,e,e,e,e]));const f=e.edges_vertices.flatMap((()=>[[1,0],[0,1],[-1,0],[0,-1],[1,0],[0,1],[-1,0],[0,-1]]));return{vertices_coords:c,vertices_color:a,verticesEdgesVector:i,vertices_vector:f}};const xv=Object.freeze({__proto__:null,makeFacesVertexData:Ev,makeThickEdgesVertexData:Av});const Mv=(e,t,{vertices_coords:s,edges_vertices:n,edges_assignment:r,faces_vertices:c,faces_edges:o,faces_normal:a}={},i={})=>{if(!s||!c){return[]}if(!o){o=In({edges_vertices:n,faces_vertices:c})}const{vertices_coords:f,vertices_normal:l,vertices_barycentric:d}=Ev({vertices_coords:s,edges_assignment:r,faces_vertices:c,faces_edges:o,faces_normal:a},i);return[{location:e.getAttribLocation(t,"v_position"),buffer:e.createBuffer(),type:e.FLOAT,length:f.length?f[0].length:3,data:new Float32Array(f.flat())},{location:e.getAttribLocation(t,"v_normal"),buffer:e.createBuffer(),type:e.FLOAT,length:l.length?l[0].length:3,data:new Float32Array(l.flat())},{location:e.getAttribLocation(t,"v_barycentric"),buffer:e.createBuffer(),type:e.FLOAT,length:3,data:new Float32Array(d.flat())}].filter((e=>e.location!==-1))};const wv=(e,t=1,s={})=>{if(!s||!s.vertices_coords||!s.faces_vertices){return[]}return[{mode:e.TRIANGLES,buffer:e.createBuffer(),data:t===2?new Uint32Array(s.faces_vertices.flat()):new Uint16Array(s.faces_vertices.flat())}]};const kv=(e,t,s,n={})=>{if(!s||!s.vertices_coords||!s.edges_vertices){return[]}const{vertices_coords:r,vertices_color:c,verticesEdgesVector:o,vertices_vector:a}=Av(s,n.assignment_color);return[{location:e.getAttribLocation(t,"v_position"),buffer:e.createBuffer(),type:e.FLOAT,length:r.length?r[0].length:3,data:new Float32Array(r.flat())},{location:e.getAttribLocation(t,"v_color"),buffer:e.createBuffer(),type:e.FLOAT,length:c.length?c[0].length:3,data:new Float32Array(c.flat())},{location:e.getAttribLocation(t,"edge_vector"),buffer:e.createBuffer(),type:e.FLOAT,length:o.length?o[0].length:3,data:new Float32Array(o.flat())},{location:e.getAttribLocation(t,"vertex_vector"),buffer:e.createBuffer(),type:e.FLOAT,length:a.length?a[0].length:3,data:new Float32Array(a.flat())}].filter((e=>e.location!==-1))};const Ov=(e,t=1,s={})=>{if(!s||!s.edges_vertices){return[]}const n=s.edges_vertices.map(((e,t)=>t*8)).flatMap((e=>[e+0,e+1,e+4,e+4,e+1,e+5,e+1,e+2,e+5,e+5,e+2,e+6,e+2,e+3,e+6,e+6,e+3,e+7,e+3,e+0,e+7,e+7,e+0,e+4]));return[{mode:e.TRIANGLES,buffer:e.createBuffer(),data:t===2?new Uint32Array(n):new Uint16Array(n)}]};const jv=Object.freeze({__proto__:null,makeFoldedElementArrays:wv,makeFoldedVertexArrays:Mv,makeThickEdgesElementArrays:Ov,makeThickEdgesVertexArrays:kv});const Fv=5e-6;const Cv=(e,t=Fv)=>{const s=zo(e);if(!s.edges_assignment){const e=ts.edges(s)||Js.edges(s);s.edges_assignment=Array(e).fill("U")}let n=[];if(s.faceOrders){n=gd(s)}else if(s.faces_layer){n=pd(s)}const r=Tp(s);const c=lr(s);if(r.faces){const e=rr(r.faces.map);e.forEach(((e,s)=>{const r=n[e];if(!r){return}c.faces_vertices[s].forEach((e=>{const s=y(r.vector,r.layer*t);c.vertices_coords[e]=x(Z(3,c.vertices_coords[e]),s)}))}))}return c};const Sv=(e,{projectionMatrix:t,modelViewMatrix:s,frontColor:n,backColor:r,strokeWidth:c,opacity:o})=>({u_matrix:{func:"uniformMatrix4fv",value:Up(t,s)},u_projection:{func:"uniformMatrix4fv",value:t},u_modelView:{func:"uniformMatrix4fv",value:s},u_frontColor:{func:"uniform3fv",value:yv(n)},u_backColor:{func:"uniform3fv",value:yv(r)},u_strokeWidth:{func:"uniform1f",value:c},u_opacity:{func:"uniform1f",value:o}});const Pv=`#version 300 es\nuniform mat4 u_modelView;\nuniform mat4 u_matrix;\nuniform vec3 u_frontColor;\nuniform vec3 u_backColor;\nin vec3 v_position;\nin vec3 v_normal;\nout vec3 front_color;\nout vec3 back_color;\nvoid main () {\n\tgl_Position = u_matrix * vec4(v_position, 1);\n\tvec3 light = abs(normalize((vec4(v_normal, 1) * u_modelView).xyz));\n\tfloat brightness = 0.5 + light.x * 0.15 + light.z * 0.35;\n\tfront_color = u_frontColor * brightness;\n\tback_color = u_backColor * brightness;\n}\n`;const Vv=`#version 300 es\nuniform mat4 u_matrix;\nuniform mat4 u_projection;\nuniform mat4 u_modelView;\nuniform float u_strokeWidth;\nin vec3 v_position;\nin vec3 v_color;\nin vec3 edge_vector;\nin vec2 vertex_vector;\nout vec3 blend_color;\nvoid main () {\n\tvec3 edge_norm = normalize(edge_vector);\n\t// axis most dissimilar to edge_vector\n\tvec3 absNorm = abs(edge_norm);\n\tvec3 xory = absNorm.x < absNorm.y ? vec3(1,0,0) : vec3(0,1,0);\n\tvec3 axis = absNorm.x > absNorm.z && absNorm.y > absNorm.z ? vec3(0,0,1) : xory;\n\t// two perpendiculars. with edge_vector these make basis vectors\n\tvec3 one = cross(axis, edge_norm);\n\tvec3 two = cross(one, edge_norm);\n\tvec3 displaceNormal = normalize(\n\t\tone * vertex_vector.x + two * vertex_vector.y\n\t);\n\tvec3 displace = displaceNormal * (u_strokeWidth * 0.5);\n\tgl_Position = u_matrix * vec4(v_position + displace, 1);\n\tblend_color = v_color;\n}\n`;const Nv=`#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\nuniform float u_opacity;\nin vec3 front_color;\nin vec3 back_color;\nin vec3 barycentric;\nout vec4 outColor;\nfloat edgeFactor(vec3 barycenter) {\n\tvec3 d = fwidth(barycenter);\n\tvec3 a3 = smoothstep(vec3(0.0), d*3.5, barycenter);\n\treturn min(min(a3.x, a3.y), a3.z);\n}\nvoid main () {\n\tgl_FragDepth = gl_FragCoord.z;\n\tvec3 color = gl_FrontFacing ? front_color : back_color;\n\toutColor = vec4(mix(vec3(0.0), color, edgeFactor(barycentric)), u_opacity);\n}\n`;const zv=`#version 100\nprecision mediump float;\nuniform float u_opacity;\nvarying vec3 barycentric;\nvarying vec3 front_color;\nvarying vec3 back_color;\nvoid main () {\n\tvec3 color = gl_FrontFacing ? front_color : back_color;\n\tvec3 boundary = vec3(0.0, 0.0, 0.0)\n\t// gl_FragDepth = 0.5;\n\tgl_FragColor = any(lessThan(barycentric, vec3(0.02)))\n\t\t? vec4(boundary, u_opacity)\n\t\t: vec4(color, u_opacity);\n}\n`;const Tv=`#version 100\nattribute vec3 v_position;\nattribute vec3 v_normal;\nuniform mat4 u_projection;\nuniform mat4 u_modelView;\nuniform mat4 u_matrix;\nuniform vec3 u_frontColor;\nuniform vec3 u_backColor;\nvarying vec3 normal_color;\nvarying vec3 front_color;\nvarying vec3 back_color;\nvoid main () {\n\tgl_Position = u_matrix * vec4(v_position, 1);\n\tvec3 light = abs(normalize((vec4(v_normal, 1) * u_modelView).xyz));\n\tfloat brightness = 0.5 + light.x * 0.15 + light.z * 0.35;\n\tfront_color = u_frontColor * brightness;\n\tback_color = u_backColor * brightness;\n}\n`;const $v=`#version 100\nattribute vec3 v_position;\nattribute vec3 v_color;\nattribute vec3 edge_vector;\nattribute vec2 vertex_vector;\nuniform mat4 u_matrix;\nuniform mat4 u_projection;\nuniform mat4 u_modelView;\nuniform float u_strokeWidth;\nvarying vec3 blend_color;\nvoid main () {\n\tvec3 edge_norm = normalize(edge_vector);\n\t// axis most dissimilar to edge_vector\n\tvec3 absNorm = abs(edge_norm);\n\tvec3 xory = absNorm.x < absNorm.y ? vec3(1,0,0) : vec3(0,1,0);\n\tvec3 axis = absNorm.x > absNorm.z && absNorm.y > absNorm.z ? vec3(0,0,1) : xory;\n\t// two perpendiculars. with edge_vector these make basis vectors\n\tvec3 one = cross(axis, edge_norm);\n\tvec3 two = cross(one, edge_norm);\n\tvec3 displaceNormal = normalize(\n\t\tone * vertex_vector.x + two * vertex_vector.y\n\t);\n\tvec3 displace = displaceNormal * (u_strokeWidth * 0.5);\n\tgl_Position = u_matrix * vec4(v_position + displace, 1);\n\tblend_color = v_color;\n}\n`;const Bv=`#version 100\nprecision mediump float;\nuniform float u_opacity;\nvarying vec3 front_color;\nvarying vec3 back_color;\nvoid main () {\n\tvec3 color = gl_FrontFacing ? front_color : back_color;\n\tgl_FragColor = vec4(color, u_opacity);\n}\n`;const Lv=`#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\nin vec3 blend_color;\nout vec4 outColor;\n \nvoid main() {\n\toutColor = vec4(blend_color.rgb, 1);\n}\n`;const Iv=`#version 100\nattribute vec3 v_position;\nattribute vec3 v_normal;\nattribute vec3 v_barycentric;\nuniform mat4 u_projection;\nuniform mat4 u_modelView;\nuniform mat4 u_matrix;\nuniform vec3 u_frontColor;\nuniform vec3 u_backColor;\nvarying vec3 normal_color;\nvarying vec3 barycentric;\nvarying vec3 front_color;\nvarying vec3 back_color;\nvoid main () {\n\tgl_Position = u_matrix * vec4(v_position, 1);\n\tbarycentric = v_barycentric;\n\tvec3 light = abs(normalize((vec4(v_normal, 1) * u_modelView).xyz));\n\tfloat brightness = 0.5 + light.x * 0.15 + light.z * 0.35;\n\tfront_color = u_frontColor * brightness;\n\tback_color = u_backColor * brightness;\n}\n`;const Rv=`#version 300 es\nuniform mat4 u_modelView;\nuniform mat4 u_matrix;\nuniform vec3 u_frontColor;\nuniform vec3 u_backColor;\nin vec3 v_position;\nin vec3 v_normal;\nin vec3 v_barycentric;\nin float v_rawEdge;\nout vec3 front_color;\nout vec3 back_color;\nout vec3 barycentric;\n// flat out int rawEdge;\nflat out int provokedVertex;\nvoid main () {\n\tgl_Position = u_matrix * vec4(v_position, 1);\n\tprovokedVertex = gl_VertexID;\n\tbarycentric = v_barycentric;\n\t// rawEdge = int(v_rawEdge);\n\tvec3 light = abs(normalize((vec4(v_normal, 1) * u_modelView).xyz));\n\tfloat brightness = 0.5 + light.x * 0.15 + light.z * 0.35;\n\tfront_color = u_frontColor * brightness;\n\tback_color = u_backColor * brightness;\n}\n`;const Uv=`#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\nuniform float u_opacity;\nin vec3 front_color;\nin vec3 back_color;\nout vec4 outColor;\nvoid main () {\n\tgl_FragDepth = gl_FragCoord.z;\n\tvec3 color = gl_FrontFacing ? front_color : back_color;\n\toutColor = vec4(color, u_opacity);\n}\n`;const qv=`#version 100\nprecision mediump float;\nvarying vec3 blend_color;\nvoid main () {\n\tgl_FragColor = vec4(blend_color.rgb, 1);\n}\n`;const Dv=(e,t=1,s={},n={})=>{const r=Cv(s,n.layerNudge);const c=t===1?iv(e,Tv,Bv):iv(e,Pv,Uv);return{program:c,vertexArrays:Mv(e,c,r,n),elementArrays:wv(e,t,r),flags:[e.DEPTH_TEST],makeUniforms:Sv}};const Wv=(e,t=1,s={},n={})=>{const r=t===1?iv(e,$v,qv):iv(e,Vv,Lv);return{program:r,vertexArrays:kv(e,r,s,n),elementArrays:Ov(e,t,s),flags:[e.DEPTH_TEST],makeUniforms:Sv}};const Gv=(e,t=1,s={},n={})=>{const r=Cv(s,n.layerNudge);const c=t===1?iv(e,Iv,zv):iv(e,Rv,Nv);return{program:c,vertexArrays:Mv(e,c,r,n),elementArrays:wv(e,t,r),flags:[e.DEPTH_TEST],makeUniforms:Sv}};const Hv=Object.freeze({__proto__:null,foldedFormEdges:Wv,foldedFormFaces:Dv,foldedFormFacesOutlined:Gv});const Jv=(e,t=1,s={},n={})=>{const r=[];if(n.faces!==false){if(n.outlines===false){r.push(Dv(e,t,s,n))}else{r.push(Gv(e,t,s,n))}}if(n.edges===true){r.push(Wv(e,t,s,n))}return r};const Qv=e=>e.map((e=>[0,1].map((t=>e[t]||0))));const Zv=(e,t)=>{if(!e||!e.vertices_coords||!e.edges_vertices){return[]}const s=t&&t.dark?hv:bv;const n={...s,...t};const r=Qv(e.edges_vertices.flatMap((t=>t.map((t=>e.vertices_coords[t])))).flatMap((e=>[e,e])));const c=Qv(zn(e));const o=e.edges_assignment?e.edges_assignment.flatMap((e=>[n[e],n[e],n[e],n[e]])):e.edges_vertices.flatMap((()=>[n.U,n.U,n.U,n.U]));const a=c.flatMap((e=>[e,e,e,e]));const i=e.edges_vertices.flatMap((()=>[[1,0],[-1,0],[-1,0],[1,0]]));return{vertices_coords:r,vertices_color:o,verticesEdgesVector:a,vertices_vector:i}};const Yv=Object.freeze({__proto__:null,makeCPEdgesVertexData:Zv});const Xv=(e,t,s,n)=>{if(!s||!s.vertices_coords||!s.edges_vertices){return[]}const{vertices_coords:r,vertices_color:c,verticesEdgesVector:o,vertices_vector:a}=Zv(s,n);return[{location:e.getAttribLocation(t,"v_position"),buffer:e.createBuffer(),type:e.FLOAT,length:2,data:new Float32Array(r.flat())},{location:e.getAttribLocation(t,"v_color"),buffer:e.createBuffer(),type:e.FLOAT,length:c.length?c[0].length:2,data:new Float32Array(c.flat())},{location:e.getAttribLocation(t,"edge_vector"),buffer:e.createBuffer(),type:e.FLOAT,length:o.length?o[0].length:2,data:new Float32Array(o.flat())},{location:e.getAttribLocation(t,"vertex_vector"),buffer:e.createBuffer(),type:e.FLOAT,length:a.length?a[0].length:2,data:new Float32Array(a.flat())}].filter((e=>e.location!==-1))};const Kv=(e,t=1,s={})=>{if(!s||!s.edges_vertices){return[]}const n=s.edges_vertices.map(((e,t)=>t*4)).flatMap((e=>[e+0,e+1,e+2,e+2,e+3,e+0]));return[{mode:e.TRIANGLES,buffer:e.createBuffer(),data:t===2?new Uint32Array(n):new Uint16Array(n)}]};const eh=e=>e.map((e=>[0,1].map((t=>e[t]||0))));const th=(e,t,s)=>{if(!s||!s.vertices_coords){return[]}return[{location:e.getAttribLocation(t,"v_position"),buffer:e.createBuffer(),type:e.FLOAT,length:2,data:new Float32Array(eh(s.vertices_coords).flat())}].filter((e=>e.location!==-1))};const sh=(e,t=1,s={})=>{if(!s||!s.vertices_coords||!s.faces_vertices){return[]}return[{mode:e.TRIANGLES,buffer:e.createBuffer(),data:t===2?new Uint32Array(Sp(s).flat()):new Uint16Array(Sp(s).flat())}]};const nh=Object.freeze({__proto__:null,makeCPEdgesElementArrays:Kv,makeCPEdgesVertexArrays:Xv,makeCPFacesElementArrays:sh,makeCPFacesVertexArrays:th});const rh=(e,{projectionMatrix:t,modelViewMatrix:s,cpColor:n,strokeWidth:r})=>({u_matrix:{func:"uniformMatrix4fv",value:Up(t,s)},u_projection:{func:"uniformMatrix4fv",value:t},u_modelView:{func:"uniformMatrix4fv",value:s},u_cpColor:{func:"uniform3fv",value:yv(n)},u_strokeWidth:{func:"uniform1f",value:r}});const ch=`#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\nin vec3 blend_color;\nout vec4 outColor;\nvoid main() {\n\toutColor = vec4(blend_color.rgb, 1);\n}\n`;const oh=`#version 100\nprecision mediump float;\nvarying vec3 blend_color;\nvoid main () {\n\tgl_FragColor = vec4(blend_color.rgb, 1);\n}\n`;const ah=`#version 300 es\nuniform mat4 u_matrix;\nuniform float u_strokeWidth;\nin vec2 v_position;\nin vec3 v_color;\nin vec2 edge_vector;\nin vec2 vertex_vector;\nout vec3 blend_color;\nvoid main () {\n\tfloat sign = vertex_vector[0];\n\tfloat halfWidth = u_strokeWidth * 0.5;\n\tvec2 side = normalize(vec2(edge_vector.y * sign, -edge_vector.x * sign)) * halfWidth;\n\tgl_Position = u_matrix * vec4(side + v_position, 0, 1);\n\tblend_color = v_color;\n}\n`;const ih=`#version 100\nuniform mat4 u_matrix;\nuniform float u_strokeWidth;\nattribute vec2 v_position;\nattribute vec3 v_color;\nattribute vec2 edge_vector;\nattribute vec2 vertex_vector;\nvarying vec3 blend_color;\nvoid main () {\n\tfloat sign = vertex_vector[0];\n\tfloat halfWidth = u_strokeWidth * 0.5;\n\tvec2 side = normalize(vec2(edge_vector.y * sign, -edge_vector.x * sign)) * halfWidth;\n\tgl_Position = u_matrix * vec4(side + v_position, 0, 1);\n\tblend_color = v_color;\n}\n`;const fh=`#version 100\nuniform mat4 u_matrix;\nuniform vec3 u_cpColor;\nattribute vec2 v_position;\nvarying vec3 blend_color;\nvoid main () {\n\tgl_Position = u_matrix * vec4(v_position, 0, 1);\n\tblend_color = u_cpColor;\n}\n`;const lh=`#version 300 es\nuniform mat4 u_matrix;\nuniform vec3 u_cpColor;\nin vec2 v_position;\nout vec3 blend_color;\nvoid main () {\n\tgl_Position = u_matrix * vec4(v_position, 0, 1);\n\tblend_color = u_cpColor;\n}\n`;const dh=(e,t={},s=undefined)=>{const n=iv(e,fh,oh);return{program:n,vertexArrays:th(e,n,t),elementArrays:sh(e,1,t),flags:[],makeUniforms:rh}};const uh=(e,t={},s=undefined)=>{const n=iv(e,ih,oh);return{program:n,vertexArrays:Xv(e,n,t,s),elementArrays:Kv(e,1,t),flags:[],makeUniforms:rh}};const mh=(e,t={},s=undefined)=>{const n=iv(e,lh,ch);return{program:n,vertexArrays:th(e,n,t),elementArrays:sh(e,2,t),flags:[],makeUniforms:rh}};const gh=(e,t={},s=undefined)=>{const n=iv(e,ah,ch);return{program:n,vertexArrays:Xv(e,n,t,s),elementArrays:Kv(e,2,t),flags:[],makeUniforms:rh}};const ph=Object.freeze({__proto__:null,cpEdgesV1:uh,cpEdgesV2:gh,cpFacesV1:dh,cpFacesV2:mh});const _h=(e,t=1,s={},n=undefined)=>{switch(t){case 1:return[dh(e,s,n),uh(e,s,n)];case 2:default:return[mh(e,s,n),gh(e,s,n)]}};const vh=Object.assign(Object.create(null),{createProgram:iv,initialize:fv,foldedForm:Jv,creasePattern:_h},mv,vv,jv,xv,Hv,nh,Yv,ph);const hh=({vertices_coords:e,edges_vertices:t})=>{const s=t.map((t=>t.map((t=>e[t])))).map((e=>I(...e)));const n=s.reduce(((e,t)=>Math.min(e,t)),Infinity);return n===Infinity?undefined:n};const bh=({vertices_coords:e,edges_vertices:t})=>{const s=hh({vertices_coords:e,edges_vertices:t});if(s){return Math.max(s*1e-4,1e-10)}const n=go({vertices_coords:e});return n&&n.span?Math.max(1e-6*Math.max(...n.span),1e-10):1e-6};const yh=e=>rr(rr(e).reverse());const Eh=(e,t)=>{const s=[];const n=od(e);const r=e.edges_faces?e.edges_faces:jn(e);r.forEach(((e,r)=>{if(e.length===1){s[r]="B"}if(e.length===2){const c=e.map((e=>n[e]));if(c[0]===c[1]){s[r]="F";return}const o=e.map((e=>t[e]));const a=o[0]<o[1];const i=c[0]?a:!a;s[r]=i?"V":"M"}}));return s};const Ah=e=>{const t=[];e.forEach((e=>{t[e[0]]=undefined;t[e[1]]=undefined}));const s=t.map((()=>[]));e.forEach((([e,t,n])=>{s[e][t]=n;s[t][e]=-n}));return s};const xh=Object.freeze({__proto__:null,faceOrdersToMatrix:Ah,facesLayerToEdgesAssignments:Eh,flipFacesLayer:yh,makeEpsilon:bh});const Mh={taco_taco:e=>[[e[0],e[2]],[e[1],e[3]],[e[1],e[2]],[e[0],e[3]],[e[0],e[1]],[e[2],e[3]]],taco_tortilla:e=>[[e[0],e[2]],[e[0],e[1]],[e[1],e[2]]],tortilla_tortilla:e=>[[e[0],e[2]],[e[1],e[3]]],transitivity:e=>[[e[0],e[1]],[e[1],e[2]],[e[2],e[0]]]};const wh=e=>e[0]<e[1]?`${e[0]} ${e[1]}`:`${e[1]} ${e[0]}`;const kh={taco_taco:e=>[wh([e[0],e[2]]),wh([e[1],e[3]]),wh([e[1],e[2]]),wh([e[0],e[3]]),wh([e[0],e[1]]),wh([e[2],e[3]])],taco_tortilla:e=>[wh([e[0],e[2]]),wh([e[0],e[1]]),wh([e[1],e[2]])],tortilla_tortilla:e=>[wh([e[0],e[2]]),wh([e[1],e[3]])],transitivity:e=>[wh([e[0],e[1]]),wh([e[1],e[2]]),wh([e[2],e[0]])]};const Oh={0:0,1:1,2:-1};const jh=(e,t)=>{const s=Object.keys(e);const n=s.map((e=>e.split(" ").map((e=>parseInt(e,10)))));n.forEach(((n,r)=>{const c=Oh[e[s[r]]];const o=!t[n[1]]?-c:c;n.push(o)}));return n};const Fh=Object.freeze({__proto__:null,constraintToFacePairs:Mh,constraintToFacePairsStrings:kh,solverSolutionToFaceOrders:jh});const Ch=({taco_taco:e,taco_tortilla:t,tortilla_tortilla:s,transitivity:n})=>{const r={};r.taco_taco=e.map((e=>[e[0][0],e[1][0],e[0][1],e[1][1]]));r.taco_tortilla=t.map((e=>[e.taco[0],e.tortilla,e.taco[1]]));r.tortilla_tortilla=s.map((e=>[e[0][0],e[0][1],e[1][0],e[1][1]]));r.transitivity=n.map((e=>[e[0],e[1],e[2]]));return r};const Sh=e=>{const t={};Object.keys(e).forEach((e=>{t[e]={}}));Object.keys(e).forEach((s=>{e[s].forEach(((e,n)=>kh[s](e).forEach((e=>{if(t[s][e]===undefined){t[s][e]=[]}t[s][e].push(n)}))))}));return t};const Ph=({vertices_coords:e,edges_vertices:t,edges_faces:s,faces_center:n})=>{const r=t.map((t=>e[t[0]]));const c=t.map((t=>O(e[t[1]],e[t[0]])));return s.map(((e,t)=>e.map((e=>B(O(n[e],r[t]),c[t]))).map((e=>Math.sign(e)))))};const Vh=({vertices_coords:e,edges_vertices:t,faces_center:s},n,r)=>{const c=n.map((s=>t[s[0]].map((t=>e[t]))));const o=c.map((e=>e[0]));const a=c.map((e=>O(e[1],e[0])));const i=r.map((e=>e.map((e=>e.map((e=>s[e]))))));return i.map(((e,t)=>e.map((e=>e.map((e=>B(O(e,o[t]),a[t]))).map((e=>Math.sign(e)))))))};const Nh=e=>{if(e[0]===1&&e[1]===-1||e[0]===-1&&e[1]===1){return"both"}if(e[0]===1&&e[1]===1){return"right"}if(e[0]===-1&&e[1]===-1){return"left"}return undefined};const zh=e=>e[0]===e[1]&&e[0]!=="both";const Th=e=>e[0]===e[1]&&e[0]==="both";const $h=e=>e[0]!==e[1]&&(e[0]==="both"||e[1]==="both");const Bh=(e,t,s)=>{const n=t[0]==="left"||t[1]==="left"?-1:1;const r=t[0]==="both"?[...e[1]]:[...e[0]];const c=t[0]==="both"?0:1;const o=s[c][0]===n?e[c][0]:e[c][1];return{taco:r,tortilla:o}};const Lh=(e,t)=>{if(e===undefined){return undefined}return t[0][0]===t[1][0]?e:[e[0],[e[1][1],e[1][0]]]};const Ih=(e,t,s)=>{const n=t.map((e=>e.length===2&&e[0]!==e[1])).map(((e,t)=>e?t:undefined)).filter((e=>e!==undefined));const r=[];n.forEach((e=>{r[e]=s[e]}));const c=r.map(((t,s)=>t.map((t=>[e[s],[t,t]])))).reduce(((e,t)=>e.concat(t)),[]);return c};const Rh=({vertices_coords:e,edges_vertices:t,edges_faces:s,faces_vertices:n,faces_center:r,edges_vector:c},o=a)=>{if(!r){r=Wn({vertices_coords:e,faces_vertices:n})}const i=Ph({vertices_coords:e,edges_vertices:t,edges_faces:s,faces_center:r});const f=m_({vertices_coords:e,edges_vertices:t,edges_vector:c},o);const l=v_({vertices_coords:e,edges_vertices:t,edges_faces:s,faces_vertices:n},o);const d=io(f).filter((e=>e.map((e=>s[e].length>1)).reduce(((e,t)=>e&&t),true)));const u=d.map((e=>e.map((e=>s[e]))));const m=Vh({vertices_coords:e,edges_vertices:t,faces_center:r},d,u);const g=m.map((e=>e.map(Nh)));const p=g.map(((e,t)=>zh(e)?u[t]:undefined)).filter((e=>e!==undefined));const _=g.map(((e,t)=>Th(e)?u[t]:undefined)).map(((e,t)=>Lh(e,m[t]))).filter((e=>e!==undefined));const v=Ih(s,i,l);const h=_.concat(v);const b=g.map(((e,t)=>$h(e)?Bh(u[t],g[t],m[t]):undefined)).filter((e=>e!==undefined));const y=l.map(((e,t)=>i[t].length>1&&i[t][0]===i[t][1]?e:[]));const E=y.map(((e,t)=>({taco:s[t],tortillas:e}))).filter((e=>e.tortillas.length));const A=E.flatMap((e=>e.tortillas.map((t=>({taco:[...e.taco],tortilla:t})))));const x=b.concat(A);return{taco_taco:p,tortilla_tortilla:h,taco_tortilla:x}};const Uh=({faces_polygon:e},t,s=a)=>{const n=t.map((()=>[]));t.forEach(((e,t)=>e.forEach((e=>{n[t][e]=true;n[e][t]=true}))));const r=[];t.forEach(((t,n)=>t.forEach((t=>{const c=eu(e[n],e[t],s);if(c){if(!r[n]){r[n]=[]}if(!r[t]){r[t]=[]}r[n][t]=c;r[t][n]=c}}))));const c=[];for(let t=0;t<r.length-1;t+=1){if(!r[t]){continue}for(let o=t+1;o<r.length;o+=1){if(!r[t][o]){continue}for(let a=o+1;a<r.length;a+=1){if(t===a||o===a){continue}if(!n[t][a]||!n[o][a]){continue}const i=eu(r[t][o],e[a],s);if(i){c.push([t,o,a].sort(((e,t)=>e-t)))}}}}return c};const qh=(e,{taco_taco:t,taco_tortilla:s})=>{const n={};t.map((e=>[e[0][0],e[0][1],e[1][0],e[1][1]].sort(((e,t)=>e-t)))).forEach((e=>[`${e[0]} ${e[1]} ${e[2]}`,`${e[0]} ${e[1]} ${e[3]}`,`${e[0]} ${e[2]} ${e[3]}`,`${e[1]} ${e[2]} ${e[3]}`].forEach((e=>{n[e]=true}))));s.map((e=>[e.taco[0],e.taco[1],e.tortilla].sort(((e,t)=>e-t)).join(" "))).forEach((e=>{n[e]=true}));return e.filter((e=>n[e.join(" ")]===undefined))};const Dh=Object.freeze({__proto__:null,filterTransitivity:qh,makeTransitivity:Uh});const Wh=({vertices_coords:e,edges_vertices:t,edges_faces:s,faces_vertices:n,faces_edges:r,edges_vector:c},o=a)=>{const i=od({vertices_coords:e,faces_vertices:n});const f=Un({vertices_coords:e,faces_vertices:n},o);i.map(((e,t)=>e?undefined:t)).filter((e=>e!==undefined)).forEach((e=>f[e].reverse()));const l=b_({vertices_coords:e,faces_vertices:n},o);const{taco_taco:d,taco_tortilla:u,tortilla_tortilla:m}=Rh({vertices_coords:e,edges_vertices:t,edges_faces:s,faces_vertices:n,faces_edges:r,edges_vector:c},o);const g=Uh({faces_polygon:f},l,o);const p=qh(g,{taco_taco:d,taco_tortilla:u});const _=io(l).map((e=>e.join(" ")));const v=Ch({taco_taco:d,taco_tortilla:u,tortilla_tortilla:m,transitivity:p});const h=Sh(v);return{constraints:v,lookup:h,facePairs:_,faces_winding:i}};const Gh=Object.freeze({__proto__:null,setup:Wh});const Hh=({edges_faces:e,edges_assignment:t},s,n)=>{const r={0:0,1:2,2:1};const c={M:1,m:1,V:2,v:2};const o={};s.forEach((e=>{o[e]=true}));const a={};e.forEach(((e,s)=>{const i=t[s];const f=c[i];if(e.length<2||f===undefined){return}const l=n[e[0]];const d=l?f:r[f];const u=`${e[0]} ${e[1]}`;const m=`${e[1]} ${e[0]}`;if(u in o){a[u]=d}if(m in o){a[m]=r[d]}}));return a};const Jh=["111112","111121","111222","112111","121112","121222","122111","122212","211121","211222","212111","212221","221222","222111","222212","222221"];const Qh=["112","121","212","221"];const Zh=["11","22"];const Yh=["112","121","122","211","212","221"];const Xh=(e,t,s)=>{const n=Array.from(s).map((e=>parseInt(e,10)));if(n.filter((e=>e===0)).length!==t){return}e[t][s]=false;let r=false;for(let s=0;s<n.length;s+=1){const c=[];if(n[s]!==0){continue}for(let r=1;r<=2;r+=1){n[s]=r;if(e[t-1][n.join("")]!==false){c.push([s,r])}}n[s]=0;if(c.length>0&&r===false){r=[]}if(c.length===1){r.push(c[0])}}if(r!==false&&r.length===0){r=true}e[t][s]=r};const Kh=e=>{const t=e[0].length;const s=Array.from(Array(t+1)).map((()=>({})));Array.from(Array(2**t)).map(((e,t)=>t.toString(2))).map((e=>Array.from(e).map((e=>parseInt(e,10)+1)).join(""))).map((e=>`11111${e}`.slice(-t))).forEach((e=>{s[0][e]=false}));e.forEach((e=>{s[0][e]=true}));Array.from(Array(t)).map(((e,t)=>t+1)).map((e=>Array.from(Array(3**t)).map(((e,t)=>t.toString(3))).map((e=>`000000${e}`.slice(-t))).forEach((t=>Xh(s,e,t)))));let n=[];Array.from(Array(t+1)).map(((e,s)=>t-s)).forEach((e=>{const t=[];Object.keys(s[e]).forEach((n=>{let r=s[e][n];if(r.constructor===Array){r=r[0]}t.push([n,r])}));n=n.concat(t)}));n.sort(((e,t)=>parseInt(e[0],10)-parseInt(t[0],10)));const r={};n.forEach((e=>{r[e[0]]=Object.freeze(e[1])}));return Object.freeze(r)};const eb={taco_taco:Kh(Jh),taco_tortilla:Kh(Qh),tortilla_tortilla:Kh(Zh),transitivity:Kh(Yh)};const tb=Object.freeze(Object.keys(eb));const sb=(e,t,...s)=>{const n={0:0,1:2,2:1};const r=Mh[e](t);const c=r.map((e=>e[1]<e[0]));const o=r.map(((e,t)=>c[t]?`${e[1]} ${e[0]}`:`${e[0]} ${e[1]}`));const a=o.map(((e,t)=>{for(let r=0;r<s.length;r+=1){if(s[r][e]){return c[t]?n[s[r][e]]:s[r][e]}}return 0})).join("");if(eb[e][a]===true||eb[e][a]===false){return eb[e][a]}const i=eb[e][a];const f=o[i[0]];const l=c[i[0]]?n[i[1]]:i[1];return[f,l]};const nb=(e,t,s)=>{const n={};tb.forEach((r=>{const c=s.flatMap((e=>t[r][e]));n[r]=cs(c).filter((t=>e[r][t]))}));return n};const rb=(e,t,s,...n)=>{let r=s;const c={};do{const s=nb(e,t,r);const o={};for(let t=0;t<tb.length;t+=1){const r=tb[t];const a=s[r];for(let t=0;t<a.length;t+=1){const s=sb(r,e[r][a[t]],...n,c);if(s===true){continue}if(s===false){throw new Error(`invalid ${r} ${a[t]}:${e[r][a[t]]}`)}if(c[s[0]]){if(c[s[0]]!==s[1]){throw new Error(`conflict ${r} ${a[t]}:${e[r][a[t]]}`)}}else{const[e,t]=s;o[e]=true;c[s[0]]=t}}}r=Object.keys(o)}while(r.length);return c};const cb=(e,t,s)=>{const n=Object.keys(t);const r={};e.forEach((e=>{r[e]=true}));let c=0;const o=[];while(c<e.length){if(!r[e[c]]){c+=1;continue}const a=[];const i=[e[c]];const f={[e[c]]:true};do{const e=i.pop();delete r[e];a.push(e);const c={};n.forEach((n=>{const r=s[n][e];if(!r){return}r.map((e=>t[n][e])).map((e=>kh[n](e).forEach((e=>{c[e]=true}))))}));const o=Object.keys(c).filter((e=>r[e])).filter((e=>!f[e]));i.push(...o);o.forEach((e=>{f[e]=true}))}while(i.length);c+=1;o.push(a)}return o};const ob=(e,t,s,...n)=>{if(!s.length){return[]}const r=s[0];const c=[];const o=[];[1,2].forEach((a=>{let i;try{i=rb(e,t,[r],...n,{[r]:a})}catch(e){return}i[r]=a;if(Object.keys(i).length===s.length){c.push(i)}else{o.push(i)}}));const a=o.map((r=>ob(e,t,s.filter((e=>!(e in r))),...n,r)));return c.map((e=>[...n,e])).concat(...a)};const ab=({constraints:e,lookup:t,facePairs:n,orders:r})=>{let c;try{c=rb(e,t,Object.keys(r),r)}catch(e){throw new Error(s.noLayerSolution,{cause:e})}const o=n.filter((e=>!(e in r))).filter((e=>!(e in c)));let a;try{a=cb(o,e,t).map((s=>ob(e,t,s,r,c)))}catch(e){throw new Error(s.noLayerSolution,{cause:e})}const i={...r,...c};const f=a.map((e=>e.map((e=>Object.assign({},...e)))));return{root:i,branches:f}};const ib=e=>{const t=e.reduce(((e,t)=>e*t),1);const s=e.slice();for(let e=s.length-2;e>=0;e-=1){s[e]*=s[e+1]}s.push(1);s.shift();return Array.from(Array(t)).map(((t,n)=>e.map(((e,t)=>Math.floor(n/s[t])%e))))};const fb={count:function(){return this.branches.map((e=>e.length))},faceOrders:function(...e){return jh(this.compile(...e),this.faces_winding)},facesLayer:function(...e){return rr(this.linearize(...e).reverse())},compile:function(...e){const t=Array(this.branches.length).fill(0).map(((t,s)=>e[s]!=null?e[s]:t));const s=this.branches?this.branches.map(((e,s)=>e[t[s]])):[];return Object.assign({},this.root,...s)},directedPairs:function(...e){const t=this.compile(...e);return Object.keys(t).map((e=>t[e]===1?e.split(" "):e.split(" ").reverse())).map((e=>e.map((e=>parseInt(e,10)))))},linearize:function(...e){return id(this.directedPairs(...e))},allSolutions:function(){return ib(this.count()).map((e=>this.compile(...e)))},allFacesLayers:function(){return ib(this.count()).map((e=>this.facesLayer(...e)))}};const lb=()=>({root:{},branches:[],faces_winding:[]});const db=({vertices_coords:e,edges_vertices:t,edges_faces:s,edges_assignment:n,faces_vertices:r,faces_edges:c,edges_vector:o},a)=>{if(!e||!t||!r){return Object.assign(Object.create(fb),lb())}if(!c){c=In({edges_vertices:t,faces_vertices:r})}if(!s){s=On({edges_vertices:t,faces_edges:c})}if(a===undefined){a=bh({vertices_coords:e,edges_vertices:t})}const{constraints:i,lookup:f,facePairs:l,faces_winding:d}=Wh({vertices_coords:e,edges_vertices:t,edges_faces:s,faces_vertices:r,faces_edges:c,edges_vector:o},a);const u=Hh({edges_faces:s,edges_assignment:n},l,d);const{root:m,branches:g}=ab({constraints:i,lookup:f,facePairs:l,orders:u});return Object.assign(Object.create(fb),{root:m,branches:g,faces_winding:d})};const ub=(e,t,s=a)=>{const n=e[0]<e[1]?e:[e[1],e[0]];const r=t[0]<t[1]?t:[t[1],t[0]];const c=Math.min(n[1],r[1])-Math.max(n[0],r[0]);return c>s};const mb=({vertices_coords:e,edges_vertices:t},s,n,r=a)=>{const c=s.map((s=>t[s].map((t=>e[t]))));const o=c.map((e=>e.map((e=>F(e,n)))));const i=ub(...o,r);return i};const gb=(e,t)=>{if(e.orders){e.orders=e.orders.flatMap((e=>jh(e,t)))}if(e.leaves){e.leaves=e.leaves.map((e=>jh(e,t)))}if(e.partitions){e.partitions.forEach((e=>gb(e,t)))}if(e.node){e.node.forEach((e=>gb(e,t)))}return e};const pb=Object.freeze({__proto__:null,doEdgesOverlap:mb,doRangesOverlap:ub,reformatSolution:gb});const _b=({vertices_coords:e,edges_vertices:t},s=a)=>{const{lines:n,edges_line:r}=rc({vertices_coords:e,edges_vertices:t},s);const c=r.map((e=>n[e].vector));const o=Nn({vertices_coords:e,edges_vertices:t}).map(((e,t)=>e.map((e=>F(c[t],e)))));return rr(r).map((e=>e.constructor===Array?e:[e])).flatMap((e=>fs(e).filter((e=>ub(...e.map((e=>o[e])))))))};const vb=({vertices_coords:e,edges_vertices:t,edges_faces:s,edges_foldAngle:n,faces_center:r},c,o,i,f=a)=>{const l=n.map(jt);const d=_b({vertices_coords:e,edges_vertices:t},f).map((e=>e[0]<e[1]?e:e.slice().reverse())).filter((e=>!(l[e[0]]&&l[e[1]]))).filter((e=>e.map((e=>s[e].length===2)).reduce(((e,t)=>e&&t),true))).filter((e=>e.map((e=>c[e]!==undefined)).reduce(((e,t)=>e&&t),true))).filter((e=>Array.from(new Set(e.flatMap((e=>c[e])))).length!==4));const u=d.map((e=>e.map((e=>c[e]))));const m=u.map((e=>Array.from(new Set(e.flat()))));const g=u.map(((e,t)=>{const s={};e.flat().forEach((e=>{s[e]=[]}));e.forEach(((e,n)=>e.forEach((e=>s[e].push(d[t][n])))));return s}));const p=d.map((e=>e.map((e=>s[e]))));const _=p.map(((e,t)=>{const s={};m[t].forEach((e=>{s[e]=[]}));e.flat().forEach((e=>s[o[e]].push(e)));return s}));const v=Nn({vertices_coords:e,edges_vertices:t});const h=m.map(((e,t)=>{const s=v[d[t][0]];const n={};e.forEach((e=>{n[e]=s.map((t=>Ip(i[e],t))).map((e=>[e[0],e[1]]))}));return n}));const b=_.map(((e,t)=>{const s={};m[t].forEach((n=>{const c=h[t][n][0];s[n]=e[n].map((e=>B(O(r[e],c),O(h[t][n][1],c)))).map((e=>Math.sign(e)))}));return s}));const y=b.map(((e,t)=>{const s={};m[t].forEach((t=>{s[t]=e[t].reduce(((s,n)=>s&&n===e[t][0]),true)}));return s}));const E=d.map(((e,t)=>{const s={};Object.keys(g[t]).forEach((e=>{s[e]={edges:g[t][e],faces:_[t][e],facesSides:b[t][e],facesSameSide:y[t][e]}}));return{edges:e,sets:s}}));const A=E.filter((e=>{const t=Object.values(e.sets).map((e=>e.faces.length===2)).reduce(((e,t)=>e&&t),true);const s=Object.values(e.sets).map((e=>e.facesSameSide)).reduce(((e,t)=>e&&t),true);return t&&s}));const x=E.filter((e=>{const t=Object.values(e.sets).length===3;const s=Object.values(e.sets).map((e=>e.facesSameSide)).reduce(((e,t)=>e&&t),true);return t&&s}));const M=E.filter((e=>{const t=Object.values(e.sets).map((e=>e.faces.length===2)).reduce(((e,t)=>e&&t),true);const s=Object.values(e.sets).map((e=>e.facesSameSide));const n=s[0]!==s[1];return t&&n}));const w=E.filter((e=>{const t=Object.values(e.sets).filter((e=>e.faces.length===3)).shift();const n=t!==undefined;if(!n){return false}const r=t.facesSides.reduce(((e,t)=>e+t),0);const c=Math.abs(r)===1;if(!c){return false}const o=t.faces.filter(((e,s)=>t.facesSides[s]===r));const a=t.edges.map((e=>s[e].map((e=>o.includes(e))).reduce(((e,t)=>e&&t),true))).reduce(((e,t)=>e||t),false);const i=!a;return n&&c&&i}));if(w.length){console.log("This model contains the third case",w)}return{tortillaTortillaEdges:A,solvable1:x,solvable2:M,solvable3:[]}};const hb=({edges_faces:e},t,s,n)=>{const r=t.map((e=>e.edges)).map((t=>t.map((t=>e[t].slice()))));r.forEach(((e,t)=>{if(s[e[0][0]]!==s[e[1][0]]){r[t][1].reverse()}}));r.map((e=>[e[0][0],e[0][1]])).map((e=>e.map((e=>n[e])))).map(((e,t)=>e[0]!==e[1]?t:undefined)).filter((e=>e!==undefined)).forEach((e=>{const t=r[e][0][1];r[e][0][1]=r[e][1][1];r[e][1][1]=t}));return r};const bb=(e,t,s=a)=>{const n=t.map((t=>Cr(e,t,ot,s))).reduce(((e,t)=>e||t),false);if(n){return true}const r=Kd(e,{vector:O(t[1],t[0]),origin:t[0]},ot,ut,s);return r!==undefined};const yb=({vertices_coords:e,edges_vertices:t,edges_faces:s,edges_foldAngle:n},r,c,o,i,f,l,d,u=a)=>{const m=o.slice();m.forEach(((e,t)=>{if(e.length<2){delete m[t]}}));const g=s.map((e=>{const t={};e.forEach((e=>{t[e]=true}));return t}));const p=d.map((e=>e.filter((e=>m[e]!==undefined)).map((e=>m[e]))));d.map(((e,t)=>t)).filter((e=>p[e].length<2)).forEach((e=>delete p[e]));const _=p.map(((e,t)=>e.map((e=>e.filter((e=>g[t][e]))))));const v=p.map(((e,t)=>e.map((e=>e.filter((e=>!g[t][e]))))));const h=p.map(((s,n)=>t[n].map((t=>e[t]))));const b=v.map(((e,t)=>e.map((e=>e.map((e=>{const s=h[t].map((t=>Ip(c[i[e]],t)));const n=s.map((e=>[e[0],e[1]]));return bb(f[e],n,u)?e:undefined})).filter((e=>e!==undefined))))));const y=p.flatMap(((e,t)=>b[t].flatMap(((e,s)=>{const n=1-s;const r=_[t];return e.map((e=>({edge:t,faces:[r[s][0],r[n][0]],overlap:e,set:i[e]})))}))));const E=y.map((e=>[e.faces[0],e.overlap]));const A=E.map((e=>e[0]<e[1]));A.forEach(((e,t)=>{if(!e){E[t].reverse()}}));const x=y.map((e=>l[e.faces[0]]));const M=y.map((e=>n[e.edge])).map(Math.sign).map((e=>e===1));const w=y.map(((e,t)=>x[t]^M[t]));const k=w.map(((e,t)=>A[t]?e:1-e)).map((e=>e+1));const O={};E.forEach(((e,t)=>{O[e.join(" ")]=k[t]}));return O};const Eb=({edges_foldAngle:e,faces_winding:t},s,n)=>{const r=s.map((t=>t.map((t=>e[t]))));const c=n.map((e=>e.map((e=>t[e]))));const o=r.map(((e,t)=>e.map(((e,s)=>c[t][s]?e:-e))));const a=o.map((e=>e[0]>e[1]));const i=n.map((e=>e[0]<e[1]));const f=n.map(((e,t)=>a[t]^i[t]));const l={};const d=n.map(((e,t)=>i[t]?e:e.slice().reverse())).map((e=>e.join(" ")));f.map((e=>e+1)).forEach(((e,t)=>{l[d[t]]=e}));return l};const Ab=({edges_foldAngle:e,faces_winding:t},s)=>{const n=s.map((e=>Object.values(e.sets).sort(((e,t)=>t.faces.length-e.faces.length)).shift()));const r=n.map((e=>e.edges));const c=n.map((e=>e.faces));return Eb({edges_foldAngle:e,faces_winding:t},r,c)};const xb=({edges_foldAngle:e,faces_winding:t},s)=>{const n=s.map((e=>Object.values(e.sets).filter((e=>e.facesSameSide)).shift()));const r=n.map((e=>e.edges));const c=n.map((e=>e.faces));return Eb({edges_foldAngle:e,faces_winding:t},r,c)};const Mb=({edges_foldAngle:e,faces_winding:t},s)=>({});const wb=({edges_foldAngle:e,faces_winding:t},s,n,r)=>{const c=Ab({edges_foldAngle:e,faces_winding:t},s);const o=xb({edges_foldAngle:e,faces_winding:t},n);const a=Mb({edges_foldAngle:e,faces_winding:t});return{...c,...o,...a}};const kb=(e,t,s)=>{const n=(e,t)=>{const s=Ip(e,t);return[s[0],s[1]]};const r=e.vertices_coords.map((e=>Z(3,e)));const c=t.map((t=>so(e,t)));s.forEach(((e,t)=>{c[t].vertices_coords=c[t].vertices_coords.map(((t,s)=>n(e,r[s])))}));const o=e.edges_foldAngle.map(jt).map(((e,t)=>!e?t:undefined)).filter((e=>e!==undefined));const a=St(e,"edges");c.forEach((e=>o.forEach((t=>a.forEach((s=>{delete e[s][t]}))))));return c};const Ob=Object.freeze({__proto__:null,graphGroupCopies:kb});const jb=({edges_vertices:e,faces_edges:t},s)=>{const n=e.map((()=>({})));s.forEach(((e,s)=>t[s].forEach((t=>{n[t][e]=true}))));const r=n.map((e=>Object.keys(e).map((e=>parseInt(e,10))).sort(((e,t)=>e-t))));return r};const Fb=({vertices_coords:e,edges_vertices:t,edges_faces:s,edges_foldAngle:n,faces_edges:r,faces_winding:c,faces_center:o},a,i,f,l,d,u,m)=>{const g=u.map((e=>f[e[0]]));const p=rr(g).map((e=>e.constructor===Array?e:[e]));const _=p.map((e=>e.map((e=>d[e]))));const v=jb({edges_vertices:t,faces_edges:r},f);v.map(((e,t)=>e.length!==2?t:undefined)).filter((e=>e!==undefined)).forEach((e=>delete v[e]));const{tortillaTortillaEdges:h,solvable1:b,solvable2:y,solvable3:E}=vb({vertices_coords:e,edges_vertices:t,edges_faces:s,edges_foldAngle:n,faces_center:o},v,f,i,m);const A=hb({edges_faces:s},h,f,c);const x=yb({vertices_coords:e,edges_vertices:t,edges_faces:s,edges_foldAngle:n},_,i,a,f,l,c,v,m);const M=wb({edges_foldAngle:n,faces_winding:c},b,y);const w={...x,...M};return{tortillas3D:A,orders:w}};const Cb=({vertices_coords:e,edges_vertices:t,edges_faces:s,edges_assignment:n,edges_foldAngle:r,faces_vertices:c,faces_edges:o,faces_faces:i},f=a)=>{if(!o){o=In({edges_vertices:t,faces_vertices:c})}if(!s){s=On({edges_vertices:t,faces_edges:o})}if(!i){i=Rn({faces_vertices:c})}if(!r&&n){r=Pn({edges_assignment:n})}if(!n){n=Cn({edges_foldAngle:r})}const{sets_faces:l,sets_transformXY:d,faces_set:u,faces_winding:m}=l_({vertices_coords:e,faces_vertices:c,faces_faces:i},f);const g=kb({vertices_coords:e,edges_vertices:t,edges_faces:s,edges_assignment:n,edges_foldAngle:r,faces_vertices:c,faces_edges:o,faces_faces:i},l,d);const p=ns(...g.map((e=>Un(e,f))));m.map(((e,t)=>e?undefined:t)).filter((e=>e!==undefined)).forEach((e=>p[e].reverse()));const _=ns(...g.map((e=>b_(e,f))));const v=p.map((e=>T(...e)));g.forEach((e=>{e.faces_center=e.faces_vertices.map(((e,t)=>v[t]))}));const h=g.map((e=>Rh(e,f)));const b=h.flatMap((e=>e.taco_taco));const y=h.flatMap((e=>e.taco_tortilla));const E=h.flatMap((e=>e.tortilla_tortilla));const A=Uh({faces_polygon:p},_,f);const x=qh(A,{taco_taco:b,taco_tortilla:y});const M=io(_);const w=M.map((e=>e.join(" ")));const{tortillas3D:k,orders:O}=Fb({vertices_coords:e,edges_vertices:t,edges_faces:s,edges_foldAngle:r,faces_edges:o,faces_winding:m,faces_center:v},l,d,u,p,w,M,f);E.push(...k);const j=Ch({taco_taco:b,taco_tortilla:y,tortilla_tortilla:E,transitivity:x});const F=Sh(j);g.map((e=>Hh(e,w,m))).forEach((e=>Object.assign(O,e)));return{constraints:j,lookup:F,facePairs:w,faces_winding:m,orders:O}};const Sb=Object.freeze({__proto__:null,setup:Cb});const Pb=()=>({root:{},branches:[],faces_winding:[]});const Vb=({vertices_coords:e,edges_vertices:t,edges_faces:s,edges_assignment:n,edges_foldAngle:r,faces_vertices:c,faces_edges:o,faces_faces:a},i)=>{if(!e||!t||!c){return Object.assign(Object.create(fb),Pb())}if(i===undefined){i=bh({vertices_coords:e,edges_vertices:t})}const{constraints:f,lookup:l,facePairs:d,faces_winding:u,orders:m}=Cb({vertices_coords:e,edges_vertices:t,edges_faces:s,edges_assignment:n,edges_foldAngle:r,faces_vertices:c,faces_edges:o,faces_faces:a},i);const{root:g,branches:p}=ab({constraints:f,lookup:l,facePairs:d,orders:m});return Object.assign(Object.create(fb),{root:g,branches:p,faces_winding:u})};const Nb=(e,t,s)=>{const n=e.map((e=>e?(e[0]+e[1])/2:undefined));const r=[];e.forEach(((c,o)=>{if(!c){return}if(!t&&o===e.length-1){return}const a=c[1];const i=a-s*2;const f=a+s*2;const l=[o,(o+1)%e.length];const d=l.map((e=>n[e])).map((e=>e>a));const u=(!d[0]&&!d[1])*1+(d[0]&&d[1])*2;const m=r.filter((e=>e.min<a&&e.max>a)).shift();const g={faces:l,taco_type:u};if(m){m.pairs.push(g)}else{r.push({min:i,max:f,pairs:[g]})}}));return r.map((e=>e.pairs)).filter((e=>e.length>1)).map((e=>({both:e.filter((e=>e.taco_type===0)).map((e=>e.faces)),left:e.filter((e=>e.taco_type===1)).map((e=>e.faces)),right:e.filter((e=>e.taco_type===2)).map((e=>e.faces))})))};const zb=(e,t,s)=>t<s?e.slice(t+1,s):e.slice(s+1,t);const Tb=(e,t,s=true,n=a)=>{const r=rr(t);const c=e.map((e=>e?e[1]:undefined));const o=e.map((e=>e?Math.min(...e):undefined)).map((e=>e+n));const i=e.map((e=>e?Math.max(...e):undefined)).map((e=>e-n));const f=r.length+(s?0:-1);for(let e=0;e<f;e+=1){const s=(e+1)%r.length;if(r[e]===r[s]){continue}const n=zb(t,r[e],r[s]).flat();const a=n.map((t=>c[e]<o[t])).reduce(((e,t)=>e&&t),true);const f=n.map((t=>c[e]>i[t])).reduce(((e,t)=>e&&t),true);if(!a&&!f){return false}}return true};const $b=e=>{const t=os(e);const s={};let n=0;for(let e=0;e<t.length;e+=1){if(s[t[e]]===undefined){n+=1;s[t[e]]=n}else if(s[t[e]]!==undefined){if(s[t[e]]!==n){return false}n-=1;s[t[e]]=undefined}}return true};const Bb=(e,t)=>e.map((e=>t[e])).filter((e=>e!==undefined));const Lb=(e,t,s,n,r)=>{const c=t.flat();if(!Tb(e,t,n,r)){return false}for(let e=0;e<s.length;e+=1){const t=Bb(c,s[e]);if(!$b(t)){return false}}return true};const Ib={V:true,v:true,M:true,m:true};const Rb=e=>{let t=0;const s=e.slice(1);return[false].concat(s.map((e=>Ib[e]?++t:t)).map((e=>e%2===1)))};const Ub={V:1,v:1,M:-1,m:-1};const qb=(e,t)=>t%2===0?Ub[e]||0:-(Ub[e]||0);const Db=e=>{let t=0;return e.slice(1).concat([e[0]]).map((e=>{const s=qb(e,t);t+=Ub[e]===undefined?0:1;return s}))};const Wb=(e,t)=>{const s=Rb(t).map(((t,s)=>e[s]*(t?-1:1)));const n=e.map((()=>undefined));n[0]=[0,s[0]];for(let r=1;r<e.length;r+=1){if(t[r]==="B"||t[r]==="b"){break}const c=(r-1+e.length)%e.length;const o=n[c][1];n[r]=[o,o+s[r]]}return n};const Gb={B:true,b:true};const Hb=(e,t,s=a)=>{const n=Wb(e,t);const r=Db(t);const c=t.map((e=>!Gb[e])).reduce(((e,t)=>e&&t),true);if(c){const e=n[0][0];const t=n[n.length-1][1];if(Math.abs(e-t)>s){return[]}}const o=Nb(n,c,s).map((e=>[e.left,e.right].map(rr).filter((e=>e.length>1)))).reduce(((e,t)=>e.concat(t)),[]);const i=(t=[0],a=0,f=0)=>{const l=a+1;const d=r[a];const u=a>=e.length-1;const m=c&&u;if(!Lb(n,t,o,m,s)){return[]}if(m){const e=rr(t);const s=e[0];const n=e[a];if(d>0&&n>s){return[]}if(d<0&&n<s){return[]}}if(u){return[t]}if(d===0){t[f]=[l].concat(t[f]);return i(t,l,f)}const g=d===1?Array.from(Array(t.length-f)).map(((e,t)=>f+t+1)):Array.from(Array(f+1)).map(((e,t)=>t));const p=g.map((()=>zo(t)));p.forEach(((e,t)=>e.splice(g[t],0,l)));return p.map(((e,t)=>i(e,l,g[t]))).reduce(((e,t)=>e.concat(t)),[])};return i().map(rr)};const Jb=(e,t,s)=>{if(t==null){t=e.map((()=>"U"))}const n=nv(t);const r=n.map((t=>Hb(e,t,s)));return n.map(((e,t)=>t)).filter((e=>r[e].length>0)).map((e=>({assignment:n[e],layer:r[e]})))};Object.assign(db,{table:eb,makeTacosAndTortillas:Rh,...Dh,...xh,...Fh,...Gh,layer3d:Vb,...Sb,...pb,...Ob,singleVertexSolver:Hb,singleVertexAssignmentSolver:Jb,foldStripWithAssignments:Wb});Object.assign(am,V_);const Qb={graph:am,cp:im,origami:fm,axiom:Wm,convert:Ig,general:Wg,math:Q_,singleVertex:cv,svg:Fl,webgl:vh,layer:db};Al.ear=Qb;Object.defineProperty(Qb,"window",{enumerable:false,set:e=>{Fl.window=c(e)}});export{Qb as default};