/* Rabbit Ear 0.9.33 alpha 2022-07-29 (c) Kraft, MIT License */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e="undefined"!=typeof globalThis?globalThis:e||self).ear=t()}(this,(function(){"use strict";const e="undefined",t="number",r="object",o="index",s="vertices",n="edges",c="faces",i="boundaries",a="vertices_coords",l="edges_vertices",d="faces_edges",u="edges_assignment",p="edges_foldAngle",g="boundary",m="front",h="back",v="foldedForm",_="black",y="white",b="none",E=typeof window!==e&&typeof window.document!==e;typeof process!==e&&null!=process.versions&&process.versions.node;const x=typeof self===r&&self.constructor&&"DedicatedWorkerGlobalScope"===self.constructor.name,O={window:void 0};E&&(O.window=window);var k=Object.create(null);const typeOf=function(e){switch(e.constructor.name){case"vector":case"matrix":case"segment":case"ray":case"line":case"circle":case"ellipse":case"rect":case"polygon":return e.constructor.name}if("object"==typeof e){if(null!=e.radius)return"circle";if(null!=e.width)return"rect";if(null!=e.x||"number"==typeof e[0])return"vector";if(null!=e[0]&&e[0].length&&("number"==typeof e[0].x||"number"==typeof e[0][0]))return"segment";if(null!=e.vector&&null!=e.origin)return"line"}},resize=(e,t)=>t.length===e?t:Array(e).fill(0).map(((e,r)=>t[r]?t[r]:e)),resizeUp=(e,t)=>{const r=e.length>t.length?e.length:t.length;return[e,t].map((e=>resize(r,e)))},countPlaces=function(e){const t=`${e}`.match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);return t?Math.max(0,(t[1]?t[1].length:0)-(t[2]?+t[2]:0)):0},cleanNumber=function(e,t=15){if("number"!=typeof e)return e;const r=parseFloat(e.toFixed(t));return countPlaces(r)===Math.min(t,countPlaces(e))?e:r},isIterable=e=>null!=e&&"function"==typeof e[Symbol.iterator],semiFlattenArrays=function(){switch(arguments.length){case void 0:case 0:return Array.from(arguments);case 1:return isIterable(arguments[0])&&"string"!=typeof arguments[0]?semiFlattenArrays(...arguments[0]):[arguments[0]];default:return Array.from(arguments).map((e=>isIterable(e)?[...semiFlattenArrays(e)]:e))}},flattenArrays=function(){switch(arguments.length){case void 0:case 0:return Array.from(arguments);case 1:return isIterable(arguments[0])&&"string"!=typeof arguments[0]?flattenArrays(...arguments[0]):[arguments[0]];default:return Array.from(arguments).map((e=>isIterable(e)?[...flattenArrays(e)]:e)).reduce(((e,t)=>e.concat(t)),[])}};var M=Object.freeze({__proto__:null,resize:resize,resizeUp:resizeUp,resizeDown:(e,t)=>{const r=e.length>t.length?t.length:e.length;return[e,t].map((e=>resize(r,e)))},cleanNumber:cleanNumber,semiFlattenArrays:semiFlattenArrays,flattenArrays:flattenArrays}),A=Object.create(null);const P=1e-6,j=180/Math.PI,w=Math.PI/180,S=2*Math.PI;var $=Object.freeze({__proto__:null,EPSILON:P,R2D:j,D2R:w,TWO_PI:S});const fnTrue=()=>!0,fnSquare=e=>e*e,fnAdd=(e,t)=>e+(t||0),fnNotUndefined=e=>void 0!==e,fnVec2Angle=e=>Math.atan2(e[1],e[0]),fnToVec2=e=>[Math.cos(e),Math.sin(e)],fnEpsilonEqual=(e,t,r=P)=>Math.abs(e-t)<r,fnEpsilonSort=(e,t,r=P)=>fnEpsilonEqual(e,t,r)?0:Math.sign(t-e),fnEpsilonEqualVectors=(e,t,r=P)=>{for(let o=0;o<Math.max(e.length,t.length);o+=1)if(!fnEpsilonEqual(e[o]||0,t[o]||0,r))return!1;return!0},include=(e,t=P)=>e>-t,exclude=(e,t=P)=>e>t,L=fnTrue,C=fnTrue,N=include,z=exclude,includeS=(e,t=P)=>e>-t&&e<1+t,excludeS=(e,t=P)=>e>t&&e<1-t,rayLimiter=e=>e<-P?0:e,segmentLimiter=e=>e<-P?0:e>1.000001?1:e;var F=Object.freeze({__proto__:null,fnTrue:fnTrue,fnSquare:fnSquare,fnAdd:fnAdd,fnNotUndefined:fnNotUndefined,fnAnd:(e,t)=>e&&t,fnCat:(e,t)=>e.concat(t),fnVec2Angle:fnVec2Angle,fnToVec2:fnToVec2,fnEqual:(e,t)=>e===t,fnEpsilonEqual:fnEpsilonEqual,fnEpsilonSort:fnEpsilonSort,fnEpsilonEqualVectors:fnEpsilonEqualVectors,include:include,exclude:exclude,includeL:L,excludeL:C,includeR:N,excludeR:z,includeS:includeS,excludeS:excludeS,lineLimiter:e=>e,rayLimiter:rayLimiter,segmentLimiter:segmentLimiter});const magnitude=e=>Math.sqrt(e.map(fnSquare).reduce(fnAdd,0)),magnitude2=e=>Math.sqrt(e[0]*e[0]+e[1]*e[1]),magnitude3=e=>Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]),magSquared=e=>e.map(fnSquare).reduce(fnAdd,0),normalize=e=>{const t=magnitude(e);return 0===t?e:e.map((e=>e/t))},normalize2=e=>{const t=magnitude2(e);return 0===t?e:[e[0]/t,e[1]/t]},normalize3=e=>{const t=magnitude3(e);return 0===t?e:[e[0]/t,e[1]/t,e[2]/t]},scale=(e,t)=>e.map((e=>e*t)),scale2=(e,t)=>[e[0]*t,e[1]*t],add=(e,t)=>e.map(((e,r)=>e+(t[r]||0))),add2=(e,t)=>[e[0]+t[0],e[1]+t[1]],subtract=(e,t)=>e.map(((e,r)=>e-(t[r]||0))),subtract2=(e,t)=>[e[0]-t[0],e[1]-t[1]],subtract3=(e,t)=>[e[0]-t[0],e[1]-t[1],e[2]-t[2]],dot=(e,t)=>e.map(((r,o)=>e[o]*t[o])).reduce(fnAdd,0),dot2=(e,t)=>e[0]*t[0]+e[1]*t[1],midpoint=(e,t)=>e.map(((e,r)=>(e+t[r])/2)),average=function(){if(0===arguments.length)return[];const e=arguments[0].length>0?arguments[0].length:0,t=Array(e).fill(0);return Array.from(arguments).forEach((e=>t.forEach(((r,o)=>{t[o]+=e[o]||0})))),t.map((e=>e/arguments.length))},lerp=(e,t,r)=>{const o=1-r;return e.map(((e,s)=>e*o+(t[s]||0)*r))},cross2=(e,t)=>e[0]*t[1]-e[1]*t[0],cross3=(e,t)=>[e[1]*t[2]-e[2]*t[1],e[2]*t[0]-e[0]*t[2],e[0]*t[1]-e[1]*t[0]],distance=(e,t)=>Math.sqrt(e.map(((r,o)=>(e[o]-t[o])**2)).reduce(fnAdd,0)),distance2=(e,t)=>{const r=e[0]-t[0],o=e[1]-t[1];return Math.sqrt(r*r+o*o)},flip=e=>e.map((e=>-e)),rotate90=e=>[-e[1],e[0]],rotate270=e=>[e[1],-e[0]],degenerate=(e,t=P)=>e.map((e=>Math.abs(e))).reduce(fnAdd,0)<t,parallel=(e,t,r=P)=>1-Math.abs(dot(normalize(e),normalize(t)))<r;var I=Object.freeze({__proto__:null,magnitude:magnitude,magnitude2:magnitude2,magnitude3:magnitude3,magSquared:magSquared,normalize:normalize,normalize2:normalize2,normalize3:normalize3,scale:scale,scale2:scale2,add:add,add2:add2,add3:(e,t)=>[e[0]+t[0],e[1]+t[1],e[2]+t[2]],subtract:subtract,subtract2:subtract2,subtract3:subtract3,dot:dot,dot2:dot2,midpoint:midpoint,midpoint2:(e,t)=>scale2(add2(e,t),.5),average:average,lerp:lerp,cross2:cross2,cross3:cross3,distance:distance,distance2:distance2,distance3:(e,t)=>{const r=e[0]-t[0],o=e[1]-t[1],s=e[2]-t[2];return Math.sqrt(r*r+o*o+s*s)},flip:flip,rotate90:rotate90,rotate270:rotate270,degenerate:degenerate,parallel:parallel,parallel2:(e,t,r=P)=>Math.abs(cross2(e,t))<r});const V=Object.freeze([1,0,0,0,1,0,0,0,1]),B=Object.freeze(V.concat(0,0,0)),isIdentity3x4=e=>B.map(((t,r)=>Math.abs(t-e[r])<P)).reduce(((e,t)=>e&&t),!0),multiplyMatrix3Vector3=(e,t)=>[e[0]*t[0]+e[3]*t[1]+e[6]*t[2]+e[9],e[1]*t[0]+e[4]*t[1]+e[7]*t[2]+e[10],e[2]*t[0]+e[5]*t[1]+e[8]*t[2]+e[11]],multiplyMatrix3Line3=(e,t,r)=>({vector:[e[0]*t[0]+e[3]*t[1]+e[6]*t[2],e[1]*t[0]+e[4]*t[1]+e[7]*t[2],e[2]*t[0]+e[5]*t[1]+e[8]*t[2]],origin:[e[0]*r[0]+e[3]*r[1]+e[6]*r[2]+e[9],e[1]*r[0]+e[4]*r[1]+e[7]*r[2]+e[10],e[2]*r[0]+e[5]*r[1]+e[8]*r[2]+e[11]]}),multiplyMatrices3=(e,t)=>[e[0]*t[0]+e[3]*t[1]+e[6]*t[2],e[1]*t[0]+e[4]*t[1]+e[7]*t[2],e[2]*t[0]+e[5]*t[1]+e[8]*t[2],e[0]*t[3]+e[3]*t[4]+e[6]*t[5],e[1]*t[3]+e[4]*t[4]+e[7]*t[5],e[2]*t[3]+e[5]*t[4]+e[8]*t[5],e[0]*t[6]+e[3]*t[7]+e[6]*t[8],e[1]*t[6]+e[4]*t[7]+e[7]*t[8],e[2]*t[6]+e[5]*t[7]+e[8]*t[8],e[0]*t[9]+e[3]*t[10]+e[6]*t[11]+e[9],e[1]*t[9]+e[4]*t[10]+e[7]*t[11]+e[10],e[2]*t[9]+e[5]*t[10]+e[8]*t[11]+e[11]],determinant3=e=>e[0]*e[4]*e[8]-e[0]*e[7]*e[5]-e[3]*e[1]*e[8]+e[3]*e[7]*e[2]+e[6]*e[1]*e[5]-e[6]*e[4]*e[2],invertMatrix3=e=>{const t=determinant3(e);if(Math.abs(t)<1e-6||Number.isNaN(t)||!Number.isFinite(e[9])||!Number.isFinite(e[10])||!Number.isFinite(e[11]))return;const r=[e[4]*e[8]-e[7]*e[5],-e[1]*e[8]+e[7]*e[2],e[1]*e[5]-e[4]*e[2],-e[3]*e[8]+e[6]*e[5],e[0]*e[8]-e[6]*e[2],-e[0]*e[5]+e[3]*e[2],e[3]*e[7]-e[6]*e[4],-e[0]*e[7]+e[6]*e[1],e[0]*e[4]-e[3]*e[1],-e[3]*e[7]*e[11]+e[3]*e[8]*e[10]+e[6]*e[4]*e[11]-e[6]*e[5]*e[10]-e[9]*e[4]*e[8]+e[9]*e[5]*e[7],e[0]*e[7]*e[11]-e[0]*e[8]*e[10]-e[6]*e[1]*e[11]+e[6]*e[2]*e[10]+e[9]*e[1]*e[8]-e[9]*e[2]*e[7],-e[0]*e[4]*e[11]+e[0]*e[5]*e[10]+e[3]*e[1]*e[11]-e[3]*e[2]*e[10]-e[9]*e[1]*e[5]+e[9]*e[2]*e[4]],o=1/t;return r.map((e=>e*o))},makeMatrix3Translate=(e=0,t=0,r=0)=>V.concat(e,t,r),singleAxisRotate=(e,t,r,o,s)=>{const n=V.concat([0,1,2].map((e=>t[e]||0))),c=Math.cos(e),i=Math.sin(e);return n[3*r+r]=c,n[3*r+o]=(s?1:-1)*i,n[3*o+r]=(s?-1:1)*i,n[3*o+o]=c,n},makeMatrix3RotateX=(e,t=[0,0,0])=>singleAxisRotate(e,t,1,2,!0),makeMatrix3RotateY=(e,t=[0,0,0])=>singleAxisRotate(e,t,0,2,!1),makeMatrix3RotateZ=(e,t=[0,0,0])=>singleAxisRotate(e,t,0,1,!0),makeMatrix3Rotate=(e,t=[0,0,1],r=[0,0,0])=>{const o=[0,1,2].map((e=>r[e]||0)),[s,n,c]=resize(3,normalize(t)),i=Math.cos(e),a=Math.sin(e),l=1-i,d=V.concat(-o[0],-o[1],-o[2]),u=V.concat(o[0],o[1],o[2]);return multiplyMatrices3(u,multiplyMatrices3([l*s*s+i,l*n*s+c*a,l*c*s-n*a,l*s*n-c*a,l*n*n+i,l*c*n+s*a,l*s*c+n*a,l*n*c-s*a,l*c*c+i,0,0,0],d))},makeMatrix3Scale=(e=[1,1,1],t=[0,0,0])=>[e[0],0,0,0,e[1],0,0,0,e[2],e[0]*-t[0]+t[0],e[1]*-t[1]+t[1],e[2]*-t[2]+t[2]],makeMatrix3ReflectZ=(e,t=[0,0])=>{const r=Math.atan2(e[1],e[0]),o=Math.cos(r),s=Math.sin(r),n=Math.cos(-r),c=Math.sin(-r),i=o*n+s*c,a=o*-c+s*n,l=s*n+-o*c,d=s*-c+-o*n;return[i,a,0,l,d,0,0,0,1,t[0]+i*-t[0]+-t[1]*l,t[1]+a*-t[0]+-t[1]*d,0]};var T=Object.freeze({__proto__:null,identity3x3:V,identity3x4:B,isIdentity3x4:isIdentity3x4,multiplyMatrix3Vector3:multiplyMatrix3Vector3,multiplyMatrix3Line3:multiplyMatrix3Line3,multiplyMatrices3:multiplyMatrices3,determinant3:determinant3,invertMatrix3:invertMatrix3,makeMatrix3Translate:makeMatrix3Translate,makeMatrix3RotateX:makeMatrix3RotateX,makeMatrix3RotateY:makeMatrix3RotateY,makeMatrix3RotateZ:makeMatrix3RotateZ,makeMatrix3Rotate:makeMatrix3Rotate,makeMatrix3Scale:makeMatrix3Scale,makeMatrix3ReflectZ:makeMatrix3ReflectZ});const vectorOriginForm=(e,t)=>({vector:e||[],origin:t||[]}),getVector=function(){if(arguments[0]instanceof A.vector)return arguments[0];let e=flattenArrays(arguments);return e.length>0&&"object"==typeof e[0]&&null!==e[0]&&!Number.isNaN(e[0].x)&&(e=["x","y","z"].map((t=>e[0][t])).filter(fnNotUndefined)),e.filter((e=>"number"==typeof e))},getVectorOfVectors=function(){return semiFlattenArrays(arguments).map((e=>getVector(e)))},getSegment=function(){if(arguments[0]instanceof A.segment)return arguments[0];const e=semiFlattenArrays(arguments);return 4===e.length?[[e[0],e[1]],[e[2],e[3]]]:e.map((e=>getVector(e)))},getLine$1=function(){const e=semiFlattenArrays(arguments);return 0===e.length?vectorOriginForm([],[]):e[0]instanceof A.line||e[0]instanceof A.ray||e[0]instanceof A.segment?e[0]:e[0].constructor===Object&&void 0!==e[0].vector?vectorOriginForm(e[0].vector||[],e[0].origin||[]):"number"==typeof e[0]?vectorOriginForm(getVector(e)):vectorOriginForm(...e.map((e=>getVector(e))))},q=getLine$1,getRectParams=(e=0,t=0,r=0,o=0)=>({x:e,y:t,width:r,height:o}),getRect=function(){if(arguments[0]instanceof A.rect)return arguments[0];const e=flattenArrays(arguments);if(e.length>0&&"object"==typeof e[0]&&null!==e[0]&&!Number.isNaN(e[0].width))return getRectParams(...["x","y","width","height"].map((t=>e[0][t])).filter(fnNotUndefined));const t=e.filter((e=>"number"==typeof e)),r=t.length<4?[,,...t]:t;return getRectParams(...r)},getCircleParams=(e=1,...t)=>({radius:e,origin:[...t]}),getCircle=function(){if(arguments[0]instanceof A.circle)return arguments[0];const e=getVectorOfVectors(arguments),t=flattenArrays(arguments).filter((e=>"number"==typeof e));if(2===arguments.length){if(1===e[1].length)return getCircleParams(e[1][0],...e[0]);if(1===e[0].length)return getCircleParams(e[0][0],...e[1]);if(e[0].length>1&&e[1].length>1)return getCircleParams(distance2(...e),...e[0])}else switch(t.length){case 0:return getCircleParams(1,0,0,0);case 1:return getCircleParams(t[0],0,0,0);default:return getCircleParams(t.pop(),...t)}return getCircleParams(1,0,0,0)},R=[[0,1,3,4,9,10],[0,1,2,3,4,5,6,7,8,9,10,11],[0,1,2,void 0,3,4,5,void 0,6,7,8,void 0,9,10,11]];[11,7,3].forEach((e=>delete R[2][e]));const matrixMap3x4=e=>{let t;return t=e<8?0:e<13?1:2,R[t]},getMatrix3x4=function(){const e=flattenArrays(arguments),t=[...B];return matrixMap3x4(e.length).forEach(((r,o)=>{null!=e[o]&&(t[r]=e[o])})),t};var D=Object.freeze({__proto__:null,getVector:getVector,getVectorOfVectors:getVectorOfVectors,getSegment:getSegment,getLine:getLine$1,getRay:q,getRectParams:getRectParams,getRect:getRect,getCircle:getCircle,getMatrix3x4:getMatrix3x4});const rayLineToUniqueLine=({vector:e,origin:t})=>{const r=magnitude(e),o=rotate90(e),s=dot(t,o)/r;return{normal:scale(o,1/r),distance:s}},uniqueLineToRayLine=({normal:e,distance:t})=>({vector:rotate270(e),origin:scale(e,t)});var U=Object.freeze({__proto__:null,rayLineToUniqueLine:rayLineToUniqueLine,uniqueLineToRayLine:uniqueLineToRayLine});const smallestComparisonSearch=(e,t,r)=>{const o=t.map(((t,o)=>({o:t,i:o,d:r(e,t)})));let s,n=1/0;for(let e=0;e<o.length;e+=1)o[e].d<n&&(s=e,n=o[e].d);return s},minimum2DPointIndex=(e,t=P)=>{const r=((e,t=fnEpsilonSort,r=P)=>{let o=[0];for(let s=1;s<e.length;s+=1)switch(t(e[s][0],e[o[0]][0],r)){case 0:o.push(s);break;case 1:o=[s]}return o})(e,fnEpsilonSort,t);let o=0;for(let t=1;t<r.length;t+=1)e[r[t]][1]<e[r[o]][1]&&(o=t);return r[o]},nearestPointOnLine=(e,t,r,o,s=P)=>{t=resize(e.length,t),r=resize(e.length,r);const n=magSquared(e),c=subtract(r,t),i=o(dot(e,c)/n,s);return add(t,scale(e,i))},nearestPointOnPolygon=(e,t)=>{const r=e.map(((e,t,r)=>subtract(r[(t+1)%r.length],e)));return e.map(((e,o)=>nearestPointOnLine(r[o],e,t,segmentLimiter))).map(((e,r)=>({point:e,i:r,distance:distance(e,t)}))).sort(((e,t)=>e.distance-t.distance)).shift()},nearestPointOnCircle=(e,t,r)=>add(t,scale(normalize(subtract(r,t)),e));var G=Object.freeze({__proto__:null,smallestComparisonSearch:smallestComparisonSearch,minimum2DPointIndex:minimum2DPointIndex,nearestPoint2:(e,t)=>{const r=smallestComparisonSearch(e,t,distance2);return void 0===r?void 0:t[r]},nearestPoint:(e,t)=>{const r=smallestComparisonSearch(e,t,distance);return void 0===r?void 0:t[r]},nearestPointOnLine:nearestPointOnLine,nearestPointOnPolygon:nearestPointOnPolygon,nearestPointOnCircle:nearestPointOnCircle});const clusterIndicesOfSortedNumbers=(e,t=P)=>{const r=[[0]];let o=0;for(let s=1;s<e.length;s+=1)fnEpsilonEqual(e[s],e[s-1],t)?r[o].push(s):(o=r.length,r.push([s]));return r},radialSortPointIndices=(e=[],t=P)=>{const r=minimum2DPointIndex(e,t),o=e.map((t=>subtract2(t,e[r]))).map((e=>normalize2(e))).map((e=>dot2([0,1],e))),s=o.map(((e,t)=>({a:e,i:t}))).sort(((e,t)=>e.a-t.a)).map((e=>e.i)).filter((e=>e!==r));return[[r]].concat(clusterIndicesOfSortedNumbers(s.map((e=>o[e])),t).map((e=>e.map((e=>s[e])))).map((t=>1===t.length?t:t.map((t=>({i:t,len:distance2(e[t],e[r])}))).sort(((e,t)=>e.len-t.len)).map((e=>e.i)))))};var W=Object.freeze({__proto__:null,sortPointsAlongVector2:(e,t)=>e.map((e=>({point:e,d:e[0]*t[0]+e[1]*t[1]}))).sort(((e,t)=>e.d-t.d)).map((e=>e.point)),clusterIndicesOfSortedNumbers:clusterIndicesOfSortedNumbers,radialSortPointIndices:radialSortPointIndices});const Z=[1,0,0,1],J=Z.concat(0,0),determinant2=e=>e[0]*e[3]-e[1]*e[2],makeMatrix2Rotate=(e,t=[0,0])=>{const r=Math.cos(e),o=Math.sin(e);return[r,o,-o,r,t[0],t[1]]};var X=Object.freeze({__proto__:null,identity2x2:Z,identity2x3:J,multiplyMatrix2Vector2:(e,t)=>[e[0]*t[0]+e[2]*t[1]+e[4],e[1]*t[0]+e[3]*t[1]+e[5]],multiplyMatrix2Line2:(e,t,r)=>({vector:[e[0]*t[0]+e[2]*t[1],e[1]*t[0]+e[3]*t[1]],origin:[e[0]*r[0]+e[2]*r[1]+e[4],e[1]*r[0]+e[3]*r[1]+e[5]]}),multiplyMatrices2:(e,t)=>[e[0]*t[0]+e[2]*t[1],e[1]*t[0]+e[3]*t[1],e[0]*t[2]+e[2]*t[3],e[1]*t[2]+e[3]*t[3],e[0]*t[4]+e[2]*t[5]+e[4],e[1]*t[4]+e[3]*t[5]+e[5]],determinant2:determinant2,invertMatrix2:e=>{const t=determinant2(e);if(!(Math.abs(t)<1e-6||Number.isNaN(t))&&Number.isFinite(e[4])&&Number.isFinite(e[5]))return[e[3]/t,-e[1]/t,-e[2]/t,e[0]/t,(e[2]*e[5]-e[3]*e[4])/t,(e[1]*e[4]-e[0]*e[5])/t]},makeMatrix2Translate:(e=0,t=0)=>Z.concat(e,t),makeMatrix2Scale:(e=[1,1],t=[0,0])=>[e[0],0,0,e[1],e[0]*-t[0]+t[0],e[1]*-t[1]+t[1]],makeMatrix2Rotate:makeMatrix2Rotate,makeMatrix2Reflect:(e,t=[0,0])=>{const r=Math.atan2(e[1],e[0]),o=Math.cos(r),s=Math.sin(r),n=Math.cos(-r),c=Math.sin(-r),i=o*n+s*c,a=o*-c+s*n,l=s*n+-o*c,d=s*-c+-o*n;return[i,a,l,d,t[0]+i*-t[0]+-t[1]*l,t[1]+a*-t[0]+-t[1]*d]}});const H=Object.freeze([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),multiplyMatrices4=(e,t)=>[e[0]*t[0]+e[4]*t[1]+e[8]*t[2]+e[12]*t[3],e[1]*t[0]+e[5]*t[1]+e[9]*t[2]+e[13]*t[3],e[2]*t[0]+e[6]*t[1]+e[10]*t[2]+e[14]*t[3],e[3]*t[0]+e[7]*t[1]+e[11]*t[2]+e[15]*t[3],e[0]*t[4]+e[4]*t[5]+e[8]*t[6]+e[12]*t[7],e[1]*t[4]+e[5]*t[5]+e[9]*t[6]+e[13]*t[7],e[2]*t[4]+e[6]*t[5]+e[10]*t[6]+e[14]*t[7],e[3]*t[4]+e[7]*t[5]+e[11]*t[6]+e[15]*t[7],e[0]*t[8]+e[4]*t[9]+e[8]*t[10]+e[12]*t[11],e[1]*t[8]+e[5]*t[9]+e[9]*t[10]+e[13]*t[11],e[2]*t[8]+e[6]*t[9]+e[10]*t[10]+e[14]*t[11],e[3]*t[8]+e[7]*t[9]+e[11]*t[10]+e[15]*t[11],e[0]*t[12]+e[4]*t[13]+e[8]*t[14]+e[12]*t[15],e[1]*t[12]+e[5]*t[13]+e[9]*t[14]+e[13]*t[15],e[2]*t[12]+e[6]*t[13]+e[10]*t[14]+e[14]*t[15],e[3]*t[12]+e[7]*t[13]+e[11]*t[14]+e[15]*t[15]],determinant4=e=>{const t=e[10]*e[15]-e[11]*e[14],r=e[9]*e[15]-e[11]*e[13],o=e[9]*e[14]-e[10]*e[13],s=e[8]*e[15]-e[11]*e[12],n=e[8]*e[14]-e[10]*e[12],c=e[8]*e[13]-e[9]*e[12];return e[0]*(e[5]*t-e[6]*r+e[7]*o)-e[1]*(e[4]*t-e[6]*s+e[7]*n)+e[2]*(e[4]*r-e[5]*s+e[7]*c)-e[3]*(e[4]*o-e[5]*n+e[6]*c)},Y=Object.freeze([1,0,0,0,0,1,0,0,0,0,1,0]),makeMatrix4Translate=(e=0,t=0,r=0)=>[...Y,e,t,r,1],singleAxisRotate4=(e,t,r,o,s)=>{const n=makeMatrix4Translate(...t),c=Math.cos(e),i=Math.sin(e);return n[4*r+r]=c,n[4*r+o]=(s?1:-1)*i,n[4*o+r]=(s?-1:1)*i,n[4*o+o]=c,n};var K=Object.freeze({__proto__:null,identity4x4:H,isIdentity4x4:e=>H.map(((t,r)=>Math.abs(t-e[r])<P)).reduce(((e,t)=>e&&t),!0),multiplyMatrix4Vector3:(e,t)=>[e[0]*t[0]+e[4]*t[1]+e[8]*t[2]+e[12],e[1]*t[0]+e[5]*t[1]+e[9]*t[2]+e[13],e[2]*t[0]+e[6]*t[1]+e[10]*t[2]+e[14]],multiplyMatrix4Line3:(e,t,r)=>({vector:[e[0]*t[0]+e[4]*t[1]+e[8]*t[2],e[1]*t[0]+e[5]*t[1]+e[9]*t[2],e[2]*t[0]+e[6]*t[1]+e[10]*t[2]],origin:[e[0]*r[0]+e[4]*r[1]+e[8]*r[2]+e[12],e[1]*r[0]+e[5]*r[1]+e[9]*r[2]+e[13],e[2]*r[0]+e[6]*r[1]+e[10]*r[2]+e[14]]}),multiplyMatrices4:multiplyMatrices4,determinant4:determinant4,invertMatrix4:e=>{const t=determinant4(e);if(Math.abs(t)<1e-6||Number.isNaN(t)||!Number.isFinite(e[12])||!Number.isFinite(e[13])||!Number.isFinite(e[14]))return;const r=e[10]*e[15]-e[11]*e[14],o=e[9]*e[15]-e[11]*e[13],s=e[9]*e[14]-e[10]*e[13],n=e[8]*e[15]-e[11]*e[12],c=e[8]*e[14]-e[10]*e[12],i=e[8]*e[13]-e[9]*e[12],a=e[6]*e[15]-e[7]*e[14],l=e[5]*e[15]-e[7]*e[13],d=e[5]*e[14]-e[6]*e[13],u=e[6]*e[11]-e[7]*e[10],p=e[5]*e[11]-e[7]*e[9],g=e[5]*e[10]-e[6]*e[9],m=e[4]*e[15]-e[7]*e[12],h=e[4]*e[14]-e[6]*e[12],v=e[4]*e[11]-e[7]*e[8],_=e[4]*e[10]-e[6]*e[8],y=e[4]*e[13]-e[5]*e[12],b=e[4]*e[9]-e[5]*e[8],E=[+(e[5]*r-e[6]*o+e[7]*s),-(e[1]*r-e[2]*o+e[3]*s),+(e[1]*a-e[2]*l+e[3]*d),-(e[1]*u-e[2]*p+e[3]*g),-(e[4]*r-e[6]*n+e[7]*c),+(e[0]*r-e[2]*n+e[3]*c),-(e[0]*a-e[2]*m+e[3]*h),+(e[0]*u-e[2]*v+e[3]*_),+(e[4]*o-e[5]*n+e[7]*i),-(e[0]*o-e[1]*n+e[3]*i),+(e[0]*l-e[1]*m+e[3]*y),-(e[0]*p-e[1]*v+e[3]*b),-(e[4]*s-e[5]*c+e[6]*i),+(e[0]*s-e[1]*c+e[2]*i),-(e[0]*d-e[1]*h+e[2]*y),+(e[0]*g-e[1]*_+e[2]*b)],x=1/t;return E.map((e=>e*x))},makeMatrix4Translate:makeMatrix4Translate,makeMatrix4RotateX:(e,t=[0,0,0])=>singleAxisRotate4(e,t,1,2,!0),makeMatrix4RotateY:(e,t=[0,0,0])=>singleAxisRotate4(e,t,0,2,!1),makeMatrix4RotateZ:(e,t=[0,0,0])=>singleAxisRotate4(e,t,0,1,!0),makeMatrix4Rotate:(e,t=[0,0,1],r=[0,0,0])=>{const o=[0,1,2].map((e=>r[e]||0)),[s,n,c]=resize(3,normalize(t)),i=Math.cos(e),a=Math.sin(e),l=1-i,d=makeMatrix4Translate(-o[0],-o[1],-o[2]),u=makeMatrix4Translate(o[0],o[1],o[2]);return multiplyMatrices4(u,multiplyMatrices4([l*s*s+i,l*n*s+c*a,l*c*s-n*a,0,l*s*n-c*a,l*n*n+i,l*c*n+s*a,0,l*s*c+n*a,l*n*c-s*a,l*c*c+i,0,0,0,0,1],d))},makeMatrix4Scale:(e=[1,1,1],t=[0,0,0])=>[e[0],0,0,0,0,e[1],0,0,0,0,e[2],0,e[0]*-t[0]+t[0],e[1]*-t[1]+t[1],e[2]*-t[2]+t[2],1],makeMatrix4ReflectZ:(e,t=[0,0])=>{const r=Math.atan2(e[1],e[0]),o=Math.cos(r),s=Math.sin(r),n=Math.cos(-r),c=Math.sin(-r),i=o*n+s*c,a=o*-c+s*n,l=s*n+-o*c,d=s*-c+-o*n;return[i,a,0,0,l,d,0,0,0,0,1,0,t[0]+i*-t[0]+-t[1]*l,t[1]+a*-t[0]+-t[1]*d,0,1]},makePerspectiveMatrix4:(e,t,r,o)=>{const s=Math.tan(.5*Math.PI-.5*e),n=1/(r-o);return[s/t,0,0,0,0,s,0,0,0,0,(r+o)*n,-1,0,0,r*o*n*2,0]},makeOrthographicMatrix4:(e,t,r,o,s,n)=>[2/(t-o),0,0,0,0,2/(e-r),0,0,0,0,2/(s-n),0,(o+t)/(o-t),(r+e)/(r-e),(s+n)/(s-n),1],makeLookAtMatrix4:(e,t,r)=>{const o=normalize3(subtract3(e,t)),s=normalize3(cross3(r,o)),n=normalize3(cross3(o,s));return[s[0],s[1],s[2],0,n[0],n[1],n[2],0,o[0],o[1],o[2],0,e[0],e[1],e[2],1]}});var Q=Object.freeze({__proto__:null,quaternionFromTwoVectors:(e,t)=>{const r=cross3(e,t),o=[r[0],r[1],r[2],dot(e,t)];return o[3]+=magnitude(o),normalize(o)},matrix4FromQuaternion:e=>multiplyMatrices4([e[3],e[2],-e[1],e[0],-e[2],e[3],e[0],e[1],e[1],-e[0],e[3],e[2],-e[0],-e[1],-e[2],e[3]],[e[3],e[2],-e[1],-e[0],-e[2],e[3],e[0],-e[1],e[1],-e[0],e[3],-e[2],e[0],e[1],e[2],e[3]])});const overlapConvexPolygonPoint=(e,t,r=exclude,o=P)=>e.map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>cross2(normalize(subtract(e[1],e[0])),subtract(t,e[0])))).map((e=>r(e,o))).map(((e,t,r)=>e===r[0])).reduce(((e,t)=>e&&t),!0),linePointFromParameter=(e,t,r)=>add(t,scale(e,r)),getIntersectParameters=(e,t,r,o,s)=>e.map(((e,t,r)=>[subtract(r[(t+1)%r.length],e),e])).map((e=>((e,t,r,o,s=includeS,n=P)=>{const c=cross2(normalize(e),normalize(r));if(Math.abs(c)<n)return;const i=cross2(e,r),a=-i,l=subtract(o,t),d=flip(l),u=cross2(l,r)/i;return s(cross2(d,e)/a,n/magnitude(r))?u:void 0})(t,r,e[0],e[1],o,s))).filter(fnNotUndefined).sort(((e,t)=>e-t)),clipLineConvexPolygon=(e,t,r,o=include,s=L,n=P)=>{const c=getIntersectParameters(e,t,r,includeS,n);if(c.length<2)return;const i=((e,t,r)=>{let o=0,s=e.length-1;for(;o<s&&!t(e[o+1]-e[o],r);)o+=1;for(;s>o&&!t(e[s]-e[s-1],r);)s-=1;if(!(o>=s))return[e[o],e[s]]})(c,o,2*n/magnitude(t));if(void 0===i)return;const a=i.map((e=>s(e)?e:e<.5?0:1));if(Math.abs(a[0]-a[1])<2*n/magnitude(t))return;const l=linePointFromParameter(t,r,(a[0]+a[1])/2);return overlapConvexPolygonPoint(e,l,o,n)?a.map((e=>linePointFromParameter(t,r,e))):void 0},clockwiseAngleRadians=(e,t)=>{for(;e<0;)e+=S;for(;t<0;)t+=S;for(;e>S;)e-=S;for(;t>S;)t-=S;const r=e-t;return r>=0?r:S-(t-e)},counterClockwiseAngleRadians=(e,t)=>{for(;e<0;)e+=S;for(;t<0;)t+=S;for(;e>S;)e-=S;for(;t>S;)t-=S;const r=t-e;return r>=0?r:S-(e-t)},clockwiseAngle2=(e,t)=>{const r=t[0]*e[0]+t[1]*e[1],o=t[0]*e[1]-t[1]*e[0];let s=Math.atan2(o,r);return s<0&&(s+=S),s},counterClockwiseAngle2=(e,t)=>{const r=e[0]*t[0]+e[1]*t[1],o=e[0]*t[1]-e[1]*t[0];let s=Math.atan2(o,r);return s<0&&(s+=S),s},clockwiseBisect2=(e,t)=>fnToVec2(fnVec2Angle(e)-clockwiseAngle2(e,t)/2),counterClockwiseBisect2=(e,t)=>fnToVec2(fnVec2Angle(e)+counterClockwiseAngle2(e,t)/2),clockwiseSubsectRadians=(e,t,r)=>{const o=clockwiseAngleRadians(t,r)/e;return Array.from(Array(e-1)).map(((e,r)=>t+o*(r+1)))},counterClockwiseSubsectRadians=(e,t,r)=>{const o=counterClockwiseAngleRadians(t,r)/e;return Array.from(Array(e-1)).map(((e,r)=>t+o*(r+1)))},clockwiseSubsect2=(e,t,r)=>{const o=Math.atan2(t[1],t[0]),s=Math.atan2(r[1],r[0]);return clockwiseSubsectRadians(e,o,s).map(fnToVec2)},counterClockwiseSubsect2=(e,t,r)=>{const o=Math.atan2(t[1],t[0]),s=Math.atan2(r[1],r[0]);return counterClockwiseSubsectRadians(e,o,s).map(fnToVec2)},bisectLines2=(e,t,r,o,s=P)=>{const n=cross2(e,r),c=dot(e,r),i=n>-s?[counterClockwiseBisect2(e,r)]:[clockwiseBisect2(e,r)];i[1]=n>-s?rotate90(i[0]):rotate270(i[0]);const a=((o[0]-t[0])*r[1]-r[0]*(o[1]-t[1]))/n,l=[e,r].map((e=>normalize(e))),d=Math.abs(cross2(...l))<s,u=d?midpoint(t,o):[t[0]+e[0]*a,t[1]+e[1]*a],p=i.map((e=>({vector:e,origin:u})));return d&&delete p[c>-s?1:0],p},counterClockwiseOrderRadians=function(){const e=Array.from(arguments).flat(),t=e.map(((e,t)=>t)).sort(((t,r)=>e[t]-e[r]));return t.slice(t.indexOf(0),t.length).concat(t.slice(0,t.indexOf(0)))},counterClockwiseSectorsRadians=function(){const e=Array.from(arguments).flat(),t=counterClockwiseOrderRadians(e).map((t=>e[t]));return t.map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>counterClockwiseAngleRadians(e[0],e[1])))},threePointTurnDirection=(e,t,r,o=P)=>{const s=normalize2(subtract2(t,e)),n=normalize2(subtract2(r,e)),c=cross2(s,n);return fnEpsilonEqual(c,0,o)?fnEpsilonEqual(distance2(e,t)+distance2(t,r),distance2(e,r))?0:void 0:Math.sign(c)};var ee=Object.freeze({__proto__:null,isCounterClockwiseBetween:(e,t,r)=>{for(;r<t;)r+=S;for(;e>t;)e-=S;for(;e<t;)e+=S;return e<r},clockwiseAngleRadians:clockwiseAngleRadians,counterClockwiseAngleRadians:counterClockwiseAngleRadians,clockwiseAngle2:clockwiseAngle2,counterClockwiseAngle2:counterClockwiseAngle2,clockwiseBisect2:clockwiseBisect2,counterClockwiseBisect2:counterClockwiseBisect2,clockwiseSubsectRadians:clockwiseSubsectRadians,counterClockwiseSubsectRadians:counterClockwiseSubsectRadians,clockwiseSubsect2:clockwiseSubsect2,counterClockwiseSubsect2:counterClockwiseSubsect2,bisectLines2:bisectLines2,counterClockwiseOrderRadians:counterClockwiseOrderRadians,counterClockwiseOrder2:function(){return counterClockwiseOrderRadians(semiFlattenArrays(arguments).map(fnVec2Angle))},counterClockwiseSectorsRadians:counterClockwiseSectorsRadians,counterClockwiseSectors2:function(){return counterClockwiseSectorsRadians(getVectorOfVectors(arguments).map(fnVec2Angle))},threePointTurnDirection:threePointTurnDirection});const convexHullIndices=(e=[],t=!1,r=P)=>{if(e.length<2)return[];const o=radialSortPointIndices(e,r).map((e=>1===e.length?e:(e=>e.concat(e.slice(0,-1).reverse()))(e))).flat();o.push(o[0]);const s=[o[0]];let n=1;const c={"-1":()=>s.pop(),1:e=>{s.push(e),n+=1},undefined:()=>{n+=1}};for(c[0]=t?c[1]:c[-1];n<o.length;){if(s.length<2){s.push(o[n]),n+=1;continue}const t=s[s.length-2],i=s[s.length-1],a=o[n];c[threePointTurnDirection(...[t,i,a].map((t=>e[t])),r)](a)}return s.pop(),s},convexHull=(e=[],t=!1,r=P)=>convexHullIndices(e,t,r).map((t=>e[t]));var te=Object.freeze({__proto__:null,convexHullIndices:convexHullIndices,convexHull:convexHull});const intersectLineLine=(e,t,r,o,s=L,n=L,c=P)=>{const i=cross2(normalize(e),normalize(r));if(Math.abs(i)<c)return;const a=cross2(e,r),l=-a,d=[o[0]-t[0],o[1]-t[1]],u=[-d[0],-d[1]],p=cross2(d,r)/a,g=cross2(u,e)/l;return s(p,c/magnitude(e))&&n(g,c/magnitude(r))?add(t,scale(e,p)):void 0};var re=Object.freeze({__proto__:null,pleat:(e,t,r)=>{const o=getLine$1(t),s=getLine$1(r);return parallel(o.vector,s.vector)?((e,t,r)=>{const o=Array.from(Array(e-1)).map(((t,r)=>(r+1)/e)).map((e=>lerp(t.origin,r.origin,e))),s=[...t.vector];return o.map((e=>({origin:e,vector:s})))})(e,o,s):((e,t,r)=>{const o=intersectLineLine(t.vector,t.origin,r.vector,r.origin);return(clockwiseAngle2(t.vector,r.vector)<counterClockwiseAngle2(t.vector,r.vector)?clockwiseSubsect2(e,t.vector,r.vector):counterClockwiseSubsect2(e,t.vector,r.vector)).map((e=>({origin:o,vector:e})))})(e,o,s)}});const angleArray=e=>Array.from(Array(Math.floor(e))).map(((t,r)=>S*(r/e))),anglesToVecs=(e,t)=>e.map((e=>[t*Math.cos(e),t*Math.sin(e)])).map((e=>e.map((e=>cleanNumber(e,14))))),makePolygonCircumradius=(e=3,t=1)=>anglesToVecs(angleArray(e),t),makePolygonCircumradiusSide=(e=3,t=1)=>{const r=Math.PI/e,o=angleArray(e).map((e=>e+r));return anglesToVecs(o,t)},circumcircle=function(e,t,r){const o=t[0]-e[0],s=t[1]-e[1],n=r[0]-e[0],c=r[1]-e[1],i=o*(e[0]+t[0])+s*(e[1]+t[1]),a=n*(e[0]+r[0])+c*(e[1]+r[1]),l=2*(o*(r[1]-t[1])-s*(r[0]-t[0]));if(Math.abs(l)<P){const o=Math.min(e[0],t[0],r[0]),s=Math.min(e[1],t[1],r[1]),n=.5*(Math.max(e[0],t[0],r[0])-o),c=.5*(Math.max(e[1],t[1],r[1])-s);return{origin:[o+n,s+c],radius:Math.sqrt(n*n+c*c)}}const d=[(c*i-s*a)/l,(o*a-n*i)/l],u=d[0]-e[0],p=d[1]-e[1];return{origin:d,radius:Math.sqrt(u*u+p*p)}},signedArea=e=>.5*e.map(((e,t,r)=>{const o=r[(t+1)%r.length];return e[0]*o[1]-o[0]*e[1]})).reduce(fnAdd,0),centroid=e=>{const t=1/(6*signedArea(e));return e.map(((e,t,r)=>{const o=r[(t+1)%r.length],s=e[0]*o[1]-o[0]*e[1];return[(e[0]+o[0])*s,(e[1]+o[1])*s]})).reduce(((e,t)=>[e[0]+t[0],e[1]+t[1]]),[0,0]).map((e=>e*t))},boundingBox=(e,t=0)=>{if(!e||!e.length)return;const r=Array(e[0].length).fill(1/0),o=Array(e[0].length).fill(-1/0);e.forEach((e=>e.forEach(((e,s)=>{e<r[s]&&(r[s]=e-t),e>o[s]&&(o[s]=e+t)}))));const s=o.map(((e,t)=>e-r[t]));return{min:r,max:o,span:s}};var oe=Object.freeze({__proto__:null,makePolygonCircumradius:makePolygonCircumradius,makePolygonCircumradiusSide:makePolygonCircumradiusSide,makePolygonInradius:(e=3,t=1)=>makePolygonCircumradius(e,t/Math.cos(Math.PI/e)),makePolygonInradiusSide:(e=3,t=1)=>makePolygonCircumradiusSide(e,t/Math.cos(Math.PI/e)),makePolygonSideLength:(e=3,t=1)=>makePolygonCircumradius(e,t/2/Math.sin(Math.PI/e)),makePolygonSideLengthSide:(e=3,t=1)=>makePolygonCircumradiusSide(e,t/2/Math.sin(Math.PI/e)),makePolygonNonCollinear:(e,t=P)=>{const r=e.map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>subtract(e[1],e[0]))).map(((e,t,r)=>[e,r[(t+r.length-1)%r.length]])).map((e=>!parallel(e[1],e[0],t)));return e.filter(((e,t)=>r[t]))},circumcircle:circumcircle,signedArea:signedArea,centroid:centroid,boundingBox:boundingBox});const overlapLinePoint=(e,t,r,o=C,s=P)=>{const n=subtract(r,t),c=magSquared(e),i=Math.sqrt(c);if(i<s)return!1;const a=cross2(n,e.map((e=>e/i))),l=dot(n,e)/c;return Math.abs(a)<s&&o(l,s/i)},splitConvexPolygon=(e,t,r)=>{const o=e.map(((e,o)=>({point:overlapLinePoint(t,r,e,L)?e:null,at_index:o}))).filter((e=>null!=e.point)),s=e.map(((e,o,s)=>({point:intersectLineLine(t,r,subtract(e,s[(o+1)%s.length]),s[(o+1)%s.length],C,excludeS),at_index:o}))).filter((e=>null!=e.point));if(2===s.length){const t=s.slice().sort(((e,t)=>e.at_index-t.at_index)),r=e.slice(t[1].at_index+1).concat(e.slice(0,t[0].at_index+1));r.push(t[0].point),r.push(t[1].point);const o=e.slice(t[0].at_index+1,t[1].at_index+1);return o.push(t[1].point),o.push(t[0].point),[r,o]}if(1===s.length&&1===o.length){o[0].type="v",s[0].type="e";const t=o.concat(s).sort(((e,t)=>e.at_index-t.at_index)),r=e.slice(t[1].at_index+1).concat(e.slice(0,t[0].at_index+1));"e"===t[0].type&&r.push(t[0].point),r.push(t[1].point);const n=e.slice(t[0].at_index+1,t[1].at_index+1);return"e"===t[1].type&&n.push(t[1].point),n.push(t[0].point),[r,n]}if(2===o.length){const t=o.slice().sort(((e,t)=>e.at_index-t.at_index));return[e.slice(t[1].at_index).concat(e.slice(0,t[0].at_index+1)),e.slice(t[0].at_index,t[1].at_index+1)]}return[e.slice()]},recurseSkeleton=(e,t,r)=>{const o=e.map(((e,t)=>({vector:r[t],origin:e}))).map(((e,t,r)=>intersectLineLine(e.vector,e.origin,r[(t+1)%r.length].vector,r[(t+1)%r.length].origin,z,z))),s=t.map(((e,t)=>nearestPointOnLine(e.vector,e.origin,o[t],(e=>e))));if(3===e.length)return e.map((e=>({type:"skeleton",points:[e,o[0]]}))).concat([{type:"perpendicular",points:[s[0],o[0]]}]);const n=o.map(((e,t)=>distance(e,s[t])));let c=0;n.forEach(((e,t)=>{e<n[c]&&(c=t)}));const i=[{type:"skeleton",points:[e[c],o[c]]},{type:"skeleton",points:[e[(c+1)%e.length],o[c]]},{type:"perpendicular",points:[s[c],o[c]]}],a=clockwiseBisect2(flip(t[(c+t.length-1)%t.length].vector),t[(c+1)%t.length].vector),l=c===e.length-1;return e.splice(c,2,o[c]),t.splice(c,1),r.splice(c,2,a),l&&(e.splice(0,1),r.splice(0,1),t.push(t.shift())),i.concat(recurseSkeleton(e,t,r))},straightSkeleton=e=>{const t=e.map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>({vector:subtract(e[1],e[0]),origin:e[0]}))),r=e.map(((e,t,r)=>[(t-1+r.length)%r.length,t,(t+1)%r.length].map((e=>r[e])))).map((e=>[subtract(e[0],e[1]),subtract(e[2],e[1])])).map((e=>clockwiseBisect2(...e)));return recurseSkeleton([...e],t,r)};var se=Object.freeze({__proto__:null,collinearBetween:(e,t,r,o=!1,s=P)=>{if([e,r].map((e=>fnEpsilonEqualVectors(t,e))).reduce(((e,t)=>e||t),!1))return o;const n=[[e,t],[t,r]].map((e=>subtract(e[1],e[0]))).map((e=>normalize(e)));return fnEpsilonEqual(1,dot(...n),s)}});var ne=Object.freeze({__proto__:null,enclosingBoundingBoxes:(e,t)=>{const r=Math.min(e.min.length,t.min.length);for(let o=0;o<r;o+=1)if(t.min[o]<e.min[o]||t.max[o]>e.max[o])return!1;return!0},enclosingPolygonPolygon:(e,t,r=include)=>{const o=e.map((e=>overlapConvexPolygonPoint(t,e,r))).reduce(((e,t)=>e||t),!1),s=t.map((e=>overlapConvexPolygonPoint(t,e,r))).reduce(((e,t)=>e&&t),!0);return!o&&s}});const rotateVector2=(e,t,r)=>{const o=t[0]-e[0],s=t[1]-e[1],n=o*Math.cos(r)+s*Math.sin(r),c=s*Math.cos(r)-o*Math.sin(r);return[e[0]+n,e[1]+c]},intersectCircleCircle=(e,t,r,o,s=P)=>{const n=e<r?e:r,c=e<r?r:e,i=e<r?t:o,a=e<r?o:t,l=[i[0]-a[0],i[1]-a[1]],d=Math.sqrt(l[0]**2+l[1]**2);if(d<s)return;const u=l.map(((e,t)=>e/d*c+a[t]));if(Math.abs(c+n-d)<s||Math.abs(c-(n+d))<s)return[u];if(d+n<c||c+n<d)return;const p=(g=(n*n-d*d-c*c)/(-2*d*c))>=1?0:g<=-1?Math.PI:Math.acos(g);var g;return[rotateVector2(a,u,+p),rotateVector2(a,u,-p)]},intersectCircleLine=(e,t,r,o,s=L,n=P)=>{const c=r[0]**2+r[1]**2,i=Math.sqrt(c),a=0===i?r:r.map((e=>e/i)),l=rotate90(a),d=subtract(o,t),u=cross2(d,a);if(Math.abs(u)>e+n)return;const p=Math.sqrt(e**2-u**2),f=(e,r)=>t[r]-l[r]*u+a[r]*e,g=Math.abs(e-Math.abs(u))<n?[p].map((e=>[e,e].map(f))):[-p,p].map((e=>[e,e].map(f))),m=g.map((e=>e.map(((e,t)=>e-o[t])))).map((e=>e[0]*r[0]+r[1]*e[1])).map((e=>e/c));return g.filter(((e,t)=>s(m[t],n)))},getUniquePair=e=>{for(let t=1;t<e.length;t+=1)if(!fnEpsilonEqualVectors(e[0],e[t]))return[e[0],e[t]]},intersectConvexPolygonLineInclusive=(e,t,r,o=includeS,s=L,n=P)=>{const c=e.map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>intersectLineLine(subtract(e[1],e[0]),e[0],t,r,o,s,n))).filter((e=>void 0!==e));switch(c.length){case 0:return;case 1:return[c];default:return getUniquePair(c)||[c[0]]}},intersectConvexPolygonLine=(e,t,r,o=includeS,s=C,n=P)=>{const c=intersectConvexPolygonLineInclusive(e,t,r,o,s,n);let i;switch(s){case z:i=N;break;case excludeS:i=includeS;break;default:return c}const a=intersectConvexPolygonLineInclusive(e,t,r,includeS,i,n);if(void 0===a)return;const l=getUniquePair(a);if(void 0===l)switch(s){case z:return overlapConvexPolygonPoint(e,r,exclude,n)?a:void 0;case excludeS:return overlapConvexPolygonPoint(e,add(r,t),exclude,n)||overlapConvexPolygonPoint(e,r,exclude,n)?a:void 0;case C:default:return}return overlapConvexPolygonPoint(e,midpoint(...l),exclude,n)?l:c},ce={polygon:e=>[e],rect:e=>[e],circle:e=>[e.radius,e.origin],line:e=>[e.vector,e.origin],ray:e=>[e.vector,e.origin],segment:e=>[e.vector,e.origin]},ie={polygon:{line:(e,t,r,o,s)=>intersectConvexPolygonLine(...e,...t,includeS,o,s),ray:(e,t,r,o,s)=>intersectConvexPolygonLine(...e,...t,includeS,o,s),segment:(e,t,r,o,s)=>intersectConvexPolygonLine(...e,...t,includeS,o,s)},circle:{circle:(e,t,r,o,s)=>intersectCircleCircle(...e,...t,s),line:(e,t,r,o,s)=>intersectCircleLine(...e,...t,o,s),ray:(e,t,r,o,s)=>intersectCircleLine(...e,...t,o,s),segment:(e,t,r,o,s)=>intersectCircleLine(...e,...t,o,s)},line:{polygon:(e,t,r,o,s)=>intersectConvexPolygonLine(...t,...e,includeS,r,s),circle:(e,t,r,o,s)=>intersectCircleLine(...t,...e,r,s),line:(e,t,r,o,s)=>intersectLineLine(...e,...t,r,o,s),ray:(e,t,r,o,s)=>intersectLineLine(...e,...t,r,o,s),segment:(e,t,r,o,s)=>intersectLineLine(...e,...t,r,o,s)},ray:{polygon:(e,t,r,o,s)=>intersectConvexPolygonLine(...t,...e,includeS,r,s),circle:(e,t,r,o,s)=>intersectCircleLine(...t,...e,r,s),line:(e,t,r,o,s)=>intersectLineLine(...t,...e,o,r,s),ray:(e,t,r,o,s)=>intersectLineLine(...e,...t,r,o,s),segment:(e,t,r,o,s)=>intersectLineLine(...e,...t,r,o,s)},segment:{polygon:(e,t,r,o,s)=>intersectConvexPolygonLine(...t,...e,includeS,r,s),circle:(e,t,r,o,s)=>intersectCircleLine(...t,...e,r,s),line:(e,t,r,o,s)=>intersectLineLine(...t,...e,o,r,s),ray:(e,t,r,o,s)=>intersectLineLine(...t,...e,o,r,s),segment:(e,t,r,o,s)=>intersectLineLine(...e,...t,r,o,s)}},ae={polygon:"polygon",rect:"polygon",circle:"circle",line:"line",ray:"ray",segment:"segment"},le={polygon:exclude,rect:exclude,circle:exclude,line:C,ray:z,segment:excludeS},intersect$1=function(e,t,r){const o=typeOf(e),s=typeOf(t),n=ae[o],c=ae[s],i=ce[o](e),a=ce[s](t),l=e.domain_function||le[o],d=t.domain_function||le[s];return ie[n][c](i,a,l,d,r)},overlapConvexPolygons=(e,t,r=P)=>{for(let o=0;o<2;o+=1){const s=0===o?e:t,n=0===o?t:e;for(let e=0;e<s.length;e+=1){const t=s[e],o=rotate90(subtract(s[(e+1)%s.length],s[e])),c=n.map((e=>subtract(e,t))).map((e=>dot(o,e))),i=s[(e+2)%s.length],a=dot(o,subtract(i,t))>0;if(c.map((e=>a?e<r:e>-r)).reduce(((e,t)=>e&&t),!0))return!1}}return!0},overlapCirclePoint=(e,t,r,o=exclude,s=P)=>o(e-distance2(t,r),s),overlapLineLine=(e,t,r,o,s=C,n=C,c=P)=>{const i=cross2(e,r),a=-i,l=[o[0]-t[0],o[1]-t[1]];if(Math.abs(i)<c){if(Math.abs(cross2(l,e))>c)return!1;const t=l,o=add(t,r),s=dot(e,e),n=dot(t,e)/s,i=dot(o,e)/s,a=(n<i?i:n)<c;return!((n<i?n:i)>1-c)&&!a}const d=[-l[0],-l[1]],u=cross2(l,r)/i,p=cross2(d,e)/a;return s(u,c/magnitude(e))&&n(p,c/magnitude(r))},de={polygon:e=>[e],rect:e=>[e],circle:e=>[e.radius,e.origin],line:e=>[e.vector,e.origin],ray:e=>[e.vector,e.origin],segment:e=>[e.vector,e.origin],vector:e=>[e]},fe={polygon:{polygon:(e,t,r,o,s)=>overlapConvexPolygons(...e,...t,s),vector:(e,t,r,o,s)=>overlapConvexPolygonPoint(...e,...t,r,s)},circle:{vector:(e,t,r,o,s)=>overlapCirclePoint(...e,...t,exclude,s)},line:{line:(e,t,r,o,s)=>overlapLineLine(...e,...t,r,o,s),ray:(e,t,r,o,s)=>overlapLineLine(...e,...t,r,o,s),segment:(e,t,r,o,s)=>overlapLineLine(...e,...t,r,o,s),vector:(e,t,r,o,s)=>overlapLinePoint(...e,...t,r,s)},ray:{line:(e,t,r,o,s)=>overlapLineLine(...t,...e,o,r,s),ray:(e,t,r,o,s)=>overlapLineLine(...e,...t,r,o,s),segment:(e,t,r,o,s)=>overlapLineLine(...e,...t,r,o,s),vector:(e,t,r,o,s)=>overlapLinePoint(...e,...t,r,s)},segment:{line:(e,t,r,o,s)=>overlapLineLine(...t,...e,o,r,s),ray:(e,t,r,o,s)=>overlapLineLine(...t,...e,o,r,s),segment:(e,t,r,o,s)=>overlapLineLine(...e,...t,r,o,s),vector:(e,t,r,o,s)=>overlapLinePoint(...e,...t,r,s)},vector:{polygon:(e,t,r,o,s)=>overlapConvexPolygonPoint(...t,...e,o,s),circle:(e,t,r,o,s)=>overlapCirclePoint(...t,...e,exclude,s),line:(e,t,r,o,s)=>overlapLinePoint(...t,...e,o,s),ray:(e,t,r,o,s)=>overlapLinePoint(...t,...e,o,s),segment:(e,t,r,o,s)=>overlapLinePoint(...t,...e,o,s),vector:(e,t,r,o,s)=>fnEpsilonEqualVectors(...e,...t,s)}},ue={polygon:"polygon",rect:"polygon",circle:"circle",line:"line",ray:"ray",segment:"segment",vector:"vector"},pe={polygon:exclude,rect:exclude,circle:exclude,line:C,ray:z,segment:excludeS,vector:C},overlap$1=function(e,t,r){const o=typeOf(e),s=typeOf(t),n=ue[o],c=ue[s],i=de[o](e),a=de[s](t),l=e.domain_function||pe[o],d=t.domain_function||pe[s];return fe[n][c](i,a,l,d,r)},ge={preserve:{magnitude:function(){return magnitude(this)},isEquivalent:function(){return fnEpsilonEqualVectors(this,getVector(arguments))},isParallel:function(){return parallel(...resizeUp(this,getVector(arguments)))},isCollinear:function(e){return overlap$1(this,e)},dot:function(){return dot(...resizeUp(this,getVector(arguments)))},distanceTo:function(){return distance(...resizeUp(this,getVector(arguments)))},overlap:function(e){return overlap$1(this,e)}},vector:{copy:function(){return[...this]},normalize:function(){return normalize(this)},scale:function(){return scale(this,arguments[0])},flip:function(){return flip(this)},rotate90:function(){return rotate90(this)},rotate270:function(){return rotate270(this)},cross:function(){return cross3(resize(3,this),resize(3,getVector(arguments)))},transform:function(){return multiplyMatrix3Vector3(getMatrix3x4(arguments),resize(3,this))},add:function(){return add(this,resize(this.length,getVector(arguments)))},subtract:function(){return subtract(this,resize(this.length,getVector(arguments)))},rotateZ:function(e,t){return multiplyMatrix3Vector3(getMatrix3x4(makeMatrix2Rotate(e,t)),resize(3,this))},lerp:function(e,t){return lerp(this,resize(this.length,getVector(e)),t)},midpoint:function(){return midpoint(...resizeUp(this,getVector(arguments)))},bisect:function(){return counterClockwiseBisect2(this,getVector(arguments))}}},me={};Object.keys(ge.preserve).forEach((e=>{me[e]=ge.preserve[e]})),Object.keys(ge.vector).forEach((e=>{me[e]=function(){return A.vector(...ge.vector[e].apply(this,arguments))}}));const he={fromAngle:function(e){return A.vector(Math.cos(e),Math.sin(e))},fromAngleDegrees:function(e){return A.vector.fromAngle(e*w)}};var ve={vector:{P:Array.prototype,A:function(){this.push(...getVector(arguments))},G:{x:function(){return this[0]},y:function(){return this[1]},z:function(){return this[2]}},M:me,S:he}},_e={fromPoints:function(){const e=getVectorOfVectors(arguments);return this.constructor({vector:subtract(e[1],e[0]),origin:e[0]})},fromAngle:function(){const e=arguments[0]||0;return this.constructor({vector:[Math.cos(e),Math.sin(e)],origin:[0,0]})},perpendicularBisector:function(){const e=getVectorOfVectors(arguments);return this.constructor({vector:rotate90(subtract(e[1],e[0])),origin:average(e[0],e[1])})}};const ye={isParallel:function(){const e=resizeUp(this.vector,getLine$1(arguments).vector);return parallel(...e)},isCollinear:function(){const e=getLine$1(arguments);return overlapLinePoint(this.vector,this.origin,e.origin)&&parallel(...resizeUp(this.vector,e.vector))},isDegenerate:function(e=P){return degenerate(this.vector,e)},reflectionMatrix:function(){return A.matrix(makeMatrix3ReflectZ(this.vector,this.origin))},nearestPoint:function(){const e=getVector(arguments);return A.vector(nearestPointOnLine(this.vector,this.origin,e,this.clip_function))},transform:function(){const e=this.dimension,t=multiplyMatrix3Line3(getMatrix3x4(arguments),resize(3,this.vector),resize(3,this.origin));return this.constructor(resize(e,t.vector),resize(e,t.origin))},translate:function(){const e=add(...resizeUp(this.origin,getVector(arguments)));return this.constructor(this.vector,e)},intersect:function(){return intersect$1(this,...arguments)},overlap:function(){return overlap$1(this,...arguments)},bisect:function(e,t){const r=getLine$1(e);return bisectLines2(this.vector,this.origin,r.vector,r.origin,t).map((e=>this.constructor(e)))}};var be={line:{P:Object.prototype,A:function(){const e=getLine$1(...arguments);this.vector=A.vector(e.vector),this.origin=A.vector(resize(this.vector.length,e.origin));const t=rayLineToUniqueLine({vector:this.vector,origin:this.origin});this.normal=t.normal,this.distance=t.distance,Object.defineProperty(this,"domain_function",{writable:!0,value:L})},G:{dimension:function(){return[this.vector,this.origin].map((e=>e.length)).reduce(((e,t)=>Math.max(e,t)),0)}},M:Object.assign({},ye,{inclusive:function(){return this.domain_function=L,this},exclusive:function(){return this.domain_function=C,this},clip_function:e=>e,svgPath:function(e=2e4){const t=add(this.origin,scale(this.vector,-e/2)),r=scale(this.vector,e);return`M${t[0]} ${t[1]}l${r[0]} ${r[1]}`}}),S:Object.assign({fromNormalDistance:function(){return this.constructor(uniqueLineToRayLine(arguments[0]))}},_e)}},Ee={ray:{P:Object.prototype,A:function(){const e=getLine$1(...arguments);this.vector=A.vector(e.vector),this.origin=A.vector(resize(this.vector.length,e.origin)),Object.defineProperty(this,"domain_function",{writable:!0,value:N})},G:{dimension:function(){return[this.vector,this.origin].map((e=>e.length)).reduce(((e,t)=>Math.max(e,t)),0)}},M:Object.assign({},ye,{inclusive:function(){return this.domain_function=N,this},exclusive:function(){return this.domain_function=z,this},flip:function(){return A.ray(flip(this.vector),this.origin)},scale:function(e){return A.ray(this.vector.scale(e),this.origin)},normalize:function(){return A.ray(this.vector.normalize(),this.origin)},clip_function:rayLimiter,svgPath:function(e=1e4){const t=this.vector.scale(e);return`M${this.origin[0]} ${this.origin[1]}l${t[0]} ${t[1]}`}}),S:_e}},xe={segment:{P:Array.prototype,A:function(){const e=getSegment(...arguments);this.push(...[e[0],e[1]].map((e=>A.vector(e)))),this.vector=A.vector(subtract(this[1],this[0])),this.origin=this[0],Object.defineProperty(this,"domain_function",{writable:!0,value:includeS})},G:{points:function(){return this},magnitude:function(){return magnitude(this.vector)},dimension:function(){return[this.vector,this.origin].map((e=>e.length)).reduce(((e,t)=>Math.max(e,t)),0)}},M:Object.assign({},ye,{inclusive:function(){return this.domain_function=includeS,this},exclusive:function(){return this.domain_function=excludeS,this},clip_function:segmentLimiter,transform:function(...e){const t=this.points[0].length,r=getMatrix3x4(e),o=this.points.map((e=>resize(3,e))).map((e=>multiplyMatrix3Vector3(r,e))).map((e=>resize(t,e)));return A.segment(o)},translate:function(){const e=getVector(arguments),t=this.points.map((t=>add(...resizeUp(t,e))));return A.segment(t)},midpoint:function(){return A.vector(average(this.points[0],this.points[1]))},svgPath:function(){const e=this.points.map((e=>`${e[0]} ${e[1]}`));return["M","L"].map(((t,r)=>`${t}${e[r]}`)).join("")}}),S:{fromPoints:function(){return this.constructor(...arguments)}}}};const pointOnEllipse=function(e,t,r,o,s,n){const c=Math.cos(s),i=Math.sin(s),a=Math.cos(n),l=Math.sin(n);return[e+c*r*a+-i*o*l,t+i*r*a+c*o*l]},pathInfo=function(e,t,r,o,s,n,c){let i=n;if(i<0&&!Number.isNaN(i))for(;i<0;)i+=2*Math.PI;const a=c>2*Math.PI?2*Math.PI:c,l=pointOnEllipse(e,t,r,o,s,i),d=pointOnEllipse(e,t,r,o,s,i+a/2),u=pointOnEllipse(e,t,r,o,s,i+a),p=a/2>Math.PI?1:0,g=a/2>0?1:0;return{x1:l[0],y1:l[1],x2:d[0],y2:d[1],x3:u[0],y3:u[1],fa:p,fs:g}},cln=e=>cleanNumber(e,4),ellipticalArcTo=(e,t,r,o,s,n,c)=>`A${cln(e)} ${cln(t)} ${cln(r)} ${cln(o)} ${cln(s)} ${cln(n)} ${cln(c)}`;var Oe={circle:{A:function(){const e=getCircle(...arguments);this.radius=e.radius,this.origin=A.vector(...e.origin)},G:{x:function(){return this.origin[0]},y:function(){return this.origin[1]},z:function(){return this.origin[2]}},M:{nearestPoint:function(){return A.vector(nearestPointOnCircle(this.radius,this.origin,getVector(arguments)))},intersect:function(e){return intersect$1(this,e)},overlap:function(e){return overlap$1(this,e)},svgPath:function(e=0,t=2*Math.PI){const r=pathInfo(this.origin[0],this.origin[1],this.radius,this.radius,0,e,t),o=ellipticalArcTo(this.radius,this.radius,0,r.fa,r.fs,r.x2,r.y2),s=ellipticalArcTo(this.radius,this.radius,0,r.fa,r.fs,r.x3,r.y3);return`M${r.x1} ${r.y1}${o}${s}`},points:function(e=128){return Array.from(Array(e)).map(((t,r)=>2*Math.PI/e*r)).map((e=>[this.origin[0]+this.radius*Math.cos(e),this.origin[1]+this.radius*Math.sin(e)]))},polygon:function(){return A.polygon(this.points(arguments[0]))},segments:function(){const e=this.points(arguments[0]);return e.map(((t,r)=>{const o=(r+1)%e.length;return[t,e[o]]}))}},S:{fromPoints:function(){if(3===arguments.length){const e=circumcircle(...arguments);return this.constructor(e.radius,e.origin)}return this.constructor(...arguments)},fromThreePoints:function(){const e=circumcircle(...arguments);return this.constructor(e.radius,e.origin)}}}};const getFoci=function(e,t,r,o){const s=t>r,n=s?t**2-r**2:r**2-t**2,c=Math.sqrt(n),i=s?Math.cos(o):Math.sin(o),a=s?Math.sin(o):Math.cos(o);return[A.vector(e[0]+c*i,e[1]+c*a),A.vector(e[0]-c*i,e[1]-c*a)]};var ke={ellipse:{A:function(){const e=flattenArrays(arguments).filter((e=>!Number.isNaN(e))),t=resize(5,e);this.rx=t[0],this.ry=t[1],this.origin=A.vector(t[2],t[3]),this.spin=t[4],this.foci=getFoci(this.origin,this.rx,this.ry,this.spin)},G:{x:function(){return this.origin[0]},y:function(){return this.origin[1]}},M:{svgPath:function(e=0,t=2*Math.PI){const r=pathInfo(this.origin[0],this.origin[1],this.rx,this.ry,this.spin,e,t),o=ellipticalArcTo(this.rx,this.ry,this.spin/Math.PI*180,r.fa,r.fs,r.x2,r.y2),s=ellipticalArcTo(this.rx,this.ry,this.spin/Math.PI*180,r.fa,r.fs,r.x3,r.y3);return`M${r.x1} ${r.y1}${o}${s}`},points:function(e=128){return Array.from(Array(e)).map(((t,r)=>2*Math.PI/e*r)).map((e=>pointOnEllipse(this.origin.x,this.origin.y,this.rx,this.ry,this.spin,e)))},polygon:function(){return A.polygon(this.points(arguments[0]))},segments:function(){const e=this.points(arguments[0]);return e.map(((t,r)=>{const o=(r+1)%e.length;return[t,e[o]]}))}},S:{}}};const Me={area:function(){return signedArea(this)},centroid:function(){return A.vector(centroid(this))},boundingBox:function(){return boundingBox(this)},straightSkeleton:function(){return straightSkeleton(this)},scale:function(e,t=centroid(this)){const r=this.map((e=>[0,1].map(((r,o)=>e[o]-t[o])))).map((r=>r.map(((o,s)=>t[s]+r[s]*e))));return this.constructor.fromPoints(r)},rotate:function(e,t=centroid(this)){const r=this.map((r=>{const o=[r[0]-t[0],r[1]-t[1]],s=Math.sqrt(o[0]**2+o[1]**2),n=Math.atan2(o[1],o[0]);return[t[0]+Math.cos(n+e)*s,t[1]+Math.sin(n+e)*s]}));return A.polygon(r)},translate:function(){const e=getVector(...arguments),t=this.map((t=>t.map(((t,r)=>t+e[r]))));return this.constructor.fromPoints(t)},transform:function(){const e=getMatrix3x4(...arguments),t=this.map((t=>multiplyMatrix3Vector3(e,resize(3,t))));return A.polygon(t)},nearest:function(){const e=getVector(...arguments),t=nearestPointOnPolygon(this,e);return void 0===t?void 0:Object.assign(t,{edge:this.sides[t.i]})},split:function(){const e=getLine$1(...arguments),t=splitConvexPolygon;return t(this,e.vector,e.origin).map((e=>A.polygon(e)))},overlap:function(){return overlap$1(this,...arguments)},intersect:function(){return intersect$1(this,...arguments)},clip:function(e,t){const r=e.domain_function?e.domain_function:L,o=clipLineConvexPolygon(this,e.vector,e.origin,this.domain_function,r,t);return o?A.segment(o):void 0},svgPath:function(){const e=Array(this.length).fill("L");return e[0]="M",`${this.map(((t,r)=>`${e[r]}${t[0]} ${t[1]}`)).join("")}z`}},rectToPoints=e=>[[e.x,e.y],[e.x+e.width,e.y],[e.x+e.width,e.y+e.height],[e.x,e.y+e.height]];var Ae={rect:{P:Array.prototype,A:function(){const e=getRect(...arguments);this.width=e.width,this.height=e.height,this.origin=A.vector(e.x,e.y),this.push(...rectToPoints(this)),Object.defineProperty(this,"domain_function",{writable:!0,value:include})},G:{x:function(){return this.origin[0]},y:function(){return this.origin[1]},center:function(){return A.vector(this.origin[0]+this.width/2,this.origin[1]+this.height/2)}},M:Object.assign({},Me,{inclusive:function(){return this.domain_function=include,this},exclusive:function(){return this.domain_function=exclude,this},area:function(){return this.width*this.height},segments:function(){return[[[(e=this).x,e.y],[e.x+e.width,e.y]],[[e.x+e.width,e.y],[e.x+e.width,e.y+e.height]],[[e.x+e.width,e.y+e.height],[e.x,e.y+e.height]],[[e.x,e.y+e.height],[e.x,e.y]]];var e},svgPath:function(){return`M${this.origin.join(" ")}h${this.width}v${this.height}h${-this.width}Z`}}),S:{fromPoints:function(){const e=boundingBox(getVectorOfVectors(arguments));return A.rect(e.min[0],e.min[1],e.span[0],e.span[1])}}}},Pe={polygon:{P:Array.prototype,A:function(){this.push(...semiFlattenArrays(arguments)),this.sides=this.map(((e,t,r)=>[e,r[(t+1)%r.length]])),this.vectors=this.sides.map((e=>subtract(e[1],e[0]))),Object.defineProperty(this,"domain_function",{writable:!0,value:include})},G:{isConvex:function(){},points:function(){return this}},M:Object.assign({},Me,{inclusive:function(){return this.domain_function=include,this},exclusive:function(){return this.domain_function=exclude,this},segments:function(){return this.sides}}),S:{fromPoints:function(){return this.constructor(...arguments)},regularPolygon:function(){return this.constructor(makePolygonCircumradius(...arguments))},convexHull:function(){return this.constructor(convexHull(...arguments))}}}},je={polyline:{P:Array.prototype,A:function(){this.push(...semiFlattenArrays(arguments))},G:{points:function(){return this}},M:{svgPath:function(){const e=Array(this.length).fill("L");return e[0]="M",`${this.map(((t,r)=>`${e[r]}${t[0]} ${t[1]}`)).join("")}`}},S:{fromPoints:function(){return this.constructor(...arguments)}}}};const array_assign=(e,t)=>{for(let r=0;r<12;r+=1)e[r]=t[r];return e};var we={matrix:{P:Array.prototype,A:function(){getMatrix3x4(arguments).forEach((e=>this.push(e)))},G:{},M:{copy:function(){return A.matrix(...Array.from(this))},set:function(){return array_assign(this,getMatrix3x4(arguments))},isIdentity:function(){return isIdentity3x4(this)},multiply:function(e){return array_assign(this,multiplyMatrices3(this,e))},determinant:function(){return determinant3(this)},inverse:function(){return array_assign(this,invertMatrix3(this))},translate:function(e,t,r){return array_assign(this,multiplyMatrices3(this,makeMatrix3Translate(e,t,r)))},rotateX:function(e){return array_assign(this,multiplyMatrices3(this,makeMatrix3RotateX(e)))},rotateY:function(e){return array_assign(this,multiplyMatrices3(this,makeMatrix3RotateY(e)))},rotateZ:function(e){return array_assign(this,multiplyMatrices3(this,makeMatrix3RotateZ(e)))},rotate:function(e,t,r){const o=makeMatrix3Rotate(e,t,r);return array_assign(this,multiplyMatrices3(this,o))},scale:function(...e){return array_assign(this,multiplyMatrices3(this,makeMatrix3Scale(...e)))},reflectZ:function(e,t){const r=makeMatrix3ReflectZ(e,t);return array_assign(this,multiplyMatrices3(this,r))},transform:function(...e){return A.vector(multiplyMatrix3Vector3(this,resize(3,getVector(e))))},transformVector:function(e){return A.vector(multiplyMatrix3Vector3(this,resize(3,getVector(e))))},transformLine:function(...e){const t=getLine$1(e);return A.line(multiplyMatrix3Line3(this,t.vector,t.origin))}},S:{}}};const Se=Object.assign({},ve,be,Ee,xe,Oe,ke,Ae,Pe,je,we),create=function(e,t){const r=Object.create(Se[e].proto);return Se[e].A.apply(r,t),r};Object.assign(A,{vector:function(){return create("vector",arguments)},line:function(){return create("line",arguments)},ray:function(){return create("ray",arguments)},segment:function(){return create("segment",arguments)},circle:function(){return create("circle",arguments)},ellipse:function(){return create("ellipse",arguments)},rect:function(){return create("rect",arguments)},polygon:function(){return create("polygon",arguments)},polyline:function(){return create("polyline",arguments)},matrix:function(){return create("matrix",arguments)}}),Object.keys(Se).forEach((e=>{const t={};t.prototype=null!=Se[e].P?Object.create(Se[e].P):Object.create(Object.prototype),t.prototype.constructor=t,A[e].prototype=t.prototype,A[e].prototype.constructor=A[e],Object.keys(Se[e].G).forEach((r=>Object.defineProperty(t.prototype,r,{get:Se[e].G[r]}))),Object.keys(Se[e].M).forEach((r=>Object.defineProperty(t.prototype,r,{value:Se[e].M[r]}))),Object.keys(Se[e].S).forEach((t=>Object.defineProperty(A[e],t,{value:Se[e].S[t].bind(A[e].prototype)}))),Se[e].proto=t.prototype}));const $e=A;$e.core=Object.assign(Object.create(null),$,M,D,F,I,W,ee,te,re,oe,ee,X,T,K,Q,G,U,se,ne,{intersectConvexPolygonLine:intersectConvexPolygonLine,intersectCircleCircle:intersectCircleCircle,intersectCircleLine:intersectCircleLine,intersectLineLine:intersectLineLine,overlapConvexPolygons:overlapConvexPolygons,overlapConvexPolygonPoint:overlapConvexPolygonPoint,overlapBoundingBoxes:(e,t)=>{const r=Math.min(e.min.length,t.min.length);for(let o=0;o<r;o+=1)if(e.min[o]>t.max[o]||e.max[o]<t.min[o])return!1;return!0},overlapLineLine:overlapLineLine,overlapLinePoint:overlapLinePoint,clipLineConvexPolygon:clipLineConvexPolygon,clipPolygonPolygon:(e,t,r=P)=>{let o,s,n,c;const inside=e=>(s[0]-o[0])*(e[1]-o[1])>(s[1]-o[1])*(e[0]-o[0])+r,intersection=()=>{const e=[o[0]-s[0],o[1]-s[1]],t=[n[0]-c[0],n[1]-c[1]],r=o[0]*s[1]-o[1]*s[0],i=n[0]*c[1]-n[1]*c[0],a=1/(e[0]*t[1]-e[1]*t[0]);return[(r*t[0]-i*e[0])*a,(r*t[1]-i*e[1])*a]};let i=e;o=t[t.length-1];for(let e in t){s=t[e];const r=i;i=[],n=r[r.length-1];for(let e in r)c=r[e],inside(c)?(inside(n)||i.push(intersection()),i.push(c)):inside(n)&&i.push(intersection()),n=c;o=s}return 0===i.length?void 0:i},splitConvexPolygon:splitConvexPolygon,straightSkeleton:straightSkeleton}),$e.typeof=typeOf,$e.intersect=intersect$1,$e.overlap=overlap$1;const vertex_degree=function(e,t){const r=this;Object.defineProperty(e,"degree",{get:()=>r.vertices_vertices&&r.vertices_vertices[t]?r.vertices_vertices[t].length:null})},edge_coords=function(e,t){const r=this;Object.defineProperty(e,"coords",{get:()=>{if(r.edges_vertices&&r.edges_vertices[t]&&r.vertices_coords)return r.edges_vertices[t].map((e=>r.vertices_coords[e]))}})},face_simple=function(e,t){const r=this;Object.defineProperty(e,"simple",{get:()=>{if(!r.faces_vertices||!r.faces_vertices[t])return null;for(let o=0;o<e.length-1;o+=1)for(let s=o+1;s<e.length;s+=1)if(r.faces_vertices[t][o]===r.faces_vertices[t][s])return!1;return!0}})},face_coords=function(e,t){const r=this;Object.defineProperty(e,"coords",{get:()=>{if(r.faces_vertices&&r.faces_vertices[t]&&r.vertices_coords)return r.faces_vertices[t].map((e=>r.vertices_coords[e]))}})};var Le={vertices:function(e,t){return vertex_degree.call(this,e,t),e},edges:function(e,t){return edge_coords.call(this,e,t),e},faces:function(e,t){return face_simple.call(this,e,t),face_coords.call(this,e,t),e}};const Ce=1.1,Ne="Rabbit Ear",ze={file:["file_spec","file_creator","file_author","file_title","file_description","file_classes","file_frames"],frame:["frame_author","frame_title","frame_description","frame_attributes","frame_classes","frame_unit","frame_parent","frame_inherit"],graph:["vertices_coords","vertices_vertices","vertices_faces","edges_vertices","edges_faces","edges_assignment","edges_foldAngle","edges_length","faces_vertices","faces_edges","vertices_edges","edges_edges","faces_faces"],orders:["edgeOrders","faceOrders"]},Fe=Object.freeze([].concat(ze.file).concat(ze.frame).concat(ze.graph).concat(ze.orders)),Ie=Object.freeze(["edges_vector","vertices_sectors","faces_sectors","faces_matrix"]),Ve=Array.from("MmVvBbFfUu"),Be={vertices:"vertex",edges:"edge",faces:"face"},Te={b:"boundary",m:"mountain",v:"valley",f:"flat",u:"unassigned"};Ve.forEach((e=>{Te[e.toUpperCase()]=Te[e]}));const qe={M:-180,m:-180,V:180,v:180,B:0,b:0,F:0,f:0,U:0,u:0},edgeAssignmentToFoldAngle=e=>qe[e]||0,edgeFoldAngleToAssignment=e=>e>$e.core.EPSILON?"V":e<-$e.core.EPSILON?"M":"U",edgeFoldAngleIsFlat=e=>$e.core.fnEpsilonEqual(0,e)||$e.core.fnEpsilonEqual(-180,e)||$e.core.fnEpsilonEqual(180,e),edgesFoldAngleAreAllFlat=({edges_foldAngle:e})=>{if(!e)return!0;for(let t=0;t<e.length;t+=1)if(!edgeFoldAngleIsFlat(e[t]))return!1;return!0},filterKeysWithSuffix=(e,t)=>Object.keys(e).map((e=>e.substring(e.length-t.length,e.length)===t?e:void 0)).filter((e=>void 0!==e)),filterKeysWithPrefix=(e,t)=>Object.keys(e).map((e=>e.substring(0,t.length)===t?e:void 0)).filter((e=>void 0!==e)),getGraphKeysWithPrefix=(e,t)=>filterKeysWithPrefix(e,`${t}_`),getGraphKeysWithSuffix=(e,t)=>filterKeysWithSuffix(e,`_${t}`),transposeGraphArrays=(e,t)=>{const r=getGraphKeysWithPrefix(e,t);if(0===r.length)return[];const o=Math.max(...r.map((t=>e[t].length))),s=Array.from(Array(o)).map((()=>({})));return r.forEach((t=>s.forEach(((r,o)=>{s[o][t]=e[t][o]})))),s},isFoldObject=(e={})=>0===Object.keys(e).length?0:[].concat(Fe,Ie).filter((t=>e[t])).length/Object.keys(e).length;var Re=Object.freeze({__proto__:null,singularize:Be,pluralize:{vertex:"vertices",edge:"edges",face:"faces"},edgesAssignmentNames:Te,edgesAssignmentDegrees:qe,edgeAssignmentToFoldAngle:edgeAssignmentToFoldAngle,edgeFoldAngleToAssignment:edgeFoldAngleToAssignment,edgeFoldAngleIsFlat:edgeFoldAngleIsFlat,edgesFoldAngleAreAllFlat:edgesFoldAngleAreAllFlat,filterKeysWithSuffix:filterKeysWithSuffix,filterKeysWithPrefix:filterKeysWithPrefix,getGraphKeysWithPrefix:getGraphKeysWithPrefix,getGraphKeysWithSuffix:getGraphKeysWithSuffix,transposeGraphArrays:transposeGraphArrays,transposeGraphArrayAtIndex:function(e,t,r){const o=getGraphKeysWithPrefix(e,t);if(0===o.length)return;const s={};return o.forEach((t=>{s[t]=e[t][r]})),s},isFoldObject:isFoldObject});const are_vertices_equivalent=(e,t,r=$e.core.EPSILON)=>{const o=e.length;for(let s=0;s<o;s+=1)if(Math.abs(e[s]-t[s])>r)return!1;return!0},getVerticesClusters=({vertices_coords:e},t=$e.core.EPSILON)=>{if(!e)return[];const r=e.map((()=>[]));for(let o=0;o<e.length-1;o+=1)for(let s=o+1;s<e.length;s+=1)r[o][s]=are_vertices_equivalent(e[o],e[s],t);const o=r.map((e=>e.map(((e,t)=>e?t:void 0)).filter((e=>void 0!==e)))),s=[],n=Array(e.length).fill(!1);let c=0;const recurse=(t,r)=>{if(!n[r]&&c!==e.length)for(n[r]=!0,c+=1,s[t]||(s[t]=[]),s[t].push(r);o[r].length>0;)recurse(t,o[r][0]),o[r].splice(0,1)};for(let t=0;t<e.length&&(recurse(t,t),c!==e.length);t+=1);return s.filter((e=>e.length))},max_arrays_length=(...e)=>Math.max(0,...e.filter((e=>void 0!==e)).map((e=>e.length))),count=(e,t)=>max_arrays_length(...getGraphKeysWithPrefix(e,t).map((t=>e[t])));count.vertices=({vertices_coords:e,vertices_faces:t,vertices_vertices:r})=>max_arrays_length(e,t,r),count.edges=({edges_vertices:e,edges_edges:t,edges_faces:r})=>max_arrays_length(e,t,r),count.faces=({faces_vertices:e,faces_edges:t,faces_faces:r})=>max_arrays_length(e,t,r);const uniqueIntegers=e=>{const t={};return e.forEach((e=>{t[e]=!0})),Object.keys(t).map((e=>parseInt(e,10)))},uniqueSortedIntegers=e=>uniqueIntegers(e).sort(((e,t)=>e-t)),splitCircularArray=(e,t)=>(t.sort(((e,t)=>e-t)),[e.slice(t[1]).concat(e.slice(0,t[0]+1)),e.slice(t[0],t[1]+1)]),removeSingleInstances=e=>{const t={};return e.forEach((e=>{void 0===t[e]&&(t[e]=0),t[e]+=1})),e.filter((e=>t[e]>1))},booleanMatrixToIndexedArray=e=>e.map((e=>e.map(((e,t)=>!0===e?t:void 0)).filter((e=>void 0!==e)))),booleanMatrixToUniqueIndexPairs=e=>{const t=[];for(let r=0;r<e.length-1;r+=1)for(let o=r+1;o<e.length;o+=1)e[r][o]&&t.push([r,o]);return t},selfRelationalUniqueIndexPairs=e=>{const t=[],r=[];return e.forEach(((e,o)=>e.forEach((e=>{o<e&&r.push([o,e]),o!==e||t[o]||(t[o]=!0,r.push([o,e]))})))),r},clusterArrayValues=(e,t=$e.core.EPSILON)=>{const r=e.map(((e,t)=>({v:e,i:t}))).sort(((e,t)=>e.v-t.v)).map((e=>e.i)),o=[[r[0]]];for(let s=1;s<r.length;s+=1){const n=r[s],c=o.length-1,i=o[c][o[c].length-1];Math.abs(e[i]-e[n])<t?o[c].push(n):o.push([n])}return o},makeSelfRelationalArrayClusters=e=>{const t=[],recurse=(r,o)=>void 0!==t[r]?0:(t[r]=o,e[r].forEach((e=>recurse(e,o))),1);for(let t=0,r=0;t<e.length;t+=1)t in e&&(r+=recurse(t,r));return t};var De=Object.freeze({__proto__:null,uniqueIntegers:uniqueIntegers,uniqueSortedIntegers:uniqueSortedIntegers,splitCircularArray:splitCircularArray,getLongestArray:e=>{if(1===e.length)return e[0];const t=e.map((e=>e.length));let r=0;for(let o=0;o<e.length;o+=1)t[o]>t[r]&&(r=o);return e[r]},removeSingleInstances:removeSingleInstances,booleanMatrixToIndexedArray:booleanMatrixToIndexedArray,booleanMatrixToUniqueIndexPairs:booleanMatrixToUniqueIndexPairs,selfRelationalUniqueIndexPairs:selfRelationalUniqueIndexPairs,clusterArrayValues:clusterArrayValues,sortedParallelVectorIndices:e=>{},makeSelfRelationalArrayClusters:makeSelfRelationalArrayClusters,circularArrayValidRanges:e=>{const t=e.map((e=>void 0!==e));if(t.reduce(((e,t)=>e&&t),!0))return[[0,e.length-1]];const r=t.map(((e,t,r)=>e&&!r[(t-1+r.length)%r.length])),o=r.reduce(((e,t)=>e+(t?1:0)),0),s=Array(o),n=Array(o).fill(0);let c=t[0]&&t[e.length-1]?0:o-1;return t.forEach(((e,o)=>{c=(c+(r[o]?1:0))%n.length,n[c]+=t[o]?1:0,r[o]&&(s[c]=o)})),s.map(((t,r)=>[t,(t+n[r]-1)%e.length]))}});const removeGeometryIndices=(e,t,r)=>{const o=count(e,t),s=uniqueSortedIntegers(r),n=[];let c,i,a;for(c=0,i=0,a=0;c<o;c+=1,i+=1){for(;c===s[a];)n[c]=void 0,c+=1,a+=1;c<o&&(n[c]=i)}return getGraphKeysWithSuffix(e,t).forEach((t=>e[t].forEach(((r,o)=>e[t][o].forEach(((r,s)=>{e[t][o][s]=n[r]})))))),s.reverse(),getGraphKeysWithPrefix(e,t).forEach((t=>s.forEach((r=>e[t].splice(r,1))))),n},replaceGeometryIndices=(e,t,r)=>{const o=count(e,t),s=Object.keys(r).map((e=>parseInt(e,10))),n=uniqueSortedIntegers(s),c=[];let i,a,l;for(i=0,a=0,l=0;i<o;i+=1,a+=1){for(;i===n[l];)c[i]=c[r[n[l]]],void 0===c[i]&&console.log("replace() found an undefined",c),i+=1,l+=1;i<o&&(c[i]=a)}return getGraphKeysWithSuffix(e,t).forEach((t=>e[t].forEach(((r,o)=>e[t][o].forEach(((r,s)=>{e[t][o][s]=c[r]})))))),n.reverse(),getGraphKeysWithPrefix(e,t).forEach((t=>n.forEach((r=>e[t].splice(r,1))))),c},getDuplicateVertices=(e,t)=>getVerticesClusters(e,t).filter((e=>e.length>1)),getIsolatedVertices=({vertices_coords:e,edges_vertices:t,faces_vertices:r})=>{if(!e)return[];let o=e.length;const s=Array(o).fill(!1);return t&&t.forEach((e=>{e.filter((e=>!s[e])).forEach((e=>{s[e]=!0,o-=1}))})),r&&r.forEach((e=>{e.filter((e=>!s[e])).forEach((e=>{s[e]=!0,o-=1}))})),s.map(((e,t)=>e?void 0:t)).filter((e=>void 0!==e))},removeIsolatedVertices=(e,t)=>(t||(t=getIsolatedVertices(e)),{map:removeGeometryIndices(e,s,t),remove:t}),removeDuplicateVertices=(e,t=$e.core.EPSILON)=>{const r=[],o=[],n=getVerticesClusters(e,t).filter((e=>e.length>1));return n.forEach((e=>{for(let t=1;t<e.length;t+=1)r[e[t]]=e[0],o.push(e[t])})),n.map((t=>t.map((t=>e.vertices_coords[t])))).map((e=>$e.core.average(...e))).forEach(((t,r)=>{e.vertices_coords[n[r][0]]=t})),{map:replaceGeometryIndices(e,s,r),remove:o}};var Ue=Object.freeze({__proto__:null,getDuplicateVertices:getDuplicateVertices,getEdgeIsolatedVertices:({vertices_coords:e,edges_vertices:t})=>{if(!e||!t)return[];let r=e.length;const o=Array(r).fill(!1);return t.forEach((e=>{e.filter((e=>!o[e])).forEach((e=>{o[e]=!0,r-=1}))})),o.map(((e,t)=>e?void 0:t)).filter((e=>void 0!==e))},getFaceIsolatedVertices:({vertices_coords:e,faces_vertices:t})=>{if(!e||!t)return[];let r=e.length;const o=Array(r).fill(!1);return t.forEach((e=>{e.filter((e=>!o[e])).forEach((e=>{o[e]=!0,r-=1}))})),o.map(((e,t)=>e?void 0:t)).filter((e=>void 0!==e))},getIsolatedVertices:getIsolatedVertices,removeIsolatedVertices:removeIsolatedVertices,removeDuplicateVertices:removeDuplicateVertices});const Ge={edges:"edgeOrders",faces:"faceOrders"},countImplied=(e,t)=>Math.max((e=>{let t=-1;return e.filter((e=>void 0!==e)).forEach((e=>e.forEach((e=>e.forEach((e=>{e>t&&(t=e)})))))),t})(getGraphKeysWithSuffix(e,t).map((t=>e[t]))),e[Ge[t]]?(e=>{let t=-1;return e.forEach((e=>{e[0]>t&&(t=e[0]),e[1]>t&&(t=e[1])})),t})(e[Ge[t]]):-1)+1;countImplied.vertices=e=>countImplied(e,s),countImplied.edges=e=>countImplied(e,n),countImplied.faces=e=>countImplied(e,c);const counterClockwiseWalk=({vertices_vertices:e,vertices_sectors:t},r,o,s={})=>{const n={},c={vertices:[r],edges:[],angles:[]};let i=r,a=o;for(;;){const r=e[a],o=(r.indexOf(i)+r.length-1)%r.length,l=r[o],d=`${a} ${l}`;if(n[d])return Object.assign(s,n),c.vertices.pop(),c;if(n[d]=!0,s[d])return;c.vertices.push(a),c.edges.push(d),t&&c.angles.push(t[a][o]),i=a,a=l}},planarVertexWalk=({vertices_vertices:e,vertices_sectors:t})=>{const r={vertices_vertices:e,vertices_sectors:t},o={};return e.map(((e,t)=>e.map((e=>counterClockwiseWalk(r,t,e,o))).filter((e=>void 0!==e)))).flat()},filterWalkedBoundaryFace=e=>e.filter((e=>e.angles.map((e=>Math.PI-e)).reduce(((e,t)=>e+t),0)>0));var We=Object.freeze({__proto__:null,counterClockwiseWalk:counterClockwiseWalk,planarVertexWalk:planarVertexWalk,filterWalkedBoundaryFace:filterWalkedBoundaryFace});const sortVerticesCounterClockwise=({vertices_coords:e},t,r)=>t.map((t=>e[t])).map((t=>$e.core.subtract(t,e[r]))).map((e=>Math.atan2(e[1],e[0]))).map((e=>e>-$e.core.EPSILON?e:e+2*Math.PI)).map(((e,t)=>({a:e,i:t}))).sort(((e,t)=>e.a-t.a)).map((e=>e.i)).map((e=>t[e])),sortVerticesAlongVector=({vertices_coords:e},t,r)=>t.map((t=>({i:t,d:$e.core.dot(e[t],r)}))).sort(((e,t)=>e.d-t.d)).map((e=>e.i));var Ze=Object.freeze({__proto__:null,sortVerticesCounterClockwise:sortVerticesCounterClockwise,sortVerticesAlongVector:sortVerticesAlongVector});const makeVerticesEdgesUnsorted=({edges_vertices:e})=>{const t=[];return e.forEach(((e,r)=>e.forEach((e=>{void 0===t[e]&&(t[e]=[]),t[e].push(r)})))),t},makeVerticesEdges=({edges_vertices:e,vertices_vertices:t})=>{const r=makeVerticesToEdgeBidirectional({edges_vertices:e});return t.map(((e,t)=>e.map((e=>r[`${t} ${e}`]))))},makeVerticesVertices=({vertices_coords:e,vertices_edges:t,edges_vertices:r})=>{t||(t=makeVerticesEdgesUnsorted({edges_vertices:r}));const o=t.map(((e,t)=>e.map((e=>r[e].filter((e=>e!==t)))).reduce(((e,t)=>e.concat(t)),[])));return void 0===e?o:o.map(((t,r)=>sortVerticesCounterClockwise({vertices_coords:e},t,r)))},makeVerticesVerticesUnsorted=({vertices_edges:e,edges_vertices:t})=>(e||(e=makeVerticesEdgesUnsorted({edges_vertices:t})),e.map(((e,r)=>e.flatMap((e=>t[e].filter((e=>e!==r))))))),makeVerticesFacesUnsorted=({vertices_coords:e,faces_vertices:t})=>{if(!t)return e.map((()=>[]));const r=void 0!==e?e.map((()=>[])):Array.from(Array(countImplied.vertices({faces_vertices:t}))).map((()=>[]));return t.forEach(((e,t)=>{const o=[];e.forEach((e=>{o[e]=t})),o.forEach(((e,t)=>r[t].push(e)))})),r},makeVerticesFaces=({vertices_coords:e,vertices_vertices:t,faces_vertices:r})=>{if(!r)return e.map((()=>[]));if(!t)return makeVerticesFacesUnsorted({vertices_coords:e,faces_vertices:r});const o=makeVerticesToFace({faces_vertices:r});return t.map(((e,t)=>e.map(((e,r,o)=>[o[(r+1)%o.length],t,e].join(" "))))).map((e=>e.map((e=>o[e]))))},makeVerticesToEdgeBidirectional=({edges_vertices:e})=>{const t={};return e.map((e=>e.join(" "))).forEach(((e,r)=>{t[e]=r})),e.map((e=>`${e[1]} ${e[0]}`)).forEach(((e,r)=>{t[e]=r})),t},makeVerticesToEdge=({edges_vertices:e})=>{const t={};return e.map((e=>e.join(" "))).forEach(((e,r)=>{t[e]=r})),t},makeVerticesToFace=({faces_vertices:e})=>{const t={};return e.forEach(((e,r)=>e.map(((t,r)=>[0,1,2].map((t=>(r+t)%e.length)).map((t=>e[t])).join(" "))).forEach((e=>{t[e]=r})))),t},makeVerticesVerticesVector=({vertices_coords:e,vertices_vertices:t,edges_vertices:r,edges_vector:o})=>{o||(o=makeEdgesVector({vertices_coords:e,edges_vertices:r}));const s=makeVerticesToEdge({edges_vertices:r});return t.map(((e,r)=>t[r].map((e=>{const t=s[`${r} ${e}`],n=s[`${e} ${r}`];return void 0!==t?o[t]:void 0!==n?$e.core.flip(o[n]):void 0}))))},makeVerticesSectors=({vertices_coords:e,vertices_vertices:t,edges_vertices:r,edges_vector:o})=>makeVerticesVerticesVector({vertices_coords:e,vertices_vertices:t,edges_vertices:r,edges_vector:o}).map((e=>1===e.length?[$e.core.TWO_PI]:$e.core.counterClockwiseSectors2(e))),makeEdgesFacesUnsorted=({edges_vertices:e,faces_edges:t})=>{const r=void 0!==e?e.map((()=>[])):Array.from(Array(countImplied.edges({faces_edges:t}))).map((()=>[]));return t.forEach(((e,t)=>{const o=[];e.forEach((e=>{o[e]=t})),o.forEach(((e,t)=>r[t].push(e)))})),r},makeEdgesFaces=({vertices_coords:e,edges_vertices:t,edges_vector:r,faces_vertices:o,faces_edges:s,faces_center:n})=>{if(!t)return makeEdgesFacesUnsorted({faces_edges:s});r||(r=makeEdgesVector({vertices_coords:e,edges_vertices:t}));const c=t.map((t=>e[t[0]]));n||(n=makeFacesConvexCenter({vertices_coords:e,faces_vertices:o}));const i=t.map((()=>[]));return s.forEach(((e,t)=>{const r=[];e.forEach((e=>{r[e]=t})),r.forEach(((e,t)=>i[t].push(e)))})),i.forEach(((e,t)=>{const o=e.map((e=>n[e])).map((e=>$e.core.subtract2(e,c[t]))).map((e=>$e.core.cross2(e,r[t])));e.sort(((e,t)=>o[e]-o[t]))})),i},Je={M:-180,m:-180,V:180,v:180},makeEdgesAssignment=({edges_vertices:e,edges_foldAngle:t,edges_faces:r,faces_vertices:o,faces_edges:s})=>(r||(s||(s=makeFacesEdgesFromVertices({edges_vertices:e,faces_vertices:o})),r=makeEdgesFacesUnsorted({edges_vertices:e,faces_edges:s})),t.map(((e,t)=>r[t].length<2?"B":0===e?"F":e<0?"M":"V"))),makeEdgesFoldAngle=({edges_assignment:e})=>e.map((e=>Je[e]||0)),makeEdgesFoldAngleFromFaces=({vertices_coords:e,edges_vertices:t,edges_faces:r,edges_assignment:o,faces_vertices:s,faces_edges:n,faces_normal:c,faces_center:i})=>(r||(n||(n=makeFacesEdgesFromVertices({edges_vertices:t,faces_vertices:s})),r=makeEdgesFacesUnsorted({edges_vertices:t,faces_edges:n})),c||(c=makeFacesNormal({vertices_coords:e,faces_vertices:s})),i||(i=makeFacesConvexCenter({vertices_coords:e,faces_vertices:s})),r.map(((e,t)=>{if(e.length>2&&console.warn("makeEdgesFoldAngleFromFaces non manifold"),e.length<2)return 0;const r=c[e[0]],s=c[e[1]],n=$e.core.normalize($e.core.subtract(i[e[1]],i[e[0]]));let a=Math.sign($e.core.dot(r,n));return 0===a&&(o&&o[t]?("F"!==o[t]&&"F"!==o[t]||(a=0),"M"!==o[t]&&"m"!==o[t]||(a=-1),"V"!==o[t]&&"v"!==o[t]||(a=1)):console.warn("makeEdgesFoldAngleFromFaces cannot determine flat folded faces")),Math.acos($e.core.dot(r,s))*(180/Math.PI)*a}))),makeEdgesCoords=({vertices_coords:e,edges_vertices:t})=>t.map((t=>t.map((t=>e[t])))),makeEdgesVector=({vertices_coords:e,edges_vertices:t})=>makeEdgesCoords({vertices_coords:e,edges_vertices:t}).map((e=>$e.core.subtract(e[1],e[0]))),makeEdgesLength=({vertices_coords:e,edges_vertices:t})=>makeEdgesVector({vertices_coords:e,edges_vertices:t}).map((e=>$e.core.magnitude(e))),makeEdgesBoundingBox=({vertices_coords:e,edges_vertices:t,edges_coords:r},o=0)=>(r||(r=makeEdgesCoords({vertices_coords:e,edges_vertices:t})),r.map((e=>$e.core.boundingBox(e,o)))),makePlanarFaces=({vertices_coords:e,vertices_vertices:t,vertices_edges:r,vertices_sectors:o,edges_vertices:s,edges_vector:n})=>{t||(t=makeVerticesVertices({vertices_coords:e,edges_vertices:s,vertices_edges:r})),o||(o=makeVerticesSectors({vertices_coords:e,vertices_vertices:t,edges_vertices:s,edges_vector:n}));const c=makeVerticesToEdgeBidirectional({edges_vertices:s});return filterWalkedBoundaryFace(planarVertexWalk({vertices_vertices:t,vertices_sectors:o})).map((e=>({...e,edges:e.edges.map((e=>c[e]))})))},makeFacesVerticesFromEdges=e=>e.faces_edges.map((t=>t.map((t=>e.edges_vertices[t])).map(((e,t,r)=>{const o=r[(t+1)%r.length];return e[0]===o[0]||e[0]===o[1]?e[1]:e[0]})))),makeFacesEdgesFromVertices=e=>{const t=makeVerticesToEdgeBidirectional(e);return e.faces_vertices.map((e=>e.map(((e,t,r)=>[e,r[(t+1)%r.length]].join(" "))))).map((e=>e.map((e=>t[e]))))},makeFacesFaces=({faces_vertices:e})=>{const t=e.map((()=>[])),r={};return e.map(((e,t)=>e.map(((o,s,n)=>{let c=n[(s+1)%e.length];c<o&&([o,c]=[c,o]);const i=`${o} ${c}`;void 0===r[i]&&(r[i]={}),r[i][t]=!0})))),Object.values(r).map((e=>Object.keys(e))).filter((e=>e.length>1)).forEach((e=>{t[e[0]].push(parseInt(e[1],10)),t[e[1]].push(parseInt(e[0],10))})),t},makeFacesPolygon=({vertices_coords:e,faces_vertices:t},r)=>t.map((t=>t.map((t=>e[t])))).map((e=>$e.core.makePolygonNonCollinear(e,r))),makeFacesConvexCenter=({vertices_coords:e,faces_vertices:t})=>t.map((t=>t.map((t=>e[t])).reduce(((e,t)=>$e.core.add(e,t)),Array(e[0].length).fill(0)).map((e=>e/t.length)))),makeFacesNormal=({vertices_coords:e,faces_vertices:t})=>t.map((t=>t.map((t=>e[t])))).map((e=>{const t=$e.core.resize(3,$e.core.subtract(e[1],e[0])),r=$e.core.resize(3,$e.core.subtract(e[2],e[0]));return $e.core.normalize3($e.core.cross3(t,r))}));var Xe=Object.freeze({__proto__:null,makeVerticesEdgesUnsorted:makeVerticesEdgesUnsorted,makeVerticesEdges:makeVerticesEdges,makeVerticesVertices:makeVerticesVertices,makeVerticesVerticesUnsorted:makeVerticesVerticesUnsorted,makeVerticesFacesUnsorted:makeVerticesFacesUnsorted,makeVerticesFaces:makeVerticesFaces,makeVerticesToEdgeBidirectional:makeVerticesToEdgeBidirectional,makeVerticesToEdge:makeVerticesToEdge,makeVerticesToFace:makeVerticesToFace,makeVerticesVerticesVector:makeVerticesVerticesVector,makeVerticesSectors:makeVerticesSectors,makeEdgesEdges:({edges_vertices:e,vertices_edges:t})=>e.map(((e,r)=>{const o=t[e[0]].filter((e=>e!==r)),s=t[e[1]].filter((e=>e!==r));return o.concat(s)})),makeEdgesFacesUnsorted:makeEdgesFacesUnsorted,makeEdgesFaces:makeEdgesFaces,makeEdgesAssignmentSimple:({edges_foldAngle:e})=>e.map((e=>0===e?"F":e<0?"M":"V")),makeEdgesAssignment:makeEdgesAssignment,makeEdgesFoldAngle:makeEdgesFoldAngle,makeEdgesFoldAngleFromFaces:makeEdgesFoldAngleFromFaces,makeEdgesCoords:makeEdgesCoords,makeEdgesVector:makeEdgesVector,makeEdgesLength:makeEdgesLength,makeEdgesBoundingBox:makeEdgesBoundingBox,makePlanarFaces:makePlanarFaces,makeFacesVerticesFromEdges:makeFacesVerticesFromEdges,makeFacesEdgesFromVertices:makeFacesEdgesFromVertices,makeFacesFaces:makeFacesFaces,makeFacesPolygon:makeFacesPolygon,makeFacesPolygonQuick:({vertices_coords:e,faces_vertices:t})=>t.map((t=>t.map((t=>e[t])))),makeFacesCenter2D:({vertices_coords:e,faces_vertices:t})=>t.map((t=>t.map((t=>e[t])))).map((e=>$e.core.centroid(e))),makeFacesConvexCenter:makeFacesConvexCenter,makeFacesNormal:makeFacesNormal});const getCircularEdges=({edges_vertices:e})=>{if(!e)return[];const t=[];for(let r=0;r<e.length;r+=1)e[r][0]===e[r][1]&&t.push(r);return t},getDuplicateEdges=({edges_vertices:e})=>{if(!e)return[];const t=[],r={};for(let o=0;o<e.length;o+=1){const s=`${e[o][0]} ${e[o][1]}`,n=`${e[o][1]} ${e[o][0]}`;void 0!==r[s]?t[o]=r[s]:(r[s]=o,r[n]=o)}return t},removeCircularEdges=(e,t)=>(t||(t=getCircularEdges(e)),t.length&&((e,t,r)=>{const o={};r.forEach((e=>{o[e]=!0})),getGraphKeysWithSuffix(e,t).forEach((t=>e[t].forEach(((r,s)=>{for(let n=r.length-1;n>=0;n-=1)!0===o[r[n]]&&e[t][s].splice(n,1)}))))})(e,n,t),{map:removeGeometryIndices(e,n,t),remove:t}),removeDuplicateEdges=(e,t)=>{t||(t=getDuplicateEdges(e));const r=Object.keys(t).map((e=>parseInt(e,10))),o=replaceGeometryIndices(e,n,t);return r.length&&(e.vertices_edges||e.vertices_vertices||e.vertices_faces)&&(e.vertices_edges=makeVerticesEdgesUnsorted(e),e.vertices_vertices=makeVerticesVertices(e),e.vertices_edges=makeVerticesEdges(e),e.vertices_faces=makeVerticesFaces(e)),{map:o,remove:r}};var He=Object.freeze({__proto__:null,getCircularEdges:getCircularEdges,getDuplicateEdges:getDuplicateEdges,removeCircularEdges:removeCircularEdges,removeDuplicateEdges:removeDuplicateEdges});const mergeSimpleNextmaps=(...e)=>{if(0===e.length)return[];const t=e[0].map(((e,t)=>t));return e.forEach((e=>t.forEach(((r,o)=>{t[o]=e[r]})))),t},mergeNextmaps=(...e)=>{if(0===e.length)return[];const t=e[0].map(((e,t)=>[t]));return e.forEach((e=>{t.forEach(((r,o)=>r.forEach(((r,s)=>{t[o][s]=e[r]})))),t.forEach(((e,r)=>{t[r]=e.reduce(((e,t)=>e.concat(t)),[]).filter((e=>void 0!==e))}))})),t},mergeBackmaps=(...e)=>{if(0===e.length)return[];let r=e[0].reduce(((e,t)=>e.concat(t)),[]).map(((e,t)=>[t]));return e.forEach((e=>{const o=[];e.forEach(((e,s)=>{o[s]=typeof e===t?r[e]:e.map((e=>r[e])).reduce(((e,t)=>e.concat(t)),[])})),r=o})),r},invertMap=e=>{const r=[];return e.forEach(((e,o)=>{null!=e&&(typeof e===t&&(void 0!==r[e]?typeof r[e]===t?r[e]=[r[e],o]:r[e].push(o):r[e]=o),e.constructor===Array&&e.forEach((e=>{r[e]=o})))})),r},invertSimpleMap=e=>{const t=[];return e.forEach(((e,r)=>{t[e]=r})),t};var Ye=Object.freeze({__proto__:null,mergeSimpleNextmaps:mergeSimpleNextmaps,mergeNextmaps:mergeNextmaps,mergeSimpleBackmaps:(...e)=>{if(0===e.length)return[];let t=e[0].map(((e,t)=>t));return e.forEach((e=>{const r=e.map((e=>t[e]));t=r})),t},mergeBackmaps:mergeBackmaps,invertMap:invertMap,invertSimpleMap:invertSimpleMap});const clean=(e,t)=>{const r=removeDuplicateVertices(e,t),o=removeCircularEdges(e),s=removeDuplicateEdges(e),n=removeIsolatedVertices(e),c=invertSimpleMap(r.map),i=n.remove.map((e=>c[e])),a=invertSimpleMap(o.map),l=s.remove.map((e=>a[e]));return{vertices:{map:mergeSimpleNextmaps(r.map,n.map),remove:r.remove.concat(i)},edges:{map:mergeSimpleNextmaps(o.map,s.map),remove:o.remove.concat(l)}}},validate$1=(e,t)=>{const r=getDuplicateEdges(e),o=getCircularEdges(e),s=getIsolatedVertices(e),n=getDuplicateVertices(e,t),c=(e=>{const t=count.vertices(e),r=count.edges(e),o=count.faces(e);return{vertices:t>=countImplied.vertices(e),edges:r>=countImplied.edges(e),faces:o>=countImplied.faces(e)}})(e);return{summary:0===r.length&&0===o.length&&0===s.length&&c.vertices&&c.edges&&c.faces?"valid":"problematic",vertices:{isolated:s,duplicate:n,references:c.vertices},edges:{circular:o,duplicate:r,references:c.edges},faces:{references:c.faces}}},populate=(e,t)=>"object"!=typeof e?e:e.edges_vertices?(e.vertices_edges=makeVerticesEdgesUnsorted(e),e.vertices_vertices=makeVerticesVertices(e),e.vertices_edges=makeVerticesEdges(e),(e=>{const t=e.edges_vertices.length;if(e.edges_assignment||(e.edges_assignment=[]),e.edges_foldAngle||(e.edges_foldAngle=[]),e.edges_assignment.length>e.edges_foldAngle.length)for(let t=e.edges_foldAngle.length;t<e.edges_assignment.length;t+=1)e.edges_foldAngle[t]=edgeAssignmentToFoldAngle(e.edges_assignment[t]);if(e.edges_foldAngle.length>e.edges_assignment.length)for(let t=e.edges_assignment.length;t<e.edges_foldAngle.length;t+=1)e.edges_assignment[t]=edgeFoldAngleToAssignment(e.edges_foldAngle[t]);for(let r=e.edges_assignment.length;r<t;r+=1)e.edges_assignment[r]="U",e.edges_foldAngle[r]=0})(e),((e,t)=>{if(void 0!==t||e.faces_vertices||e.faces_edges||(t=!0),t&&e.vertices_coords){const t=makePlanarFaces(e);return e.faces_vertices=t.map((e=>e.vertices)),void(e.faces_edges=t.map((e=>e.edges)))}e.faces_vertices&&e.faces_edges||(e.faces_vertices&&!e.faces_edges?e.faces_edges=makeFacesEdgesFromVertices(e):e.faces_edges&&!e.faces_vertices?e.faces_vertices=makeFacesVerticesFromEdges(e):(e.faces_vertices=[],e.faces_edges=[]))})(e,t),e.vertices_faces=makeVerticesFaces(e),e.edges_faces=makeEdgesFacesUnsorted(e),e.faces_faces=makeFacesFaces(e),e):e,getEdgesVerticesOverlappingSpan=(e,t=$e.core.EPSILON)=>makeEdgesBoundingBox(e,t).map((t=>e.vertices_coords.map((e=>e[0]>t.min[0]&&e[1]>t.min[1]&&e[0]<t.max[0]&&e[1]<t.max[1])))),getEdgesEdgesOverlapingSpans=({vertices_coords:e,edges_vertices:t,edges_coords:r},o=$e.core.EPSILON)=>{const s=makeEdgesBoundingBox({vertices_coords:e,edges_vertices:t,edges_coords:r},o),n=t.map((()=>[]));for(let e=0;e<t.length-1;e+=1)for(let r=e+1;r<t.length;r+=1){const t=(s[e].max[0]<s[r].min[0]||s[r].max[0]<s[e].min[0])&&(s[e].max[1]<s[r].min[1]||s[r].max[1]<s[e].min[1]);n[e][r]=!t,n[r][e]=!t}for(let e=0;e<t.length;e+=1)n[e][e]=!0;return n};var Ke=Object.freeze({__proto__:null,getEdgesVerticesOverlappingSpan:getEdgesVerticesOverlappingSpan,getEdgesEdgesOverlapingSpans:getEdgesEdgesOverlapingSpans});const isVertexCollinear=({vertices_coords:e,vertices_edges:t,edges_vertices:r},o,s=$e.core.EPSILON)=>{if(!e||!r)return!1;t||(t=makeVerticesEdgesUnsorted({edges_vertices:r}));const n=t[o];if(void 0===n||2!==n.length)return!1;const c=(({edges_vertices:e},t,r)=>(r.forEach((r=>{e[r][0]===t&&e[r][1]===t&&console.warn("removePlanarVertex circular edge")})),r.map((r=>e[r][0]===t?e[r][1]:e[r][0]))))({edges_vertices:r},o,n),i=[c[0],o,c[1]].map((t=>e[t]));return $e.core.collinearBetween(...i,!1,s)},getVerticesEdgesOverlap=({vertices_coords:e,edges_vertices:t,edges_coords:r},o=$e.core.EPSILON)=>{r||(r=t.map((t=>t.map((t=>e[t])))));const s=getEdgesVerticesOverlappingSpan({vertices_coords:e,edges_vertices:t,edges_coords:r},o);for(let t=0;t<r.length;t+=1)for(let n=0;n<e.length;n+=1)s[t][n]&&(s[t][n]=$e.core.overlapLinePoint($e.core.subtract(r[t][1],r[t][0]),r[t][0],e[n],$e.core.excludeS,o));return s.map((e=>e.map(((e,t)=>e?t:void 0)).filter((e=>void 0!==e))))};var Qe=Object.freeze({__proto__:null,isVertexCollinear:isVertexCollinear,getVerticesEdgesOverlap:getVerticesEdgesOverlap});const makeEdgesLineParallelOverlap=({vertices_coords:e,edges_vertices:t},r,o,s=$e.core.EPSILON)=>{const n=$e.core.normalize2(r),c=t.map((t=>e[t[0]])),i=t.map((t=>t.map((t=>e[t])))).map((e=>$e.core.subtract2(e[1],e[0]))).map((e=>$e.core.parallel2(e,r,s)));for(let e=0;e<t.length;e+=1){if(!i[e])continue;if($e.core.fnEpsilonEqualVectors(c[e],o)){i[e]=!0;continue}const t=$e.core.normalize2($e.core.subtract2(c[e],o)),r=Math.abs($e.core.dot2(t,n));i[e]=Math.abs(1-r)<s}return i},makeEdgesSegmentIntersection=({vertices_coords:e,edges_vertices:t,edges_coords:r},o,s,n=$e.core.EPSILON)=>{r||(r=makeEdgesCoords({vertices_coords:e,edges_vertices:t}));const c=$e.core.boundingBox([o,s],n),i=$e.core.subtract2(s,o);return makeEdgesBoundingBox({vertices_coords:e,edges_vertices:t,edges_coords:r},n).map((e=>$e.core.overlapBoundingBoxes(c,e))).map(((e,t)=>e?$e.core.intersectLineLine(i,o,$e.core.subtract2(r[t][1],r[t][0]),r[t][0],$e.core.includeS,$e.core.includeS,n):void 0))},makeEdgesEdgesIntersection=function({vertices_coords:e,edges_vertices:t,edges_vector:r,edges_origin:o},s=$e.core.EPSILON){r||(r=makeEdgesVector({vertices_coords:e,edges_vertices:t})),o||(o=t.map((t=>e[t[0]])));const n=r.map((()=>[])),c=getEdgesEdgesOverlapingSpans({vertices_coords:e,edges_vertices:t},s);for(let e=0;e<r.length-1;e+=1)for(let t=e+1;t<r.length;t+=1)!0===c[e][t]?(n[e][t]=$e.core.intersectLineLine(r[e],o[e],r[t],o[t],$e.core.excludeS,$e.core.excludeS,s),n[t][e]=n[e][t]):n[e][t]=void 0;return n},intersectConvexFaceLine=({vertices_coords:e,edges_vertices:t,faces_vertices:r,faces_edges:o},s,n,c,i=$e.core.EPSILON)=>{const a=r[s].map((t=>e[t])).map((e=>$e.core.overlapLinePoint(n,c,e,(()=>!0),i))).map(((e,t)=>e?t:void 0)).filter((e=>void 0!==e)),l=a.map((e=>r[s][e]));if(a.concat(a.map((e=>e+r[s].length))).map(((e,t,r)=>r[t+1]-e==1)).reduce(((e,t)=>e||t),!1))return;if(l.length>1)return{vertices:l,edges:[]};const d=o[s].map((r=>t[r].map((t=>e[t])))).map((e=>$e.core.intersectLineLine(n,c,$e.core.subtract(e[1],e[0]),e[0],$e.core.includeL,$e.core.excludeS,i))).map(((e,t)=>({coords:e,edge:o[s][t]}))).filter((e=>void 0!==e.coords)).filter((e=>!l.map((r=>t[e.edge].includes(r))).reduce(((e,t)=>e||t),!1)));return d.length+l.length===2?{vertices:l,edges:d}:void 0};var et=Object.freeze({__proto__:null,makeEdgesLineParallelOverlap:makeEdgesLineParallelOverlap,makeEdgesSegmentIntersection:makeEdgesSegmentIntersection,makeEdgesEdgesIntersection:makeEdgesEdgesIntersection,intersectConvexFaceLine:intersectConvexFaceLine});const fragment_graph=(e,t=$e.core.EPSILON)=>{const r=e.edges_vertices.map((t=>t.map((t=>e.vertices_coords[t])))),o=r.map((e=>$e.core.subtract(e[1],e[0]))),s=r.map((e=>e[0])),n=makeEdgesEdgesIntersection({vertices_coords:e.vertices_coords,edges_vertices:e.edges_vertices,edges_vector:o,edges_origin:s},1e-6),c=getVerticesEdgesOverlap({vertices_coords:e.vertices_coords,edges_vertices:e.edges_vertices,edges_coords:r},t);if(0===n.flat().filter((e=>void 0!==e)).length&&0===c.flat().filter((e=>void 0!==e)).length)return;const i=e.vertices_coords.length;n.forEach((t=>t.filter((e=>void 0!==e)).filter((e=>2===e.length)).forEach((t=>{const r=e.vertices_coords.length;e.vertices_coords.push([...t]),t.splice(0,2),t.push(r)})))),n.forEach(((e,t)=>{e.forEach(((e,r)=>{e&&(n[t][r]=e[0])}))}));const a=n.map((e=>e.filter((e=>void 0!==e))));e.edges_vertices.forEach(((e,t)=>e.push(...a[t],...c[t]))),e.edges_vertices.forEach(((t,r)=>{e.edges_vertices[r]=sortVerticesAlongVector({vertices_coords:e.vertices_coords},t,o[r])}));const l=e.edges_vertices.map(((e,t)=>Array(e.length-1).fill(t))).flat();if(e.edges_vertices=e.edges_vertices.map((e=>Array.from(Array(e.length-1)).map(((t,r,o)=>[e[r],e[r+1]])))).flat(),e.edges_assignment&&e.edges_foldAngle&&e.edges_foldAngle.length>e.edges_assignment.length)for(let t=e.edges_assignment.length;t<e.edges_foldAngle.length;t+=1)e.edges_assignment[t]=edgeFoldAngleToAssignment(e.edges_foldAngle[t]);return e.edges_assignment&&(e.edges_assignment=l.map((t=>e.edges_assignment[t]||"U"))),e.edges_foldAngle&&(e.edges_foldAngle=l.map((t=>e.edges_foldAngle[t])).map(((t,r)=>void 0===t?edgeAssignmentToFoldAngle(e.edges_assignment[r]):t))),{vertices:{new:Array.from(Array(e.vertices_coords.length-i)).map(((e,t)=>i+t))},edges:{backmap:l}}},tt=[a,l,u,p],fragment=(e,t=$e.core.EPSILON)=>{e.vertices_coords=e.vertices_coords.map((e=>e.slice(0,2))),[s,n,c].map((t=>getGraphKeysWithPrefix(e,t))).flat().filter((e=>!tt.includes(e))).forEach((t=>delete e[t]));const r={vertices:{},edges:{}};let o;for(o=0;o<20;o+=1){const o=removeDuplicateVertices(e,t/2),s=removeDuplicateEdges(e),n=removeCircularEdges(e),c=fragment_graph(e,t);if(void 0===c){r.vertices.map=void 0===r.vertices.map?o.map:mergeNextmaps(r.vertices.map,o.map),r.edges.map=void 0===r.edges.map?mergeNextmaps(s.map,n.map):mergeNextmaps(r.edges.map,s.map,n.map);break}const i=invertMap(c.edges.backmap),a=mergeNextmaps(s.map,n.map,i);r.vertices.map=void 0===r.vertices.map?o.map:mergeNextmaps(r.vertices.map,o.map),r.edges.map=void 0===r.edges.map?a:mergeNextmaps(r.edges.map,a)}return 20===o&&console.warn("fragment reached max iterations"),r},getBoundaryVertices=({edges_vertices:e,edges_assignment:t})=>uniqueIntegers(e.filter(((e,r)=>"B"===t[r]||"b"===t[r])).flat()),getBoundary=({vertices_edges:e,edges_vertices:t,edges_assignment:r})=>{if(void 0===r)return{vertices:[],edges:[]};e||(e=makeVerticesEdgesUnsorted({edges_vertices:t}));const o=r.map((e=>"B"===e||"b"===e)),s=[],n=[];let c=-1;for(let e=0;e<o.length;e+=1)if(o[e]){c=e;break}if(-1===c)return{vertices:[],edges:[]};o[c]=!1,s.push(c),n.push(t[c][0]);let i=t[c][1];for(;n[0]!==i;){if(n.push(i),c=e[i].filter((e=>o[e])).shift(),void 0===c)return{vertices:[],edges:[]};t[c][0]===i?[,i]=t[c]:[i]=t[c],o[c]=!1,s.push(c)}return{vertices:n,edges:s}};var rt=Object.freeze({__proto__:null,getBoundingBox:({vertices_coords:e},t)=>$e.core.boundingBox(e,t),getBoundaryVertices:getBoundaryVertices,getBoundary:getBoundary,getPlanarBoundary:({vertices_coords:e,vertices_edges:t,vertices_vertices:r,edges_vertices:o})=>{r||(r=makeVerticesVertices({vertices_coords:e,vertices_edges:t,edges_vertices:o}));const s=makeVerticesToEdgeBidirectional({edges_vertices:o}),n=[],c=[],i={vertices:c,edges:n};let a=-1/0,l=-1;if(e.forEach(((e,t)=>{e[0]>a&&(a=e[0],l=t)})),-1===l)return i;c.push(l);const d=e[l],u=r[l],p=u.map((t=>e[t])).map((e=>[e[0]-d[0],e[1]-d[1]])).map((e=>Math.atan2(e[1],e[0]))).map((e=>e<0?e+2*Math.PI:e)).map(((e,t)=>({a:e,i:t}))).sort(((e,t)=>e.a-t.a)).shift().i,g=u[p],m=s[l<g?`${l} ${g}`:`${g} ${l}`];n.push(m);let h=l,v=g,_=0;for(;_<1e4;){const e=r[v],t=e.indexOf(h),o=e[(t+1)%e.length],a=s[v<o?`${v} ${o}`:`${o} ${v}`];if(a===n[0])return i;c.push(v),n.push(a),h=v,v=o,_+=1}return console.warn("calculate boundary potentially entered infinite loop"),i}});const apply_matrix_to_graph=function(e,t){return filterKeysWithSuffix(e,"coords").forEach((r=>{e[r]=e[r].map((e=>$e.core.resize(3,e))).map((e=>$e.core.multiplyMatrix3Vector3(t,e)))})),filterKeysWithSuffix(e,"matrix").forEach((r=>{e[r]=e[r].map((e=>$e.core.multiplyMatrices3(e,t)))})),e};var ot={scale:(e,...t)=>{const r=1===t.length?[t[0],t[0],t[0]]:[1,1,1].map(((e,r)=>void 0===t[r]?e:t[r])),o=$e.core.makeMatrix3Scale(r);return apply_matrix_to_graph(e,o)},translate:(e,...t)=>{const r=$e.core.getVector(...t),o=$e.core.resize(3,r),s=$e.core.makeMatrix3Translate(...o);return apply_matrix_to_graph(e,s)},rotateZ:(e,t,...r)=>{const o=$e.core.getVector(...r),s=$e.core.resize(3,o),n=$e.core.makeMatrix3RotateZ(t,...s);return apply_matrix_to_graph(e,n)},transform:apply_matrix_to_graph};const getFaceFaceSharedVertices=(e,t)=>{const r={};t.forEach((e=>{r[e]=!0}));const o=e.map((e=>!!r[e])),s=[],n=o.indexOf(!1),c={};for(let t=n+1;t<o.length;t+=1)o[t]&&!c[e[t]]&&(s.push(e[t]),c[e[t]]=!0);for(let t=0;t<n;t+=1)o[t]&&!c[e[t]]&&(s.push(e[t]),c[e[t]]=!0);return s},makeFaceSpanningTree=({faces_vertices:e,faces_faces:t},r=0)=>{if(t||(t=makeFacesFaces({faces_vertices:e})),0===t.length)return[];const o=[[{face:r}]],s={};s[r]=!0;do{const r=o[o.length-1].map((e=>t[e.face].map((t=>({face:t,parent:e.face}))))).reduce(((e,t)=>e.concat(t)),[]),n={};r.forEach(((e,t)=>{s[e.face]&&(n[t]=!0),s[e.face]=!0}));const c=r.filter(((e,t)=>!n[t]));c.map((t=>getFaceFaceSharedVertices(e[t.face],e[t.parent]))).forEach(((e,t)=>{const r=e.slice(0,2);c[t].edge_vertices=r})),o[o.length]=c}while(o[o.length-1].length>0);return o.length>0&&0===o[o.length-1].length&&o.pop(),o};var st=Object.freeze({__proto__:null,getFaceFaceSharedVertices:getFaceFaceSharedVertices,makeFaceSpanningTree:makeFaceSpanningTree});const multiplyVerticesFacesMatrix2=({vertices_coords:e,vertices_faces:t,faces_vertices:r},o)=>{t||(t=makeVerticesFaces({faces_vertices:r}));const s=t.map((e=>e.filter((e=>null!=e)).shift())).map((e=>void 0===e?$e.core.identity2x3:o[e]));return e.map(((e,t)=>$e.core.multiplyMatrix2Vector2(s[t],e)))},nt={U:!0,u:!0},makeFacesMatrix=({vertices_coords:e,edges_vertices:t,edges_foldAngle:r,edges_assignment:o,faces_vertices:s,faces_faces:n},c=0)=>{!o&&r&&(o=makeEdgesAssignment({edges_foldAngle:r})),r||(r=o?makeEdgesFoldAngle({edges_assignment:o}):Array(t.length).fill(0));const i=makeVerticesToEdgeBidirectional({edges_vertices:t}),a=s.map((()=>$e.core.identity3x4));return makeFaceSpanningTree({faces_vertices:s,faces_faces:n},c).slice(1).forEach((t=>t.forEach((t=>{const s=t.edge_vertices.map((t=>e[t])),n=t.edge_vertices.join(" "),c=i[n],l=nt[o[c]]?Math.PI:r[c]*Math.PI/180,d=$e.core.makeMatrix3Rotate(l,$e.core.subtract(...$e.core.resizeUp(s[1],s[0])),s[0]);a[t.face]=$e.core.multiplyMatrices3(a[t.parent],d)})))),a},ct={M:!0,m:!0,V:!0,v:!0,U:!0,u:!0,F:!1,f:!1,B:!1,b:!1},makeEdgesIsFolded=({edges_vertices:e,edges_foldAngle:t,edges_assignment:r})=>void 0===r?void 0===t?e.map((()=>!0)):t.map((e=>e<-$e.core.EPSILON||e>$e.core.EPSILON)):r.map((e=>ct[e])),makeFacesMatrix2=({vertices_coords:e,edges_vertices:t,edges_foldAngle:r,edges_assignment:o,faces_vertices:s,faces_faces:n},c=0)=>{r||(r=o?makeEdgesFoldAngle({edges_assignment:o}):Array(t.length).fill(0));const i=makeEdgesIsFolded({edges_vertices:t,edges_foldAngle:r,edges_assignment:o}),a=makeVerticesToEdgeBidirectional({edges_vertices:t}),l=s.map((()=>$e.core.identity2x3));return makeFaceSpanningTree({faces_vertices:s,faces_faces:n},c).slice(1).forEach((t=>t.forEach((t=>{const r=t.edge_vertices.map((t=>e[t])),o=t.edge_vertices.join(" "),s=a[o],n=$e.core.subtract2(r[1],r[0]),c=r[0],d=i[s]?$e.core.makeMatrix2Reflect(n,c):$e.core.identity2x3;l[t.face]=$e.core.multiplyMatrices2(l[t.parent],d)})))),l};var it=Object.freeze({__proto__:null,multiplyVerticesFacesMatrix2:multiplyVerticesFacesMatrix2,makeFacesMatrix:makeFacesMatrix,makeEdgesIsFolded:makeEdgesIsFolded,makeFacesMatrix2:makeFacesMatrix2});const makeVerticesCoordsFolded=({vertices_coords:e,vertices_faces:t,edges_vertices:r,edges_foldAngle:o,edges_assignment:s,faces_vertices:n,faces_faces:c,faces_matrix:i},a)=>{i=makeFacesMatrix({vertices_coords:e,edges_vertices:r,edges_foldAngle:o,edges_assignment:s,faces_vertices:n,faces_faces:c},a),t||(t=makeVerticesFaces({faces_vertices:n}));const l=t.map((e=>e.filter((e=>null!=e)).shift())).map((e=>void 0===e?$e.core.identity3x4:i[e]));return e.map((e=>$e.core.resize(3,e))).map(((e,t)=>$e.core.multiplyMatrix3Vector3(l[t],e)))},makeVerticesCoordsFlatFolded=({vertices_coords:e,edges_vertices:t,edges_foldAngle:r,edges_assignment:o,faces_vertices:s,faces_faces:n},c=0)=>{const i=makeEdgesIsFolded({edges_vertices:t,edges_foldAngle:r,edges_assignment:o}),a=[];s[c].forEach((t=>{a[t]=[...e[t]]}));const l=[];l[c]=!1;const d=makeVerticesToEdgeBidirectional({edges_vertices:t});return makeFaceSpanningTree({faces_vertices:s,faces_faces:n},c).slice(1).forEach((r=>r.forEach((r=>{const o=r.edge_vertices.join(" "),n=d[o],c=t[n].map((e=>a[e]));if(void 0===c[0]||void 0===c[1])return;const u=t[n].map((t=>e[t])),p=u[0],g=$e.core.normalize2($e.core.subtract2(u[1],u[0])),m=$e.core.rotate90(g);l[r.face]=i[n]?!l[r.parent]:l[r.parent];const h=$e.core.normalize2($e.core.subtract2(c[1],c[0])),v=c[0],_=l[r.face]?$e.core.rotate270(h):$e.core.rotate90(h);s[r.face].filter((e=>void 0===a[e])).forEach((t=>{const r=$e.core.subtract2(e[t],p),o=$e.core.dot(r,m),s=$e.core.dot(r,g),n=$e.core.scale2(h,s),c=$e.core.scale2(_,o),i=$e.core.add2($e.core.add2(v,n),c);a[t]=i}))})))),a};var at=Object.freeze({__proto__:null,makeVerticesCoordsFolded:makeVerticesCoordsFolded,makeVerticesCoordsFlatFolded:makeVerticesCoordsFlatFolded});const clone=function(e){let t,o;if(typeof e!==r)return e;if(!e)return e;if("[object Array]"===Object.prototype.toString.apply(e)){for(t=[],o=0;o<e.length;o+=1)t[o]=clone(e[o]);return t}for(o in t={},e)e.hasOwnProperty(o)&&(t[o]=clone(e[o]));return t},makeFacesWindingFromMatrix2=e=>e.map((e=>e[0]*e[3]-e[1]*e[2])).map((e=>e>=0)),makeFacesWinding=({vertices_coords:e,faces_vertices:t})=>t.map((t=>t.map((t=>e[t])).map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>(e[1][0]-e[0][0])*(e[1][1]+e[0][1]))).reduce(((e,t)=>e+t),0))).map((e=>e<0));var lt=Object.freeze({__proto__:null,makeFacesWindingFromMatrix:e=>e.map((e=>e[0]*e[4]-e[1]*e[3])).map((e=>e>=0)),makeFacesWindingFromMatrix2:makeFacesWindingFromMatrix2,makeFacesWinding:makeFacesWinding});const explodeFaces=e=>{const t=e.faces_vertices.flatMap((t=>t.map((t=>e.vertices_coords[t]))));let r=0;const o=e.faces_vertices.map((e=>e.map((()=>r++))));return{vertices_coords:JSON.parse(JSON.stringify(t)),faces_vertices:o}},explodeShrinkFaces=({vertices_coords:e,faces_vertices:t},r=.333)=>{const o=explodeFaces({vertices_coords:e,faces_vertices:t}),s=makeFacesWinding(o),n=o.faces_vertices.map((e=>e.map((e=>o.vertices_coords[e])))).map((e=>e.map(((e,t,r)=>$e.core.subtract2(e,r[(t+1)%r.length]))))),c=makeFacesConvexCenter({vertices_coords:e,faces_vertices:t}),i=t.map((t=>t.map((t=>e[t])))).map(((e,t)=>e.map((e=>$e.core.distance2(e,c[t]))))),a=n.map(((e,t)=>e.map(((e,t,r)=>[e,$e.core.flip(r[(t-1+r.length)%r.length])])).map((e=>s[t]?$e.core.counterClockwiseBisect2(...e):$e.core.clockwiseBisect2(...e))))).map(((e,t)=>e.map(((e,r)=>$e.core.scale(e,i[t][r])))));return o.faces_vertices.forEach(((e,t)=>e.forEach(((e,s)=>{o.vertices_coords[e]=$e.core.add2(o.vertices_coords[e],$e.core.scale2(a[t][s],-r))})))),o};var dt=Object.freeze({__proto__:null,explode:e=>{if(!e.faces_vertices)return{};const t=e.faces_edges?e.faces_edges:makeFacesEdgesFromVertices(e),r=e.faces_vertices.flatMap((e=>e)),o=t.flatMap((e=>e));let s=0,n=0,c=0;return e.faces_vertices=e.faces_vertices.map((e=>e.map((()=>s++)))),e.faces_edges=e.faces_edges.map((e=>e.map((()=>n++)))),e.edges_vertices=e.faces_edges.flatMap((e=>e.map(((e,t,r)=>{const o=t===r.length-1?[c,c+1-r.length]:[c,c+1];return c+=1,o})))),e.vertices_coords&&(e.vertices_coords=clone(r.map((t=>e.vertices_coords[t])))),e.edges_assignment&&(e.edges_assignment=clone(o.map((t=>e.edges_assignment[t])))),e.edges_foldAngle&&(e.edges_foldAngle=clone(o.map((t=>e.edges_foldAngle[t])))),e.vertices_vertices&&delete e.vertices_vertices,e.vertices_edges&&delete e.vertices_edges,e.vertices_faces&&delete e.vertices_faces,e.edges_edges&&delete e.edges_edges,e.edges_faces&&delete e.edges_faces,e.faces_faces&&delete e.faces_faces,{vertices:{map:r},edges:{map:o}}},explodeFaces:explodeFaces,explodeShrinkFaces:explodeShrinkFaces});const nearestVertex=({vertices_coords:e},t)=>{if(!e)return;const r=$e.core.resize(e[0].length,t),o=e.map(((e,t)=>({d:$e.core.distance(r,e),i:t}))).sort(((e,t)=>e.d-t.d)).shift();return o?o.i:void 0},nearestEdge=({vertices_coords:e,edges_vertices:t},r)=>{if(!e||!t)return;const o=t.map((t=>t.map((t=>e[t])))).map((e=>$e.core.nearestPointOnLine($e.core.subtract(e[1],e[0]),e[0],r,$e.core.segmentLimiter)));return $e.core.smallestComparisonSearch(r,o,$e.core.distance)},faceContainingPoint=({vertices_coords:e,faces_vertices:t},r)=>{if(!e||!t)return;const o=t.map(((t,r)=>({face:t.map((t=>e[t])),i:r}))).filter((e=>$e.core.overlapConvexPolygonPoint(e.face,r))).shift();return void 0===o?void 0:o.i},nearestFace=(e,t)=>{const r=faceContainingPoint(e,t);if(void 0!==r)return r;if(e.edges_faces){const r=nearestEdge(e,t),o=e.edges_faces[r];if(1===o.length)return o[0];if(o.length>1){const r=makeFacesConvexCenter({vertices_coords:e.vertices_coords,faces_vertices:o.map((t=>e.faces_vertices[t]))}).map((e=>$e.core.distance(e,t)));let s=0;for(let e=0;e<r.length;e+=1)r[e]<r[s]&&(s=e);return o[s]}}};var ft=Object.freeze({__proto__:null,nearestVertex:nearestVertex,nearestEdge:nearestEdge,faceContainingPoint:faceContainingPoint,nearestFace:nearestFace,nearest:(e,...t)=>{const r={vertices:nearestVertex,edges:nearestEdge,faces:nearestFace},o=$e.core.getVector(...t),s=Object.create(null);return["vertices","edges","faces"].forEach((t=>{Object.defineProperty(s,Be[t],{enumerable:!0,get:()=>r[t](e,o)}),filterKeysWithPrefix(e,t).forEach((r=>Object.defineProperty(s,r,{enumerable:!0,get:()=>e[r][s[Be[t]]]})))})),s}});const addVertices=(e,t,r=$e.core.EPSILON)=>{e.vertices_coords||(e.vertices_coords=[]),"number"==typeof t[0]&&(t=[t]);const o=t.map((t=>e.vertices_coords.map((e=>$e.core.distance(e,t)<r)).map(((e,t)=>e?t:void 0)).filter((e=>void 0!==e)).shift()));let s=e.vertices_coords.length;const n=t.filter(((e,t)=>void 0===o[t]));return e.vertices_coords.push(...n),o.map((e=>void 0===e?s++:e))},splitEdge=(e,t,r,o=$e.core.EPSILON)=>{if(e.edges_vertices.length<t)return{};const s=e.edges_vertices[t];r||(r=$e.core.midpoint(...s));const c=s.map((t=>e.vertices_coords[t])).map((e=>$e.core.distance(e,r)<o));if(c[0])return{vertex:s[0],edges:{}};if(c[1])return{vertex:s[1],edges:{}};const i=e.vertices_coords.length;e.vertices_coords[i]=r;const a=[0,1].map((t=>t+e.edges_vertices.length));((e,t,r)=>{const o=e.edges_vertices[t],s=[{edges_vertices:[o[0],r]},{edges_vertices:[r,o[1]]}];if(s.forEach((r=>[u,p].filter((r=>e[r]&&void 0!==e[r][t])).forEach((o=>{r[o]=e[o][t]})))),e.vertices_coords&&(e.edges_length||e.edges_vector)){const t=s.map((t=>t.edges_vertices.map((t=>e.vertices_coords[t]))));e.edges_vector&&s.forEach(((e,r)=>{e.edges_vector=$e.core.subtract(t[r][1],t[r][0])})),e.edges_length&&s.forEach(((e,r)=>{e.edges_length=$e.core.distance2(...t[r])}))}return s})(e,t,i).forEach(((t,r)=>Object.keys(t).forEach((o=>{e[o][a[r]]=t[o]})))),(({vertices_vertices:e},t,r)=>{e&&(e[t]=[...r],r.forEach(((r,o,s)=>{const n=s[(o+1)%s.length],c=e[r].indexOf(n);e[r][c]=t})))})(e,i,s),(({vertices_coords:e,vertices_vertices:t,vertices_sectors:r},o)=>{r&&(r[o]=1===t[o].length?[$e.core.TWO_PI]:$e.core.counterClockwiseSectors2(t[o].map((t=>$e.core.subtract2(e[t],e[o])))))})(e,i),(({vertices_edges:e},t,r,o,s)=>{e&&(e[r]=[...s],o.map((r=>e[r].indexOf(t))).forEach(((t,r)=>{e[o[r]][t]=s[r]})))})(e,t,i,s,a);const l=(({vertices_faces:e,edges_vertices:t,edges_faces:r,faces_edges:o,faces_vertices:s},n)=>{if(r&&r[n])return r[n];const c=t[n];if(void 0!==e){const t=[];for(let r=0;r<e[c[0]].length;r+=1)for(let o=0;o<e[c[1]].length;o+=1)if(e[c[0]][r]===e[c[1]][o]){if(void 0===e[c[0]][r])continue;t.push(e[c[0]][r])}return t}if(o){const e=[];for(let t=0;t<o.length;t+=1)for(let r=0;r<o[t].length;r+=1)o[t][r]===n&&e.push(t);return e}s&&console.warn("todo: findAdjacentFacesToEdge")})(e,t);l&&((({vertices_faces:e},t,r)=>{e&&(e[t]=[...r])})(e,i,l),(({edges_faces:e},t,r)=>{e&&t.forEach((t=>{e[t]=[...r]}))})(e,a,l),(({faces_vertices:e},t,r,o)=>{e&&o.map((t=>e[t])).forEach((e=>e.map(((e,t,o)=>{const s=(t+1)%o.length;return e===r[0]&&o[s]===r[1]||e===r[1]&&o[s]===r[0]?s:void 0})).filter((e=>void 0!==e)).sort(((e,t)=>t-e)).forEach((r=>e.splice(r,0,t)))))})(e,i,s,l),(({edges_vertices:e,faces_vertices:t,faces_edges:r},o)=>{const s=makeVerticesToEdgeBidirectional({edges_vertices:e});o.map((e=>t[e].map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>s[e.join(" ")])))).forEach(((e,t)=>{r[o[t]]=e}))})(e,l));const d=removeGeometryIndices(e,n,[t]);return a.forEach(((e,t)=>{a[t]=d[a[t]]})),d.splice(-2),d[t]=a,{vertex:i,edges:{map:d,new:a,remove:t}}},rebuild_edge=(e,t,r)=>{const o=e.edges_vertices.length,s=(({vertices_coords:e},t,r)=>{const o=t.map((t=>e[t])).reverse();return{edges_vertices:[...t],edges_foldAngle:0,edges_assignment:"U",edges_length:$e.core.distance2(...o),edges_vector:$e.core.subtract(...o),edges_faces:[r,r]}})(e,r,t);return Object.keys(s).filter((t=>void 0!==e[t])).forEach((t=>{e[t][o]=s[t]})),o},build_faces=(e,t,r)=>{const o=[0,1].map((t=>e.faces_vertices.length+t));return(({edges_vertices:e,faces_vertices:t,faces_edges:r},o,s)=>{const n=s.map((e=>t[o].indexOf(e))),c=splitCircularArray(t[o],n).map((e=>({faces_vertices:e})));if(r){const t=makeVerticesToEdgeBidirectional({edges_vertices:e});c.map((e=>e.faces_vertices.map(((e,t,r)=>`${e} ${r[(t+1)%r.length]}`)).map((e=>t[e])))).forEach(((e,t)=>{c[t].faces_edges=e}))}return c})(e,t,r).forEach(((t,r)=>Object.keys(t).forEach((s=>{e[s][o[r]]=t[s]})))),o},ut="splitFace potentially given a non-convex face",splitFace=(e,t,r,o,s)=>{const n=intersectConvexFaceLine(e,t,r,o,s);if(void 0===n)return;const i=((e,{vertices:t,edges:r})=>{let o;const s=r.map((t=>{const r=splitEdge(e,o?o[t.edge]:t.edge,t.coords);return o=o?mergeNextmaps(o,r.edges.map):r.edges.map,r}));let n;return t.push(...s.map((e=>e.vertex))),s.forEach((e=>{e.edges.remove=n?n[e.edges.remove]:e.edges.remove;const t=invertSimpleMap(e.edges.map);n=n?mergeBackmaps(n,t):t})),{vertices:t,edges:{map:o,remove:s.map((e=>e.edges.remove))}}})(e,n);i.edges.new=rebuild_edge(e,t,i.vertices),(({vertices_coords:e,vertices_vertices:t,edges_vertices:r},o)=>{const s=r[o][0],n=r[o][1];t[s]=sortVerticesCounterClockwise({vertices_coords:e},t[s].concat(n),s),t[n]=sortVerticesCounterClockwise({vertices_coords:e},t[n].concat(s),n)})(e,i.edges.new),(({edges_vertices:e,vertices_edges:t,vertices_vertices:r},o)=>{if(!t||!r)return;const s=e[o];s.map((e=>r[e])).map(((e,t)=>e.indexOf(s[(t+1)%s.length]))).forEach(((e,r)=>t[s[r]].splice(e,0,o)))})(e,i.edges.new);const a=build_faces(e,t,i.vertices);((e,t,r)=>{const o={};r.forEach((t=>e.faces_vertices[t].forEach((e=>{o[e]||(o[e]=[]),o[e].push(t)})))),e.faces_vertices[t].forEach((r=>{const s=e.vertices_faces[r].indexOf(t),n=o[r];-1!==s&&n?e.vertices_faces[r].splice(s,1,...n):console.warn(ut)}))})(e,t,a),((e,t,r,o)=>{const s={};o.forEach((t=>e.faces_edges[t].forEach((e=>{s[e]||(s[e]=[]),s[e].push(t)})))),[...e.faces_edges[t],r].forEach((r=>{const o=s[r],n=[];for(let o=0;o<e.edges_faces[r].length;o+=1)e.edges_faces[r][o]===t&&n.push(o);if(0===n.length||!o)return void console.warn(ut);n.reverse().forEach((t=>e.edges_faces[r].splice(t,1)));const c=n[n.length-1];e.edges_faces[r].splice(c,0,...o)}))})(e,t,i.edges.new,a),(({faces_vertices:e,faces_faces:t},r,o)=>{const s=t[r],n=o.map((t=>e[t])),c=s.map((t=>{const r=e[t],s=[0,0];for(let e=0;e<n.length;e+=1){let t=0;for(let o=0;o<r.length;o+=1)-1!==n[e].indexOf(r[o])&&(t+=1);s[e]=t}return s[0]>=2?o[0]:s[1]>=2?o[1]:void 0}));o.forEach(((e,r,s)=>{t[e]=[s[(r+1)%o.length]]})),s.forEach(((e,o)=>{for(let s=0;s<t[e].length;s+=1)t[e][s]===r&&(t[e][s]=c[o],t[c[o]].push(e))}))})(e,t,a);const l=removeGeometryIndices(e,c,[t]);return a.forEach(((e,t)=>{a[t]=l[a[t]]})),l.splice(-2),l[t]=a,i.faces={map:l,new:a,remove:t},i},pt={};pt.prototype=Object.create(Object.prototype),pt.prototype.constructor=pt;const gt=Object.assign({clean:clean,validate:validate$1,populate:populate,fragment:fragment,addVertices:addVertices,splitEdge:splitEdge,faceSpanningTree:makeFaceSpanningTree,explodeFaces:explodeFaces,explodeShrinkFaces:explodeShrinkFaces},ot);Object.keys(gt).forEach((e=>{pt.prototype[e]=function(){return gt[e](this,...arguments)}})),pt.prototype.splitFace=function(e,...t){const r=$e.core.getLine(...t);return splitFace(this,e,r.vector,r.origin)},pt.prototype.copy=function(){return Object.assign(Object.create(Object.getPrototypeOf(this)),clone(this))},pt.prototype.clear=function(){return ze.graph.forEach((e=>delete this[e])),ze.orders.forEach((e=>delete this[e])),delete this.file_frames,this},pt.prototype.boundingBox=function(){return $e.rect.fromPoints(this.vertices_coords)},pt.prototype.unitize=function(){if(!this.vertices_coords)return this;const e=$e.core.bounding_box(this.vertices_coords),t=Math.max(...e.span),r=0===t?1:1/t,o=e.min;return this.vertices_coords=this.vertices_coords.map((e=>$e.core.subtract(e,o))).map((e=>e.map((e=>e*r)))),this},pt.prototype.folded=function(){const e=this.faces_matrix2?multiplyVerticesFacesMatrix2(this,this.faces_matrix2):makeVerticesCoordsFolded(this,...arguments);return Object.assign(Object.create(Object.getPrototypeOf(this)),Object.assign(clone(this),{vertices_coords:e,frame_classes:[v]}))},pt.prototype.flatFolded=function(){const e=this.faces_matrix2?multiplyVerticesFacesMatrix2(this,this.faces_matrix2):makeVerticesCoordsFlatFolded(this,...arguments);return Object.assign(Object.create(Object.getPrototypeOf(this)),Object.assign(clone(this),{vertices_coords:e,frame_classes:[v]}))};const shortenKeys=function(e){const t=Object.create(null);return Object.keys(e).forEach((r=>{t[r.substring(this.length+1)]=e[r]})),t},getComponent=function(e){return transposeGraphArrays(this,e).map(shortenKeys.bind(e)).map(Le[e].bind(this))};[s,n,c].forEach((e=>Object.defineProperty(pt.prototype,e,{enumerable:!0,get:function(){return getComponent.call(this,e)}}))),Object.defineProperty(pt.prototype,g,{enumerable:!0,get:function(){const e=getBoundary(this),t=e.vertices.map((e=>this.vertices_coords[e]));return Object.keys(e).forEach((r=>{t[r]=e[r]})),Object.assign(t,e)}});const mt={vertices:nearestVertex,edges:nearestEdge,faces:nearestFace};pt.prototype.nearest=function(){const e=$e.core.getVector(arguments),t=Object.create(null),r={};return[s,n,c].forEach((o=>{Object.defineProperty(t,Be[o],{enumerable:!0,get:()=>(void 0!==r[o]||(r[o]=mt[o](this,e)),r[o])}),filterKeysWithPrefix(this,o).forEach((e=>Object.defineProperty(t,e,{enumerable:!0,get:()=>this[e][t[Be[o]]]})))})),t};var ht=pt.prototype;const clip=function(e,t){const r=getBoundary(e).vertices.map((t=>e.vertices_coords[t])),o=t.vector?t.vector:$e.core.subtract2(t[1],t[0]),s=t.origin?t.origin:t[0],n=t.domain_function?t.domain_function:$e.core.includeL;return $e.core.clipLineConvexPolygon(r,o,s,$e.core.include,n)},addEdges=(e,t)=>{e.edges_vertices||(e.edges_vertices=[]),"number"==typeof t[0]&&(t=[t]);const r=t.map(((t,r)=>e.edges_vertices.length+r));e.edges_vertices.push(...t);const o=removeDuplicateEdges(e).map;return r.map((e=>o[e]))},addPlanarSegment=(e,t,r,o=$e.core.EPSILON)=>{e.vertices_sectors||(e.vertices_sectors=makeVerticesSectors(e));const s=[t,r].map((e=>[e[0],e[1]])),n=$e.core.subtract2(s[1],s[0]),c=makeEdgesSegmentIntersection(e,s[0],s[1],o),i=c.map(((e,t)=>void 0===e?void 0:t)).filter((e=>void 0!==e)).sort(((e,t)=>e-t)),a={};i.forEach((t=>e.edges_faces[t].forEach((e=>{a[e]=!0}))));const l=Object.keys(a).map((e=>parseInt(e,10))).sort(((e,t)=>e-t)),d=i.reverse().map((t=>splitEdge(e,t,c[t],o))).map((e=>e.vertex)),u=addVertices(e,s,o),p={};d.forEach((e=>{p[e]=!0})),u.forEach((e=>{p[e]=!0}));const g=Object.keys(p).map((e=>parseInt(e,10))),m=sortVerticesAlongVector(e,g,n),h=makeVerticesToEdgeBidirectional(e),v=((e,t,r)=>{const o=Array.from(Array(t.length-1)).map(((e,r)=>[t[r],t[r+1]])),s=o.map((e=>e.join(" "))).map((e=>void 0===r[e])),n=o.filter(((e,t)=>s[t])),c=Array.from(Array(n.length)).map(((t,r)=>e.edges_vertices.length+r));c.forEach(((t,r)=>{e.edges_vertices[t]=n[r]})),e.edges_assignment&&c.forEach((t=>{e.edges_assignment[t]="U"})),e.edges_foldAngle&&c.forEach((t=>{e.edges_foldAngle[t]=0}));for(let r=0;r<t.length;r+=1){const o=t[r],n=[s[r-1]?t[r-1]:void 0,s[r]?t[r+1]:void 0].filter((e=>void 0!==e)),c=(e.vertices_vertices[o]?e.vertices_vertices[o]:[]).concat(n);e.vertices_vertices[o]=sortVerticesCounterClockwise(e,c,t[r])}const i=makeVerticesToEdgeBidirectional(e);for(let r=0;r<t.length;r+=1){const o=t[r];e.vertices_edges[o]=e.vertices_vertices[o].map((e=>i[`${o} ${e}`]))}return t.map((t=>1===e.vertices_vertices[t].length?[$e.core.TWO_PI]:$e.core.counterClockwiseSectors2(e.vertices_vertices[t].map((r=>$e.core.subtract2(e.vertices_coords[r],e.vertices_coords[t])))))).forEach(((r,o)=>{e.vertices_sectors[t[o]]=r})),c})(e,m,h);v.forEach((t=>{const r=e.edges_vertices[t];h[`${r[0]} ${r[1]}`]=t,h[`${r[1]} ${r[0]}`]=t}));const _=m.map((t=>e.vertices_vertices[t].map((e=>[[e,t],[t,e]])))).reduce(((e,t)=>e.concat(t)),[]).reduce(((e,t)=>e.concat(t)),[]),y={},b=_.map((t=>counterClockwiseWalk(e,t[0],t[1],y))).filter((e=>void 0!==e)),E=filterWalkedBoundaryFace(b);removeGeometryIndices(e,"faces",l);const x=E.map(((t,r)=>e.faces_vertices.length+r));return e.faces_vertices&&x.forEach(((t,r)=>{e.faces_vertices[t]=E[r].vertices})),e.faces_edges&&x.forEach(((t,r)=>{e.faces_edges[t]=E[r].edges.map((e=>h[e]))})),e.faces_angles&&x.forEach(((t,r)=>{e.faces_angles[t]=E[r].faces_angles})),e.vertices_faces&&(e.vertices_faces=makeVerticesFaces(e)),e.edges_faces&&(e.edges_faces=makeEdgesFacesUnsorted(e)),e.faces_faces&&(e.faces_faces=makeFacesFaces(e)),e.vertices_coords.length===e.vertices_vertices.length&&e.vertices_coords.length===e.vertices_edges.length&&e.vertices_coords.length===e.vertices_faces.length||console.warn("vertices mismatch",JSON.parse(JSON.stringify(e))),e.edges_vertices.length===e.edges_faces.length&&e.edges_vertices.length===e.edges_assignment.length||console.warn("edges mismatch",JSON.parse(JSON.stringify(e))),e.faces_vertices.length===e.faces_edges.length&&e.faces_vertices.length===e.faces_faces.length||console.warn("faces mismatch",JSON.parse(JSON.stringify(e))),v},removePlanarEdge=(e,t)=>{const r=[...e.edges_vertices[t]].sort(((e,t)=>t-e)),o=[...e.edges_faces[t]];(({vertices_vertices:e},t)=>{const r=[t[1],t[0]];t.map(((t,o)=>e[t].indexOf(r[o]))).forEach(((r,o)=>e[t[o]].splice(r,1)))})(e,r),(({vertices_edges:e},t,r)=>{r.map(((r,o)=>e[r].indexOf(t))).forEach(((t,o)=>e[r[o]].splice(t,1)))})(e,t,r);const s=r.map((t=>0===e.vertices_vertices[t].length)),n=r.filter(((e,t)=>s[t]));if(2===o.length&&o[0]!==o[1]){const s=e.faces_vertices.length,n=((e,t,r,o)=>{const s=t.map((t=>e.faces_edges[t].indexOf(r))),n=[];t.forEach(((t,r)=>e.faces_vertices[t].forEach(((e,t,s)=>{const c=s[(t+1)%s.length];(e===o[0]&&c===o[1]||e===o[1]&&c===o[0])&&(n[r]=t)})))),void 0!==n[0]&&void 0!==n[1]||console.warn("removePlanarEdge error joining faces");const c=t.map((t=>e.faces_edges[t].length)),i=t.map((t=>e.faces_vertices[t].length)),a=c.map((e=>e-1)),l=i.map((e=>e-1)),d=s.map(((e,t)=>(e+1)%c[t])),u=n.map(((e,t)=>(e+1)%i[t])),p=t.map(((t,r)=>Array.from(Array(a[r])).map(((e,t)=>(d[r]+t)%c[r])).map((r=>e.faces_edges[t][r])))),g=t.map(((t,r)=>Array.from(Array(l[r])).map(((e,t)=>(u[r]+t)%i[r])).map((r=>e.faces_vertices[t][r])))),m=t.map((t=>e.faces_faces[t])).reduce(((e,t)=>e.concat(t)),[]).filter((e=>e!==t[0]&&e!==t[1]));return{vertices:g[0].concat(g[1]),edges:p[0].concat(p[1]),faces:m}})(e,o,t,r);e.faces_vertices.push(n.vertices),e.faces_edges.push(n.edges),e.faces_faces.push(n.faces),e.vertices_faces.forEach(((t,r)=>{let n=!1;t.forEach(((c,i)=>{if(c===o[0]||c===o[1]){e.vertices_faces[r][i]=s;const o=n?[r,1]:[r,1,s];t.splice(...o),n=!0}}))})),e.edges_faces.forEach(((t,r)=>t.forEach(((t,n)=>{t!==o[0]&&t!==o[1]||(e.edges_faces[r][n]=s)})))),e.faces_faces.forEach(((t,r)=>t.forEach(((t,n)=>{t!==o[0]&&t!==o[1]||(e.faces_faces[r][n]=s)})))),e.faces_vertices.forEach((t=>t.forEach((t=>{void 0===t&&console.log("FOUND ONE before remove",e.faces_vertices)})))),removeGeometryIndices(e,"faces",o)}if(2===o.length&&o[0]===o[1]&&n.length){const r=o[0];e.faces_vertices[r]=e.faces_vertices[r].filter((e=>!n.includes(e))).filter(((e,t,r)=>e!==r[(t+1)%r.length])),e.faces_edges[r]=e.faces_edges[r].filter((e=>e!==t))}removeGeometryIndices(e,"edges",[t]),removeGeometryIndices(e,"vertices",n)},removePlanarVertex=(e,t)=>{const r=e.vertices_edges[t],o=uniqueSortedIntegers(e.vertices_faces[t].filter((e=>null!=e)));if(2!==r.length||o.length>2)return void console.warn("cannot remove non 2-degree vertex yet (e,f)",r,o);const s=((e,t,r)=>(r.forEach((r=>{e.edges_vertices[r][0]===t&&e.edges_vertices[r][1]===t&&console.warn("removePlanarVertex circular edge")})),r.map((r=>e.edges_vertices[r][0]===t?e.edges_vertices[r][1]:e.edges_vertices[r][0]))))(e,t,r),n=s.slice().reverse();r.sort(((e,t)=>e-t)),s.forEach((t=>{const o=e.vertices_edges[t].indexOf(r[1]);-1!==o&&(e.vertices_edges[t][o]=r[0])})),s.forEach(((r,o)=>{const s=e.vertices_vertices[r].indexOf(t);-1!==s?e.vertices_vertices[r][s]=n[o]:console.warn("removePlanarVertex unknown vertex issue")})),e.edges_vertices[r[0]]=[...s],o.forEach((r=>{const o=e.faces_vertices[r].indexOf(t);-1!==o?e.faces_vertices[r].splice(o,1):console.warn("removePlanarVertex unknown face_vertex issue")})),o.forEach((t=>{const o=e.faces_edges[t].indexOf(r[1]);-1!==o?e.faces_edges[t].splice(o,1):console.warn("removePlanarVertex unknown face_edge issue")})),removeGeometryIndices(e,"vertices",[t]),removeGeometryIndices(e,"edges",[r[1]])},alternatingSum=e=>[0,1].map((t=>e.filter(((e,r)=>r%2===t)).reduce(((e,t)=>e+t),0))),kawasakiSolutionsRadians=e=>e.map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>$e.core.counterClockwiseAngleRadians(...e))).map(((e,t,r)=>r.slice(t+1,r.length).concat(r.slice(0,t)))).map((e=>alternatingSum(e).map((e=>Math.PI-e)))).map(((t,r)=>e[r]+t[0])).map(((t,r)=>$e.core.isCounterClockwiseBetween(t,e[r],e[(r+1)%e.length])?t:void 0)),kawasakiSolutionsVectors=e=>{const t=e.map((e=>Math.atan2(e[1],e[0])));return kawasakiSolutionsRadians(t).map((e=>void 0===e?void 0:[Math.cos(e),Math.sin(e)]))};var vt=Object.freeze({__proto__:null,alternatingSum:alternatingSum,alternatingSumDifference:e=>{const t=e.reduce(((e,t)=>e+t),0)/2;return alternatingSum(e).map((e=>e-t))},kawasakiSolutionsRadians:kawasakiSolutionsRadians,kawasakiSolutionsVectors:kawasakiSolutionsVectors});const _t={B:!0,b:!0,F:!0,f:!0,U:!0,u:!0},vertices_flat=({vertices_edges:e,edges_assignment:t})=>e.map((e=>e.map((e=>_t[t[e]])).reduce(((e,t)=>e&&t),!0))).map(((e,t)=>e?t:void 0)).filter((e=>void 0!==e)),yt={M:!0,m:!0,V:!0,v:!0},bt={M:-1,m:-1,V:1,v:1},validateMaekawa=({edges_vertices:e,vertices_edges:t,edges_assignment:r})=>{t||(t=makeVerticesEdgesUnsorted({edges_vertices:e}));const o=t.map((e=>e.map((e=>bt[r[e]])).filter((e=>void 0!==e)).reduce(((e,t)=>e+t),0))).map((e=>2===e||-2===e));return getBoundaryVertices({edges_vertices:e,edges_assignment:r}).forEach((e=>{o[e]=!0})),vertices_flat({vertices_edges:t,edges_assignment:r}).forEach((e=>{o[e]=!0})),o.map(((e,t)=>e?void 0:t)).filter((e=>void 0!==e))},validateKawasaki=({vertices_coords:e,vertices_vertices:t,vertices_edges:r,edges_vertices:o,edges_assignment:s,edges_vector:n},c=$e.core.EPSILON)=>{t||(t=makeVerticesVertices({vertices_coords:e,vertices_edges:r,edges_vertices:o}));const i=makeVerticesVerticesVector({vertices_coords:e,vertices_vertices:t,edges_vertices:o,edges_vector:n}).map(((e,t)=>e.filter(((e,o)=>yt[s[r[t][o]]])))).map((e=>e.length>1?$e.core.counterClockwiseSectors2(e):[0,0])).map((e=>alternatingSum(e))).map((e=>Math.abs(e[0]-e[1])<c));return getBoundaryVertices({edges_vertices:o,edges_assignment:s}).forEach((e=>{i[e]=!0})),vertices_flat({vertices_edges:r,edges_assignment:s}).forEach((e=>{i[e]=!0})),i.map(((e,t)=>e?void 0:t)).filter((e=>void 0!==e))};var Et=Object.freeze({__proto__:null,validateMaekawa:validateMaekawa,validateKawasaki:validateKawasaki});const xt={};xt.prototype=Object.create(ht),xt.prototype.constructor=xt;const make_edges_array=function(e){return e.mountain=(t=-180)=>(e.forEach((e=>{this.edges_assignment[e]="M",this.edges_foldAngle[e]=t})),e),e.valley=(t=180)=>(e.forEach((e=>{this.edges_assignment[e]="V",this.edges_foldAngle[e]=t})),e),e.flat=()=>(e.forEach((e=>{this.edges_assignment[e]="F",this.edges_foldAngle[e]=0})),e),e};["line","ray","segment"].forEach((e=>{xt.prototype[e]=function(){const t=$e[e](...arguments);if(!t)return;const r=clip(this,t);if(!r)return;const o=addPlanarSegment(this,r[0],r[1]);return make_edges_array.call(this,o)}})),["circle","ellipse","rect","polygon"].forEach((e=>{xt.prototype[e]=function(){const t=$e[e](...arguments);if(!t)return;const r=t.segments(96).map((e=>$e.segment(e))).map((e=>clip(this,e))).filter((e=>void 0!==e));if(!r)return;const o=[],s=[];r.forEach((e=>{const t=addVertices(this,e);o.push(...t),s.push(...addEdges(this,t))}));const{map:n}=fragment(this).edges;return populate(this),make_edges_array.call(this,s.map((e=>n[e])).reduce(((e,t)=>e.concat(t)),[]))}})),xt.prototype.removeEdge=function(e){const t=this.edges_vertices[e];return removePlanarEdge(this,e),t.map((e=>isVertexCollinear(this,e))).map(((e,r)=>e?t[r]:void 0)).filter((e=>void 0!==e)).sort(((e,t)=>t-e)).forEach((e=>removePlanarVertex(this,e))),!0},xt.prototype.validate=function(e){const t=validate$1(this,e);return t.vertices.kawasaki=validateKawasaki(this,e),t.vertices.maekawa=validateMaekawa(this),this.edges_foldAngle&&(t.edges.not_flat=this.edges_foldAngle.map(((e,t)=>edgeFoldAngleIsFlat(e)?void 0:t)).filter((e=>void 0!==e))),"valid"===t.summary&&(t.vertices.kawasaki.length||t.vertices.maekawa.length?t.summary="invalid":t.edges.not_flat.length&&(t.summary="not flat")),t};var Ot=xt.prototype;const make_face_side=(e,t,r,o)=>{const s=$e.core.subtract2(r,t),n=$e.core.cross2(e,s);return o?n>0:n<0},make_face_center=(e,t)=>e.faces_vertices[t]?e.faces_vertices[t].map((t=>e.vertices_coords[t])).reduce(((e,t)=>[e[0]+t[0],e[1]+t[1]]),[0,0]).map((r=>r/e.faces_vertices[t].length)):[0,0],kt={F:!0,f:!0,U:!0,u:!0},Mt={M:"V",m:"V",V:"M",v:"M"},face_snapshot=(e,t)=>({center:e.faces_center[t],matrix:e.faces_matrix2[t],winding:e.faces_winding[t],crease:e.faces_crease[t],side:e.faces_side[t],layer:e.faces_layer[t]}),flatFold=(e,t,r,o="V",s=$e.core.EPSILON)=>{const n=Mt[c=o]||c;var c;populate(e),e.faces_layer||(e.faces_layer=Array(e.faces_vertices.length).fill(0)),e.faces_center=e.faces_vertices.map(((t,r)=>make_face_center(e,r))),e.faces_matrix2||(e.faces_matrix2=makeFacesMatrix2(e,0)),e.faces_winding=makeFacesWindingFromMatrix2(e.faces_matrix2),e.faces_crease=e.faces_matrix2.map($e.core.invertMatrix2).map((e=>$e.core.multiplyMatrix2Line2(e,t,r))),e.faces_side=e.faces_vertices.map(((t,r)=>make_face_side(e.faces_crease[r].vector,e.faces_crease[r].origin,e.faces_center[r],e.faces_winding[r])));const i=multiplyVerticesFacesMatrix2(e,e.faces_matrix2),a=makeEdgesLineParallelOverlap({vertices_coords:i,edges_vertices:e.edges_vertices},t,r,s).map(((e,t)=>e?t:void 0)).filter((e=>void 0!==e)).filter((t=>kt[e.edges_assignment[t]]));a.map((t=>e.edges_faces[t].find((e=>null!=e)))).map((t=>e.faces_winding[t])).map((e=>e?o:n)).forEach(((t,r)=>{e.edges_assignment[a[r]]=t,e.edges_foldAngle[a[r]]=edgeAssignmentToFoldAngle(t)}));const l=face_snapshot(e,0),d=e.faces_vertices.map(((e,t)=>t)).reverse().map((t=>{const r=face_snapshot(e,t),c=splitFace(e,t,r.crease.vector,r.crease.origin,s);if(void 0===c)return;e.edges_assignment[c.edges.new]=r.winding?o:n,e.edges_foldAngle[c.edges.new]=edgeAssignmentToFoldAngle(e.edges_assignment[c.edges.new]);return c.faces.map[c.faces.remove].forEach((t=>{e.faces_center[t]=make_face_center(e,t),e.faces_side[t]=make_face_side(r.crease.vector,r.crease.origin,e.faces_center[t],r.winding),e.faces_layer[t]=r.layer})),c})).filter((e=>void 0!==e)),u=mergeNextmaps(...d.map((e=>e.faces.map))),p=mergeNextmaps(...d.map((e=>e.edges.map)).filter((e=>void 0!==e))),g=d.map((e=>e.faces.remove)).reverse();e.faces_layer=((e,t)=>{const r=[],o=e.map(((e,t)=>t)),s=o.filter((e=>t[e])),n=o.filter((e=>!t[e]));return n.sort(((t,r)=>e[t]-e[r])).forEach(((e,t)=>{r[e]=t})),s.sort(((t,r)=>e[r]-e[t])).forEach(((e,t)=>{r[e]=n.length+t})),r})(e.faces_layer,e.faces_side);const m=u&&u[0]&&2===u[0].length,h=m?u[0].filter((t=>e.faces_side[t])).shift():0;let v=l.matrix;return o!==n&&(v=m||e.faces_side[0]?$e.core.multiplyMatrices2(l.matrix,$e.core.makeMatrix2Reflect(l.crease.vector,l.crease.origin)):l.matrix),e.faces_matrix2=makeFacesMatrix2(e,h).map((e=>$e.core.multiplyMatrices2(v,e))),delete e.faces_center,delete e.faces_winding,delete e.faces_crease,delete e.faces_side,{faces:{map:u,remove:g},edges:{map:p}}},At={};At.prototype=Object.create(ht),At.prototype.constructor=At,At.prototype.flatFold=function(){const e=$e.core.getLine(arguments);return flatFold(this,e.vector,e.origin),this};var Pt=At.prototype;const isFoldedForm=e=>e.frame_classes&&e.frame_classes.includes("foldedForm")||e.file_classes&&e.file_classes.includes("foldedForm");var jt=Object.freeze({__proto__:null,isFoldedForm:isFoldedForm});var wt=Object.freeze({__proto__:null,getDisjointedVertices:({edges_vertices:e,vertices_edges:t,vertices_vertices:r})=>{t||(t=makeVerticesEdgesUnsorted({edges_vertices:e})),r||(r=makeVerticesVerticesUnsorted({vertices_edges:t,edges_vertices:e}));const o={};e.forEach((e=>{o[e[0]]=!0,o[e[1]]=!0}));const s=Object.keys(o).map((e=>parseInt(e,10)));let n=0;const c=[];for(;n<s.length;){if(!o[s[n]]){n+=1;continue}const e=[],t=[s[n]],i={[s[n]]:!0};do{const s=t.shift();delete o[s],e.push(s);const n=r[s]?r[s].filter((e=>o[e]&&!i[e])):[];t.push(...n),n.forEach((e=>{i[e]=!0}))}while(t.length);n+=1,c.push(e)}return c}});const makeEdgesEdgesParallel=({vertices_coords:e,edges_vertices:t,edges_vector:r},o=$e.core.EPSILON)=>{r||(r=makeEdgesVector({vertices_coords:e,edges_vertices:t}));const s=r.map((e=>$e.core.normalize(e)));return s.map(((e,t)=>s.map(((e,r)=>t===r?void 0:1-Math.abs($e.core.dot(s[t],s[r]))<o)).map(((e,t)=>e?t:void 0)).filter((e=>void 0!==e))))},overwriteEdgesOverlaps=(e,t,r,o,s)=>{const n=e.map((()=>[]));return e.forEach(((e,c)=>e.forEach((e=>{c>=e||$e.core.overlapLineLine(t[c],r[c],t[e],r[e],o,o,s)&&(n[c].push(e),n[e].push(c))})))),n},makeEdgesEdgesParallelOverlap=({vertices_coords:e,edges_vertices:t,edges_vector:r},o)=>{r||(r=makeEdgesVector({vertices_coords:e,edges_vertices:t}));const s=t.map((t=>e[t[0]])),n=makeEdgesEdgesParallel({vertices_coords:e,edges_vertices:t,edges_vector:r},o);return overwriteEdgesOverlaps(n,r,s,$e.core.excludeS,o)};var St=Object.freeze({__proto__:null,makeEdgesEdgesSimilar:({vertices_coords:e,edges_vertices:t,edges_coords:r},o=$e.core.EPSILON)=>{r||(r=makeEdgesCoords({vertices_coords:e,edges_vertices:t}));const s=makeEdgesBoundingBox({vertices_coords:e,edges_vertices:t,edges_coords:r}),n=Array.from(Array(r.length)).map((()=>[])),c=s.length?s[0].min.length:0;for(let e=0;e<r.length-1;e+=1)for(let t=e+1;t<r.length;t+=1){let r=!0;for(let n=0;n<c;n+=1)$e.core.fnEpsilonEqual(s[e].min[n],s[t].min[n],o)&&$e.core.fnEpsilonEqual(s[e].max[n],s[t].max[n],o)||(r=!1);n[e][t]=r,n[t][e]=r}for(let e=0;e<r.length-1;e+=1)for(let t=e+1;t<r.length;t+=1){if(!n[e][t])continue;const s=$e.core.fnEpsilonEqualVectors(r[e][0],r[t][0],o)&&$e.core.fnEpsilonEqualVectors(r[e][1],r[t][1],o),c=$e.core.fnEpsilonEqualVectors(r[e][0],r[t][1],o)&&$e.core.fnEpsilonEqualVectors(r[e][1],r[t][0],o),i=s||c;n[e][t]=i,n[t][e]=i}return booleanMatrixToIndexedArray(n)},makeEdgesEdgesParallel:makeEdgesEdgesParallel,makeEdgesEdges2DParallel:({vertices_coords:e,edges_vertices:t,edges_vector:r},o=$e.core.EPSILON)=>{r||(r=makeEdgesVector({vertices_coords:e,edges_vertices:t}));const s=r.map((e=>Math.atan2(e[1],e[0]))).map(((e,t)=>({a:e,i:t}))).sort(((e,t)=>e.a-t.a));s.forEach(((e,t)=>{}));const n=s.slice(-1).concat(s.slice(0,-1)).filter((e=>e));console.log("shifted",n)},makeEdgesEdgesCrossing:({vertices_coords:e,edges_vertices:t,edges_vector:r},o)=>{r||(r=makeEdgesVector({vertices_coords:e,edges_vertices:t}));const s=t.map((t=>e[t[0]])),n=(({vertices_coords:e,edges_vertices:t,edges_vector:r},o=$e.core.EPSILON)=>{r||(r=makeEdgesVector({vertices_coords:e,edges_vertices:t}));const s=r.map((e=>$e.core.normalize(e)));return s.map(((e,t)=>s.map(((e,r)=>t===r?void 0:1-Math.abs($e.core.dot(s[t],s[r]))<o)).map(((e,t)=>e?void 0:t)).filter((e=>void 0!==e))))})({vertices_coords:e,edges_vertices:t,edges_vector:r},o);return overwriteEdgesOverlaps(n,r,s,$e.core.excludeS,o)},makeEdgesEdgesParallelOverlap:makeEdgesEdgesParallelOverlap});const parallelNormalized=(e,t,r=$e.core.EPSILON)=>1-Math.abs($e.core.dot(e,t))<r,getCoplanarFacesGroups=({vertices_coords:e,faces_vertices:t},r=$e.core.EPSILON)=>{const o=makeFacesNormal({vertices_coords:e,faces_vertices:t}),s=t.map((()=>[]));for(let e=0;e<t.length-1;e+=1)for(let n=e+1;n<t.length;n+=1)e!==n&&parallelNormalized(o[e],o[n],r)&&(s[e].push(n),s[n].push(e));const n=makeSelfRelationalArrayClusters(s),c=invertMap(n).map((e=>"number"==typeof e?[e]:e)),i=c.map((e=>o[e[0]])),a=[];c.forEach(((e,t)=>e.forEach((e=>{a[e]=$e.core.dot(o[e],i[t])>0}))));const l=t.map((t=>e[t[0]])),d=c.map(((e,t)=>e.map((e=>$e.core.dot(l[e],i[t]))))).map(((e,t)=>clusterArrayValues(e).map((e=>e.map((e=>c[t][e])))))),u=d.flatMap(((e,t)=>e.map((()=>[...i[t]]))));return d.flat().map(((e,t)=>({normal:u[t],faces:e,facesAligned:e.map((e=>a[e]))})))},getOverlappingFacesGroups=({vertices_coords:e,faces_vertices:t},r=$e.core.EPSILON)=>{const o=getCoplanarFacesGroups({vertices_coords:e,faces_vertices:t},r),s=[];o.forEach(((e,t)=>e.faces.forEach((e=>{s[e]=t}))));const n=[];o.forEach((e=>e.facesAligned.forEach(((t,r)=>{n[e.faces[r]]=t}))));const c=[0,0,1],i=o.map((e=>$e.core.resize(3,e.normal))).map((e=>{const t=$e.core.dot(e,c);return Math.abs(t+1)<10*r?$e.core.makeMatrix4Rotate(Math.PI,[1,0,0]):$e.core.matrix4FromQuaternion($e.core.quaternionFromTwoVectors(e,c))})),a=e.map((e=>$e.core.resize(3,e))),l=o.map((e=>e.faces.map(((r,o)=>e.facesAligned[o]?t[r]:t[r].slice().reverse())).map((e=>e.map((e=>a[e])))))).map(((e,t)=>e.map((e=>e.map((e=>$e.core.multiplyMatrix4Vector3(i[t],e))).map((e=>[e[0],e[1]])))))),d=t.map((()=>[]));l.forEach(((e,t)=>{for(let r=0;r<e.length-1;r+=1)for(let s=r+1;s<e.length;s+=1){if(void 0!==$e.core.clipPolygonPolygon(e[r],e[s])){const e=[o[t].faces[r],o[t].faces[s]];d[e[0]].push(e[1]),d[e[1]].push(e[0])}}}));const u=makeSelfRelationalArrayClusters(d),p=invertMap(u).map((e=>"number"==typeof e?[e]:e));return{groups_plane:p.map((e=>({normal:o[s[e[0]]].normal,origin:a[t[e[0]][0]]}))),groups_transformXY:p.map((e=>i[s[e[0]]])),faces_group:u,faces_groupNormalAligned:n,faces_facesOverlap:d}},makeEdgesFacesOverlap=({vertices_coords:e,edges_vertices:t,edges_vector:r,edges_faces:o,faces_vertices:s},n)=>{r||(r=makeEdgesVector({vertices_coords:e,edges_vertices:t}));const c=makeFacesWinding({vertices_coords:e,faces_vertices:s}),i=t.map((t=>e[t[0]])),a=t.map((t=>t.map((t=>e[t])))),l=s.map((t=>t.map((t=>e[t]))));c.forEach(((e,t)=>{e||l[t].reverse()}));const d=t.map((()=>s.map((()=>{}))));o.forEach(((e,t)=>e.forEach((e=>{d[t][e]=!1}))));const u=makeEdgesBoundingBox({edges_coords:a}),p=l.map((e=>$e.core.boundingBox(e)));return u.forEach(((e,t)=>p.forEach(((r,o)=>{!1!==d[t][o]&&($e.core.overlapBoundingBoxes(r,e)||(d[t][o]=!1))})))),a.forEach(((e,t)=>l.forEach(((e,o)=>{if(void 0!==d[t][o])return;if(a[t].map((e=>$e.core.overlapConvexPolygonPoint(l[o],e,$e.core.exclude,n))).reduce(((e,t)=>e||t),!1))return void(d[t][o]=!0);$e.core.intersectConvexPolygonLine(l[o],r[t],i[t],$e.core.excludeS,$e.core.excludeS,n)?d[t][o]=!0:d[t][o]=!1})))),d},getFacesFaces2DOverlap=({vertices_coords:e,faces_vertices:t},r=$e.core.EPSILON)=>{const o=Array.from(Array(t.length)).map((()=>Array.from(Array(t.length)))),s=t.map((t=>t.map((t=>e[t])))),n=s.map((e=>$e.core.boundingBox(e)));for(let e=0;e<n.length-1;e+=1)for(let t=e+1;t<n.length;t+=1)$e.core.overlapBoundingBoxes(n[e],n[t])||(o[e][t]=!1,o[t][e]=!1);const c=s.map((e=>$e.core.makePolygonNonCollinear(e,r)));for(let e=0;e<t.length-1;e+=1)for(let s=e+1;s<t.length;s+=1){if(!1===o[e][s])continue;const t=$e.core.overlapConvexPolygons(c[e],c[s],r);o[e][s]=t,o[s][e]=t}return o};var $t=Object.freeze({__proto__:null,getCoplanarFacesGroups:getCoplanarFacesGroups,getOverlappingFacesGroups:getOverlappingFacesGroups,makeEdgesFacesOverlap:makeEdgesFacesOverlap,getFacesFaces2DOverlap:getFacesFaces2DOverlap});const triangulateConvexFacesVertices=({faces_vertices:e})=>e.flatMap((e=>{return e.length<4?[e]:(t=e,Array.from(Array(t.length-2)).map(((e,r)=>[t[0],t[r+1],t[r+2]])));var t}));var Lt=Object.freeze({__proto__:null,triangulateConvexFacesVertices:triangulateConvexFacesVertices,triangulate:(e,t)=>{if(!e.faces_vertices)return{};const r=makeVerticesToEdgeBidirectional(e),o=(({faces_vertices:e})=>{let t=0;return e.flatMap((e=>{if(e.length<4)return[t++];const r=Array.from(Array(e.length-2)).map((()=>t));return t+=1,r}))})(e);e.faces_vertices=triangulateConvexFacesVertices(e);let s=e.edges_vertices.length;const n=[];e.faces_edges=e.faces_vertices.map((e=>e.map(((e,t,o)=>{const c=[e,o[(t+1)%o.length]],i=c.join(" ");return i in r?r[i]:(n.push(c),s++)}))));const c=n.length;return e.edges_vertices.push(...n),e.edges_assignment&&e.edges_assignment.push(...Array(c).fill("J")),e.edges_foldAngle&&e.edges_foldAngle.push(...Array(c).fill(0)),e.vertices_vertices&&delete e.vertices_vertices,e.vertices_edges&&delete e.vertices_edges,e.vertices_faces&&delete e.vertices_faces,e.edges_faces&&delete e.edges_faces,e.faces_faces&&delete e.faces_faces,e.faceOrders&&delete e.faceOrders,{faces:{map:o}}}});var Ct=Object.assign(Object.create(null),{count:count,countImplied:countImplied,validate:validate$1,clean:clean,populate:populate,remove:removeGeometryIndices,replace:replaceGeometryIndices,removePlanarVertex:removePlanarVertex,removePlanarEdge:removePlanarEdge,addVertices:addVertices,addEdges:addEdges,splitEdge:splitEdge,splitFace:splitFace,flatFold:flatFold,addPlanarSegment:addPlanarSegment,subgraph:(e,t)=>{const r={},o={};[c,n,s].forEach((s=>{r[s]=Array.from(Array(count[s](e))).map(((e,t)=>t)),o[s]=uniqueSortedIntegers(t[s]||[]).reverse()})),Object.keys(o).forEach((e=>o[e].forEach((t=>r[e].splice(t,1)))));const i=JSON.parse(JSON.stringify(e));return Object.keys(r).forEach((e=>removeGeometryIndices(i,e,r[e]))),i},clip:clip,fragment:fragment,getVerticesClusters:getVerticesClusters,clone:clone,flattenFrame:(e,t=1)=>{if(!e.file_frames||e.file_frames.length<t)return e;const r=["frame_parent","frame_inherit"],o={visited_frames:[]},recurse=(e,t,r)=>{if(-1!==o.visited_frames.indexOf(t))throw new Error("flatten cycle detected");return o.visited_frames.push(t),r=[t].concat(r),0===t?r:e.file_frames[t-1].frame_inherit&&null!=e.file_frames[t-1].frame_parent?recurse(e,e.file_frames[t-1].frame_parent,r):r};return recurse(e,t,[]).map((t=>{if(0===t){const t=e.file_frames;e.file_frames=null;const o=clone(e);return e.file_frames=t,delete o.file_frames,r.forEach((e=>delete o[e])),o}const o=clone(e.file_frames[t-1]);return r.forEach((e=>delete o[e])),o})).reduce(((e,t)=>Object.assign(e,t)),{})},foldKeys:Fe,foldFileClasses:["singleModel","multiModel","animation","diagrams"],foldFrameClasses:["creasePattern","foldedForm","graph","linkage"],foldFrameAttributes:["2D","3D","abstract","manifold","nonManifold","orientable","nonOrientable","selfTouching","nonSelfTouching","selfIntersecting","nonSelfIntersecting"]},Xe,rt,We,ft,Re,Ze,Ke,Ye,jt,wt,et,$t,Lt,ot,Ue,He,Qe,St,at,st,it,lt,dt,De);const Nt={},make_rect_vertices_coords=(e,t)=>[[0,0],[e,0],[e,t],[0,t]],make_closed_polygon=e=>populate({vertices_coords:e,edges_vertices:e.map(((e,t,r)=>[t,(t+1)%r.length])),edges_assignment:Array(e.length).fill("B")});Nt.square=(e=1)=>make_closed_polygon(make_rect_vertices_coords(e,e)),Nt.rectangle=(e=1,t=1)=>make_closed_polygon(make_rect_vertices_coords(e,t)),Nt.polygon=(e=3,t=1)=>make_closed_polygon($e.core.makePolygonCircumradius(e,t)),Nt.kite=()=>populate({vertices_coords:[[0,0],[1,0],[1,Math.sqrt(2)-1],[1,1],[Math.sqrt(2)-1,1],[0,1]],edges_vertices:[[0,1],[1,2],[2,3],[3,4],[4,5],[5,0],[0,2],[0,4],[0,3]],edges_assignment:Array.from("BBBBBBVVF")});const zt=Object.create(null),Ft={graph:ht,cp:Ot,origami:Pt},It={graph:()=>{},cp:Nt.square,origami:Nt.square},Vt={graph:()=>({file_spec:Ce,file_creator:Ne}),cp:()=>({file_spec:Ce,file_creator:Ne,frame_classes:["creasePattern"]}),origami:()=>({file_spec:Ce,file_creator:Ne,frame_classes:["foldedForm"]})};Object.keys(Ft).forEach((e=>{zt[e]=function(){const t=Array.from(arguments).filter((e=>isFoldObject(e))).map((e=>JSON.parse(JSON.stringify(e))));return populate(Object.assign(Object.create(Ft[e]),t.length?{}:It[e](),...t,Vt[e]()))},zt[e].prototype=Ft[e],zt[e].prototype.constructor=zt[e],Object.keys(Nt).forEach((t=>{zt[e][t]=function(){return zt[e](Nt[t](...arguments))}}))})),Object.assign(zt.graph,Ct);const cubrt=e=>e<0?-Math.pow(-e,1/3):Math.pow(e,1/3),normalAxiom6=(e,t,r,o)=>{if(Math.abs(1-$e.core.dot2(e.normal,r)/e.distance)<.02)return[];const s=$e.core.rotate90(e.normal),n=$e.core.subtract2($e.core.add2(r,$e.core.scale2(e.normal,e.distance)),$e.core.scale2(o,2)),c=$e.core.subtract2($e.core.scale2(e.normal,e.distance),r),i=$e.core.dot2(o,t.normal)-t.distance,a=2*$e.core.dot2(c,s),l=$e.core.dot2(c,c),d=$e.core.dot2($e.core.add2(n,c),s),u=$e.core.dot2(n,c),p=$e.core.dot2(s,t.normal),g=$e.core.dot2(c,t.normal),m=p,h=i+d*p+g,v=i*a+u*p+d*g,_=i*l+u*g;let y=0;return Math.abs(v)>$e.core.EPSILON&&(y=1),Math.abs(h)>$e.core.EPSILON&&(y=2),Math.abs(m)>$e.core.EPSILON&&(y=3),((e,t,r,o,s)=>{switch(e){case 1:return[-s/o];case 2:{const e=Math.pow(o,2)-4*r*s;if(e<-$e.core.EPSILON)return[];const t=-o/(2*r);if(e<$e.core.EPSILON)return[t];const n=Math.sqrt(e)/(2*r);return[t+n,t-n]}case 3:{const e=r/t,n=o/t,c=s/t,i=(3*n-Math.pow(e,2))/9,a=(9*e*n-27*c-2*Math.pow(e,3))/54,l=Math.pow(i,3)+Math.pow(a,2),d=-e/3;if(l>0){const e=Math.sqrt(l);return[d+cubrt(a+e)+cubrt(a-e)]}if(Math.abs(l)<$e.core.EPSILON){const e=Math.pow(a,1/3);return a<0?[]:[d+2*e,d-e]}const u=Math.sqrt(-l),p=Math.atan2(u,a)/3,g=Math.pow(Math.pow(a,2)-l,1/6),m=g*Math.cos(p),h=g*Math.sin(p);return[d+2*m,d-m-Math.sqrt(3)*h,d-m+Math.sqrt(3)*h]}default:return[]}})(y,m,h,v,_).map((t=>$e.core.add2($e.core.scale2(e.normal,e.distance),$e.core.scale2(s,t)))).map((e=>({p:e,normal:$e.core.normalize2($e.core.subtract2(e,r))}))).map((e=>({normal:e.normal,distance:$e.core.dot2(e.normal,$e.core.midpoint2(e.p,r))})))};var Bt=Object.freeze({__proto__:null,normalAxiom1:(e,t)=>{const r=$e.core.normalize2($e.core.rotate90($e.core.subtract2(t,e)));return{normal:r,distance:$e.core.dot2($e.core.add2(e,t),r)/2}},normalAxiom2:(e,t)=>{const r=$e.core.normalize2($e.core.subtract2(t,e));return{normal:r,distance:$e.core.dot2($e.core.add2(e,t),r)/2}},normalAxiom3:(e,t)=>{const r=((e,t)=>{const r=$e.core.cross2(e.normal,t.normal);if(Math.abs(r)<$e.core.EPSILON)return;return[(e.distance*t.normal[1]-t.distance*e.normal[1])/r,(t.distance*e.normal[0]-e.distance*t.normal[0])/r]})(e,t);return void 0===r?[{normal:e.normal,distance:(e.distance+t.distance*$e.core.dot2(e.normal,t.normal))/2}]:[$e.core.add2,$e.core.subtract2].map((r=>$e.core.normalize2(r(e.normal,t.normal)))).map((e=>({normal:e,distance:$e.core.dot2(r,e)})))},normalAxiom4:(e,t)=>{const r=$e.core.rotate90(e.normal);return{normal:r,distance:$e.core.dot2(t,r)}},normalAxiom5:(e,t,r)=>{const o=$e.core.dot2(t,e.normal),s=e.distance-o,n=$e.core.distance2(t,r);if(s>n)return[];const c=Math.sqrt(n*n-s*s),i=$e.core.scale2(e.normal,s),a=$e.core.add2(t,i),l=$e.core.scale2($e.core.rotate90(e.normal),c);return(c<$e.core.EPSILON?[a]:[$e.core.add2(a,l),$e.core.subtract2(a,l)]).map((e=>$e.core.normalize2($e.core.subtract2(r,e)))).map((e=>({normal:e,distance:$e.core.dot2(t,e)})))},normalAxiom6:normalAxiom6,normalAxiom7:(e,t,r)=>{const o=$e.core.rotate90(e.normal),s=$e.core.dot2(o,t.normal);if(Math.abs(s)<$e.core.EPSILON)return;const n=$e.core.dot2(r,o),c=$e.core.dot2(r,t.normal);return{normal:o,distance:(t.distance+2*n*s-c)/(2*s)}}});var Tt=Object.freeze({__proto__:null,axiom1:(e,t)=>({vector:$e.core.normalize2($e.core.subtract2(...$e.core.resizeUp(t,e))),origin:e}),axiom2:(e,t)=>({vector:$e.core.normalize2($e.core.rotate90($e.core.subtract2(...$e.core.resizeUp(t,e)))),origin:$e.core.midpoint2(e,t)}),axiom3:(e,t)=>$e.core.bisectLines2(e.vector,e.origin,t.vector,t.origin),axiom4:(e,t)=>({vector:$e.core.rotate90($e.core.normalize2(e.vector)),origin:t}),axiom5:(e,t,r)=>($e.core.intersectCircleLine($e.core.distance2(t,r),t,e.vector,e.origin,$e.core.include_l)||[]).map((e=>({vector:$e.core.normalize2($e.core.rotate90($e.core.subtract2(...$e.core.resizeUp(e,r)))),origin:$e.core.midpoint2(r,e)}))),axiom6:(e,t,r,o)=>normalAxiom6($e.core.rayLineToUniqueLine(e),$e.core.rayLineToUniqueLine(t),r,o).map($e.core.uniqueLineToRayLine),axiom7:(e,t,r)=>{const o=$e.core.intersectLineLine(e.vector,e.origin,t.vector,r,$e.core.include_l,$e.core.include_l);return void 0===o?void 0:{vector:$e.core.normalize2($e.core.rotate90($e.core.subtract2(...$e.core.resizeUp(o,r)))),origin:$e.core.midpoint2(r,o)}}});const arrayify=(e,t)=>{switch(e){case 3:case"3":case 5:case"5":case 6:case"6":return t;case 7:case"7":return void 0===t?[]:[t];default:return[t]}},reflectPoint=(e,t)=>{const r=$e.core.makeMatrix2Reflect(e.vector,e.origin);return $e.core.multiplyMatrix2Vector2(r,t)},validateAxiom1=(e,t)=>e.points.map((e=>$e.core.overlapConvexPolygonPoint(t,e,$e.core.include))).reduce(((e,t)=>e&&t),!0),qt=validateAxiom1,validateAxiom3=(e,t,r)=>{const o=e.lines.map((e=>$e.core.clipLineConvexPolygon(t,e.vector,e.origin,$e.core.include,$e.core.includeL)));if(void 0===o[0]||void 0===o[1])return[!1,!1];const s=r.map((e=>void 0===e?void 0:$e.core.clipLineConvexPolygon(t,e.vector,e.origin,$e.core.include,$e.core.includeL))),n=[0,1].map((e=>void 0!==s[e])),c=r.map((e=>void 0===e?void 0:[reflectPoint(e,o[0][0]),reflectPoint(e,o[0][1])])).map((e=>void 0!==e&&($e.core.overlapLinePoint($e.core.subtract(o[1][1],o[1][0]),o[1][0],e[0],$e.core.includeS)||$e.core.overlapLinePoint($e.core.subtract(o[1][1],o[1][0]),o[1][0],e[1],$e.core.includeS)||$e.core.overlapLinePoint($e.core.subtract(e[1],e[0]),e[0],o[1][0],$e.core.includeS)||$e.core.overlapLinePoint($e.core.subtract(e[1],e[0]),e[0],o[1][1],$e.core.includeS))));return[0,1].map((e=>!0===c[e]&&!0===n[e]))},validateAxiom4=(e,t)=>{const r=$e.core.intersectLineLine(e.lines[0].vector,e.lines[0].origin,$e.core.rotate90(e.lines[0].vector),e.points[0],$e.core.includeL,$e.core.includeL);return[e.points[0],r].filter((e=>void 0!==e)).map((e=>$e.core.overlapConvexPolygonPoint(t,e,$e.core.include))).reduce(((e,t)=>e&&t),!0)},validateAxiom5=(e,t,r)=>{if(0===r.length)return[];const o=e.points.map((e=>$e.core.overlapConvexPolygonPoint(t,e,$e.core.include))).reduce(((e,t)=>e&&t),!0);return r.map((t=>reflectPoint(t,e.points[1]))).map((e=>$e.core.overlapConvexPolygonPoint(t,e,$e.core.include))).map((e=>e&&o))},validateAxiom6=function(e,t,r){if(0===r.length)return[];if(!e.points.map((e=>$e.core.overlapConvexPolygonPoint(t,e,$e.core.include))).reduce(((e,t)=>e&&t),!0))return r.map((()=>!1));const o=r.map((t=>reflectPoint(t,e.points[0]))).map((e=>$e.core.overlapConvexPolygonPoint(t,e,$e.core.include))),s=r.map((t=>reflectPoint(t,e.points[1]))).map((e=>$e.core.overlapConvexPolygonPoint(t,e,$e.core.include)));return r.map(((e,t)=>o[t]&&s[t]))},validateAxiom7=(e,t,r)=>{const o=$e.core.overlapConvexPolygonPoint(t,e.points[0],$e.core.include);if(void 0===r)return[!1];const s=reflectPoint(r,e.points[0]),n=$e.core.overlapConvexPolygonPoint(t,s,$e.core.include),c=void 0!==$e.core.intersectConvexPolygonLine(t,e.lines[1].vector,e.lines[1].origin,$e.core.includeS,$e.core.includeL),i=$e.core.intersectLineLine(e.lines[1].vector,e.lines[1].origin,r.vector,r.origin,$e.core.includeL,$e.core.includeL),a=!!i&&$e.core.overlapConvexPolygonPoint(t,i,$e.core.include);return o&&n&&c&&a};var Rt=Object.freeze({__proto__:null,validateAxiom1:validateAxiom1,validateAxiom2:qt,validateAxiom3:validateAxiom3,validateAxiom4:validateAxiom4,validateAxiom5:validateAxiom5,validateAxiom6:validateAxiom6,validateAxiom7:validateAxiom7,validate:(e,t,r,o)=>arrayify(e,[null,validateAxiom1,qt,validateAxiom3,validateAxiom4,validateAxiom5,validateAxiom6,validateAxiom7][e](t,r,((e,t)=>{switch(e){case 3:case"3":case 5:case"5":case 6:case"6":return t;default:return t?t[0]:void 0}})(e,o)))});const spreadParams=e=>[...e.lines?e.lines:[],...e.points?e.points:[]],axiomInBoundary=(e,t={},r)=>{const o=arrayify(e,Tt[`axiom${e}`](...spreadParams(t))).map((e=>$e.line(e)));return r&&arrayify(e,Rt[`validateAxiom${e}`](t,r,o)).forEach(((e,t)=>e?t:void 0)).filter((e=>void 0!==e)).forEach((e=>delete o[e])),o};var Dt=Object.freeze({__proto__:null,axiomInBoundary:axiomInBoundary,normalAxiomInBoundary:(e,t={},r)=>{const o=arrayify(e,Bt[`normalAxiom${e}`](...spreadParams(t))).map((e=>$e.line.fromNormalDistance(e)));return r&&arrayify(e,Rt[`validateAxiom${e}`]((e=>({points:e.points,lines:e.lines.map($e.core.uniqueLineToRayLine)}))(t),r,o)).forEach(((e,t)=>e?t:void 0)).filter((e=>void 0!==e)).forEach((e=>delete o[e])),o}});const axiom=(e,t={},r)=>axiomInBoundary(e,t,r);Object.keys(Tt).forEach((e=>{axiom[e]=Tt[e]})),Object.keys(Bt).forEach((e=>{axiom[e]=Bt[e]})),Object.keys(Dt).forEach((e=>{axiom[e]=Dt[e]})),Object.keys(Rt).forEach((e=>{axiom[e]=Rt[e]}));const line_line_for_arrows=(e,t)=>$e.core.intersectLineLine(e.vector,e.origin,t.vector,t.origin,$e.core.includeL,$e.core.includeL),diagram_reflect_point=(e,t)=>{const r=$e.core.makeMatrix2Reflect(e.vector,e.origin);return $e.core.multiplyMatrix2Vector2(r,t)},boundary_for_arrows$1=({vertices_coords:e})=>$e.core.convexHull(e),widest_perp=(e,t,r)=>{const o=boundary_for_arrows$1(e);if(void 0===r){const e=$e.core.clipLineConvexPolygon(o,t.vector,t.origin,$e.core.exclude,$e.core.includeL);r=$e.core.midpoint(...e)}const s=$e.core.rotate270(t.vector),n=$e.core.clipLineConvexPolygon(o,s,r,$e.core.exclude,$e.core.includeL).map((e=>$e.core.distance(r,e))).sort(((e,t)=>e-t)).shift(),c=$e.core.scale($e.core.normalize(s),n);return $e.segment($e.core.add(r,$e.core.flip(c)),$e.core.add(r,c))},between_2_segments=(e,t,r)=>{const o=t.map((e=>$e.core.midpoint(e[0],e[1]))),s=$e.line.fromPoints(...o),n=$e.intersect(r,s),c=$e.line(r.vector.rotate90(),n);return $e.segment(e.lines.map((e=>$e.intersect(e,c))))},Ut=[null,(e,t)=>axiom(1,e).map((e=>[widest_perp(t,e)])),e=>[[$e.segment(e.points)]],(e,t)=>{const r=boundary_for_arrows$1(t),o=e.lines.map((e=>$e.core.clipLineConvexPolygon(r,e.vector,e.origin,$e.core.exclude,$e.core.includeL))),s=o.map((e=>$e.core.subtract(e[1],e[0]))),n=$e.core.intersectLineLine(s[0],o[0][0],s[1],o[1][0],$e.core.excludeS,$e.core.excludeS);return n?axiom(3,e).map((t=>((e,t,r,o)=>{const s=e.lines.map((e=>e.vector)),n=s.map($e.core.flip),c=s.concat(n).map((e=>$e.ray(e,t))),i=c.filter((e=>$e.core.dot(e.vector,r.vector)>0&&$e.core.cross2(e.vector,r.vector)>0)).shift(),a=c.filter((e=>$e.core.dot(e.vector,r.vector)>0&&$e.core.cross2(e.vector,r.vector)<0)).shift(),l=c.filter((e=>$e.core.dot(e.vector,r.vector)<0&&$e.core.cross2(e.vector,r.vector)>0)).shift(),d=c.filter((e=>$e.core.dot(e.vector,r.vector)<0&&$e.core.cross2(e.vector,r.vector)<0)).shift(),u=[i,a,l,d].map((e=>$e.core.intersectConvexPolygonLine(o,e.vector,e.origin,$e.core.excludeS,$e.core.excludeR).shift().shift())),p=u.map((e=>$e.core.distance(e,t))),g=p[0]<p[1]?u[0]:u[1],m=p[0]<p[1]?$e.core.add(a.origin,a.vector.normalize().scale(p[0])):$e.core.add(i.origin,i.vector.normalize().scale(p[1])),h=p[2]<p[3]?u[2]:u[3],v=p[2]<p[3]?$e.core.add(d.origin,d.vector.normalize().scale(p[2])):$e.core.add(l.origin,l.vector.normalize().scale(p[3]));return[$e.segment(g,m),$e.segment(h,v)]})(e,n,t,r))):[between_2_segments(e,o,axiom(3,e).filter((e=>void 0!==e)).shift())]},(e,t)=>axiom(4,e).map((r=>[widest_perp(t,r,line_line_for_arrows(r,e.lines[0]))])),e=>axiom(5,e).map((t=>[$e.segment(e.points[1],diagram_reflect_point(t,e.points[1]))])),e=>axiom(6,e).map((t=>e.points.map((e=>$e.segment(e,diagram_reflect_point(t,e)))))),(e,t)=>axiom(7,e).map((r=>[$e.segment(e.points[0],diagram_reflect_point(r,e.points[0])),widest_perp(t,r,line_line_for_arrows(r,e.lines[1]))]))];delete Ut[0];const axiomArrows=(e,t={},...r)=>{const o=t.points?t.points.map((e=>$e.core.getVector(e))):void 0,s=t.lines?t.lines.map((e=>$e.core.getLine(e))):void 0;return Ut[e]({points:o,lines:s},...r)};Object.keys(Ut).forEach((e=>{axiomArrows[e]=(...t)=>axiomArrows(e,...t)}));var Gt=Object.assign(Object.create(null),{axiom_arrows:axiomArrows,simple_arrow:(e,t)=>{const r=(({vertices_coords:e})=>$e.core.convexHull(e))(e),o=$e.core.boundingBox(r),s=((e,t,r)=>{if(void 0===r){const o=$e.core.clipLineConvexPolygon(e,t.vector,t.origin,$e.core.exclude,$e.core.includeL);if(void 0===o)return;r=$e.core.midpoint(...o)}const o=$e.core.rotate90(t.vector),s=$e.core.clipLineConvexPolygon(e,o,r,$e.core.exclude,$e.core.includeL).map((e=>$e.core.distance(r,e))).sort(((e,t)=>e-t)).shift(),n=$e.core.scale($e.core.normalize(o),s);return $e.segment($e.core.add(r,$e.core.flip(n)),$e.core.add(r,n))})(r,t);if(void 0===s)return;const n=$e.core.subtract(s[1],s[0]),c=$e.core.magnitude(n),i=$e.core.dot(n,[1,0]),a=o.span[0]<o.span[1]?o.span[0]:o.span[1];return s.head={width:.1*a,height:.15*a},s.bend=i>0?.3:-.3,s.padding=.05*c,s}});var Wt=Object.freeze({__proto__:null,flipFacesLayer:e=>invertMap(invertMap(e).reverse()),facesLayerToEdgesAssignments:(e,t)=>{const r=[],o=makeFacesWinding(e);return(e.edges_faces?e.edges_faces:makeEdgesFaces(e)).forEach(((e,s)=>{if(1===e.length&&(r[s]="B"),2===e.length){const n=e.map((e=>o[e]));if(n[0]===n[1])return void(r[s]="F");const c=e.map((e=>t[e])),i=c[0]<c[1],a=n[0]?i:!i;r[s]=a?"V":"M"}})),r},ordersToMatrix:e=>{const t=Object.keys(e).map((e=>e.split(" ").map((e=>parseInt(e,10))))),r=[];t.reduce(((e,t)=>e.concat(t)),[]).forEach((e=>{r[e]=void 0}));const o=r.map((()=>[]));return t.forEach((([t,r])=>{o[t][r]=e[`${t} ${r}`],o[r][t]=-e[`${t} ${r}`]})),o}});const makeFoldedStripTacos=(e,t,r)=>{const o=e.map((e=>e?(e[0]+e[1])/2:void 0)),s=[];return e.forEach(((n,c)=>{if(!n)return;if(!t&&c===e.length-1)return;const i=n[1],a=i-2*r,l=i+2*r,d=[c,(c+1)%e.length],u=d.map((e=>o[e])).map((e=>e>i)),p=1*(!u[0]&&!u[1])+2*(u[0]&&u[1]),g=s.filter((e=>e.min<i&&e.max>i)).shift(),m={faces:d,taco_type:p};g?g.pairs.push(m):s.push({min:a,max:l,pairs:[m]})})),s.map((e=>e.pairs)).filter((e=>e.length>1)).map((e=>({both:e.filter((e=>0===e.taco_type)).map((e=>e.faces)),left:e.filter((e=>1===e.taco_type)).map((e=>e.faces)),right:e.filter((e=>2===e.taco_type)).map((e=>e.faces))})))},between=(e,t,r)=>t<r?e.slice(t+1,r):e.slice(r+1,t),validateTacoTortillaStrip=(e,t,r=!0,o=$e.core.EPSILON)=>{const s=invertMap(t),n=e.map((e=>e?e[1]:void 0)),c=e.map((e=>e?Math.min(...e):void 0)).map((e=>e+o)),i=e.map((e=>e?Math.max(...e):void 0)).map((e=>e-o)),a=s.length+(r?0:-1);for(let e=0;e<a;e+=1){const r=(e+1)%s.length;if(s[e]===s[r])continue;const o=between(t,s[e],s[r]).flat(),a=o.map((t=>n[e]<c[t])).reduce(((e,t)=>e&&t),!0),l=o.map((t=>n[e]>i[t])).reduce(((e,t)=>e&&t),!0);if(!a&&!l)return!1}return!0},validateTacoTacoFacePairs=e=>{const t=removeSingleInstances(e),r={};let o=0;for(let e=0;e<t.length;e+=1)if(void 0===r[t[e]])o+=1,r[t[e]]=o;else if(void 0!==r[t[e]]){if(r[t[e]]!==o)return!1;o-=1,r[t[e]]=void 0}return!0},build_layers=(e,t)=>e.map((e=>t[e])).filter((e=>void 0!==e)),validateLayerSolver=(e,t,r,o,s)=>{const n=$e.core.flattenArrays(t);if(!validateTacoTortillaStrip(e,t,o,s))return!1;for(let e=0;e<r.length;e+=1){const t=build_layers(n,r[e]);if(!validateTacoTacoFacePairs(t))return!1}return!0},Zt={V:!0,v:!0,M:!0,m:!0},Jt={V:1,v:1,M:-1,m:-1},assignmentsToFacesVertical=e=>{let t=0;return e.slice(1).concat([e[0]]).map((e=>{const r=(o=e,t%2==0?Jt[o]||0:-(Jt[o]||0));var o;return t+=void 0===Jt[e]?0:1,r}))},foldStripWithAssignments=(e,t)=>{const r=(e=>{let t=0;const r=e.slice(1);return[!1].concat(r.map((e=>Zt[e]?++t:t)).map((e=>e%2==1)))})(t).map(((t,r)=>e[r]*(t?-1:1))),o=e.map((()=>{}));o[0]=[0,r[0]];for(let s=1;s<e.length&&("B"!==t[s]&&"b"!==t[s]);s+=1){const t=o[(s-1+e.length)%e.length][1];o[s]=[t,t+r[s]]}return o},Xt={B:!0,b:!0},singleVertexSolver=(e,t,r=$e.core.EPSILON)=>{const o=foldStripWithAssignments(e,t),s=assignmentsToFacesVertical(t),n=t.map((e=>!Xt[e])).reduce(((e,t)=>e&&t),!0);if(n){const e=o[0][0],t=o[o.length-1][1];if(Math.abs(e-t)>r)return[]}const c=makeFoldedStripTacos(o,n,r).map((e=>[e.left,e.right].map(invertMap).filter((e=>e.length>1)))).reduce(((e,t)=>e.concat(t)),[]),recurse=(t=[0],i=0,a=0)=>{const l=i+1,d=s[i],u=i>=e.length-1,p=n&&u;if(!validateLayerSolver(o,t,c,p,r))return[];if(p){const e=invertMap(t),r=e[0],o=e[i];if(d>0&&o>r)return[];if(d<0&&o<r)return[]}if(u)return[t];if(0===d)return t[a]=[l].concat(t[a]),recurse(t,l,a);const g=1===d?Array.from(Array(t.length-a)).map(((e,t)=>a+t+1)):Array.from(Array(a+1)).map(((e,t)=>t)),m=g.map((()=>clone(t)));return m.forEach(((e,t)=>e.splice(g[t],0,l))),m.map(((e,t)=>recurse(e,l,g[t]))).reduce(((e,t)=>e.concat(t)),[])};return recurse().map(invertMap)},maekawaAssignments=e=>{const t=(r=e).map(((e,t)=>t)).filter((e=>"U"===r[e]||"u"===r[e]));var r;const o=Array.from(Array(2**t.length)).map(((e,t)=>t.toString(2))).map((e=>Array(t.length-e.length+1).join("0")+e)).map((e=>Array.from(e).map((e=>"0"===e?"V":"M")))).map((r=>{const o=e.slice();return t.forEach(((e,t)=>{o[e]=r[t]})),o}));if(e.includes("B")||e.includes("b"))return o;const s=o.map((e=>e.filter((e=>"M"===e||"m"===e)).length)),n=o.map((e=>e.filter((e=>"V"===e||"v"===e)).length));return o.filter(((e,t)=>2===Math.abs(s[t]-n[t])))},make_lookup=e=>{const t=e[0].length,r=Array.from(Array(t+1)).map((()=>({})));Array.from(Array(Math.pow(2,t))).map(((e,t)=>t.toString(2))).map((e=>Array.from(e).map((e=>parseInt(e,10)+1)).join(""))).map((e=>`11111${e}`.slice(-t))).forEach((e=>{r[0][e]=!1})),e.forEach((e=>{r[0][e]=!0})),Array.from(Array(t)).map(((e,t)=>t+1)).map((e=>Array.from(Array(Math.pow(3,t))).map(((e,t)=>t.toString(3))).map((e=>`000000${e}`.slice(-t))).forEach((t=>((e,t,r)=>{const o=Array.from(r).map((e=>parseInt(e,10)));if(o.filter((e=>0===e)).length!==t)return;e[t][r]=!1;let s=!1;for(let r=0;r<o.length;r+=1){const n=[];if(0===o[r]){for(let s=1;s<=2;s+=1)o[r]=s,!1!==e[t-1][o.join("")]&&n.push([r,s]);o[r]=0,n.length>0&&!1===s&&(s=[]),1===n.length&&s.push(n[0])}}!1!==s&&0===s.length&&(s=!0),e[t][r]=s})(r,e,t)))));let o=[];Array.from(Array(t+1)).map(((e,r)=>t-r)).forEach((e=>{const t=[];Object.keys(r[e]).forEach((o=>{let s=r[e][o];s.constructor===Array&&(s=s[0]),t.push([o,s])})),o=o.concat(t)})),o.sort(((e,t)=>parseInt(e[0],10)-parseInt(t[0],10)));const s={};return o.forEach((e=>{s[e[0]]=Object.freeze(e[1])})),Object.freeze(s)},Ht={taco_taco:make_lookup(["111112","111121","111222","112111","121112","121222","122111","122212","211121","211222","212111","212221","221222","222111","222212","222221"]),taco_tortilla:make_lookup(["112","121","212","221"]),tortilla_tortilla:make_lookup(["11","22"]),transitivity:make_lookup(["112","121","122","211","212","221"])},Yt={taco_taco:e=>[[e[0],e[2]],[e[1],e[3]],[e[1],e[2]],[e[0],e[3]],[e[0],e[1]],[e[2],e[3]]],taco_tortilla:e=>[[e[0],e[2]],[e[0],e[1]],[e[1],e[2]]],tortilla_tortilla:e=>[[e[0],e[2]],[e[1],e[3]]],transitivity:e=>[[e[0],e[1]],[e[1],e[2]],[e[2],e[0]]]},pairArrayToSortedPairString$1=e=>e[0]<e[1]?`${e[0]} ${e[1]}`:`${e[1]} ${e[0]}`,Kt={taco_taco:e=>[pairArrayToSortedPairString$1([e[0],e[2]]),pairArrayToSortedPairString$1([e[1],e[3]]),pairArrayToSortedPairString$1([e[1],e[2]]),pairArrayToSortedPairString$1([e[0],e[3]]),pairArrayToSortedPairString$1([e[0],e[1]]),pairArrayToSortedPairString$1([e[2],e[3]])],taco_tortilla:e=>[pairArrayToSortedPairString$1([e[0],e[2]]),pairArrayToSortedPairString$1([e[0],e[1]]),pairArrayToSortedPairString$1([e[1],e[2]])],tortilla_tortilla:e=>[pairArrayToSortedPairString$1([e[0],e[2]]),pairArrayToSortedPairString$1([e[1],e[3]])],transitivity:e=>[pairArrayToSortedPairString$1([e[0],e[1]]),pairArrayToSortedPairString$1([e[1],e[2]]),pairArrayToSortedPairString$1([e[2],e[0]])]},Qt={0:0,1:1,2:-1},er=Object.freeze(Object.keys(Ht)),tr={0:0,1:2,2:1},buildRuleAndLookup=(e,t,...r)=>{const o=Yt[e](t),s=o.map((e=>e[1]<e[0])),n=o.map(((e,t)=>s[t]?`${e[1]} ${e[0]}`:`${e[0]} ${e[1]}`)),c=n.map(((e,t)=>{for(let o=0;o<r.length;o+=1)if(r[o][e])return s[t]?tr[r[o][e]]:r[o][e];return 0})).join("");if(!0===Ht[e][c])return!0;if(!1===Ht[e][c])return!1;const i=Ht[e][c];return[n[i[0]],s[i[0]]?tr[i[1]]:i[1]]},getConstraintIndicesFromFacePairs=(e,t,r)=>{const o={};return er.forEach((s=>{const n=r.flatMap((e=>t[s][e]));o[s]=uniqueIntegers(n).filter((t=>e[s][t]))})),o},propagate=(e,t,r,...o)=>{let s=r;const n={};do{const r=getConstraintIndicesFromFacePairs(e,t,s),c={};for(let t=0;t<er.length;t+=1){const s=er[t],i=r[s];for(let t=0;t<i.length;t+=1){const r=buildRuleAndLookup(s,e[s][i[t]],...o,n);if(!0!==r){if(!1===r)return console.warn("invalid state found",s,e[s][i[t]]),!1;if(n[r[0]]){if(n[r[0]]!==r[1])return console.warn("order conflict",s,e[s][i[t]]),!1}else{const[e,t]=r;c[e]=!0,n[r[0]]=t}}}}s=Object.keys(c)}while(s.length);return n},getBranches=(e,t,r,o={})=>{const s=Object.keys(t),n={};e.forEach((e=>{n[e]=!0}));let c=0;const i=[];for(;c<e.length;){if(!n[e[c]]){c+=1;continue}const a=[],l=[e[c]],d={[e[c]]:!0};do{const e=l.shift();let c;if(delete n[e],a.push(e),o[e])c=o[e];else{const n={};s.forEach((o=>{const s=r[o][e];s&&s.map((e=>t[o][e])).map((e=>Kt[o](e).forEach((e=>{n[e]=!0}))))})),c=Object.keys(n),o[e]=c}const i=c.filter((e=>n[e])).filter((e=>!d[e]));l.push(...i),i.forEach((e=>{d[e]=!0}))}while(l.length);c+=1,i.push(a)}return i},makeTortillaTortillaFacesCrossing$1=(e,t,r)=>((e,t,r)=>{const o=makeFacesWinding(e),s=makeFacesPolygon(e,r);for(let e=0;e<s.length;e+=1)o[e]||s[e].reverse();const n=t.map((e=>2===e.length&&e[0]!==e[1])).map(((e,t)=>e?t:void 0)).filter((e=>void 0!==e)),c=n.map((t=>e.edges_vertices[t])).map((t=>t.map((t=>e.vertices_coords[t])))),i=c.map((e=>$e.core.subtract2(e[1],e[0]))),a=[];return n.forEach((e=>{a[e]=[]})),n.map(((e,t)=>s.map((e=>$e.core.clipLineConvexPolygon(e,i[t],c[t][0],$e.core.exclude,$e.core.excludeS,r))).map((e=>void 0!==e)))).forEach(((e,t)=>e.forEach(((e,r)=>{e&&a[n[t]].push(r)})))),a})(e,t,r).map(((t,r)=>t.map((t=>[e.edges_faces[r],[t,t]])))).reduce(((e,t)=>e.concat(t)),[]),classify_faces_pair$1=e=>1===e[0]&&-1===e[1]||-1===e[0]&&1===e[1]?"both":1===e[0]&&1===e[1]?"right":-1===e[0]&&-1===e[1]?"left":void 0,makeTacosTortillas$1=(e,t=$e.core.EPSILON)=>{const r=makeFacesConvexCenter(e),o=((e,t)=>{const r=e.edges_vertices.map((t=>e.vertices_coords[t[0]])),o=e.edges_vertices.map((t=>$e.core.subtract2(e.vertices_coords[t[1]],e.vertices_coords[t[0]])));return e.edges_faces.map(((e,s)=>e.map((e=>$e.core.cross2($e.core.subtract2(t[e],r[s]),o[s]))).map((e=>Math.sign(e)))))})(e,r),s=makeEdgesEdgesParallelOverlap(e,t),n=booleanMatrixToUniqueIndexPairs(s).filter((t=>t.map((t=>e.edges_faces[t].length>1)).reduce(((e,t)=>e&&t),!0))),c=n.map((t=>t.map((t=>e.edges_faces[t])))),i=((e,t,r,o)=>{const s=r.map((t=>e.edges_vertices[t[0]].map((t=>e.vertices_coords[t])))),n=s.map((e=>e[0])),c=s.map((e=>$e.core.subtract2(e[1],e[0])));return o.map((e=>e.map((e=>e.map((e=>t[e])))))).map(((e,t)=>e.map((e=>e.map((e=>$e.core.cross2($e.core.subtract2(e,n[t]),c[t]))).map((e=>Math.sign(e)))))))})(e,r,n,c),a=i.map((e=>e.map(classify_faces_pair$1))),l=a.map(((e,t)=>{return(r=e)[0]===r[1]&&"both"!==r[0]?c[t]:void 0;var r})).filter((e=>void 0!==e)),d=a.map(((e,t)=>{return(r=e)[0]===r[1]&&"both"===r[0]?c[t]:void 0;var r})).map(((e,t)=>((e,t)=>{if(void 0!==e)return t[0][0]===t[1][0]?e:[e[0],[e[1][1],e[1][0]]]})(e,i[t]))).filter((e=>void 0!==e)),u=makeTortillaTortillaFacesCrossing$1(e,o,t),p=d.concat(u),g=a.map(((e,t)=>{return(r=e)[0]===r[1]||"both"!==r[0]&&"both"!==r[1]?void 0:((e,t,r)=>{const o="left"===t[0]||"left"===t[1]?-1:1,s="both"===t[0]?[...e[1]]:[...e[0]],n="both"===t[0]?0:1;return{taco:s,tortilla:r[n][0]===o?e[n][0]:e[n][1]}})(c[t],a[t],i[t]);var r})).filter((e=>void 0!==e)),m=makeEdgesFacesOverlap(e,t),h=booleanMatrixToIndexedArray(m).map(((e,t)=>o[t].length>1&&o[t][0]===o[t][1]?e:[])).map(((t,r)=>({taco:e.edges_faces[r],tortillas:t}))).filter((e=>e.tortillas.length)).flatMap((e=>e.tortillas.map((t=>({taco:[...e.taco],tortilla:t})))));return{taco_taco:l,tortilla_tortilla:p,taco_tortilla:g.concat(h)}},makeTransitivityTrios$1=(e,t,r,o=$e.core.EPSILON)=>{t||(t=getFacesFaces2DOverlap(e,o)),r||(r=makeFacesWinding(e));const s=e.faces_vertices.map((t=>t.map((t=>e.vertices_coords[t]))));s.forEach(((e,t)=>{r[t]||e.reverse()}));const n=e.faces_vertices.map((()=>[]));for(let e=0;e<n.length-1;e+=1)for(let r=e+1;r<n.length;r+=1){if(!t[e][r])continue;const c=$e.core.clipPolygonPolygon(s[e],s[r],o);c&&(n[e][r]=c)}const c=[];for(let e=0;e<n.length-1;e+=1)for(let r=e+1;r<n.length;r+=1)if(n[e][r])for(let i=r+1;i<n.length;i+=1){if(e===i||r===i)continue;if(!t[e][i]||!t[r][i])continue;$e.core.clipPolygonPolygon(n[e][r],s[i],o)&&c.push([e,r,i].sort(((e,t)=>e-t)))}return c},rr={0:0,1:2,2:1},or={M:1,m:1,V:2,v:2},makeFacePairs=(e,t)=>(t||(t=getFacesFaces2DOverlap(e)),booleanMatrixToUniqueIndexPairs(t).map((e=>e.join(" ")))),solveEdgeAdjacentFacePairs$1=(e,t,r)=>{r||(r=makeFacesWinding(e));const o={};t.forEach((e=>{o[e]=!0}));const s={};return e.edges_faces.forEach(((t,n)=>{const c=e.edges_assignment[n],i=or[c];if(t.length<2||void 0===i)return;const a=r[t[0]]?i:rr[i],l=`${t[0]} ${t[1]}`,d=`${t[1]} ${t[0]}`;l in o&&(s[l]=a),d in o&&(s[d]=rr[a])})),s};var sr=Object.freeze({__proto__:null,makeFacePairs:makeFacePairs,solveEdgeAdjacentFacePairs:solveEdgeAdjacentFacePairs$1});const prepare$1=(e,t=1e-6)=>{const r=getFacesFaces2DOverlap(e,t),o=makeFacesWinding(e),s=makeTacosTortillas$1(e,t),n=((e,t)=>{const r={};return t.taco_taco.map((e=>[e[0][0],e[0][1],e[1][0],e[1][1]].sort(((e,t)=>e-t)))).forEach((e=>[`${e[0]} ${e[1]} ${e[2]}`,`${e[0]} ${e[1]} ${e[3]}`,`${e[0]} ${e[2]} ${e[3]}`,`${e[1]} ${e[2]} ${e[3]}`].forEach((e=>{r[e]=!0})))),t.taco_tortilla.map((e=>[e.taco[0],e.taco[1],e.tortilla].sort(((e,t)=>e-t)).join(" "))).forEach((e=>{r[e]=!0})),e.filter((e=>void 0===r[e.join(" ")]))})(makeTransitivityTrios$1(e,r,o,t),s),c=((e,t)=>{const r={};return r.taco_taco=e.taco_taco.map((e=>[e[0][0],e[1][0],e[0][1],e[1][1]])),r.taco_tortilla=e.taco_tortilla.map((e=>[e.taco[0],e.tortilla,e.taco[1]])),r.tortilla_tortilla=e.tortilla_tortilla.map((e=>[e[0][0],e[0][1],e[1][0],e[1][1]])),r.transitivity=t.map((e=>[e[0],e[1],e[2]])),r})(s,n),i=(e=>{const t={};return Object.keys(e).forEach((e=>{t[e]={}})),Object.keys(e).forEach((r=>{e[r].forEach(((e,o)=>Kt[r](e).forEach((e=>{void 0===t[r][e]&&(t[r][e]=[]),t[r][e].push(o)}))))})),t})(c),a=makeFacePairs(e,r);return{constraints:c,constraintsLookup:i,facePairs:a,edgeAdjacentOrders:solveEdgeAdjacentFacePairs$1(e,a,o)}},nr={allSolutions:function(){return(e=>{const recurse=(e,t=[])=>{e.faceOrders&&t.push(e.faceOrders);const r=e.finished?e.finished.map((e=>[...t,e.faceOrders])):void 0;if(e.unfinished){const o=e.unfinished.map((e=>recurse(e,JSON.parse(JSON.stringify(t))))),s=o.length>1?((e,t)=>{const r=[];for(let o=0;o<e.length;o+=1)for(let s=0;s<t.length;s+=1)r.push([e[o],t[s]]);return r})(...o):o;s.forEach((e=>{e.branch=!0})),r.forEach((e=>e.push(...s)))}return r.finished=!0,r};return recurse(e)})(this)}},solveBranch=(e,t,r,o,s,...n)=>{if(!o.length)return[];const c=o[0],i=[],a=[];[1,2].forEach((r=>{const s=propagate(e,t,[c],...n,{[c]:r});!1!==s&&(s[c]=r,Object.keys(s).length===o.length?i.push(s):a.push(s))}));const l=a.map((e=>({faceOrders:e}))),d=a.map(((s,c)=>{const i=o.filter((e=>!(e in s)));return getBranches(i,e,t,r).map((o=>solveBranch(e,t,r,o,l[c],...n,s)))}));return i.length&&(s.finished=i.map((e=>({faceOrders:e})))),l.length&&(s.unfinished=l),l.length>1&&i.length&&console.log("HAPPENED"),i.map((e=>[...n,e])).concat(...d)},makeTortillaTortillaFacesCrossing=(e,t,r)=>((e,t,r)=>{const o=makeFacesWinding(e),s=makeFacesPolygon(e,r);o.forEach(((e,t)=>{e||s[t].reverse()}));const n=t.map((e=>2===e.length&&e[0]!==e[1])).map(((e,t)=>e?t:void 0)).filter((e=>void 0!==e)),c=n.map((t=>e.edges_vertices[t])).map((t=>t.map((t=>e.vertices_coords[t])))),i=c.map((e=>$e.core.subtract2(e[1],e[0]))),a=[];return n.forEach((e=>{a[e]=[]})),n.map(((e,t)=>s.map((e=>$e.core.clipLineConvexPolygon(e,i[t],c[t][0],$e.core.exclude,$e.core.excludeS,r))).map((e=>void 0!==e)))).forEach(((e,t)=>e.forEach(((e,r)=>{e&&a[n[t]].push(r)})))),a})(e,t,r).map(((t,r)=>t.map((t=>[e.edges_faces[r],[t,t]])))).reduce(((e,t)=>e.concat(t)),[]),classify_faces_pair=e=>1===e[0]&&-1===e[1]||-1===e[0]&&1===e[1]?"both":1===e[0]&&1===e[1]?"right":-1===e[0]&&-1===e[1]?"left":void 0,makeTacosTortillas=(e,t=$e.core.EPSILON)=>{const r=(e=>{const t=e.edges_vertices.map((t=>e.vertices_coords[t[0]])),r=e.edges_vertices.map((t=>$e.core.subtract2(e.vertices_coords[t[1]],e.vertices_coords[t[0]])));return e.edges_faces.map(((o,s)=>o.map((o=>$e.core.cross2($e.core.subtract2(e.faces_center[o],t[s]),r[s]))).map((e=>Math.sign(e)))))})(e),o=makeEdgesEdgesParallelOverlap(e,t),s=selfRelationalUniqueIndexPairs(o).filter((t=>t.map((t=>e.edges_faces[t].length>1)).reduce(((e,t)=>e&&t),!0))),n=s.map((t=>t.map((t=>e.edges_faces[t])))),c=((e,t,r)=>{const o=t.map((t=>e.edges_vertices[t[0]].map((t=>e.vertices_coords[t])))),s=o.map((e=>e[0])),n=o.map((e=>$e.core.subtract2(e[1],e[0])));return r.map((t=>t.map((t=>t.map((t=>e.faces_center[t])))))).map(((e,t)=>e.map((e=>e.map((e=>$e.core.cross2($e.core.subtract2(e,s[t]),n[t]))).map((e=>Math.sign(e)))))))})(e,s,n),i=c.map((e=>e.map(classify_faces_pair))),a=i.map(((e,t)=>{return(r=e)[0]===r[1]&&"both"!==r[0]?n[t]:void 0;var r})).filter((e=>void 0!==e)),l=i.map(((e,t)=>{return(r=e)[0]===r[1]&&"both"===r[0]?n[t]:void 0;var r})).map(((e,t)=>((e,t)=>{if(void 0!==e)return t[0][0]===t[1][0]?e:[e[0],[e[1][1],e[1][0]]]})(e,c[t]))).filter((e=>void 0!==e)),d=makeTortillaTortillaFacesCrossing(e,r,t),u=l.concat(d),p=i.map(((e,t)=>{return(r=e)[0]===r[1]||"both"!==r[0]&&"both"!==r[1]?void 0:((e,t,r)=>{const o="left"===t[0]||"left"===t[1]?-1:1,s="both"===t[0]?[...e[1]]:[...e[0]],n="both"===t[0]?0:1;return{taco:s,tortilla:r[n][0]===o?e[n][0]:e[n][1]}})(n[t],i[t],c[t]);var r})).filter((e=>void 0!==e)),g=makeEdgesFacesOverlap(e,t),m=booleanMatrixToIndexedArray(g).map(((e,t)=>r[t].length>1&&r[t][0]===r[t][1]?e:[])).map(((t,r)=>({taco:e.edges_faces[r],tortillas:t}))).filter((e=>e.tortillas.length)).flatMap((e=>e.tortillas.map((t=>({taco:[...e.taco],tortilla:t})))));return{taco_taco:a,tortilla_tortilla:u,taco_tortilla:p.concat(m)}},pairArrayToSortedPairString=e=>e[0]<e[1]?`${e[0]} ${e[1]}`:`${e[1]} ${e[0]}`,cr={taco_taco:e=>[pairArrayToSortedPairString([e[0],e[2]]),pairArrayToSortedPairString([e[1],e[3]]),pairArrayToSortedPairString([e[1],e[2]]),pairArrayToSortedPairString([e[0],e[3]]),pairArrayToSortedPairString([e[0],e[1]]),pairArrayToSortedPairString([e[2],e[3]])],taco_tortilla:e=>[pairArrayToSortedPairString([e[0],e[2]]),pairArrayToSortedPairString([e[0],e[1]]),pairArrayToSortedPairString([e[1],e[2]])],tortilla_tortilla:e=>[pairArrayToSortedPairString([e[0],e[2]]),pairArrayToSortedPairString([e[1],e[3]])],transitivity:e=>[pairArrayToSortedPairString([e[0],e[1]]),pairArrayToSortedPairString([e[1],e[2]]),pairArrayToSortedPairString([e[2],e[0]])]},ir={0:0,1:2,2:1},ar={M:1,m:1,V:2,v:2};var lr=Object.assign(Object.create(null),{solver:(e,t=1e-6)=>{const r=new Date,{constraints:o,constraintsLookup:s,facePairs:n,edgeAdjacentOrders:c}=prepare$1(e,t),i=Date.now()-r,a=new Date,l=propagate(o,s,Object.keys(c),c);if(!l)return;const d={},u=n.filter((e=>!(e in c))).filter((e=>!(e in l))),p={},g=getBranches(u,o,s,p),m=g.map((()=>({}))),h=g.map(((e,t)=>solveBranch(o,s,p,e,m[t],c,l)));m.length&&(d.unfinished=m),d.faceOrders={...c,...l};const v=e.faces_normal?e.faces_normal:makeFacesNormal(e),_=[0,0,1],recurse=e=>{e.faceOrders&&(e.faceOrders=((e,t,r)=>{const o=t.map((e=>$e.core.dot(e,r)>0)),s=Object.keys(e),n=s.map((e=>e.split(" ").map((e=>parseInt(e,10)))));return n.forEach(((t,r)=>{const n=Qt[e[s[r]]],c=o[t[1]]?n:-n;t.push(c)})),n})(e.faceOrders,v,_)),e.finished&&e.finished.forEach((e=>recurse(e))),e.unfinished&&e.unfinished.forEach((e=>recurse(e)))};recurse(d);const y=Date.now()-a;return console.log(`prep ${i}ms solver ${y}ms`),console.log("branches",h),Object.assign(Object.create(nr),d)},table:Ht,topologicalOrder:(e,t)=>{if(!e)return[];const r=[];Object.keys(e).forEach((t=>{const o=t.split(" ").map((e=>parseInt(e,10)));-1===e[t]&&o.reverse(),void 0===r[o[0]]&&(r[o[0]]=[]),r[o[0]].push(o[1])})),t&&t.faces_vertices&&t.faces_vertices.forEach(((e,t)=>{void 0===r[t]&&(r[t]=[])}));const o=[],s=[];let n=0;for(let e=0;e<r.length;e+=1){if(s[e])continue;const t=[e];for(;t.length&&n<2*r.length;){const e=t[t.length-1];if(r[e]&&r[e].length){const o=r[e].pop();s[o]||t.push(o)}else o.push(e),s[e]=!0,t.pop(),n+=1}}return n>=2*r.length&&console.warn("fix protection in topological order"),o},makeTacosTortillas:makeTacosTortillas$1,makeFoldedStripTacos:makeFoldedStripTacos,makeTransitivityTrios:makeTransitivityTrios$1,singleVertexSolver:singleVertexSolver,singleVertexAssignmentSolver:(e,t,r)=>{null==t&&(t=e.map((()=>"U")));const o=maekawaAssignments(t),s=o.map((t=>singleVertexSolver(e,t,r)));return o.map(((e,t)=>t)).filter((e=>s[e].length>0)).map((e=>({assignment:o[e],layer:s[e]})))},validateLayerSolver:validateLayerSolver,validateTacoTacoFacePairs:validateTacoTacoFacePairs,validateTacoTortillaStrip:validateTacoTortillaStrip,foldStripWithAssignments:foldStripWithAssignments},Wt,sr,{prepare:(e,t=1e-6)=>{const r={...e};r.faces_edges||(r.faces_edges=makeFacesEdgesFromVertices(r));const o=getOverlappingFacesGroups(r,t);console.log("prepare",o);const s=invertMap(o.faces_group).map((e=>e.constructor===Array?e:[e])),n=((e,t,r)=>{const o=t.groups_transformXY.map((()=>({...e})));filterKeysWithPrefix(e,"vertices").forEach((e=>o.forEach((t=>delete t[e])))),o.forEach((e=>delete e.edges_edges)),o.forEach((e=>delete e.edges_faces));const s=filterKeysWithPrefix(e,"faces");o.forEach(((t,o)=>s.forEach((s=>{t[s]=[],r[o].forEach((r=>{t[s][r]=e[s][r]}))}))));const n=e.vertices_coords.map((e=>$e.core.resize(3,e))),c=r.map((()=>({})));r.forEach(((t,r)=>t.forEach((t=>e.faces_vertices[t].forEach((e=>{c[r][e]=!0}))))));const i=c.map((e=>Object.keys(e).map((e=>parseInt(e,10)))));o.forEach((e=>{e.vertices_coords=[]})),t.groups_transformXY.forEach(((e,t)=>i[t].forEach((r=>{const s=$e.core.multiplyMatrix4Vector3(e,n[r]);o[t].vertices_coords[r]=[s[0],s[1]]}))));const a=r.map((()=>({})));r.forEach(((t,r)=>t.forEach((t=>e.faces_edges[t].forEach((e=>{a[r][e]=!0}))))));const l=a.map((e=>Object.keys(e).map((e=>parseInt(e,10))))),d=filterKeysWithPrefix(e,"edges");return o.forEach(((t,r)=>d.forEach((o=>{t[o]=[],l[r].forEach((r=>{t[o][r]=e[o][r]}))})))),o.forEach((e=>{e.edges_faces=makeEdgesFacesUnsorted(e)})),o})(r,o,s);console.log("graphCopies",n);const c=[];s.map(((e,t)=>e.map((e=>r.faces_vertices[e])).map((e=>e.map((e=>n[t].vertices_coords[e])))).forEach(((t,r)=>{c[e[r]]=t}))));const i=c.map((e=>e.reduce(((e,t)=>$e.core.add(e,t)),[0,0]).map((t=>t/e.length))));console.log("faces_polygon",c),console.log("faces_center",i),n.forEach((e=>{e.faces_center=e.faces_vertices.map(((e,t)=>i[t]))}));const a=n.map((e=>makeTacosTortillas(e,t)));console.log("groups_tacos_tortillas",a);const l=n.map((e=>((e,t,r,o=$e.core.EPSILON)=>{const s=e.faces_vertices.map((t=>t.map((t=>e.vertices_coords[t]))));makeFacesWinding(e).forEach(((e,t)=>{e||s[t].reverse()}));const n=e.faces_vertices.map((()=>[]));s.forEach(((e,r)=>t[r].forEach((e=>{n[r][e]=$e.core.clipPolygonPolygon(s[r],s[e],o)}))));const c=[];return n.forEach(((e,r)=>e.forEach(((e,i)=>{n[r][i]&&n.forEach(((n,a)=>{r!==a&&i!==a&&t[r][a]&&t[i][a]&&$e.core.clipPolygonPolygon(e,s[a],o)&&c.push([r,i,a].sort(((e,t)=>e-t)))}))})))),c})(e,o.faces_facesOverlap,o.faces_groupNormalAligned,t))).map(((e,t)=>((e,t)=>{const r={};return t.taco_taco.map((e=>[e[0][0],e[0][1],e[1][0],e[1][1]].sort(((e,t)=>e-t)))).forEach((e=>[`${e[0]} ${e[1]} ${e[2]}`,`${e[0]} ${e[1]} ${e[3]}`,`${e[0]} ${e[2]} ${e[3]}`,`${e[1]} ${e[2]} ${e[3]}`].forEach((e=>{r[e]=!0})))),t.taco_tortilla.map((e=>[e.taco[0],e.taco[1],e.tortilla].sort(((e,t)=>e-t)).join(" "))).forEach((e=>{r[e]=!0})),e.filter((e=>void 0===r[e.join(" ")]))})(e,a[t])));console.log("groups_transitivity_trios",l);const d=a.map(((e,t)=>((e,t)=>{const r={};return r.taco_taco=e.taco_taco.map((e=>[e[0][0],e[1][0],e[0][1],e[1][1]])),r.taco_tortilla=e.taco_tortilla.map((e=>[e.taco[0],e.tortilla,e.taco[1]])),r.tortilla_tortilla=e.tortilla_tortilla.map((e=>[e[0][0],e[0][1],e[1][0],e[1][1]])),r.transitivity=t.map((e=>[e[0],e[1],e[2]])),r})(e,l[t]))),u=d.map((e=>(e=>{const t={};return Object.keys(e).forEach((e=>{t[e]={}})),Object.keys(e).forEach((r=>{e[r].forEach(((e,o)=>cr[r](e).forEach((e=>{void 0===t[r][e]&&(t[r][e]=[]),t[r][e].push(o)}))))})),t})(e)));console.log("groups_constraints",d),console.log("groups_constraintsLookup",u);const p=selfRelationalUniqueIndexPairs(o.faces_facesOverlap).map((e=>e.join(" "))),g=n.map((e=>((e,t,r)=>{const o={};t.forEach((e=>{o[e]=!0}));const s={};return e.edges_faces.forEach(((t,n)=>{const c=e.edges_assignment[n],i=ar[c];if(t.length<2||void 0===i)return;const a=r[t[0]]?i:ir[i],l=`${t[0]} ${t[1]}`,d=`${t[1]} ${t[0]}`;l in o&&(s[l]=a),d in o&&(s[d]=ir[a])})),s})(e,p,o.faces_groupNormalAligned)));return console.log("facePairs",p),console.log("groups_edgeAdjacentOrders",g),{groups_constraints:d,groups_constraintsLookup:u,facePairs:p,groups_edgeAdjacentOrders:g}}});var dr=Object.freeze({__proto__:null,kawasakiSolutions:({vertices_coords:e,vertices_edges:t,edges_vertices:r,edges_vectors:o},s)=>{o||(o=makeEdgesVector({vertices_coords:e,edges_vertices:r})),t||(t=makeVerticesEdgesUnsorted({edges_vertices:r}));const n=t[s].map((e=>o[e])),c=$e.core.counterClockwiseOrder2(n).map((e=>n[e]));return kawasakiSolutionsVectors(c)}}),fr=Object.assign(Object.create(null),{maekawaAssignments:maekawaAssignments,foldAngles4:(e,t,r=0)=>{const o=(e=>{let t=0,r=0;for(let o=0;o<e.length;o+=1)"M"!==e[o]&&"m"!==e[o]||(t+=1),"V"!==e[o]&&"v"!==e[o]||(r+=1);for(let o=0;o<e.length;o+=1){if(t>r&&("V"===e[o]||"v"===e[o]))return o;if(r>t&&("M"===e[o]||"m"===e[o]))return o}})(t);if(void 0===o)return;const s=e[(o+1)%e.length],n=e[(o+2)%e.length],c=Math.PI*r,i=-Math.cos(s)*Math.cos(n)+Math.sin(s)*Math.sin(n)*Math.cos(Math.PI-c),a=Math.cos(Math.PI-c)-Math.sin(Math.PI-c)**2*Math.sin(s)*Math.sin(n)/(1-i),l=-Math.acos(a)+Math.PI;return o%2==0?[l,c,l,c].map(((e,t)=>o===t?-e:e)):[c,l,c,l].map(((e,t)=>o===t?-e:e))}},vt,dr,Et),ur={axioms:{ar:[null,"اصنع خطاً يمر بنقطتين","اصنع خطاً عن طريق طي نقطة واحدة إلى أخرى","اصنع خطاً عن طريق طي خط واحد على آخر","اصنع خطاً يمر عبر نقطة واحدة ويجعل خطاً واحداً فوق نفسه","اصنع خطاً يمر بالنقطة الأولى ويجعل النقطة الثانية على الخط","اصنع خطاً يجلب النقطة الأولى إلى الخط الأول والنقطة الثانية إلى الخط الثاني","اصنع خطاً يجلب نقطة إلى خط ويجعل خط ثاني فوق نفسه"],de:[null,"Falte eine Linie durch zwei Punkte","Falte zwei Punkte aufeinander","Falte zwei Linien aufeinander","Falte eine Linie auf sich selbst, falte dabei durch einen Punkt","Falte einen Punkt auf eine Linie, falte dabei durch einen anderen Punkt","Falte einen Punkt auf eine Linie und einen weiteren Punkt auf eine weitere Linie","Falte einen Punkt auf eine Linie und eine weitere Linie in sich selbst zusammen"],en:[null,"fold a line through two points","fold two points together","fold two lines together","fold a line on top of itself, creasing through a point","fold a point to a line, creasing through another point","fold a point to a line and another point to another line","fold a point to a line and another line onto itself"],es:[null,"dobla una línea entre dos puntos","dobla dos puntos juntos","dobla y une dos líneas","dobla una línea sobre sí misma, doblándola hacia un punto","dobla un punto hasta una línea, doblándola a través de otro punto","dobla un punto hacia una línea y otro punto hacia otra línea","dobla un punto hacia una línea y otra línea sobre sí misma"],fr:[null,"créez un pli passant par deux points","pliez pour superposer deux points","pliez pour superposer deux lignes","rabattez une ligne sur elle-même à l'aide d'un pli qui passe par un point","rabattez un point sur une ligne à l'aide d'un pli qui passe par un autre point","rabattez un point sur une ligne et un autre point sur une autre ligne","rabattez un point sur une ligne et une autre ligne sur elle-même"],hi:[null,"एक क्रीज़ बनाएँ जो दो स्थानों से गुजरता है","एक स्थान को दूसरे स्थान पर मोड़कर एक क्रीज़ बनाएँ","एक रेखा पर दूसरी रेखा को मोड़कर क्रीज़ बनाएँ","एक क्रीज़ बनाएँ जो एक स्थान से गुजरता है और एक रेखा को स्वयं के ऊपर ले आता है","एक क्रीज़ बनाएँ जो पहले स्थान से गुजरता है और दूसरे स्थान को रेखा पर ले आता है","एक क्रीज़ बनाएँ जो पहले स्थान को पहली रेखा पर और दूसरे स्थान को दूसरी रेखा पर ले आता है","एक क्रीज़ बनाएँ जो एक स्थान को एक रेखा पर ले आता है और दूसरी रेखा को स्वयं के ऊपर ले आता है"],jp:[null,"2点に沿って折り目を付けます","2点を合わせて折ります","2つの線を合わせて折ります","点を通過させ、既にある線に沿って折ります","点を線沿いに合わせ別の点を通過させ折ります","線に向かって点を折り、同時にもう一方の線に向かってもう一方の点を折ります","線に向かって点を折り、同時に別の線をその上に折ります"],ko:[null,"두 점을 통과하는 선으로 접으세요","두 점을 함께 접으세요","두 선을 함께 접으세요","그 위에 선을 접으면서 점을 통과하게 접으세요","점을 선으로 접으면서, 다른 점을 지나게 접으세요","점을 선으로 접고 다른 점을 다른 선으로 접으세요","점을 선으로 접고 다른 선을 그 위에 접으세요"],ms:[null,"lipat garisan melalui dua titik","lipat dua titik bersama","lipat dua garisan bersama","lipat satu garisan di atasnya sendiri, melipat melalui satu titik","lipat satu titik ke garisan, melipat melalui titik lain","lipat satu titik ke garisan dan satu lagi titik ke garisan lain","lipat satu titik ke garisan dan satu lagi garisan di atasnya sendiri"],pt:[null,"dobre uma linha entre dois pontos","dobre os dois pontos para uni-los","dobre as duas linhas para uni-las","dobre uma linha sobre si mesma, criando uma dobra ao longo de um ponto","dobre um ponto até uma linha, criando uma dobra ao longo de outro ponto","dobre um ponto até uma linha e outro ponto até outra linha","dobre um ponto até uma linha e outra linha sobre si mesma"],ru:[null,"сложите линию через две точки","сложите две точки вместе","сложите две линии вместе","сверните линию сверху себя, сгибая через точку","сложите точку в линию, сгибая через другую точку","сложите точку в линию и другую точку в другую линию","сложите точку в линию и другую линию на себя"],tr:[null,"iki noktadan geçen bir çizgi boyunca katla","iki noktayı birbirine katla","iki çizgiyi birbirine katla","bir noktadan kıvırarak kendi üzerindeki bir çizgi boyunca katla","başka bir noktadan kıvırarak bir noktayı bir çizgiye katla","bir noktayı bir çizgiye ve başka bir noktayı başka bir çizgiye katla","bir noktayı bir çizgiye ve başka bir çizgiyi kendi üzerine katla"],vi:[null,"tạo một nếp gấp đi qua hai điểm","tạo nếp gấp bằng cách gấp một điểm này sang điểm khác","tạo nếp gấp bằng cách gấp một đường lên một đường khác","tạo một nếp gấp đi qua một điểm và đưa một đường lên trên chính nó","tạo một nếp gấp đi qua điểm đầu tiên và đưa điểm thứ hai lên đường thẳng","tạo một nếp gấp mang điểm đầu tiên đến đường đầu tiên và điểm thứ hai cho đường thứ hai","tạo một nếp gấp mang lại một điểm cho một đường và đưa một đường thứ hai lên trên chính nó"],zh:[null,"通過兩點折一條線","將兩點折疊起來","將兩條線折疊在一起","通過一個點折疊一條線在自身上面","將一個點，通過另一個點折疊成一條線，","將一個點折疊為一條線，再將另一個點折疊到另一條線","將一個點折疊成一條線，另一條線折疊到它自身上"]},instructions:{fold:{es:"doblez"},"valley fold":{es:"doblez de valle",zh:"谷摺"},"mountain fold":{es:"doblez de montaña",zh:"山摺"},"inside reverse fold":{zh:"內中割摺"},"outside reverse fold":{zh:"外中割摺"},sink:{},"open sink":{zh:"開放式沉壓摺"},"closed sink":{zh:"封閉式沉壓摺"},"rabbit ear":{zh:"兔耳摺"},"double rabbit ear":{zh:"雙兔耳摺"},"petal fold":{zh:"花瓣摺"},blintz:{zh:"坐墊基"},squash:{zh:"壓摺"},"flip over":{es:"dale la vuelta a tu papel"}}};const pairify=e=>e.map(((e,t,r)=>[e,r[(t+1)%r.length]]));var pr={objToFold:e=>{const t=e.split("\n").map((e=>e.trim().split(/\s+/))),r={vertices_coords:[],faces_vertices:[]};for(let e=0;e<t.length;e+=1)switch(t[e][0].toLowerCase()){case"f":r.faces_vertices.push(t[e].slice(1).map((e=>parseInt(e,10)-1)));break;case"v":r.vertices_coords.push(t[e].slice(1).map((e=>parseFloat(e))))}return r.faces_normal=makeFacesNormal(r),r.faces_center=makeFacesConvexCenter(r),r.edges_vertices=(({faces_vertices:e})=>{const t={},r=[];return e.flatMap(pairify).forEach((e=>{const o=[e.join(" "),`${e[1]} ${e[0]}`];o[0]in t||o[1]in t||(r.push(e),t[o[0]]=!0)})),r})(r),r.faces_edges=makeFacesEdgesFromVertices(r),r.edges_faces=makeEdgesFacesUnsorted(r),r.edges_foldAngle=makeEdgesFoldAngleFromFaces(r),r.edges_assignment=makeEdgesAssignment(r),delete r.faces_normal,delete r.faces_center,delete r.edges_faces,(e=>{e.file_spec=Ce,e.file_creator=Ne;let t="creasePattern";for(let r=0;r<e.edges_foldAngle.length;r+=1)if(0!==e.edges_foldAngle[r]&&-180!==e.edges_foldAngle[r]&&180!==e.edges_foldAngle[r]){t="foldedForm";break}e.frame_classes=[t]})(r),r}};const addClassToClassList=(e,...t)=>{if(!e)return;const r={},o=e.getAttribute("class"),s=o?o.split(" "):[];s.push(...t),s.forEach((e=>{r[e]=!0}));const n=Object.keys(r).join(" ");e.setAttribute("class",n)},gr={},mr={stroke:_},hr={},vr={M:{stroke:"red"},m:{stroke:"red"},V:{stroke:"blue"},v:{stroke:"blue"},F:{stroke:"lightgray"},f:{stroke:"lightgray"}},edgesPathData=e=>(({vertices_coords:e,edges_vertices:t})=>e&&t?t.map((t=>t.map((t=>e[t])))):[])(e).map((e=>{return`M${(t=e)[0][0]} ${t[0][1]}L${t[1][0]} ${t[1][1]}`;var t})).join(""),edgesPathDataAssign=({vertices_coords:e,edges_vertices:t,edges_assignment:r})=>{if(!e||!t)return{};if(!r)return{u:edgesPathData({vertices_coords:e,edges_vertices:t})};const o=(e=>{const t={u:[],f:[],v:[],m:[],b:[]},r=e[u].map((e=>e.toLowerCase()));return e.edges_vertices.map(((e,t)=>r[t]||"u")).forEach(((e,r)=>t[e].push(r))),t})({vertices_coords:e,edges_vertices:t,edges_assignment:r});return Object.keys(o).forEach((r=>{o[r]=edgesPathData({vertices_coords:e,edges_vertices:o[r].map((e=>t[e]))})})),Object.keys(o).forEach((e=>{""===o[e]&&delete o[e]})),o},applyEdgesStyle=(e,t={})=>Object.keys(t).forEach((r=>e.setAttributeNS(null,r,t[r]))),edgesPaths=(e,t={})=>{const r=k.svg.g();if(!e)return r;const o=isFoldedForm(e),s=(({vertices_coords:e,edges_vertices:t,edges_assignment:r})=>{const o=edgesPathDataAssign({vertices_coords:e,edges_vertices:t,edges_assignment:r});return Object.keys(o).forEach((e=>{const t=k.svg.path(o[e]);addClassToClassList(t,Te[e]),o[e]=t})),o})(e);return Object.keys(s).forEach((e=>{addClassToClassList(s[e],Te[e]),applyEdgesStyle(s[e],o?hr[e]:vr[e]),applyEdgesStyle(s[e],t[e]),applyEdgesStyle(s[e],t[Te[e]]),r.appendChild(s[e]),Object.defineProperty(r,Te[e],{get:()=>s[e]})})),applyEdgesStyle(r,o?gr:mr),applyEdgesStyle(r,t.stroke?{stroke:t.stroke}:{}),r},edgesLines=(e,t={})=>{const r=k.svg.g();if(!e)return r;const o=isFoldedForm(e),s=(e.edges_assignment?e.edges_assignment:makeEdgesAssignment(e)).map((e=>e.toLowerCase())),n={};["b","m","v","f","u"].forEach((e=>{const s=k.svg.g();r.appendChild(s),addClassToClassList(s,Te[e]),applyEdgesStyle(s,o?hr[e]:vr[e]),applyEdgesStyle(s,t[Te[e]]),Object.defineProperty(r,Te[e],{get:()=>s}),n[e]=s}));const c=e.edges_vertices.map((t=>t.map((t=>e.vertices_coords[t])))).map((e=>k.svg.line(e[0][0],e[0][1],e[1][0],e[1][1])));return e.edges_foldAngle&&c.forEach(((t,r)=>{const o=e.edges_foldAngle[r];var s;0!==o&&180!==o&&-180!==o&&t.setAttributeNS(null,"opacity",(s=o,Math.abs(s)/180))})),c.forEach(((e,t)=>n[s[t]].appendChild(e))),applyEdgesStyle(r,o?gr:mr),applyEdgesStyle(r,t.stroke?{stroke:t.stroke}:{}),r},_r={back:{fill:y},front:{fill:"#ddd"}},yr={back:{opacity:.1},front:{opacity:.1}},br={},Er={stroke:_,"stroke-linejoin":"bevel"},xr={stroke:b,fill:_,"stroke-linejoin":"bevel"},Or={fill:b},applyFacesStyle=(e,t={})=>Object.keys(t).forEach((r=>e.setAttributeNS(null,r,t[r]))),finalize_faces=(e,t,r,o)=>{const s=isFoldedForm(e),n=null!=e.faces_layer,c=[[m],[h]],i=makeFacesWinding(e);i.map((e=>e?c[0]:c[1])).forEach(((e,r)=>{addClassToClassList(t[r],e),applyFacesStyle(t[r],s?n?_r[e]:yr[e]:br[e]),applyFacesStyle(t[r],o[e])}));return(n?function(e,t){const r=t.faces_vertices.length||t.faces_edges.length;return Array.from(Array(r)).map(((e,t)=>t)).filter((t=>null==e[t])).concat(invertMap(e))}(e.faces_layer,e).map((e=>t[e])):t).forEach((e=>r.appendChild(e))),Object.defineProperty(r,m,{get:()=>t.filter(((e,t)=>i[t]))}),Object.defineProperty(r,h,{get:()=>t.filter(((e,t)=>!i[t]))}),applyFacesStyle(r,s?n?Er:xr:Or),r},kr={fill:b},Mr={stroke:_,fill:y},Ar={vertices:(e,t={})=>{const r=k.svg.g();return e&&e.vertices_coords?(e.vertices_coords.map((e=>k.svg.circle(e[0],e[1],.01))).forEach((e=>r.appendChild(e))),r.setAttributeNS(null,"fill",b),Object.keys(t).forEach((e=>r.setAttributeNS(null,e,t[e]))),r):r},edges:(e,t)=>edgesFoldAngleAreAllFlat(e)?edgesPaths(e,t):edgesLines(e,t),faces:(e,t)=>e&&e.faces_vertices?((e,t={})=>{const r=k.svg.g();if(!e||!e.vertices_coords||!e.faces_vertices)return r;const s=e.faces_vertices.map((t=>t.map((t=>[0,1].map((r=>e.vertices_coords[t][r])))))).map((e=>k.svg.polygon(e)));return s.forEach(((e,t)=>e.setAttributeNS(null,o,t))),r.setAttributeNS(null,"fill",y),finalize_faces(e,s,r,t)})(e,t):e&&e.faces_edges?function(e,t={}){const r=k.svg.g();if(!e||d in e==0||l in e==0||a in e==0)return r;const s=e.faces_edges.map((t=>t.map((t=>e.edges_vertices[t])).map(((e,t,r)=>{const o=r[(t+1)%r.length];return e[1]===o[0]||e[1]===o[1]?e[0]:e[1]})).map((t=>[0,1].map((r=>e.vertices_coords[t][r])))))).map((e=>k.svg.polygon(e)));return s.forEach(((e,t)=>e.setAttributeNS(null,o,t))),r.setAttributeNS(null,"fill","white"),finalize_faces(e,s,r,t)}(e,t):k.svg.g(),boundaries:(e,t={})=>{const r=k.svg.g();if(!(e&&e.vertices_coords&&e.edges_vertices&&e.edges_assignment))return r;const o=getBoundary(e).vertices.map((t=>[0,1].map((r=>e.vertices_coords[t][r]))));if(0===o.length)return r;const s=k.svg.polygon(o);return addClassToClassList(s,g),r.appendChild(s),((e,t={})=>{Object.keys(t).forEach((r=>e.setAttributeNS(null,r,t[r])))})(r,isFoldedForm(e)?kr:Mr),Object.keys(t).forEach((e=>r.setAttributeNS(null,e,t[e]))),r}},drawGroup=(e,t,r)=>{const o=!1===r?k.svg.g():Ar[e](t,r);return addClassToClassList(o,e),o},DrawGroups=(e,t={})=>[i,c,n,s].map((r=>drawGroup(r,e,t[r])));[i,c,n,s].forEach((e=>{DrawGroups[e]=function(t,r={}){return drawGroup(e,t,r[e])}}));const getBoundingRect=({vertices_coords:e})=>{if(null==e||0===e.length)return;const t=Array(2).fill(1/0),r=Array(2).fill(-1/0);e.forEach((e=>{e[0]<t[0]&&(t[0]=e[0]),e[0]>r[0]&&(r[0]=e[0]),e[1]<t[1]&&(t[1]=e[1]),e[1]>r[1]&&(r[1]=e[1])}));return Number.isNaN(t[0])||Number.isNaN(t[1])||Number.isNaN(r[0])||Number.isNaN(r[1])?void 0:[t[0],t[1],r[0]-t[0],r[1]-t[1]]},findSVGInParents=e=>"SVG"===(e.nodeName||"").toUpperCase()?e:e.parentNode?findSVGInParents(e.parentNode):void 0,applyTopLevelOptions=(e,t,r,o)=>{const s=t[3]&&t[3].childNodes.length;if(!(o.strokeWidth||o.viewBox||s))return;const n=getBoundingRect(r),c=n?Math.max(n[2],n[3]):1,i=findSVGInParents(e);if(i&&o.viewBox){const e=n?n.join(" "):"0 0 1 1";i.setAttributeNS(null,"viewBox",e)}if(i&&o.padding){const e=i.getAttribute("viewBox");if(null!=e){const t=o.padding*c,r=e.split(" ").map((e=>parseFloat(e))),s=[-t,-t,2*t,2*t].map(((e,t)=>r[t]+e)).join(" ");i.setAttributeNS(null,"viewBox",s)}}if(o.strokeWidth||o["stroke-width"]){const t=o.strokeWidth?o.strokeWidth:o["stroke-width"],s=(({vertices_coords:e,edges_vertices:t,edges_length:r})=>{if(!e||!t)return;r||(r=makeEdgesLength({vertices_coords:e,edges_vertices:t}));const o=r.slice().sort(((e,t)=>e-t));return o[Math.floor(.1*o.length)]})(r);let n;n=s?"number"==typeof t?10*s*t:10*s*.01:"number"==typeof t?c*t:.01*c,e.setAttributeNS(null,"stroke-width",n)}if(s){const e=o.vertices&&null!=o.vertices.radius?o.vertices.radius:o.radius,r="string"==typeof e?parseFloat(e):e,s="number"!=typeof r||Number.isNaN(r)?.02*c:c*r;((e,t)=>{for(let r=0;r<e.childNodes.length;r+=1)e.childNodes[r].setAttributeNS(null,"r",t)})(t[3],s)}},drawInto=(e,t,r={})=>{const o=DrawGroups(t,r);return o.filter((e=>e.childNodes.length>0)).forEach((t=>e.appendChild(t))),applyTopLevelOptions(e,o,t,r),((e,t)=>{const r=[t.file_classes||[],t.frame_classes||[]].flat();r.length&&addClassToClassList(e,...r)})(e,t),Object.keys(DrawGroups).map(((e,t)=>({key:e,i:t}))).filter((t=>null==e[t.key])).forEach((t=>Object.defineProperty(e,t.key,{get:()=>o[t.i]}))),e},FOLDtoSVG=(e,t)=>drawInto(k.svg(),e,t);Object.keys(DrawGroups).forEach((e=>{FOLDtoSVG[e]=DrawGroups[e]})),FOLDtoSVG.drawInto=drawInto,FOLDtoSVG.getViewBox=e=>{const t=getBoundingRect(e);return void 0===t?"":t.join(" ")},Object.defineProperty(FOLDtoSVG,"linker",{enumerable:!1,value:function(e){e.graph.svg=this;const t={svg:this};Object.keys(t).forEach((r=>{e.graph.prototype[r]=function(){return t[r](this,...arguments)}}))}.bind(FOLDtoSVG)});const Pr={init:()=>{}};function SVG(){return Pr.init(...arguments)}const jr="class",wr="function",Sr="undefined",$r="number",Lr="string",Cr="object",Nr="svg",zr="path",Fr="id",Ir="style",Vr="viewBox",Br="transform",Tr="points",qr="stroke",Rr="none",Dr="arrow",Ur="head",Gr="tail",Wr=typeof window!==Sr&&typeof window.document!==Sr,Zr=typeof process!==Sr&&null!=process.versions&&null!=process.versions.node,Jr=[];Jr[10]='"error 010: window" not set. if using node/deno, include package @xmldom/xmldom, set to the main export ( ear.window = xmldom; )';const Xr={window:void 0};Wr&&(Xr.window=window);const SVGWindow=()=>{if(void 0===Xr.window)throw Jr[10];return Xr.window};var Hr="http://www.w3.org/2000/svg",Yr={s:["svg"],d:["defs"],h:["desc","filter","metadata","style","script","title","view"],c:["cdata"],g:["g"],v:["circle","ellipse","line","path","polygon","polyline","rect"],t:["text"],i:["marker","symbol","clipPath","mask"],p:["linearGradient","radialGradient","pattern"],cT:["textPath","tspan"],cG:["stop"],cF:["feBlend","feColorMatrix","feComponentTransfer","feComposite","feConvolveMatrix","feDiffuseLighting","feDisplacementMap","feDistantLight","feDropShadow","feFlood","feFuncA","feFuncB","feFuncG","feFuncR","feGaussianBlur","feImage","feMerge","feMergeNode","feMorphology","feOffset","fePointLight","feSpecularLighting","feSpotLight","feTile","feTurbulence"]};const svg_add2=(e,t)=>[e[0]+t[0],e[1]+t[1]],svg_sub2=(e,t)=>[e[0]-t[0],e[1]-t[1]],svg_scale2=(e,t)=>[e[0]*t,e[1]*t],svg_magnitudeSq2=e=>e[0]**2+e[1]**2,svg_magnitude2=e=>Math.sqrt(svg_magnitudeSq2(e)),svg_distanceSq2=(e,t)=>svg_magnitudeSq2(svg_sub2(e,t)),svg_distance2=(e,t)=>Math.sqrt(svg_distanceSq2(e,t)),svg_polar_to_cart=(e,t)=>[Math.cos(e)*t,Math.sin(e)*t];var Kr=Object.freeze({__proto__:null,svg_add2:svg_add2,svg_sub2:svg_sub2,svg_scale2:svg_scale2,svg_magnitudeSq2:svg_magnitudeSq2,svg_magnitude2:svg_magnitude2,svg_distanceSq2:svg_distanceSq2,svg_distance2:svg_distance2,svg_polar_to_cart:svg_polar_to_cart});const arcPath=(e,t,r,o,s,n=!1)=>{if(null==s)return"";const c=svg_polar_to_cart(o,r),i=svg_polar_to_cart(s,r),a=[i[0]-c[0],i[1]-c[1]],l=c[0]*i[1]-c[1]*i[0],d=c[0]*i[0]+c[1]*i[1],u=Math.atan2(l,d)>0?0:1;let p=n?`M ${e},${t} l ${c[0]},${c[1]} `:`M ${e+c[0]},${t+c[1]} `;return p+=["a ",r,r,0,u,1,a[0],a[1]].join(" "),n&&(p+=" Z"),p},arcArguments=(e,t,r,o,s)=>[arcPath(e,t,r,o,s,!1)];var Qr={arc:{nodeName:zr,attributes:["d"],args:arcArguments,methods:{setArc:(e,...t)=>e.setAttribute("d",arcArguments(...t))}}};const wedgeArguments=(e,t,r,o,s)=>[arcPath(e,t,r,o,s,!0)];var eo={wedge:{nodeName:zr,args:wedgeArguments,attributes:["d"],methods:{setArc:(e,...t)=>e.setAttribute("d",wedgeArguments(...t))}}};const parabolaArguments=(e=-1,t=0,r=2,o=1)=>Array.from(Array(129)).map(((e,t)=>(t-128)/128*2+1)).map((s=>[e+(s+1)*r*.5,t+s**2*o]));var to={parabola:{nodeName:"polyline",attributes:[Tr],args:(e,t,r,o)=>[parabolaArguments(e,t,r,o).map((e=>`${e[0]},${e[1]}`)).join(" ")]}};const regularPolygonArguments=(e,t,r,o)=>{const s=[t,r];return Array.from(Array(e)).map(((t,r)=>2*Math.PI*(r/e))).map((e=>[Math.cos(e),Math.sin(e)])).map((e=>s.map(((t,r)=>t+o*e[r]))))};var ro={regularPolygon:{nodeName:"polygon",attributes:[Tr],args:(e,t=0,r=0,o=1)=>[regularPolygonArguments(e,t,r,o).map((e=>`${e[0]},${e[1]}`)).join(" ")]}};var oo={roundRect:{nodeName:zr,attributes:["d"],args:(e,t,r,o,s=0)=>{s>r/2&&(s=r/2),s>o/2&&(s=o/2);const n=r-2*s,c=o-2*s,i=`A${s} ${s} 0 0 1`;return[[`M${e+(r-n)/2},${t}`,`h${n}`,i,`${e+r},${t+(o-c)/2}`,`v${c}`,i,`${e+r-s},${t+o}`,"h"+-n,i,`${e},${t+o-s}`,"v"+-c,i,`${e+s},${t}`].join(" ")]}}},so={toCamel:e=>e.replace(/([-_][a-z])/gi,(e=>e.toUpperCase().replace("-","").replace("_",""))),toKebab:e=>e.replace(/([a-z0-9])([A-Z])/g,"$1-$2").replace(/([A-Z])([A-Z])(?=[a-z])/g,"$1-$2").toLowerCase(),capitalized:e=>e.charAt(0).toUpperCase()+e.slice(1)};const svg_is_iterable=e=>null!=e&&typeof e[Symbol.iterator]===wr,svg_semi_flatten_arrays=function(){switch(arguments.length){case void 0:case 0:return Array.from(arguments);case 1:return svg_is_iterable(arguments[0])&&typeof arguments[0]!==Lr?svg_semi_flatten_arrays(...arguments[0]):[arguments[0]];default:return Array.from(arguments).map((e=>svg_is_iterable(e)?[...svg_semi_flatten_arrays(e)]:e))}};var coordinates=(...e)=>e.filter((e=>typeof e===$r)).concat(e.filter((e=>typeof e===Cr&&null!==e)).map((e=>typeof e.x===$r?[e.x,e.y]:typeof e[0]===$r?[e[0],e[1]]:void 0)).filter((e=>void 0!==e)).reduce(((e,t)=>e.concat(t)),[]));const no=[Gr,Ur],stringifyPoint=e=>e.join(","),pointsToPath=e=>"M"+e.map((e=>e.join(","))).join("L")+"Z",setArrowheadOptions=(e,t,r)=>{"boolean"==typeof t?e.options[r].visible=t:typeof t===Cr?(Object.assign(e.options[r],t),null==t.visible&&(e.options[r].visible=!0)):null==t&&(e.options[r].visible=!0)},setArrowStyle=(e,t={},r=Ur)=>{const o=e.getElementsByClassName(`arrow-${r}`)[0];Object.keys(t).map((e=>({key:e,fn:o[so.toCamel(e)]}))).filter((e=>typeof e.fn===wr&&"class"!==e.key)).forEach((e=>e.fn(t[e.key]))),Object.keys(t).filter((e=>"class"===e)).forEach((e=>o.classList.add(t[e])))},redraw=e=>{const t=function(e){let t=[[0,1],[2,3]].map((t=>t.map((t=>e.points[t]||0)))),r=svg_sub2(t[1],t[0]),o=svg_add2(t[0],svg_scale2(r,.5));const s=svg_magnitude2(r),n=no.map((t=>e[t].visible?(1+e[t].padding)*e[t].height*2.5:0)).reduce(((e,t)=>e+t),0);if(s<n){const e=0===s?[n,0]:svg_scale2(r,n/s);t=[svg_sub2,svg_add2].map((t=>t(o,svg_scale2(e,.5)))),r=svg_sub2(t[1],t[0])}let c=[r[1],-r[0]],i=svg_add2(o,svg_scale2(c,e.bend));const a=t.map((e=>svg_sub2(i,e))),l=a.map((e=>svg_magnitude2(e))),d=a.map(((e,t)=>0===l[t]?e:svg_scale2(e,1/l[t]))),u=d.map((e=>svg_scale2(e,-1))),p=u.map((e=>[e[1],-e[0]])),g=no.map(((t,r)=>e[t].padding?e[t].padding:e.padding?e.padding:0)),m=no.map(((t,r)=>e[t].height*(e[t].visible?1:0))).map(((e,t)=>e+g[t])),h=t.map(((e,t)=>svg_add2(e,svg_scale2(d[t],m[t]))));r=svg_sub2(h[1],h[0]),c=[r[1],-r[0]],o=svg_add2(h[0],svg_scale2(r,.5)),i=svg_add2(o,svg_scale2(c,e.bend));const v=h.map(((t,r)=>svg_add2(t,svg_scale2(svg_sub2(i,t),e.pinch)))),_=no.map(((t,r)=>[svg_add2(h[r],svg_scale2(u[r],e[t].height)),svg_add2(h[r],svg_scale2(p[r],e[t].width/2)),svg_add2(h[r],svg_scale2(p[r],-e[t].width/2))]));return{line:`M${stringifyPoint(h[0])}C${stringifyPoint(v[0])},${stringifyPoint(v[1])},${stringifyPoint(h[1])}`,tail:pointsToPath(_[0]),head:pointsToPath(_[1])}}(e.options);return Object.keys(t).map((t=>({path:t,element:e.getElementsByClassName(`arrow-${t}`)[0]}))).filter((e=>e.element)).map((e=>(e.element.setAttribute("d",t[e.path]),e))).filter((t=>e.options[t.path])).forEach((t=>t.element.setAttribute("visibility",e.options[t.path].visible?"visible":"hidden"))),e},setPoints$3=(e,...t)=>(e.options.points=coordinates(...svg_semi_flatten_arrays(...t)).slice(0,4),redraw(e));var co={setPoints:setPoints$3,points:setPoints$3,bend:(e,t)=>(e.options.bend=t,redraw(e)),pinch:(e,t)=>(e.options.pinch=t,redraw(e)),padding:(e,t)=>(e.options.padding=t,redraw(e)),head:(e,t)=>(setArrowheadOptions(e,t,Ur),setArrowStyle(e,t,Ur),redraw(e)),tail:(e,t)=>(setArrowheadOptions(e,t,Gr),setArrowStyle(e,t,Gr),redraw(e)),getLine:e=>e.getElementsByClassName("arrow-line")[0],getHead:e=>e.getElementsByClassName(`arrow-${Ur}`)[0],getTail:e=>e.getElementsByClassName(`arrow-${Gr}`)[0]};const io=Object.keys({head:{visible:!1,width:8,height:10,padding:0},tail:{visible:!1,width:8,height:10,padding:0},bend:0,padding:0,pinch:.618,points:[]});var ao={arrow:{nodeName:"g",attributes:[],args:()=>[],methods:co,init:function(e,...t){e.classList.add(Dr);const r=["line",Gr,Ur].map((t=>SVG.path().addClass(`arrow-${t}`).appendTo(e)));r[0].setAttribute(Ir,"fill:none;"),r[1].setAttribute(qr,Rr),r[2].setAttribute(qr,Rr),e.options={head:{visible:!1,width:8,height:10,padding:0},tail:{visible:!1,width:8,height:10,padding:0},bend:0,padding:0,pinch:.618,points:[]},co.setPoints(e,...t);const o=((...e)=>{for(let t=0;t<e.length;t+=1){if(typeof e[t]!==Cr)continue;const r=Object.keys(e[t]);for(let o=0;o<r.length;o+=1)if(io.includes(r[o]))return e[t]}})(...t);return o&&Object.keys(o).filter((e=>co[e])).forEach((t=>co[t](e,o[t]))),e}}};const svg_flatten_arrays=function(){return svg_semi_flatten_arrays(arguments).reduce(((e,t)=>e.concat(t)),[])},makeCurvePath=(e=[],t=0,r=.5)=>{const o=[e[0]||0,e[1]||0],s=[e[2]||0,e[3]||0],n=svg_sub2(s,o),c=svg_add2(o,svg_scale2(n,.5)),i=[n[1],-n[0]],a=svg_add2(c,svg_scale2(i,t)),l=svg_add2(o,svg_scale2(svg_sub2(a,o),r)),d=svg_add2(s,svg_scale2(svg_sub2(a,s),r));return`M${o[0]},${o[1]}C${l[0]},${l[1]} ${d[0]},${d[1]} ${s[0]},${s[1]}`},getNumbersFromPathCommand=e=>e.slice(1).split(/[, ]+/).map((e=>parseFloat(e))),getCurveEndpoints=e=>{const t=(e=>e.match(/[Mm][(0-9), .-]+/).map((e=>getNumbersFromPathCommand(e))))(e).shift(),r=(e=>e.match(/[Cc][(0-9), .-]+/).map((e=>getNumbersFromPathCommand(e))))(e).shift();return[...t?[t[t.length-2],t[t.length-1]]:[0,0],...r?[r[r.length-2],r[r.length-1]]:[0,0]]},setPoints$2=(e,...t)=>{const r=coordinates(...svg_flatten_arrays(...t)).slice(0,4);return e.setAttribute("d",makeCurvePath(r,e._bend,e._pinch)),e};var lo={curve:{nodeName:zr,attributes:["d"],args:(...e)=>[makeCurvePath(coordinates(...svg_flatten_arrays(...e)))],methods:{setPoints:setPoints$2,bend:(e,t)=>(e._bend=t,setPoints$2(e,...getCurveEndpoints(e.getAttribute("d")))),pinch:(e,t)=>(e._pinch=t,setPoints$2(e,...getCurveEndpoints(e.getAttribute("d"))))}}};const fo={};Object.assign(fo,Qr,eo,to,ro,oo,ao,lo);const uo=Object.keys(fo),po=[Yr.h,Yr.p,Yr.i],go=[Yr.g,Yr.v,Yr.t,uo],mo={svg:[Yr.s,Yr.d].concat(po).concat(go),g:go,text:[Yr.cT],linearGradient:[Yr.cG],radialGradient:[Yr.cG],defs:po,filter:[Yr.cF],marker:go,symbol:go,clipPath:go,mask:go},ho=Object.create(null);Object.keys(mo).forEach((e=>{ho[e]=mo[e].reduce(((e,t)=>e.concat(t)),[])}));const viewBoxValue=function(e,t,r,o,s=0){const n=r/1-r;return[e-n-s,t-n-s,r+2*n+2*s,o+2*n+2*s].join(" ")};function viewBox$1(){const e=coordinates(...svg_flatten_arrays(arguments));return 2===e.length&&e.unshift(0,0),4===e.length?viewBoxValue(...e):void 0}const cdata=e=>(new(SVGWindow().DOMParser)).parseFromString("<root></root>","text/xml").createCDATASection(`${e}`),removeChildren=e=>{for(;e.lastChild;)e.removeChild(e.lastChild);return e},moveChildren=(e,t)=>{for(;t.childNodes.length>0;){const r=t.childNodes[0];t.removeChild(r),e.appendChild(r)}return e},assignSVG=(e,t)=>(Array.from(t.attributes).forEach((t=>e.setAttribute(t.name,t.value))),moveChildren(e,t));var vo={removeChildren:removeChildren,appendTo:(e,t)=>(null!=t&&t.appendChild(e),e),setAttributes:(e,t)=>Object.keys(t).forEach((r=>e.setAttribute(so.toKebab(r),t[r])))};const filterWhitespaceNodes=e=>{if(null===e)return e;for(let t=e.childNodes.length-1;t>=0;t-=1){const r=e.childNodes[t];3===r.nodeType&&r.data.match(/^\s*$/)&&e.removeChild(r),1===r.nodeType&&filterWhitespaceNodes(r)}return e},parse=e=>(new(SVGWindow().DOMParser)).parseFromString(e,"text/xml"),checkParseError=e=>{const t=e.getElementsByTagName("parsererror");if(t.length>0)throw new Error(t[0]);return filterWhitespaceNodes(e.documentElement)},sync=function(e){if(typeof e===Lr||e instanceof String)try{return checkParseError(parse(e))}catch(e){return e}if(null!=e.childNodes)return e},Load=e=>(e=>typeof e===Lr&&/^[\w,\s-]+\.[A-Za-z]{3}$/.test(e)&&e.length<1e4)(e)&&Wr&&typeof SVGWindow().fetch===wr?function(e){return new Promise(((t,r)=>{if(typeof e===Lr||e instanceof String)fetch(e).then((e=>e.text())).then((e=>checkParseError(parse(e)))).then((e=>e.nodeName===Nr?e:e.getElementsByTagName(Nr)[0])).then((e=>null==e?r(new Error("valid XML found, but no SVG element")):t(e))).catch((e=>r(e)));else if(e instanceof SVGWindow().Document)return asyncDone(e)}))}(e):sync(e);const save=function(e,t){if((t=Object.assign({download:!1,output:Lr,windowStyle:!1,filename:"image.svg"},t)).windowStyle){const t=SVGWindow().document.createElementNS(Hr,Ir);t.setAttribute("type","text/css"),t.innerHTML=function(){const e=[];if(SVGWindow().document.styleSheets)for(let t=0;t<SVGWindow().document.styleSheets.length;t+=1){const r=SVGWindow().document.styleSheets[t];try{const t="cssRules"in r?r.cssRules:r.rules;for(let r=0;r<t.length;r+=1){const o=t[r];"cssText"in o?e.push(o.cssText):e.push(`${o.selectorText} {\n${o.style.cssText}\n}\n`)}}catch(e){console.warn(e)}}return e.join("\n")}(),e.appendChild(t)}const r=function vkXML(e,t){const r=e.replace(/>\s{0,}</g,"><").replace(/</g,"~::~<").replace(/\s*xmlns\:/g,"~::~xmlns:").split("~::~"),o=r.length;let s=!1,n=0,c="";const i=null!=t&&"string"==typeof t?t:"\t",a=["\n"];for(let e=0;e<100;e+=1)a.push(a[e]+i);for(let e=0;e<o;e+=1)r[e].search(/<!/)>-1?(c+=a[n]+r[e],s=!0,(r[e].search(/-->/)>-1||r[e].search(/\]>/)>-1||r[e].search(/!DOCTYPE/)>-1)&&(s=!1)):r[e].search(/-->/)>-1||r[e].search(/\]>/)>-1?(c+=r[e],s=!1):/^<\w/.exec(r[e-1])&&/^<\/\w/.exec(r[e])&&/^<[\w:\-\.\,]+/.exec(r[e-1])==/^<\/[\w:\-\.\,]+/.exec(r[e])[0].replace("/","")?(c+=r[e],s||(n-=1)):r[e].search(/<\w/)>-1&&-1===r[e].search(/<\//)&&-1===r[e].search(/\/>/)?c=c+=s?r[e]:a[n++]+r[e]:r[e].search(/<\w/)>-1&&r[e].search(/<\//)>-1?c=c+=s?r[e]:a[n]+r[e]:r[e].search(/<\//)>-1?c=c+=s?r[e]:a[--n]+r[e]:r[e].search(/\/>/)>-1?c=c+=s?r[e]:a[n]+r[e]:r[e].search(/<\?/)>-1||r[e].search(/xmlns\:/)>-1||r[e].search(/xmlns\=/)>-1?c+=a[n]+r[e]:c+=r[e];return"\n"===c[0]?c.slice(1):c}((new(SVGWindow().XMLSerializer)).serializeToString(e));return t.download&&Wr&&!Zr&&function(e,t){const r=new(SVGWindow().Blob)([t],{type:"text/plain"}),o=SVGWindow().document.createElement("a");o.setAttribute("href",SVGWindow().URL.createObjectURL(r)),o.setAttribute("download",e),SVGWindow().document.body.appendChild(o),o.click(),SVGWindow().document.body.removeChild(o)}(t.filename,r),t.output===Nr?e:r},setViewBox=(e,...t)=>{const r=1===t.length&&typeof t[0]===Lr?t[0]:viewBox$1(...t);return r&&e.setAttribute(Vr,r),e},getViewBox=function(e){const t=e.getAttribute(Vr);return null==t?void 0:t.split(" ").map((e=>parseFloat(e)))},convertToViewBox=function(e,t,r){const o=e.createSVGPoint();o.x=t,o.y=r;const s=o.matrixTransform(e.getScreenCTM().inverse());return[s.x,s.y]};var _o=Object.freeze({__proto__:null,setViewBox:setViewBox,getViewBox:getViewBox,convertToViewBox:convertToViewBox});const loadSVG=(e,t)=>{const r=Load(t);if(null!=r)return typeof r.then===wr?r.then((t=>assignSVG(e,t))):assignSVG(e,r)},getFrame=function(e){const t=getViewBox(e);if(void 0!==t)return t;if(typeof e.getBoundingClientRect===wr){const t=e.getBoundingClientRect();return[t.x,t.y,t.width,t.height]}return[]},yo="svg-background-rectangle",stylesheet=function(e,t){let r=function(e){const t=e.getElementsByTagName(Ir);return 0===t.length?void 0:t[0]}(e);return null==r&&(r=this.Constructor(Ir),e.insertBefore(r,e.firstChild)),r.textContent="",r.appendChild(cdata(t)),r};var bo={clear:e=>(Array.from(e.attributes).filter((e=>"xmlns"!==e)).forEach((t=>e.removeAttribute(t.name))),removeChildren(e)),size:setViewBox,setViewBox:setViewBox,getViewBox:getViewBox,padding:function(e,t){const r=getViewBox(e);return void 0!==r&&setViewBox(e,...[-t,-t,2*t,2*t].map(((e,t)=>r[t]+e))),e},background:function(e,t){let r=Array.from(e.childNodes).filter((e=>e.getAttribute(jr)===yo)).shift();return null==r&&(r=this.Constructor("rect",null,...getFrame(e)),r.setAttribute(jr,yo),r.setAttribute(qr,Rr),e.insertBefore(r,e.firstChild)),r.setAttribute("fill",t),e},getWidth:e=>getFrame(e)[2],getHeight:e=>getFrame(e)[3],stylesheet:function(e,t){return stylesheet.call(this,e,t)},load:loadSVG,save:save};const Eo={math:{vector:(...e)=>[...e]}},xo={move:["mousemove","touchmove"],press:["mousedown","touchstart"],release:["mouseup","touchend"],leave:["mouseleave","touchcancel"]},Oo=Object.values(xo).reduce(((e,t)=>e.concat(t)),[]),defineGetter=(e,t,r)=>Object.defineProperty(e,t,{get:()=>r,enumerable:!0,configurable:!0}),assignPress=(e,t)=>{["pressX","pressY"].filter((t=>!Object.prototype.hasOwnProperty.call(e,t))).forEach(((r,o)=>defineGetter(e,r,t[o]))),Object.prototype.hasOwnProperty.call(e,"press")||defineGetter(e,"press",Eo.math.vector(...t))},TouchEvents=function(e){let t=[];const r=[];Object.keys(xo).forEach((e=>{xo[e].forEach((e=>{r[e]=[]}))}));const o={press:(e,r)=>{t=r,assignPress(e,t)},release:()=>{},leave:()=>{},move:(e,r)=>{e.buttons>0&&void 0===t[0]?t=r:0===e.buttons&&void 0!==t[0]&&(t=[]),assignPress(e,t)}};Object.keys(xo).forEach((t=>{const s=`on${so.capitalized(t)}`;Object.defineProperty(e,s,{set:s=>{null!=s?xo[t].forEach((n=>{const handlerFunc=r=>{const n=null!=r.touches?r.touches[0]:r;if(void 0!==n){const s=convertToViewBox(e,n.clientX,n.clientY).map((e=>Number.isNaN(e)?void 0:e));["x","y"].filter((e=>!Object.prototype.hasOwnProperty.call(r,e))).forEach(((e,t)=>defineGetter(r,e,s[t]))),Object.prototype.hasOwnProperty.call(r,"position")||defineGetter(r,"position",Eo.math.vector(...s)),o[t](r,s)}s(r)};e.addEventListener&&(r[n].push(handlerFunc),e.addEventListener(n,handlerFunc))})):(t=>{xo[t].forEach((t=>r[t].forEach((r=>e.removeEventListener(t,r)))))})(t)},enumerable:!0})})),Object.defineProperty(e,"off",{value:()=>((e,t)=>Oo.forEach((r=>{t[r].forEach((t=>e.removeEventListener(r,t))),t[r]=[]})))(e,r)})};var UUID=()=>Math.random().toString(36).replace(/[^a-z]+/g,"").concat("aaaaa").substr(0,5);const ko=[["cx","cy"],["x","y"]],controlPoint=function(e,t={}){const r=[0,0],o={selected:!1,svg:void 0,updatePosition:e=>e},updateSVG=()=>{o.svg&&(o.svg.parentNode||e.appendChild(o.svg),ko.filter((e=>null!=o.svg[e[0]])).forEach((e=>e.forEach(((e,t)=>{o.svg.setAttribute(e,r[t])})))))},s=new Proxy(r,{set:(e,t,r)=>(e[t]=r,updateSVG(),!0)}),setPosition=function(...e){coordinates(...svg_flatten_arrays(...e)).forEach(((e,t)=>{r[t]=e})),updateSVG(),typeof r.delegate===wr&&r.delegate.apply(r.pointsContainer,[s,r.pointsContainer])};return r.delegate=void 0,r.setPosition=setPosition,r.onMouseMove=e=>o.selected?setPosition(o.updatePosition(e)):void 0,r.onMouseUp=()=>{o.selected=!1},r.distance=e=>Math.sqrt(svg_distanceSq2(e,r)),["x","y"].forEach(((e,t)=>Object.defineProperty(r,e,{get:()=>r[t],set:e=>{r[t]=e}}))),[Nr,"updatePosition","selected"].forEach((e=>Object.defineProperty(r,e,{get:()=>o[e],set:t=>{o[e]=t}}))),Object.defineProperty(r,"remove",{value:()=>{var e;(e=o.svg)&&e.parentNode&&e.parentNode.removeChild(e),r.delegate=void 0}}),s},controls=function(e,t,r){let o,s;const n=Array.from(Array(t)).map((()=>controlPoint(e,r))),protocol=e=>typeof s===wr?s.call(n,e,o,n):void 0;n.forEach((e=>{e.delegate=protocol,e.pointsContainer=n}));e.onPress=function(e){n.length>0&&(o=n.map(((t,r)=>({i:r,d:svg_distanceSq2(t,[e.x,e.y])}))).sort(((e,t)=>e.d-t.d)).shift().i,n[o].selected=!0)},e.onMove=function(e){n.forEach((t=>t.onMouseMove(e)))},e.onRelease=function(){n.forEach((e=>e.onMouseUp())),o=void 0},Object.defineProperty(n,"selectedIndex",{get:()=>o}),Object.defineProperty(n,"selected",{get:()=>n[o]}),Object.defineProperty(n,"add",{value:t=>{n.push(controlPoint(e,t))}}),n.removeAll=()=>{for(;n.length>0;)n.pop().remove()};const c={onChange:(e,t)=>{if(s=e,!0===t){const t=n.length-1;e.call(n,n[t],t,n)}},position:e=>n.forEach(((t,r)=>t.setPosition(e.call(n,t,r,n)))),svg:e=>n.forEach(((t,r)=>{t.svg=e.call(n,t,r,n)}))};return Object.keys(c).forEach((e=>{n[e]=function(){return typeof arguments[0]===wr&&c[e](...arguments),n}})),n.parent=function(e){return null!=e&&null!=e.appendChild&&n.forEach((t=>{e.appendChild(t.svg)})),n},n},applyControlsToSVG=e=>{e.controls=(...t)=>controls.call(e,e,...t)};var Mo={svg:{args:(...e)=>[viewBox$1(coordinates(...e))].filter((e=>null!=e)),methods:bo,init:(e,...t)=>{t.filter((e=>typeof e===Lr)).forEach((t=>loadSVG(e,t))),t.filter((e=>null!=e)).filter((e=>typeof e.appendChild===wr)).forEach((t=>t.appendChild(e))),TouchEvents(e),function(e){let t;const r={};let o,s=0;const removeHandlers=()=>{SVGWindow().cancelAnimationFrame&&SVGWindow().cancelAnimationFrame(o),Object.keys(r).forEach((e=>delete r[e])),t=void 0,s=0};Object.defineProperty(e,"play",{set:e=>{if(removeHandlers(),null==e)return;const n=UUID();r[n]=c=>{t||(t=c,s=0),e({time:.001*(c-t),frame:s}),s+=1,r[n]&&(o=SVGWindow().requestAnimationFrame(r[n]))},SVGWindow().requestAnimationFrame&&(o=SVGWindow().requestAnimationFrame(r[n]))},enumerable:!0}),Object.defineProperty(e,"stop",{value:removeHandlers,enumerable:!0})}(e),applyControlsToSVG(e)}}};const loadGroup=(e,...t)=>{const r=t.map((e=>sync(e))).filter((e=>void 0!==e));return r.filter((e=>e.tagName===Nr)).forEach((t=>moveChildren(e,t))),r.filter((e=>e.tagName!==Nr)).forEach((t=>e.appendChild(t))),e};var Ao={g:{init:loadGroup,methods:{load:loadGroup}}},Po=Object.assign(Object.create(null),{svg:[Vr],line:["x1","y1","x2","y2"],rect:["x","y","width","height"],circle:["cx","cy","r"],ellipse:["cx","cy","rx","ry"],polygon:[Tr],polyline:[Tr],path:["d"],text:["x","y"],mask:[Fr],symbol:[Fr],clipPath:[Fr,"clip-rule"],marker:[Fr,"markerHeight","markerUnits","markerWidth","orient","refX","refY"],linearGradient:["x1","x2","y1","y2"],radialGradient:["cx","cy","r","fr","fx","fy"],stop:["offset","stop-color","stop-opacity"],pattern:["patternContentUnits","patternTransform","patternUnits"]});const setRadius=(e,t)=>(e.setAttribute(Po.circle[2],t),e),setOrigin=(e,t,r)=>([...coordinates(...svg_flatten_arrays(t,r)).slice(0,2)].forEach(((t,r)=>e.setAttribute(Po.circle[r],t))),e);var jo={circle:{args:(e,t,r,o)=>{const s=coordinates(...svg_flatten_arrays(e,t,r,o));switch(s.length){case 0:case 1:return[,,...s];case 2:case 3:return s;default:return((e,t,r,o)=>[e,t,svg_distance2([e,t],[r,o])])(...s)}},methods:{radius:setRadius,setRadius:setRadius,origin:setOrigin,setOrigin:setOrigin,center:setOrigin,setCenter:setOrigin,position:setOrigin,setPosition:setOrigin}}};const setRadii=(e,t,r)=>([,,t,r].forEach(((t,r)=>e.setAttribute(Po.ellipse[r],t))),e),setCenter=(e,t,r)=>([...coordinates(...svg_flatten_arrays(t,r)).slice(0,2)].forEach(((t,r)=>e.setAttribute(Po.ellipse[r],t))),e);var wo={ellipse:{args:(e,t,r,o)=>{const s=coordinates(...svg_flatten_arrays(e,t,r,o)).slice(0,4);switch(s.length){case 0:case 1:case 2:return[,,...s];default:return s}},methods:{radius:setRadii,setRadius:setRadii,origin:setCenter,setOrigin:setCenter,center:setCenter,setCenter:setCenter,position:setCenter,setPosition:setCenter}}};const Args$1=(...e)=>coordinates(...svg_semi_flatten_arrays(...e)).slice(0,4);var So={line:{args:Args$1,methods:{setPoints:(e,...t)=>(Args$1(...t).forEach(((t,r)=>e.setAttribute(Po.line[r],t))),e)}}};const $o=/[MmLlSsQqLlHhVvCcSsQqTtAaZz]/g,Lo=/-?[0-9]*\.?\d+/g,Co={m:"move",l:"line",v:"vertical",h:"horizontal",a:"ellipse",c:"curve",s:"smoothCurve",q:"quadCurve",t:"smoothQuadCurve",z:"close"};Object.keys(Co).forEach((e=>{const t=Co[e];Co[e.toUpperCase()]=t.charAt(0).toUpperCase()+t.slice(1)}));const getD=e=>{const t=e.getAttribute("d");return null==t?"":t},appendPathCommand=(e,t,...r)=>(e.setAttribute("d",`${getD(e)}${t}${svg_flatten_arrays(...r).join(" ")}`),e),getCommands=e=>function(e){const t=[];let r;for(;null!==(r=$o.exec(e));)t.push(r);return t.map((t=>({command:e[t.index],index:t.index}))).reduceRight(((t,r)=>{const o=e.substring(r.index,t.length?t[t.length-1].index:e.length);return t.concat([{command:r.command,index:r.index,chunk:o.length>0?o.substr(1,o.length-1):o}])}),[]).reverse().map((e=>{const t=e.chunk.match(Lo);return e.en=Co[e.command],e.values=t?t.map(parseFloat):[],delete e.chunk,e}))}(getD(e)),No={addCommand:appendPathCommand,appendCommand:appendPathCommand,clear:e=>(e.removeAttribute("d"),e),getCommands:getCommands,get:getCommands,getD:e=>e.getAttribute("d")};Object.keys(Co).forEach((e=>{No[Co[e]]=(t,...r)=>appendPathCommand(t,e,...r)}));var zo={path:{methods:No}};const setRectSize=(e,t,r)=>([,,t,r].forEach(((t,r)=>e.setAttribute(Po.rect[r],t))),e),setRectOrigin=(e,t,r)=>([...coordinates(...svg_flatten_arrays(t,r)).slice(0,2)].forEach(((t,r)=>e.setAttribute(Po.rect[r],t))),e),fixNegatives=function(e){return[0,1].forEach((t=>{e[2+t]<0&&(void 0===e[0+t]&&(e[0+t]=0),e[0+t]+=e[2+t],e[2+t]=-e[2+t])})),e};var Fo={rect:{args:(e,t,r,o)=>{const s=coordinates(...svg_flatten_arrays(e,t,r,o)).slice(0,4);switch(s.length){case 0:case 1:case 2:case 3:return fixNegatives([,,...s]);default:return fixNegatives(s)}},methods:{origin:setRectOrigin,setOrigin:setRectOrigin,center:setRectOrigin,setCenter:setRectOrigin,size:setRectSize,setSize:setRectSize}}},Io={style:{init:(e,t)=>{e.textContent="",e.appendChild(cdata(t))},methods:{setTextContent:(e,t)=>(e.textContent="",e.appendChild(cdata(t)),e)}}},Vo={text:{args:(e,t,r)=>coordinates(...svg_flatten_arrays(e,t,r)).slice(0,2),init:(e,t,r,o,s)=>{const n=[t,r,o,s].filter((e=>typeof e===Lr)).shift();n&&e.appendChild(SVGWindow().document.createTextNode(n))}}};const makeIDString=function(){return Array.from(arguments).filter((e=>typeof e===Lr||e instanceof String)).shift()||UUID()},maskArgs=(...e)=>[makeIDString(...e)];var Bo={mask:{args:maskArgs},clipPath:{args:maskArgs},symbol:{args:maskArgs},marker:{args:maskArgs,methods:{size:setViewBox,setViewBox:setViewBox}}};const getPoints=e=>{const t=e.getAttribute(Tr);return null==t?"":t},polyString=function(){return Array.from(Array(Math.floor(arguments.length/2))).map(((e,t)=>`${arguments[2*t+0]},${arguments[2*t+1]}`)).join(" ")},stringifyArgs=(...e)=>[polyString(...coordinates(...svg_semi_flatten_arrays(...e)))],setPoints=(e,...t)=>(e.setAttribute(Tr,stringifyArgs(...t)[0]),e),addPoint=(e,...t)=>(e.setAttribute(Tr,[getPoints(e),stringifyArgs(...t)[0]].filter((e=>""!==e)).join(" ")),e),Args=function(...e){return 1===e.length&&typeof e[0]===Lr?[e[0]]:stringifyArgs(...e)};var To={polyline:{args:Args,methods:{setPoints:setPoints,addPoint:addPoint}},polygon:{args:Args,methods:{setPoints:setPoints,addPoint:addPoint}}},qo=Object.assign({},Mo,Ao,jo,wo,So,zo,Fo,Io,Vo,Bo,To),Ro={presentation:["color","color-interpolation","cursor","direction","display","fill","fill-opacity","fill-rule","font-family","font-size","font-size-adjust","font-stretch","font-style","font-variant","font-weight","image-rendering","letter-spacing","opacity","overflow","paint-order","pointer-events","preserveAspectRatio","shape-rendering","stroke","stroke-dasharray","stroke-dashoffset","stroke-linecap","stroke-linejoin","stroke-miterlimit","stroke-opacity","stroke-width","tabindex","transform-origin","user-select","vector-effect","visibility"],animation:["accumulate","additive","attributeName","begin","by","calcMode","dur","end","from","keyPoints","keySplines","keyTimes","max","min","repeatCount","repeatDur","restart","to","values"],effects:["azimuth","baseFrequency","bias","color-interpolation-filters","diffuseConstant","divisor","edgeMode","elevation","exponent","filter","filterRes","filterUnits","flood-color","flood-opacity","in","in2","intercept","k1","k2","k3","k4","kernelMatrix","lighting-color","limitingConeAngle","mode","numOctaves","operator","order","pointsAtX","pointsAtY","pointsAtZ","preserveAlpha","primitiveUnits","radius","result","seed","specularConstant","specularExponent","stdDeviation","stitchTiles","surfaceScale","targetX","targetY","type","xChannelSelector","yChannelSelector"],text:["dx","dy","alignment-baseline","baseline-shift","dominant-baseline","lengthAdjust","method","overline-position","overline-thickness","rotate","spacing","startOffset","strikethrough-position","strikethrough-thickness","text-anchor","text-decoration","text-rendering","textLength","underline-position","underline-thickness","word-spacing","writing-mode"],gradient:["gradientTransform","gradientUnits","spreadMethod"]};Object.values(Yr).reduce(((e,t)=>e.concat(t)),[]).filter((e=>void 0===Po[e])).forEach((e=>{Po[e]=[]})),[[[Nr,"defs","g"].concat(Yr.v,Yr.t),Ro.presentation],[["filter"],Ro.effects],[Yr.cT.concat("text"),Ro.text],[Yr.cF,Ro.effects],[Yr.cG,Ro.gradient]].forEach((e=>e[0].forEach((t=>{Po[t]=Po[t].concat(e[1])}))));const getClassList=e=>{if(null==e)return[];const t=e.getAttribute(jr);return null==t?[]:t.split(" ").filter((e=>""!==e))};var Do={addClass:(e,t)=>{const r=getClassList(e).filter((e=>e!==t));r.push(t),e.setAttributeNS(null,jr,r.join(" "))},removeClass:(e,t)=>{const r=getClassList(e).filter((e=>e!==t));e.setAttributeNS(null,jr,r.join(" "))},setClass:(e,t)=>{e.setAttributeNS(null,jr,t)},setId:(e,t)=>{e.setAttributeNS(null,Fr,t)}};const getAttr=e=>{const t=e.getAttribute(Br);return null==t||""===t?void 0:t},Uo={clearTransform:e=>(e.removeAttribute(Br),e)};["translate","rotate","scale","matrix"].forEach((e=>{Uo[e]=(t,...r)=>t.setAttribute(Br,[getAttr(t),`${e}(${r.join(" ")})`].filter((e=>void 0!==e)).join(" "))}));const Go={};["clip-path","mask","symbol","marker-end","marker-mid","marker-start"].forEach((e=>{Go[so.toCamel(e)]=(t,r)=>t.setAttribute(e,function(e){if(null==e)return"";if(typeof e===Lr)return"url"===e.slice(0,3)?e:`url(#${e})`;if(null!=e.getAttribute)return`url(#${e.getAttribute(Fr)})`;return""}(r))}));const Wo={};Yr.v.push(...Object.keys(fo)),Object.keys(fo).forEach((e=>{fo[e].attributes=void 0===fo[e].attributes?[...Ro.presentation]:fo[e].attributes.concat(Ro.presentation)})),Object.assign(Wo,qo,fo),Object.keys(Yr).forEach((e=>Yr[e].filter((e=>void 0===Wo[e])).forEach((e=>{Wo[e]={}}))));const passthrough=function(){return Array.from(arguments)};Object.keys(Wo).forEach((e=>{Wo[e].nodeName||(Wo[e].nodeName=e),Wo[e].init||(Wo[e].init=passthrough),Wo[e].args||(Wo[e].args=passthrough),Wo[e].methods||(Wo[e].methods={}),Wo[e].attributes||(Wo[e].attributes=Po[e]||[])}));const assignMethods=(e,t)=>{e.forEach((e=>Object.keys(t).forEach((r=>{Wo[e].methods[r]=function(){return t[r](...arguments),arguments[0]}}))))};assignMethods(svg_flatten_arrays(Yr.t,Yr.v,Yr.g,Yr.s,Yr.p,Yr.i,Yr.h,Yr.d),Do),assignMethods(svg_flatten_arrays(Yr.t,Yr.v,Yr.g,Yr.s,Yr.p,Yr.i,Yr.h,Yr.d),vo),assignMethods(svg_flatten_arrays(Yr.v,Yr.g,Yr.s),Uo),assignMethods(svg_flatten_arrays(Yr.t,Yr.v,Yr.g),Go);const Zo={svg:{version:"1.1",xmlns:Hr},style:{type:"text/css"}},Jo={},constructor=(e,t,...r)=>{const o=SVGWindow().document.createElementNS(Hr,Wo[e].nodeName);return t&&t.appendChild(o),((e,t)=>{Zo[t]&&Object.keys(Zo[t]).forEach((r=>e.setAttribute(r,Zo[t][r])))})(o,e),Wo[e].init(o,...r),Wo[e].args(...r).forEach(((t,r)=>{null!=Wo[e].attributes[r]&&o.setAttribute(Wo[e].attributes[r],t)})),Wo[e].attributes.forEach((e=>{Object.defineProperty(o,so.toCamel(e),{value:function(){return o.setAttribute(e,...arguments),o}})})),Object.keys(Wo[e].methods).forEach((t=>Object.defineProperty(o,t,{value:function(){return Wo[e].methods[t].call(Jo,o,...arguments)}}))),ho[e]&&ho[e].forEach((e=>{const value=function(){return constructor(e,o,...arguments)};Wo[e].static&&Object.keys(Wo[e].static).forEach((t=>{value[t]=function(){return Wo[e].static[t](o,...arguments)}})),Object.defineProperty(o,e,{value:value})})),o};Jo.Constructor=constructor;const Xo={};Object.keys(Yr).forEach((e=>Yr[e].forEach((e=>{Xo[e]=(...t)=>constructor(e,null,...t)}))));const link_rabbitear_math=(e,t)=>{["segment","circle","ellipse","rect","polygon"].filter((e=>t[e]&&t[e].prototype)).forEach((r=>{t[r].prototype.svg=function(){return e.path(this.svgPath())}})),Eo.math.vector=t.vector},initialize=function(e,...t){t.filter((e=>typeof e===wr)).forEach((t=>t.call(e,e)))};Pr.init=function(){const e=constructor(Nr,null,...arguments);return"loading"===SVGWindow().document.readyState?SVGWindow().document.addEventListener("DOMContentLoaded",(()=>initialize(e,...arguments))):initialize(e,...arguments),e},SVG.NS=Hr,SVG.linker=function(e){e.graph&&e.origami&&(e.svg=this,link_rabbitear_math(this,e),((e,t)=>{const r="origami";Wo.origami={nodeName:"g",init:function(e,...r){return t.graph.svg.drawInto(e,...r)},args:()=>[],methods:Wo.g.methods,attributes:Wo.g.attributes,static:{}},Object.keys(t.graph.svg).forEach((e=>{Wo.origami.static[e]=(r,...o)=>{const s=t.graph.svg[e](...o);return r.appendChild(s),s}})),ho.origami=[...ho.g],ho.svg.push(r),ho.g.push(r),e.origami=(...e)=>constructor(r,null,...e),Object.keys(t.graph.svg).forEach((r=>{e.origami[r]=t.graph.svg[r]}))})(this,e))}.bind(SVG),Object.assign(SVG,Xo),SVG.core=Object.assign(Object.create(null),{load:Load,save:save,coordinates:coordinates,flatten:svg_flatten_arrays,attributes:Po,children:ho,cdata:cdata},so,Do,vo,Kr,Uo,_o),Object.defineProperty(SVG,"window",{enumerable:!1,set:e=>{var t;(t=e).document||(t.document=(e=>(new e.DOMParser).parseFromString("<!DOCTYPE html><title>.</title>","text/html"))(t)),Xr.window=t,Xr.window}});const compileShader=(e,t,r)=>{const o=e.createShader(r);if(e.shaderSource(o,t),e.compileShader(o),!e.getShaderParameter(o,e.COMPILE_STATUS))throw new Error(e.getShaderInfoLog(o));return o};var Ho=Object.assign(Object.create(null),{createProgram:(e,t,r)=>((e,t,r)=>{const o=e.createProgram();if(e.attachShader(o,t),e.attachShader(o,r),e.linkProgram(o),!e.getProgramParameter(o,e.LINK_STATUS))throw new Error(e.getProgramInfoLog(o));return e.deleteShader(t),e.deleteShader(r),o})(e,compileShader(e,t,e.VERTEX_SHADER),compileShader(e,r,e.FRAGMENT_SHADER)),initialize:(e,t)=>{const r=[null,"webgl","webgl2"],o=window.devicePixelRatio||1;if(e.width=e.clientWidth*o,e.height=e.clientHeight*o,t)return{gl:e.getContext(r[t]),version:t};const s=e.getContext(r[2]);if(s)return{gl:s,version:2};const n=e.getContext(r[1]);if(n)return{gl:n,version:1};throw new Error("WebGl not Supported")}});const Yo=Object.assign(k,zt,{math:$e.core,axiom:axiom,diagram:Gt,layer:lr,singleVertex:fr,text:ur,convert:pr,webgl:Ho});return Object.keys($e).filter((e=>"core"!==e)).forEach((e=>{Yo[e]=$e[e]})),Object.defineProperty(Yo,"use",{enumerable:!1,value:function(e){null!=e&&"function"==typeof e.linker&&e.linker(this)}.bind(Yo)}),x||(Yo.use(FOLDtoSVG),Yo.use(SVG)),Object.defineProperty(Yo,"window",{enumerable:!1,set:e=>{var t;(t=e).document||(t.document=(e=>(new e.DOMParser).parseFromString("<!DOCTYPE html><title>.</title>","text/html"))(t)),O.window=t,O.window,SVG.window=e}}),Yo}));
