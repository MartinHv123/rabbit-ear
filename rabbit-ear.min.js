!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e="undefined"!=typeof globalThis?globalThis:e||self).ear=t()}(this,(function(){"use strict";const e="undefined"!=typeof window&&void 0!==window.document,t="undefined"!=typeof process&&null!=process.versions&&null!=process.versions.node;var r="valid manifold required",s="cycle not allowed",o="replace() index < value. indices parameter modified",a="replace() generated undefined",n="foldAngles cannot be determined from flat-folded faces without an assignment",c="WebGl not Supported",i="only convex faces are supported",l="window not set; if using node/deno include package @xmldom/xmldom and set ear.window = xmldom",d="non-convex triangulation requires vertices_coords",m="svgToFold found <style> in <svg>. rendering will be incomplete unless run in a major browser.",g="LayerSolver bad input. no solution possible";const p={window:void 0};e&&(p.window=window);const RabbitEarWindow=()=>{if(void 0===p.window)throw new Error(l);return p.window},v=1e-6,_=180/Math.PI,u=Math.PI/180,h=2*Math.PI;var b=Object.freeze({__proto__:null,D2R:u,EPSILON:v,R2D:_,TWO_PI:h});const safeAdd=(e,t)=>e+(t||0),magnitude=e=>Math.sqrt(e.map((e=>e*e)).reduce(safeAdd,0)),magnitude2=e=>Math.sqrt(e[0]*e[0]+e[1]*e[1]),magnitude3=e=>Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]),magSquared=e=>e.map((e=>e*e)).reduce(safeAdd,0),normalize=e=>{const t=magnitude(e);return 0===t?e:e.map((e=>e/t))},normalize2=e=>{const t=magnitude2(e);return 0===t?e:[e[0]/t,e[1]/t]},normalize3=e=>{const t=magnitude3(e);return 0===t?e:[e[0]/t,e[1]/t,e[2]/t]},scale$1=(e,t)=>e.map((e=>e*t)),scale2=(e,t)=>[e[0]*t,e[1]*t],scale3=(e,t)=>[e[0]*t,e[1]*t,e[2]*t],add=(e,t)=>e.map(((e,r)=>e+(t[r]||0))),add2=(e,t)=>[e[0]+t[0],e[1]+t[1]],add3=(e,t)=>[e[0]+t[0],e[1]+t[1],e[2]+t[2]],subtract=(e,t)=>e.map(((e,r)=>e-(t[r]||0))),subtract2=(e,t)=>[e[0]-t[0],e[1]-t[1]],subtract3=(e,t)=>[e[0]-t[0],e[1]-t[1],e[2]-t[2]],dot=(e,t)=>e.map(((r,s)=>e[s]*t[s])).reduce(safeAdd,0),dot2=(e,t)=>e[0]*t[0]+e[1]*t[1],dot3=(e,t)=>e[0]*t[0]+e[1]*t[1]+e[2]*t[2],midpoint=(e,t)=>e.map(((e,r)=>(e+t[r])/2)),midpoint2=(e,t)=>scale2(add2(e,t),.5),average=function(){if(0===arguments.length)return;const e=arguments[0].length>0?arguments[0].length:0,t=Array(e).fill(0);return Array.from(arguments).forEach((e=>t.forEach(((r,s)=>{t[s]+=e[s]||0})))),t.map((e=>e/arguments.length))},average2=(...e)=>{if(!e||!e.length)return;const t=1/e.length;return e.reduce(((e,t)=>add2(e,t)),[0,0]).map((e=>e*t))},lerp=(e,t,r)=>{const s=1-r;return e.map(((e,o)=>e*s+(t[o]||0)*r))},cross2=(e,t)=>e[0]*t[1]-e[1]*t[0],cross3=(e,t)=>[e[1]*t[2]-e[2]*t[1],e[2]*t[0]-e[0]*t[2],e[0]*t[1]-e[1]*t[0]],distance=(e,t)=>Math.sqrt(e.map(((r,s)=>(e[s]-t[s])**2)).reduce(safeAdd,0)),distance2=(e,t)=>{const r=e[0]-t[0],s=e[1]-t[1];return Math.sqrt(r*r+s*s)},distance3=(e,t)=>{const r=e[0]-t[0],s=e[1]-t[1],o=e[2]-t[2];return Math.sqrt(r*r+s*s+o*o)},flip=e=>e.map((e=>-e)),rotate90=e=>[-e[1],e[0]],rotate270=e=>[e[1],-e[0]],parallelNormalized=(e,t,r=v)=>1-Math.abs(dot(e,t))<r,parallel=(e,t,r=v)=>parallelNormalized(normalize(e),normalize(t),r),resize=(e,t)=>t.length===e?t:Array(e).fill(0).map(((e,r)=>t[r]?t[r]:e)),resizeUp=(e,t)=>[e,t].map((r=>resize(Math.max(e.length,t.length),r))),basisVectors2=(e=[1,0])=>{const t=normalize2(e);return[t,rotate90(t)]},basisVectors3=(e=[1,0,0])=>{const t=normalize3(e),r=[[1,0,0],[0,1,0],[0,0,1]].map((e=>cross3(e,t))),s=r.map(magnitude3).map(((e,t)=>({n:e,i:t}))).sort(((e,t)=>t.n-e.n)).map((e=>e.i)).shift(),o=normalize3(r[s]);return[t,o,cross3(t,o)]};var y=Object.freeze({__proto__:null,add:add,add2:add2,add3:add3,average:average,average2:average2,basisVectors:e=>2===e.length?basisVectors2(e):basisVectors3(e),basisVectors2:basisVectors2,basisVectors3:basisVectors3,cross2:cross2,cross3:cross3,degenerate:(e,t=v)=>e.map((e=>Math.abs(e))).reduce(safeAdd,0)<t,distance:distance,distance2:distance2,distance3:distance3,dot:dot,dot2:dot2,dot3:dot3,flip:flip,lerp:lerp,magSquared:magSquared,magnitude:magnitude,magnitude2:magnitude2,magnitude3:magnitude3,midpoint:midpoint,midpoint2:midpoint2,midpoint3:(e,t)=>scale3(add3(e,t),.5),normalize:normalize,normalize2:normalize2,normalize3:normalize3,parallel:parallel,parallel2:(e,t,r=v)=>Math.abs(cross2(e,t))<r,parallelNormalized:parallelNormalized,resize:resize,resizeUp:resizeUp,rotate270:rotate270,rotate90:rotate90,scale:scale$1,scale2:scale2,scale3:scale3,subtract:subtract,subtract2:subtract2,subtract3:subtract3});const E=[1,0,0,1],A=E.concat(0,0),multiplyMatrix2Vector2=(e,t)=>[e[0]*t[0]+e[2]*t[1]+e[4],e[1]*t[0]+e[3]*t[1]+e[5]],multiplyMatrix2Line2=(e,t,r)=>({vector:[e[0]*t[0]+e[2]*t[1],e[1]*t[0]+e[3]*t[1]],origin:[e[0]*r[0]+e[2]*r[1]+e[4],e[1]*r[0]+e[3]*r[1]+e[5]]}),multiplyMatrices2=(e,t)=>[e[0]*t[0]+e[2]*t[1],e[1]*t[0]+e[3]*t[1],e[0]*t[2]+e[2]*t[3],e[1]*t[2]+e[3]*t[3],e[0]*t[4]+e[2]*t[5]+e[4],e[1]*t[4]+e[3]*t[5]+e[5]],determinant2=e=>e[0]*e[3]-e[1]*e[2],invertMatrix2=e=>{const t=determinant2(e);if(!(Math.abs(t)<1e-12||Number.isNaN(t))&&Number.isFinite(e[4])&&Number.isFinite(e[5]))return[e[3]/t,-e[1]/t,-e[2]/t,e[0]/t,(e[2]*e[5]-e[3]*e[4])/t,(e[1]*e[4]-e[0]*e[5])/t]},makeMatrix2Scale=(e=[1,1],t=[0,0])=>[e[0],0,0,e[1],e[0]*-t[0]+t[0],e[1]*-t[1]+t[1]],makeMatrix2Reflect=(e,t=[0,0])=>{const r=Math.atan2(e[1],e[0]),s=Math.cos(r),o=Math.sin(r),a=Math.cos(-r),n=Math.sin(-r),c=s*a+o*n,i=s*-n+o*a,l=o*a+-s*n,d=o*-n+-s*a;return[c,i,l,d,t[0]+c*-t[0]+-t[1]*l,t[1]+i*-t[0]+-t[1]*d]};var x=Object.freeze({__proto__:null,determinant2:determinant2,identity2x2:E,identity2x3:A,invertMatrix2:invertMatrix2,makeMatrix2Reflect:makeMatrix2Reflect,makeMatrix2Rotate:(e,t=[0,0])=>{const r=Math.cos(e),s=Math.sin(e);return[r,s,-s,r,t[0],t[1]]},makeMatrix2Scale:makeMatrix2Scale,makeMatrix2Translate:(e=0,t=0)=>E.concat(e,t),makeMatrix2UniformScale:(e=1,t=[0,0])=>makeMatrix2Scale([e,e],t),multiplyMatrices2:multiplyMatrices2,multiplyMatrix2Line2:multiplyMatrix2Line2,multiplyMatrix2Vector2:multiplyMatrix2Vector2});const M=Object.freeze([1,0,0,0,1,0,0,0,1]),O=Object.freeze(M.concat(0,0,0)),multiplyMatrix3Vector3=(e,t)=>[e[0]*t[0]+e[3]*t[1]+e[6]*t[2]+e[9],e[1]*t[0]+e[4]*t[1]+e[7]*t[2]+e[10],e[2]*t[0]+e[5]*t[1]+e[8]*t[2]+e[11]],multiplyMatrices3=(e,t)=>[e[0]*t[0]+e[3]*t[1]+e[6]*t[2],e[1]*t[0]+e[4]*t[1]+e[7]*t[2],e[2]*t[0]+e[5]*t[1]+e[8]*t[2],e[0]*t[3]+e[3]*t[4]+e[6]*t[5],e[1]*t[3]+e[4]*t[4]+e[7]*t[5],e[2]*t[3]+e[5]*t[4]+e[8]*t[5],e[0]*t[6]+e[3]*t[7]+e[6]*t[8],e[1]*t[6]+e[4]*t[7]+e[7]*t[8],e[2]*t[6]+e[5]*t[7]+e[8]*t[8],e[0]*t[9]+e[3]*t[10]+e[6]*t[11]+e[9],e[1]*t[9]+e[4]*t[10]+e[7]*t[11]+e[10],e[2]*t[9]+e[5]*t[10]+e[8]*t[11]+e[11]],determinant3=e=>e[0]*e[4]*e[8]-e[0]*e[7]*e[5]-e[3]*e[1]*e[8]+e[3]*e[7]*e[2]+e[6]*e[1]*e[5]-e[6]*e[4]*e[2],makeMatrix3Translate=(e=0,t=0,r=0)=>M.concat(e,t,r),singleAxisRotate=(e,t,r,s,o)=>{const a=Math.cos(e),n=Math.sin(e),c=M.concat([0,0,0]);c[3*r+r]=a,c[3*r+s]=(o?1:-1)*n,c[3*s+r]=(o?-1:1)*n,c[3*s+s]=a;const i=[0,1,2].map((e=>t[e]||0)),l=M.concat(flip(i)),d=M.concat(i);return multiplyMatrices3(d,multiplyMatrices3(c,l))},makeMatrix3RotateZ=(e,t=[0,0,0])=>singleAxisRotate(e,t,0,1,!0),makeMatrix3Rotate=(e,t=[0,0,1],r=[0,0,0])=>{const s=[0,1,2].map((e=>r[e]||0)),[o,a,n]=resize(3,normalize(t)),c=Math.cos(e),i=Math.sin(e),l=1-c,d=M.concat(-s[0],-s[1],-s[2]),m=M.concat(s[0],s[1],s[2]);return multiplyMatrices3(m,multiplyMatrices3([l*o*o+c,l*a*o+n*i,l*n*o-a*i,l*o*a-n*i,l*a*a+c,l*n*a+o*i,l*o*n+a*i,l*a*n-o*i,l*n*n+c,0,0,0],d))},makeMatrix3Scale=(e=[1,1,1],t=[0,0,0])=>[e[0],0,0,0,e[1],0,0,0,e[2],e[0]*-t[0]+t[0],e[1]*-t[1]+t[1],e[2]*-t[2]+t[2]];var w=Object.freeze({__proto__:null,determinant3:determinant3,identity3x3:M,identity3x4:O,invertMatrix3:e=>{const t=determinant3(e);if(Math.abs(t)<1e-12||Number.isNaN(t)||!Number.isFinite(e[9])||!Number.isFinite(e[10])||!Number.isFinite(e[11]))return;const r=[e[4]*e[8]-e[7]*e[5],-e[1]*e[8]+e[7]*e[2],e[1]*e[5]-e[4]*e[2],-e[3]*e[8]+e[6]*e[5],e[0]*e[8]-e[6]*e[2],-e[0]*e[5]+e[3]*e[2],e[3]*e[7]-e[6]*e[4],-e[0]*e[7]+e[6]*e[1],e[0]*e[4]-e[3]*e[1],-e[3]*e[7]*e[11]+e[3]*e[8]*e[10]+e[6]*e[4]*e[11]-e[6]*e[5]*e[10]-e[9]*e[4]*e[8]+e[9]*e[5]*e[7],e[0]*e[7]*e[11]-e[0]*e[8]*e[10]-e[6]*e[1]*e[11]+e[6]*e[2]*e[10]+e[9]*e[1]*e[8]-e[9]*e[2]*e[7],-e[0]*e[4]*e[11]+e[0]*e[5]*e[10]+e[3]*e[1]*e[11]-e[3]*e[2]*e[10]-e[9]*e[1]*e[5]+e[9]*e[2]*e[4]],s=1/t;return r.map((e=>e*s))},isIdentity3x4:e=>O.map(((t,r)=>Math.abs(t-e[r])<v)).reduce(((e,t)=>e&&t),!0),makeMatrix3ReflectZ:(e,t=[0,0])=>{const r=makeMatrix2Reflect(e,t);return[r[0],r[1],0,r[2],r[3],0,0,0,1,r[4],r[5],0]},makeMatrix3Rotate:makeMatrix3Rotate,makeMatrix3RotateX:(e,t=[0,0,0])=>singleAxisRotate(e,t,1,2,!0),makeMatrix3RotateY:(e,t=[0,0,0])=>singleAxisRotate(e,t,0,2,!1),makeMatrix3RotateZ:makeMatrix3RotateZ,makeMatrix3Scale:makeMatrix3Scale,makeMatrix3Translate:makeMatrix3Translate,makeMatrix3UniformScale:(e=1,t=[0,0,0])=>makeMatrix3Scale([e,e,e],t),multiplyMatrices3:multiplyMatrices3,multiplyMatrix3Line3:(e,t,r)=>({vector:[e[0]*t[0]+e[3]*t[1]+e[6]*t[2],e[1]*t[0]+e[4]*t[1]+e[7]*t[2],e[2]*t[0]+e[5]*t[1]+e[8]*t[2]],origin:[e[0]*r[0]+e[3]*r[1]+e[6]*r[2]+e[9],e[1]*r[0]+e[4]*r[1]+e[7]*r[2]+e[10],e[2]*r[0]+e[5]*r[1]+e[8]*r[2]+e[11]]}),multiplyMatrix3Vector3:multiplyMatrix3Vector3});const isIterable=e=>null!=e&&"function"==typeof e[Symbol.iterator],semiFlattenArrays=function(){switch(arguments.length){case 0:return Array.from(arguments);case 1:return isIterable(arguments[0])&&"string"!=typeof arguments[0]?semiFlattenArrays(...arguments[0]):[arguments[0]];default:return Array.from(arguments).map((e=>isIterable(e)?[...semiFlattenArrays(e)]:e))}},flattenArrays=function(){switch(arguments.length){case 0:return Array.from(arguments);case 1:return isIterable(arguments[0])&&"string"!=typeof arguments[0]?flattenArrays(...arguments[0]):[arguments[0]];default:return Array.from(arguments).map((e=>isIterable(e)?[...flattenArrays(e)]:e)).flat()}};var j=Object.freeze({__proto__:null,flattenArrays:flattenArrays,semiFlattenArrays:semiFlattenArrays});const getVector=function(){let e=flattenArrays(arguments);const t=e[0];return"object"!=typeof t||null===t||Number.isNaN(t.x)||(e=["x","y","z"].map((e=>t[e])).filter((e=>void 0!==e))),e.filter((e=>"number"==typeof e))},getArrayOfVectors=function(){return semiFlattenArrays(arguments).map((e=>getVector(e)))},getSegment=function(){const e=semiFlattenArrays(arguments);return 4===e.length?[[0,1],[2,3]].map((t=>t.map((t=>e[t])))):e.map((e=>getVector(e)))},vectorOriginForm=(e,t=[])=>({vector:e,origin:t}),getLine$1=function(){const e=semiFlattenArrays(arguments);return 0===e.length||null==e[0]?vectorOriginForm([],[]):e[0].constructor===Object&&void 0!==e[0].vector?vectorOriginForm(e[0].vector,e[0].origin||[]):"number"==typeof e[0]?vectorOriginForm(getVector(e)):vectorOriginForm(...e.map((e=>getVector(e))))};var F=Object.freeze({__proto__:null,getArrayOfVectors:getArrayOfVectors,getLine:getLine$1,getSegment:getSegment,getVector:getVector});const angleArray=e=>Array.from(Array(Math.floor(e))).map(((t,r)=>h*(r/e))),anglesToVecs=(e,t)=>e.map((e=>[t*Math.cos(e),t*Math.sin(e)])),makePolygonCircumradius=(e=3,t=1)=>anglesToVecs(angleArray(e),t),makePolygonCircumradiusSide=(e=3,t=1)=>{const r=Math.PI/e,s=angleArray(e).map((e=>e+r));return anglesToVecs(s,t)},makePolygonNonCollinear=(e,t=v)=>{const r=e.map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>subtract(e[1],e[0]))).map(((e,t,r)=>[e,r[(t+r.length-1)%r.length]])).map((e=>!parallel(e[1],e[0],t)));return e.filter(((e,t)=>r[t]))},signedArea=e=>.5*e.map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>cross2(...e))).reduce(((e,t)=>e+t),0),centroid=e=>{const t=1/(6*signedArea(e));return e.map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>scale2(add2(...e),cross2(...e)))).reduce(((e,t)=>add2(e,t)),[0,0]).map((e=>e*t))},boundingBox$1=(e,t=0)=>{if(!e||!e.length)return;const r=Array(e[0].length).fill(1/0),s=Array(e[0].length).fill(-1/0);e.forEach((e=>e.forEach(((e,o)=>{e<r[o]&&(r[o]=e-t),e>s[o]&&(s[o]=e+t)}))));const o=s.map(((e,t)=>e-r[t]));return{min:r,max:s,span:o}};var C=Object.freeze({__proto__:null,boundingBox:boundingBox$1,centroid:centroid,circumcircle:(e,t,r)=>{const s=t[0]-e[0],o=t[1]-e[1],a=r[0]-e[0],n=r[1]-e[1],c=s*(e[0]+t[0])+o*(e[1]+t[1]),i=a*(e[0]+r[0])+n*(e[1]+r[1]),l=2*(s*(r[1]-t[1])-o*(r[0]-t[0]));if(Math.abs(l)<v){const s=Math.min(e[0],t[0],r[0]),o=Math.min(e[1],t[1],r[1]),a=.5*(Math.max(e[0],t[0],r[0])-s),n=.5*(Math.max(e[1],t[1],r[1])-o);return{origin:[s+a,o+n],radius:Math.sqrt(a*a+n*n)}}const d=[(n*c-o*i)/l,(s*i-a*c)/l],m=d[0]-e[0],g=d[1]-e[1];return{origin:d,radius:Math.sqrt(m*m+g*g)}},makePolygonCircumradius:makePolygonCircumradius,makePolygonCircumradiusSide:makePolygonCircumradiusSide,makePolygonInradius:(e=3,t=1)=>makePolygonCircumradius(e,t/Math.cos(Math.PI/e)),makePolygonInradiusSide:(e=3,t=1)=>makePolygonCircumradiusSide(e,t/Math.cos(Math.PI/e)),makePolygonNonCollinear:makePolygonNonCollinear,makePolygonSideLength:(e=3,t=1)=>makePolygonCircumradius(e,t/2/Math.sin(Math.PI/e)),makePolygonSideLengthSide:(e=3,t=1)=>makePolygonCircumradiusSide(e,t/2/Math.sin(Math.PI/e)),signedArea:signedArea});const epsilonEqual=(e,t,r=v)=>Math.abs(e-t)<r,epsilonCompare=(e,t,r=v)=>epsilonEqual(e,t,r)?0:Math.sign(t-e),epsilonEqualVectors=(e,t,r=v)=>{for(let s=0;s<Math.max(e.length,t.length);s+=1)if(!epsilonEqual(e[s]||0,t[s]||0,r))return!1;return!0},include=(e,t=v)=>e>-t,exclude=(e,t=v)=>e>t,includeL=()=>!0,excludeL=()=>!0,S=include,P=exclude,includeS=(e,t=v)=>e>-t&&e<1+t,excludeS=(e,t=v)=>e>t&&e<1-t,clampLine=e=>e,clampSegment=e=>e<-v?0:e>1.000001?1:e;var V=Object.freeze({__proto__:null,clampLine:clampLine,clampRay:e=>e<-v?0:e,clampSegment:clampSegment,epsilonCompare:epsilonCompare,epsilonEqual:epsilonEqual,epsilonEqualVectors:epsilonEqualVectors,exclude:exclude,excludeL:excludeL,excludeR:P,excludeS:excludeS,include:include,includeL:includeL,includeR:S,includeS:includeS});const N={file:["file_spec","file_creator","file_author","file_title","file_description","file_classes","file_frames"],frame:["frame_author","frame_title","frame_description","frame_attributes","frame_classes","frame_unit","frame_parent","frame_inherit"],graph:["vertices_coords","vertices_vertices","vertices_faces","edges_vertices","edges_faces","edges_assignment","edges_foldAngle","edges_length","faces_vertices","faces_edges","vertices_edges","edges_edges","faces_faces"],orders:["edgeOrders","faceOrders"]};var z=Object.freeze({__proto__:null,foldFileClasses:["singleModel","multiModel","animation","diagrams"],foldFrameAttributes:["2D","3D","abstract","manifold","nonManifold","orientable","nonOrientable","selfTouching","nonSelfTouching","selfIntersecting","nonSelfIntersecting"],foldFrameClasses:["creasePattern","foldedForm","graph","linkage"],foldKeys:N});const T={vertices:"vertex",edges:"edge",faces:"face"},$=Array.from("BbMmVvFfJjCcUu"),B={b:"boundary",m:"mountain",v:"valley",f:"flat",j:"join",c:"cut",u:"unassigned"};Object.keys(B).forEach((e=>{B[e.toUpperCase()]=B[e]}));const L={B:0,b:0,M:-180,m:-180,V:180,v:180,F:0,f:0,J:0,j:0,C:0,c:0,U:0,u:0},I={B:!1,b:!1,M:!0,m:!0,V:!0,v:!0,F:!1,f:!1,J:!1,j:!1,C:!1,c:!1,U:!0,u:!0},U={B:!0,b:!0,M:!1,m:!1,V:!1,v:!1,F:!1,f:!1,J:!1,j:!1,C:!0,c:!0,U:!1,u:!1},edgeAssignmentToFoldAngle=e=>L[e]||0,edgeFoldAngleToAssignment=e=>e>v?"V":e<-v?"M":"U",edgeFoldAngleIsFlat=e=>epsilonEqual(0,e)||epsilonEqual(-180,e)||epsilonEqual(180,e),edgesFoldAngleAreAllFlat=({edges_foldAngle:e})=>{if(!e)return!0;for(let t=0;t<e.length;t+=1)if(!edgeFoldAngleIsFlat(e[t]))return!1;return!0},filterKeys=(e,t)=>Object.keys(e).filter((e=>t(e))),filterKeysWithPrefix=(e,t)=>filterKeys(e,(e=>e.substring(0,t.length+1)===`${t}_`)),filterKeysWithSuffix=(e,t)=>filterKeys(e,(e=>e.substring(e.length-t.length-1,e.length)===`_${t}`)),R=Object.freeze([].concat(N.file).concat(N.frame).concat(N.graph).concat(N.orders)),isFoldedForm=({frame_classes:e,file_classes:t})=>e&&e.includes("foldedForm")||t&&t.includes("foldedForm"),getDimension=({vertices_coords:e})=>{if(void 0!==e[0])return e[0].length;const t=e.filter((()=>!0)).shift();return t?t.length:void 0},makeEdgesIsFolded=({edges_vertices:e,edges_foldAngle:t,edges_assignment:r})=>void 0===r?void 0===t?e.map((()=>!0)):t.map((e=>e<-v||e>v)):r.map((e=>I[e])),q={M:"V",m:"v",V:"M",v:"m"},invertAssignment=e=>q[e]||e,invertAssignments=e=>(e.edges_assignment&&(e.edges_assignment=e.edges_assignment.map((e=>q[e]?q[e]:e))),e.edges_foldAngle&&(e.edges_foldAngle=e.edges_foldAngle.map((e=>-e))),e);var D=Object.freeze({__proto__:null,assignmentCanBeFolded:I,assignmentFlatFoldAngle:L,assignmentIsBoundary:U,edgeAssignmentToFoldAngle:edgeAssignmentToFoldAngle,edgeFoldAngleIsFlat:edgeFoldAngleIsFlat,edgeFoldAngleToAssignment:edgeFoldAngleToAssignment,edgesAssignmentNames:B,edgesAssignmentValues:$,edgesFoldAngleAreAllFlat:edgesFoldAngleAreAllFlat,filterKeysWithPrefix:filterKeysWithPrefix,filterKeysWithSuffix:filterKeysWithSuffix,getDimension:getDimension,getFileMetadata:(e={})=>{const t={};return N.file.filter((e=>"file_frames"!==e)).filter((t=>void 0!==e[t])).forEach((r=>{t[r]=e[r]})),t},invertAssignment:invertAssignment,invertAssignments:invertAssignments,isFoldObject:(e={})=>0===Object.keys(e).length?0:R.filter((t=>e[t])).length/Object.keys(e).length,isFoldedForm:isFoldedForm,makeEdgesIsFolded:makeEdgesIsFolded,pluralize:{vertex:"vertices",edge:"edges",face:"faces"},singularize:T,transposeGraphArrayAtIndex:(e,t,r)=>{const s=filterKeysWithPrefix(e,t);if(0===s.length)return;const o={};return s.forEach((t=>{o[t]=e[t][r]})),o},transposeGraphArrays:(e,t)=>{const r=filterKeysWithPrefix(e,t);if(0===r.length)return[];const s=Math.max(...r.map((t=>e[t].length))),o=Array.from(Array(s)).map((()=>({})));return r.forEach((t=>o.forEach(((r,s)=>{o[s][t]=e[t][s]})))),o}});const transform=function(e,t){return filterKeysWithSuffix(e,"coords").forEach((r=>{e[r]=e[r].map((e=>resize(3,e))).map((e=>multiplyMatrix3Vector3(t,e)))})),filterKeysWithSuffix(e,"matrix").forEach((r=>{e[r]=e[r].map((e=>multiplyMatrices3(e,t)))})),e};var W=Object.freeze({__proto__:null,rotate:(e,t,r,s)=>transform(e,makeMatrix3Rotate(t,r,s)),rotateZ:(e,t,...r)=>{const s=getVector(...r),o=resize(3,s),a=makeMatrix3RotateZ(t,o);return transform(e,a)},scale:(e,...t)=>{const r=t.flat(),s=1===r.length?[r[0],r[0],r[0]]:[1,1,1].map(((e,t)=>void 0===r[t]?e:r[t])),o=makeMatrix3Scale(s);return transform(e,o)},transform:transform,translate:(e,...t)=>{const r=getVector(...t),s=resize(3,r),o=makeMatrix3Translate(...s);return transform(e,o)},unitize:function(e){if(!e.vertices_coords)return e;const t=boundingBox$1(e.vertices_coords),r=Math.max(...t.span),s=0===r?1:1/r,o=t.min;return e.vertices_coords=e.vertices_coords.map((e=>subtract(e,o))).map((e=>e.map((e=>e*s)))),e}});const getVerticesClusters=({vertices_coords:e},t=v)=>{if(!e)return[];const r=getDimension({vertices_coords:e}),s=Array.from(Array(r)),o=[],a=[],n=e.map(((e,t)=>({i:t,d:e[0]}))).sort(((e,t)=>e.d-t.d)).map((e=>e.i));let c=0;const i=s.map((()=>[0,0])),isInsideCluster=t=>s.map(((r,s)=>e[t][s]>i[s][0]&&e[t][s]<i[s][1])).reduce(((e,t)=>e&&t),!0),updateRange=s=>{const o=s[s.length-1];for(;e[o][0]-e[s[c]][0]>t;)c+=1;const a=s.slice(c,s.length).map((t=>e[t]));i[0]=[a[0][0]-t,a[a.length-1][0]+t];for(let e=1;e<r;e+=1){const r=a.map((t=>t[e]));i[e]=[Math.min(...r)-t,Math.max(...r)+t]}};for(;a.length!==e.length;){const t=[],r=n.shift();t.push(r),a.push(r),c=0,updateRange(t);let s=0;for(;s<n.length&&e[n[s]][0]<i[0][1];)if(isInsideCluster(n[s])){const e=n.splice(s,1).shift();t.push(e),a.push(e),updateRange(t)}else s+=1;o.push(t)}return o};var G=Object.freeze({__proto__:null,getVerticesClusters:getVerticesClusters});const max_arrays_length=(...e)=>Math.max(0,...e.filter((e=>void 0!==e)).map((e=>e.length))),count=(e,t)=>max_arrays_length(...filterKeysWithPrefix(e,t).map((t=>e[t])));count.vertices=({vertices_coords:e,vertices_faces:t,vertices_vertices:r})=>max_arrays_length(e,t,r),count.edges=({edges_vertices:e,edges_edges:t,edges_faces:r})=>max_arrays_length(e,t,r),count.faces=({faces_vertices:e,faces_edges:t,faces_faces:r})=>max_arrays_length(e,t,r);const uniqueElements=e=>Array.from(new Set(e)),nonUniqueElements=e=>{const t={};return e.forEach((e=>{void 0===t[e]&&(t[e]=0),t[e]+=1})),e.filter((e=>t[e]>1))},uniqueSortedNumbers=e=>{const t={};return e.forEach((e=>{t[e]=!0})),Object.keys(t).map(parseFloat)},epsilonUniqueSortedNumbers=(e,t=v)=>{const r=e.slice().sort(((e,t)=>e-t));if(r.length<2)return r;const s=[!0];for(let e=1;e<r.length;e+=1)s[e]=!epsilonEqual(r[e],r[e-1],t);return r.filter(((e,t)=>s[t]))},flatSort=(...e)=>{const t=[];return e.forEach((e=>e.forEach(((e,r)=>{t[r]=e})))),t},splitCircularArray=(e,t)=>(t.sort(((e,t)=>e-t)),[e.slice(t[1]).concat(e.slice(0,t[0]+1)),e.slice(t[0],t[1]+1)]),selfRelationalUniqueIndexPairs=e=>{const t=[],r=[];return e.forEach(((e,s)=>e.forEach((e=>{s<e&&r.push([s,e]),s!==e||t[s]||(t[s]=!0,r.push([s,e]))})))),r},clusterSortedGeneric=(e,t)=>{if(!e.length)return[];const r=e.map(((e,t)=>t)),s=[[r[0]]];for(let o=1;o<r.length;o+=1){const a=r[o];if(void 0===a)continue;const n=s.length-1;t(e[s[n][s[n].length-1]],e[a])?s[n].push(a):s.push([a])}return s},clusterScalars=(e,t=v)=>{const r=e.map(((e,t)=>({v:e,i:t}))).sort(((e,t)=>e.v-t.v)).map((e=>e.i)),s=r.map((t=>e[t]));return clusterSortedGeneric(s,((e,r)=>Math.abs(e-r)<t)).map((e=>e.map((e=>r[e]))))},clusterParallelVectors=(e,t=v)=>{const r=[[0]];for(let s=1;s<e.length;s+=1){let o=!1;for(let a=0;a<r.length;a+=1){const n=r[a][0];if(parallel(e[s],e[n],t)){r[a].push(s),o=!0;break}}o||r.push([s])}return r},chooseTwoPairs=e=>{const t=Array(e.length*(e.length-1)/2);let r=0;for(let s=0;s<e.length-1;s+=1)for(let o=s+1;o<e.length;o+=1,r+=1)t[r]=[e[s],e[o]];return t};var H=Object.freeze({__proto__:null,chooseTwoPairs:chooseTwoPairs,clusterParallelVectors:clusterParallelVectors,clusterScalars:clusterScalars,clusterSortedGeneric:clusterSortedGeneric,epsilonUniqueSortedNumbers:epsilonUniqueSortedNumbers,flatSort:flatSort,nonUniqueElements:nonUniqueElements,selfRelationalUniqueIndexPairs:selfRelationalUniqueIndexPairs,splitCircularArray:splitCircularArray,uniqueElements:uniqueElements,uniqueSortedNumbers:uniqueSortedNumbers});const replaceGeometryIndices=(e,t,r)=>{const s=count(e,t);let n=!1;Object.entries(r).filter((([e,t])=>e<t)).forEach((([e,t])=>{n=!0,delete r[e],r[t]=e})),n&&console.warn(o);const c=Object.keys(r).map((e=>parseInt(e,10))),i=uniqueSortedNumbers(c),l=[];for(let e=0,t=0,o=0;e<s;e+=1,t+=1){for(;e===i[o];){if(l[e]=l[r[i[o]]],void 0===l[e])throw new Error(a);e+=1,o+=1}e<s&&(l[e]=t)}return filterKeysWithSuffix(e,t).forEach((t=>e[t].forEach(((r,s)=>e[t][s].forEach(((r,o)=>{e[t][s][o]=l[r]})))))),i.reverse(),filterKeysWithPrefix(e,t).forEach((t=>i.forEach((r=>e[t].splice(r,1))))),l},duplicateVertices=(e,t)=>getVerticesClusters(e,t).filter((e=>e.length>1)),removeDuplicateVertices=(e,t=v)=>{const r=[],s=[],o=getVerticesClusters(e,t).filter((e=>e.length>1));return o.forEach((e=>{Math.min(...e)!==e[0]&&e.sort(((e,t)=>e-t));for(let t=1;t<e.length;t+=1)r[e[t]]=e[0],s.push(e[t])})),o.map((t=>t.map((t=>e.vertices_coords[t])))).map((e=>average(...e))).forEach(((t,r)=>{e.vertices_coords[o[r][0]]=t})),{map:replaceGeometryIndices(e,"vertices",r),remove:s}};var J=Object.freeze({__proto__:null,duplicateVertices:duplicateVertices,removeDuplicateVertices:removeDuplicateVertices});const removeGeometryIndices=(e,t,r)=>{const s=count(e,t),o=uniqueSortedNumbers(r),a=[];for(let e=0,t=0,r=0;e<s;e+=1,t+=1){for(;e===o[r];)a[e]=void 0,e+=1,r+=1;e<s&&(a[e]=t)}return filterKeysWithSuffix(e,t).forEach((t=>e[t].forEach(((r,s)=>e[t][s].forEach(((r,o)=>{e[t][s][o]=a[r]})))))),o.reverse(),filterKeysWithPrefix(e,t).forEach((t=>o.forEach((r=>e[t].splice(r,1))))),filterKeysWithSuffix(e,t).forEach((t=>e[t].forEach(((r,s)=>{e[t][s]=e[t][s].filter((e=>void 0!==e))})))),a},edgeIsolatedVertices=({vertices_coords:e,edges_vertices:t})=>{if(!e||!t)return[];let r=e.length;const s=Array(r).fill(!1);return t.forEach((e=>{e.filter((e=>!s[e])).forEach((e=>{s[e]=!0,r-=1}))})),s.map(((e,t)=>e?void 0:t)).filter((e=>void 0!==e))},isolatedVertices=({vertices_coords:e,edges_vertices:t,faces_vertices:r})=>{if(!e)return[];let s=e.length;const o=Array(s).fill(!1);return t&&t.forEach((e=>{e.filter((e=>!o[e])).forEach((e=>{o[e]=!0,s-=1}))})),r&&r.forEach((e=>{e.filter((e=>!o[e])).forEach((e=>{o[e]=!0,s-=1}))})),o.map(((e,t)=>e?void 0:t)).filter((e=>void 0!==e))},removeIsolatedVertices=(e,t)=>(t||(t=isolatedVertices(e)),{map:removeGeometryIndices(e,"vertices",t),remove:t});var Q=Object.freeze({__proto__:null,edgeIsolatedVertices:edgeIsolatedVertices,faceIsolatedVertices:({vertices_coords:e,faces_vertices:t})=>{if(!e||!t)return[];let r=e.length;const s=Array(r).fill(!1);return t.forEach((e=>{e.filter((e=>!s[e])).forEach((e=>{s[e]=!0,r-=1}))})),s.map(((e,t)=>e?void 0:t)).filter((e=>void 0!==e))},isolatedVertices:isolatedVertices,removeIsolatedVertices:removeIsolatedVertices});const vectorToAngle=e=>Math.atan2(e[1],e[0]),angleToVector=e=>[Math.cos(e),Math.sin(e)],pointsToLine=(...e)=>{const t=getArrayOfVectors(...e);return{vector:subtract(t[1],t[0]),origin:t[0]}},vecLineToUniqueLine=({vector:e,origin:t})=>{const r=magnitude(e),s=rotate90(e),o=dot(t,s)/r;return{normal:scale$1(s,1/r),distance:o}},uniqueLineToVecLine=({normal:e,distance:t})=>({vector:rotate270(e),origin:scale$1(e,t)});var Z=Object.freeze({__proto__:null,angleToVector:angleToVector,pointsToLine:pointsToLine,uniqueLineToVecLine:uniqueLineToVecLine,vecLineToUniqueLine:vecLineToUniqueLine,vectorToAngle:vectorToAngle});const isCounterClockwiseBetween=(e,t,r)=>{for(;r<t;)r+=h;for(;e>t;)e-=h;for(;e<t;)e+=h;return e<r},clockwiseAngleRadians=(e,t)=>{for(;e<0;)e+=h;for(;t<0;)t+=h;for(;e>h;)e-=h;for(;t>h;)t-=h;const r=e-t;return r>=0?r:h-(t-e)},counterClockwiseAngleRadians=(e,t)=>{for(;e<0;)e+=h;for(;t<0;)t+=h;for(;e>h;)e-=h;for(;t>h;)t-=h;const r=t-e;return r>=0?r:h-(e-t)},clockwiseAngle2=(e,t)=>{const r=t[0]*e[0]+t[1]*e[1],s=t[0]*e[1]-t[1]*e[0];let o=Math.atan2(s,r);return o<0&&(o+=h),o},counterClockwiseAngle2=(e,t)=>{const r=e[0]*t[0]+e[1]*t[1],s=e[0]*t[1]-e[1]*t[0];let o=Math.atan2(s,r);return o<0&&(o+=h),o},clockwiseBisect2=(e,t)=>angleToVector(vectorToAngle(e)-clockwiseAngle2(e,t)/2),clockwiseSubsectRadians=(e,t,r)=>{const s=clockwiseAngleRadians(e,t)/r;return Array.from(Array(r-1)).map(((t,r)=>e+s*(r+1)))},counterClockwiseSubsectRadians=(e,t,r)=>{const s=counterClockwiseAngleRadians(e,t)/r;return Array.from(Array(r-1)).map(((t,r)=>e+s*(r+1)))},counterClockwiseSubsect2=(e,t,r)=>{const s=Math.atan2(e[1],e[0]),o=Math.atan2(t[1],t[0]);return counterClockwiseSubsectRadians(s,o,r).map(angleToVector)},counterClockwiseOrderRadians=e=>{const t=e.map(((e,t)=>t)).sort(((t,r)=>e[t]-e[r]));return t.slice(t.indexOf(0),t.length).concat(t.slice(0,t.indexOf(0)))},counterClockwiseOrder2=e=>counterClockwiseOrderRadians(e.map(vectorToAngle)),counterClockwiseSectorsRadians=e=>counterClockwiseOrderRadians(e).map((t=>e[t])).map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>counterClockwiseAngleRadians(e[0],e[1]))),counterClockwiseSectors2=e=>counterClockwiseSectorsRadians(e.map(vectorToAngle)),threePointTurnDirection=(e,t,r,s=v)=>{const o=normalize2(subtract2(t,e)),a=normalize2(subtract2(r,e)),n=cross2(o,a);return epsilonEqual(n,0,s)?epsilonEqual(distance2(e,t)+distance2(t,r),distance2(e,r))?0:void 0:Math.sign(n)};var Y=Object.freeze({__proto__:null,clockwiseAngle2:clockwiseAngle2,clockwiseAngleRadians:clockwiseAngleRadians,clockwiseBisect2:clockwiseBisect2,clockwiseSubsect2:(e,t,r)=>{const s=Math.atan2(e[1],e[0]),o=Math.atan2(t[1],t[0]);return clockwiseSubsectRadians(s,o,r).map(angleToVector)},clockwiseSubsectRadians:clockwiseSubsectRadians,counterClockwiseAngle2:counterClockwiseAngle2,counterClockwiseAngleRadians:counterClockwiseAngleRadians,counterClockwiseBisect2:(e,t)=>angleToVector(vectorToAngle(e)+counterClockwiseAngle2(e,t)/2),counterClockwiseOrder2:counterClockwiseOrder2,counterClockwiseOrderRadians:counterClockwiseOrderRadians,counterClockwiseSectors2:counterClockwiseSectors2,counterClockwiseSectorsRadians:counterClockwiseSectorsRadians,counterClockwiseSubsect2:counterClockwiseSubsect2,counterClockwiseSubsectRadians:counterClockwiseSubsectRadians,isCounterClockwiseBetween:isCounterClockwiseBetween,threePointTurnDirection:threePointTurnDirection});const X={edges:"edgeOrders",faces:"faceOrders"},countImplied=(e,t)=>Math.max((e=>{let t=-1;return e.filter((e=>void 0!==e)).forEach((e=>e.forEach((e=>e.forEach((e=>{e>t&&(t=e)})))))),t})(filterKeysWithSuffix(e,t).map((t=>e[t]))),e[X[t]]?(e=>{let t=-1;return e.forEach((e=>{e[0]>t&&(t=e[0]),e[1]>t&&(t=e[1])})),t})(e[X[t]]):-1)+1;countImplied.vertices=e=>countImplied(e,"vertices"),countImplied.edges=e=>countImplied(e,"edges"),countImplied.faces=e=>countImplied(e,"faces");const counterClockwiseWalk=({vertices_vertices:e,vertices_sectors:t},r,s,o={})=>{const a={},n={vertices:[r],edges:[],angles:[]};let c=r,i=s;for(;;){const r=e[i],s=(r.indexOf(c)+r.length-1)%r.length,l=r[s],d=`${i} ${l}`;if(a[d])return Object.assign(o,a),n.vertices.pop(),n;if(a[d]=!0,o[d])return;n.vertices.push(i),n.edges.push(d),t&&n.angles.push(t[i][s]),c=i,i=l}},planarVertexWalk=({vertices_vertices:e,vertices_sectors:t})=>{const r={vertices_vertices:e,vertices_sectors:t},s={};return e.map(((e,t)=>e.map((e=>counterClockwiseWalk(r,t,e,s))).filter((e=>void 0!==e)))).flat()},filterWalkedBoundaryFace=e=>e.filter((e=>e.angles.map((e=>Math.PI-e)).reduce(((e,t)=>e+t),0)>0));var K=Object.freeze({__proto__:null,counterClockwiseWalk:counterClockwiseWalk,filterWalkedBoundaryFace:filterWalkedBoundaryFace,planarVertexWalk:planarVertexWalk});const projectPointOnPlane=(e,t=[1,0,0],r=[0,0,0])=>{const s=resize(3,e),o=subtract3(s,resize(3,r)),a=normalize3(resize(3,t)),n=dot3(a,o),c=scale3(a,n);return subtract3(s,c)};var ee=Object.freeze({__proto__:null,projectPointOnPlane:projectPointOnPlane});const smallestComparisonSearch=(e,t,r)=>{const s=e.map(((e,s)=>({i:s,d:r(t,e)})));let o,a=1/0;for(let e=0;e<s.length;e+=1)s[e].d<a&&(o=e,a=s[e].d);return o},minimum2DPointIndex=(e,t=v)=>{if(!e||!e.length)return;const r=((e,t,r,s)=>{let o=[0];for(let a=1;a<e.length;a+=1)switch(r(e[a][t],e[o[0]][t],s)){case 0:o.push(a);break;case 1:o=[a]}return o})(e,0,epsilonCompare,t);let s=0;for(let t=1;t<r.length;t+=1)e[r[t]][1]<e[r[s]][1]&&(s=t);return r[s]};var te=Object.freeze({__proto__:null,minimum2DPointIndex:minimum2DPointIndex,smallestComparisonSearch:smallestComparisonSearch});const sortAgainstItem=(e,t,r)=>e.map(((e,s)=>({i:s,n:r(e,t)}))).sort(((e,t)=>e.n-t.n)).map((e=>e.i)),sortPointsAlongVector=(e,t)=>sortAgainstItem(e,t,dot),clusterIndicesOfSortedNumbers=(e,t=v)=>{const r=[[0]];let s=0;for(let o=1;o<e.length;o+=1)epsilonEqual(e[o],e[o-1],t)?r[s].push(o):(s=r.length,r.push([o]));return r},radialSortPointIndices2=(e,t=v)=>{const r=minimum2DPointIndex(e,t);if(void 0===r)return[];const s=e.map((t=>subtract2(t,e[r]))).map((e=>normalize2(e))).map((e=>dot2([0,1],e))),o=s.map(((e,t)=>({a:e,i:t}))).sort(((e,t)=>e.a-t.a)).map((e=>e.i)).filter((e=>e!==r));return[[r]].concat(clusterIndicesOfSortedNumbers(o.map((e=>s[e])),t).map((e=>e.map((e=>o[e])))).map((t=>1===t.length?t:t.map((t=>({i:t,len:distance2(e[t],e[r])}))).sort(((e,t)=>e.len-t.len)).map((e=>e.i)))))},radialSortUnitVectors2=e=>{const t=[e=>e[0]>=0&&e[1]>=0,e=>e[0]<0&&e[1]>=0,e=>e[0]<0&&e[1]<0,e=>e[0]>=0&&e[1]<0],r=[(t,r)=>e[r][0]-e[t][0],(t,r)=>e[r][0]-e[t][0],(t,r)=>e[t][0]-e[r][0],(t,r)=>e[t][0]-e[r][0]],s=e.map((e=>t.map(((t,r)=>t(e)?r:void 0)).filter((e=>void 0!==e)).shift())),o=[[],[],[],[]];return s.forEach(((e,t)=>{o[e].push(t)})),o.flatMap(((e,t)=>e.sort(r[t])))},radialSortPointIndices3=(e,t=[1,0,0],r=[0,0,0])=>{const s=basisVectors3(t),o=[s[1],s[2],s[0]],a=e.map((e=>projectPointOnPlane(e,t,r))).map((e=>subtract(e,r))).map((e=>[dot(e,o[0]),dot(e,o[1])])).map(normalize2);return radialSortUnitVectors2(a)};var re=Object.freeze({__proto__:null,clusterIndicesOfSortedNumbers:clusterIndicesOfSortedNumbers,radialSortPointIndices2:radialSortPointIndices2,radialSortPointIndices3:radialSortPointIndices3,radialSortUnitVectors2:radialSortUnitVectors2,sortAgainstItem:sortAgainstItem,sortPointsAlongVector:sortPointsAlongVector});const sortVerticesCounterClockwise=({vertices_coords:e},t,r)=>t.map((t=>e[t])).map((t=>subtract(t,e[r]))).map((e=>Math.atan2(e[1],e[0]))).map((e=>e>-v?e:e+2*Math.PI)).map(((e,t)=>({a:e,i:t}))).sort(((e,t)=>e.a-t.a)).map((e=>e.i)).map((e=>t[e])),sortVerticesAlongVector=({vertices_coords:e},t,r)=>sortPointsAlongVector(t.map((t=>e[t])),r).map((e=>t[e]));var se=Object.freeze({__proto__:null,sortVerticesAlongVector:sortVerticesAlongVector,sortVerticesCounterClockwise:sortVerticesCounterClockwise});const makeFacesNormal=({vertices_coords:e,faces_vertices:t})=>t.map((t=>t.map((t=>e[t])))).map((e=>{let t,r,s=0;do{t=subtract(e[(s+1)%e.length],e[s]),r=subtract(e[(s+2)%e.length],e[s]),s+=1}while(s<e.length&&parallel(t,r));return normalize3(cross3(resize(3,t),resize(3,r)))})),makeVerticesNormal=({vertices_coords:e,faces_vertices:t,faces_normal:r})=>{r||(r=makeFacesNormal({vertices_coords:e,faces_vertices:t}));const s=e.map((()=>[0,0,0]));return t.forEach(((e,t)=>e.forEach((e=>{return o=s[e],a=r[t],o[0]+=a[0],o[1]+=a[1],void(o[2]+=a[2]);var o,a})))),s.map((e=>normalize3(e)))};var oe=Object.freeze({__proto__:null,makeFacesNormal:makeFacesNormal,makeVerticesNormal:makeVerticesNormal});const makeVerticesEdgesUnsorted=({edges_vertices:e})=>{const t=[];return e.forEach(((e,r)=>e.forEach((e=>{void 0===t[e]&&(t[e]=[]),t[e].push(r)})))),t},makeVerticesEdges=({edges_vertices:e,vertices_vertices:t})=>{const r=makeVerticesToEdgeBidirectional({edges_vertices:e});return t.map(((e,t)=>e.map((e=>r[`${t} ${e}`]))))},makeVerticesVertices2D=({vertices_coords:e,vertices_edges:t,edges_vertices:r})=>{t||(t=makeVerticesEdgesUnsorted({edges_vertices:r}));const s=t.map(((e,t)=>e.map((e=>r[e].filter((e=>e!==t)))).reduce(((e,t)=>e.concat(t)),[])));return void 0===e?s:s.map(((t,r)=>sortVerticesCounterClockwise({vertices_coords:e},t,r)))},makeVerticesVerticesFromFaces=({vertices_coords:e,vertices_faces:t,faces_vertices:r})=>{t||(t=makeVerticesFacesUnsorted({vertices_coords:e,faces_vertices:r}));const s=t.map((e=>e.map((e=>r[e])))),o=s.map(((e,t)=>e.map((e=>e.indexOf(t)))));return s.map(((e,t)=>e.map(((e,r)=>[(o[t][r]+e.length-1)%e.length,o[t][r],(o[t][r]+1)%e.length])))).map(((e,t)=>e.map(((e,r)=>e.map((e=>s[t][r][e])))))).map((e=>{const t=e.map((e=>[[0,1],[1,2]].map((t=>t.map((t=>e[t])).join(" "))))),r={},s={};return t.forEach(((e,t)=>{r[e[0]]=t,s[e[1]]=t})),{facesVerts:t,to:s,from:r}})).map((e=>{const t=Object.keys(e.to),r=t.map((e=>e.split(" ").reverse().join(" "))),s=t.filter(((t,s)=>!(r[s]in e.from)));if(s.length>2)return console.warn("vertices_vertices found an unsolvable vertex"),[];const o=s.length?s:[t[0]],a=[],n={};for(let t=0;t<o.length;t+=1){const r=o[t],s=[r];n[r]=!0;let c=!1;do{const t=s[s.length-1],r=e.to[t];if(!(r in e.facesVerts))break;let o;if(e.facesVerts[r][0]===t&&(o=e.facesVerts[r][1]),e.facesVerts[r][1]===t&&(o=e.facesVerts[r][0]),void 0===o)return"not found";const a=o.split(" ").reverse().join(" ");s.push(o),c=a in n,c||s.push(a),n[o]=!0,n[a]=!0}while(!c);const i=s.filter(((e,t)=>t%2==0)).map((e=>e.split(" ")[1])).map((e=>parseInt(e,10)));a.push(...i)}return a}))},makeVerticesVertices=e=>{if(!e.vertices_coords||!e.vertices_coords.length)return[];return 3===e.vertices_coords.filter((()=>!0)).shift().length?makeVerticesVerticesFromFaces(e):makeVerticesVertices2D(e)},makeVerticesVerticesUnsorted=({vertices_edges:e,edges_vertices:t})=>(e||(e=makeVerticesEdgesUnsorted({edges_vertices:t})),e.map(((e,r)=>e.flatMap((e=>t[e].filter((e=>e!==r))))))),makeVerticesFacesUnsorted=({vertices_coords:e,vertices_edges:t,faces_vertices:r})=>{const s=e||t;if(!r)return(s||[]).map((()=>[]));const o=void 0!==s?s.map((()=>[])):Array.from(Array(countImplied.vertices({faces_vertices:r}))).map((()=>[]));return r.forEach(((e,t)=>{const r=[];e.forEach((e=>{r[e]=t})),r.forEach(((e,t)=>o[t].push(e)))})),o},makeVerticesFaces=({vertices_coords:e,vertices_vertices:t,faces_vertices:r})=>{if(!r)return e.map((()=>[]));if(!t)return makeVerticesFacesUnsorted({vertices_coords:e,faces_vertices:r});const s=makeVerticesToFace({faces_vertices:r});return t.map(((e,t)=>e.map(((e,r,s)=>[s[(r+1)%s.length],t,e].join(" "))))).map((e=>e.map((e=>s[e]))))},makeVerticesToEdgeBidirectional=({edges_vertices:e})=>{const t={};return e.map((e=>e.join(" "))).forEach(((e,r)=>{t[e]=r})),e.map((e=>`${e[1]} ${e[0]}`)).forEach(((e,r)=>{t[e]=r})),t},makeVerticesToEdge=({edges_vertices:e})=>{const t={};return e.map((e=>e.join(" "))).forEach(((e,r)=>{t[e]=r})),t},makeVerticesToFace=({faces_vertices:e})=>{const t={};return e.forEach(((e,r)=>e.map(((t,r)=>[0,1,2].map((t=>(r+t)%e.length)).map((t=>e[t])).join(" "))).forEach((e=>{t[e]=r})))),t},makeVerticesVerticesVector=({vertices_coords:e,vertices_vertices:t,edges_vertices:r,edges_vector:s})=>{s||(s=makeEdgesVector({vertices_coords:e,edges_vertices:r}));const o=makeVerticesToEdge({edges_vertices:r});return t.map(((e,r)=>t[r].map((e=>{const t=o[`${r} ${e}`],a=o[`${e} ${r}`];return void 0!==t?s[t]:void 0!==a?flip(s[a]):void 0}))))},makeVerticesSectors=({vertices_coords:e,vertices_vertices:t,edges_vertices:r,edges_vector:s})=>makeVerticesVerticesVector({vertices_coords:e,vertices_vertices:t,edges_vertices:r,edges_vector:s}).map((e=>1===e.length?[h]:counterClockwiseSectors2(e))),makeEdgesFacesUnsorted=({edges_vertices:e,faces_edges:t})=>{const r=void 0!==e?e.map((()=>[])):Array.from(Array(countImplied.edges({faces_edges:t}))).map((()=>[]));return t.forEach(((e,t)=>{const s=[];e.forEach((e=>{s[e]=t})),s.forEach(((e,t)=>r[t].push(e)))})),r},makeEdgesFaces=({vertices_coords:e,edges_vertices:t,edges_vector:r,faces_vertices:s,faces_edges:o,faces_center:a})=>{if(!t||!s&&!o)return makeEdgesFacesUnsorted({faces_edges:o});s||(s=makeFacesVerticesFromEdges({edges_vertices:t,faces_edges:o})),o||(o=makeFacesEdgesFromVertices({edges_vertices:t,faces_vertices:s})),r||(r=makeEdgesVector({vertices_coords:e,edges_vertices:t}));const n=t.map((t=>e[t[0]]));a||(a=makeFacesConvexCenter({vertices_coords:e,faces_vertices:s}));const c=t.map((()=>[]));return o.forEach(((e,t)=>{const r=[];e.forEach((e=>{r[e]=t})),r.forEach(((e,t)=>c[t].push(e)))})),c.forEach(((e,t)=>{const s=e.map((e=>a[e])).map((e=>subtract2(e,n[t]))).map((e=>cross2(e,r[t])));e.sort(((e,t)=>s[e]-s[t]))})),c},ae={M:-180,m:-180,V:180,v:180},makeEdgesAssignmentSimple=({edges_foldAngle:e})=>e.map((e=>0===e?"F":e<0?"M":"V")),makeEdgesAssignment=({edges_vertices:e,edges_foldAngle:t,edges_faces:r,faces_vertices:s,faces_edges:o})=>(r||(o||(o=makeFacesEdgesFromVertices({edges_vertices:e,faces_vertices:s})),r=makeEdgesFacesUnsorted({edges_vertices:e,faces_edges:o})),t.map(((e,t)=>r[t].length<2?"B":0===e?"F":e<0?"M":"V"))),makeEdgesFoldAngle=({edges_assignment:e})=>e.map((e=>ae[e]||0)),makeEdgesFoldAngleFromFaces=({vertices_coords:e,edges_vertices:t,edges_faces:s,edges_assignment:o,faces_vertices:a,faces_edges:c,faces_normal:i,faces_center:l})=>(s||(c||(c=makeFacesEdgesFromVertices({edges_vertices:t,faces_vertices:a})),s=makeEdgesFacesUnsorted({edges_vertices:t,faces_edges:c})),i||(i=makeFacesNormal({vertices_coords:e,faces_vertices:a})),l||(l=makeFacesConvexCenter({vertices_coords:e,faces_vertices:a})),s.map(((e,t)=>{if(e.length>2)throw new Error(r);if(e.length<2)return 0;const s=i[e[0]],a=i[e[1]],c=normalize(subtract(l[e[1]],l[e[0]]));let d=Math.sign(dot(s,c));if(0===d){if(!o||!o[t])throw new Error(n);"F"!==o[t]&&"F"!==o[t]||(d=0),"M"!==o[t]&&"m"!==o[t]||(d=-1),"V"!==o[t]&&"v"!==o[t]||(d=1)}return Math.acos(dot(s,a))*(180/Math.PI)*d}))),makeEdgesCoords=({vertices_coords:e,edges_vertices:t})=>t.map((t=>t.map((t=>e[t])))),makeEdgesVector=({vertices_coords:e,edges_vertices:t})=>makeEdgesCoords({vertices_coords:e,edges_vertices:t}).map((e=>subtract(e[1],e[0]))),makeEdgesLength=({vertices_coords:e,edges_vertices:t})=>makeEdgesVector({vertices_coords:e,edges_vertices:t}).map((e=>magnitude(e))),makeEdgesBoundingBox=({vertices_coords:e,edges_vertices:t,edges_coords:r},s=0)=>(r||(r=makeEdgesCoords({vertices_coords:e,edges_vertices:t})),r.map((e=>boundingBox$1(e,s)))),makePlanarFaces=({vertices_coords:e,vertices_vertices:t,vertices_edges:r,vertices_sectors:s,edges_vertices:o,edges_vector:a})=>{t||(t=makeVerticesVertices({vertices_coords:e,edges_vertices:o,vertices_edges:r})),s||(s=makeVerticesSectors({vertices_coords:e,vertices_vertices:t,edges_vertices:o,edges_vector:a}));const n=makeVerticesToEdgeBidirectional({edges_vertices:o}),c=filterWalkedBoundaryFace(planarVertexWalk({vertices_vertices:t,vertices_sectors:s})).map((e=>({...e,edges:e.edges.map((e=>n[e]))})));return{faces_vertices:c.map((e=>e.vertices)),faces_edges:c.map((e=>e.edges)),faces_sectors:c.map((e=>e.angles))}},makeFacesVerticesFromEdges=({edges_vertices:e,faces_edges:t})=>t.map((t=>t.map((t=>e[t])).map(((e,t,r)=>{const s=r[(t+1)%r.length];return e[0]===s[0]||e[0]===s[1]?e[1]:e[0]})))),makeFacesEdgesFromVertices=({edges_vertices:e,faces_vertices:t})=>{const r=makeVerticesToEdgeBidirectional({edges_vertices:e});return t.map((e=>e.map(((e,t,r)=>[e,r[(t+1)%r.length]].join(" "))))).map((e=>e.map((e=>r[e]))))},makeFacesFaces=({faces_vertices:e})=>{const t=e.map((()=>[])),r={};return e.forEach(((e,t)=>e.forEach(((s,o,a)=>{let n=a[(o+1)%e.length];n<s&&([s,n]=[n,s]);const c=`${s} ${n}`;void 0===r[c]&&(r[c]={}),r[c][t]=!0})))),Object.values(r).map((e=>Object.keys(e))).filter((e=>e.length>1)).forEach((e=>{t[e[0]].push(parseInt(e[1],10)),t[e[1]].push(parseInt(e[0],10))})),t},makeFacesPolygon=({vertices_coords:e,faces_vertices:t},r)=>t.map((t=>t.map((t=>e[t])))).map((e=>makePolygonNonCollinear(e,r))),makeFacesConvexCenter=({vertices_coords:e,faces_vertices:t})=>{const r=e.filter((()=>!0)).shift();if(!r)return t.map((()=>[]));const s=r.length;return t.map((t=>t.map((t=>e[t])).reduce(((e,t)=>add(e,t)),Array(s).fill(0)).map((e=>e/t.length))))};var ne=Object.freeze({__proto__:null,makeEdgesAssignment:makeEdgesAssignment,makeEdgesAssignmentSimple:makeEdgesAssignmentSimple,makeEdgesBoundingBox:makeEdgesBoundingBox,makeEdgesCoords:makeEdgesCoords,makeEdgesEdges:({edges_vertices:e,vertices_edges:t})=>e.map(((e,r)=>{const s=t[e[0]].filter((e=>e!==r)),o=t[e[1]].filter((e=>e!==r));return s.concat(o)})),makeEdgesFaces:makeEdgesFaces,makeEdgesFacesUnsorted:makeEdgesFacesUnsorted,makeEdgesFoldAngle:makeEdgesFoldAngle,makeEdgesFoldAngleFromFaces:makeEdgesFoldAngleFromFaces,makeEdgesLength:makeEdgesLength,makeEdgesVector:makeEdgesVector,makeFacesCenter2D:({vertices_coords:e,faces_vertices:t})=>t.map((t=>t.map((t=>e[t])))).map((e=>centroid(e))),makeFacesConvexCenter:makeFacesConvexCenter,makeFacesEdgesFromVertices:makeFacesEdgesFromVertices,makeFacesFaces:makeFacesFaces,makeFacesPolygon:makeFacesPolygon,makeFacesPolygonQuick:({vertices_coords:e,faces_vertices:t})=>t.map((t=>t.map((t=>e[t])))),makeFacesVerticesFromEdges:makeFacesVerticesFromEdges,makePlanarFaces:makePlanarFaces,makeVerticesEdges:makeVerticesEdges,makeVerticesEdgesUnsorted:makeVerticesEdgesUnsorted,makeVerticesFaces:makeVerticesFaces,makeVerticesFacesUnsorted:makeVerticesFacesUnsorted,makeVerticesSectors:makeVerticesSectors,makeVerticesToEdge:makeVerticesToEdge,makeVerticesToEdgeBidirectional:makeVerticesToEdgeBidirectional,makeVerticesToFace:makeVerticesToFace,makeVerticesVertices:makeVerticesVertices,makeVerticesVertices2D:makeVerticesVertices2D,makeVerticesVerticesFromFaces:makeVerticesVerticesFromFaces,makeVerticesVerticesUnsorted:makeVerticesVerticesUnsorted,makeVerticesVerticesVector:makeVerticesVerticesVector});const duplicateEdges=({edges_vertices:e})=>{if(!e)return[];const t=[],r={};for(let s=0;s<e.length;s+=1){const o=`${e[s][0]} ${e[s][1]}`,a=`${e[s][1]} ${e[s][0]}`;void 0!==r[o]?t[s]=r[o]:(r[o]=s,r[a]=s)}return t},removeDuplicateEdges=(e,t)=>{t||(t=duplicateEdges(e));const r=Object.keys(t).map((e=>parseInt(e,10))),s=replaceGeometryIndices(e,"edges",t);return r.length&&(e.vertices_edges||e.vertices_vertices||e.vertices_faces)&&(e.vertices_edges=makeVerticesEdgesUnsorted(e),e.vertices_vertices=makeVerticesVertices(e),e.vertices_edges=makeVerticesEdges(e),e.vertices_faces=makeVerticesFaces(e)),{map:s,remove:r}};var ce=Object.freeze({__proto__:null,duplicateEdges:duplicateEdges,removeDuplicateEdges:removeDuplicateEdges});const circularEdges=({edges_vertices:e})=>{if(!e)return[];const t=[];for(let r=0;r<e.length;r+=1)e[r][0]===e[r][1]&&t.push(r);return t},removeCircularEdges=(e,t)=>(t||(t=circularEdges(e)),t.length&&((e,t,r)=>{const s={};r.forEach((e=>{s[e]=!0})),filterKeysWithSuffix(e,t).forEach((t=>e[t].forEach(((r,o)=>{for(let a=r.length-1;a>=0;a-=1)!0===s[r[a]]&&e[t][o].splice(a,1)}))))})(e,"edges",t),{map:removeGeometryIndices(e,"edges",t),remove:t});var ie=Object.freeze({__proto__:null,circularEdges:circularEdges,removeCircularEdges:removeCircularEdges});const mergeSimpleNextmaps=(...e)=>{if(0===e.length)return[];const t=e[0].map(((e,t)=>t));return e.forEach((e=>t.forEach(((r,s)=>{t[s]=e[r]})))),t},mergeNextmaps=(...e)=>{if(0===e.length)return[];const t=e[0].map(((e,t)=>[t]));return e.forEach((e=>{t.forEach(((r,s)=>r.forEach(((r,o)=>{t[s][o]=e[r]})))),t.forEach(((e,r)=>{t[r]=e.reduce(((e,t)=>e.concat(t)),[]).filter((e=>void 0!==e))}))})),t},mergeBackmaps=(...e)=>{if(0===e.length)return[];let t=e[0].reduce(((e,t)=>e.concat(t)),[]).map(((e,t)=>[t]));return e.forEach((e=>{const r=[];e.forEach(((e,s)=>{r[s]="number"==typeof e?t[e]:e.map((e=>t[e])).reduce(((e,t)=>e.concat(t)),[])})),t=r})),t},invertMap=e=>{const t=[],setIndexValue=(e,r)=>{void 0!==t[e]?"number"==typeof t[e]?t[e]=[t[e],r]:t[e].push(r):t[e]=r};return e.forEach(((e,t)=>{null!=e&&("number"==typeof e&&setIndexValue(e,t),e.constructor===Array&&e.forEach((e=>setIndexValue(e,t))))})),t},invertMapArray=e=>{const t=[],setIndexValue=(e,r)=>{void 0===t[e]&&(t[e]=[]),t[e].push(r)};return e.forEach(((e,t)=>{null!=e&&("number"==typeof e&&setIndexValue(e,t),e.constructor===Array&&e.forEach((e=>setIndexValue(e,t))))})),t},invertSimpleMap=e=>{const t=[];return e.forEach(((e,r)=>{t[e]=r})),t};var le=Object.freeze({__proto__:null,invertMap:invertMap,invertMapArray:invertMapArray,invertSimpleMap:invertSimpleMap,mergeBackmaps:mergeBackmaps,mergeNextmaps:mergeNextmaps,mergeSimpleBackmaps:(...e)=>{if(0===e.length)return[];let t=e[0].map(((e,t)=>t));return e.forEach((e=>{const r=e.map((e=>t[e]));t=r})),t},mergeSimpleNextmaps:mergeSimpleNextmaps});const clean=(e,t)=>{const r=removeDuplicateVertices(e,t),s=removeCircularEdges(e),o=removeDuplicateEdges(e),a=removeIsolatedVertices(e),n=invertSimpleMap(r.map),c=a.remove.map((e=>n[e])),i=invertSimpleMap(s.map),l=o.remove.map((e=>i[e]));return{vertices:{map:mergeSimpleNextmaps(r.map,a.map),remove:r.remove.concat(c)},edges:{map:mergeSimpleNextmaps(s.map,o.map),remove:s.remove.concat(l)}}},explodeFaces=({vertices_coords:e,edges_vertices:t,edges_assignment:r,edges_foldAngle:s,faces_vertices:o,faces_edges:a})=>{if(!o)return;let n=0,c=0;const i={faces_vertices:o.map((e=>e.map((()=>c++))))};if(!e)return i;if(i.vertices_coords=structuredClone(o.flatMap((t=>t.map((t=>e[t]))))),!t)return i;a||(a=makeFacesEdgesFromVertices({edges_vertices:t,faces_vertices:o})),i.edges_vertices=a.flatMap((e=>e.map(((e,t,r)=>t===r.length-1?[n,++n-r.length]:[n,++n]))));const l=a.flatMap((e=>e));return r&&(i.edges_assignment=structuredClone(l.map((e=>r[e])))),s&&(i.edges_foldAngle=structuredClone(l.map((e=>s[e])))),i};var fe=Object.freeze({__proto__:null,explodeEdges:({vertices_coords:e,edges_vertices:t,edges_assignment:r,edges_foldAngle:s})=>{if(!t)return;let o=0;const a={edges_vertices:t.map((e=>e.map((()=>o++))))};return r&&(a.edges_assignment=r),s&&(a.edges_foldAngle=s),e&&(a.vertices_coords=structuredClone(t.flatMap((t=>t.map((t=>e[t])))))),a},explodeFaces:explodeFaces});const nearestPointOnLine=({vector:e,origin:t},r,s=clampLine,o=v)=>{t=resize(e.length,t),r=resize(e.length,r);const a=magSquared(e),n=subtract(r,t),c=s(dot(e,n)/a,o);return add(t,scale$1(e,c))};var de=Object.freeze({__proto__:null,nearestPoint:(e,t)=>{const r=smallestComparisonSearch(e,t,distance);return void 0===r?void 0:e[r]},nearestPoint2:(e,t)=>{const r=smallestComparisonSearch(e,t,distance2);return void 0===r?void 0:e[r]},nearestPointOnCircle:({radius:e,origin:t},r)=>add(t,scale$1(normalize(subtract(r,t)),e)),nearestPointOnLine:nearestPointOnLine,nearestPointOnPolygon:(e,t)=>e.map(((e,t,r)=>subtract(r[(t+1)%r.length],e))).map(((t,r)=>({vector:t,origin:e[r]}))).map((e=>nearestPointOnLine(e,t,clampSegment))).map(((e,r)=>({point:e,edge:r,distance:distance(e,t)}))).sort(((e,t)=>e.distance-t.distance)).shift()});const overlapLinePoint=({vector:e,origin:t},r,s=includeL,o=v)=>{const a=subtract2(r,t),n=magSquared(e),c=Math.sqrt(n);if(c<o)return!1;const i=cross2(a,e.map((e=>e/c))),l=dot2(a,e)/n;return Math.abs(i)<o&&s(l,o/c)},overlapLineLine=(e,t,r=includeL,s=includeL,o=v)=>{const a=cross2(e.vector,t.vector),n=-a,c=subtract2(t.origin,e.origin),i=[-c[0],-c[1]];if(Math.abs(a)<o){if(Math.abs(cross2(c,e.vector))>o)return!1;const a=i,n=add2(a,e.vector),l=midpoint2(a,n),d=c,m=add2(d,t.vector),g=midpoint2(d,m),p=dot2(e.vector,e.vector),v=dot2(t.vector,t.vector),_=dot2(a,t.vector)/v,u=dot2(n,t.vector)/v,h=dot2(l,t.vector)/v,b=dot2(d,e.vector)/p,y=dot2(m,e.vector)/p,E=dot2(g,e.vector)/p;return r(b,o)||r(y,o)||s(_,o)||s(u,o)||r(E,o)||s(h,o)}const l=cross2(c,t.vector)/a,d=cross2(i,e.vector)/n;return r(l,o/magnitude2(e.vector))&&s(d,o/magnitude2(t.vector))},overlapConvexPolygonPoint=(e,t,r=exclude,s=v)=>e.map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>cross2(normalize2(subtract2(e[1],e[0])),subtract2(t,e[0])))).map((e=>r(e,s))).map(((e,t,r)=>e===r[0])).reduce(((e,t)=>e&&t),!0),overlapConvexPolygons=(e,t,r=v)=>{for(let s=0;s<2;s+=1){const o=0===s?e:t,a=0===s?t:e;for(let e=0;e<o.length;e+=1){const t=o[e],s=rotate90(subtract2(o[(e+1)%o.length],o[e])),n=a.map((e=>subtract2(e,t))).map((e=>dot2(s,e))),c=o[(e+2)%o.length],i=dot2(s,subtract2(c,t))>0;if(n.map((e=>i?e<r:e>-r)).reduce(((e,t)=>e&&t),!0))return!1}}return!0},overlapBoundingBoxes=(e,t,r=v)=>{const s=Math.min(e.min.length,t.min.length);for(let o=0;o<s;o+=1)if(e.min[o]>t.max[o]+r||e.max[o]<t.min[o]-r)return!1;return!0};var me=Object.freeze({__proto__:null,overlapBoundingBoxes:overlapBoundingBoxes,overlapCirclePoint:({radius:e,origin:t},r,s=exclude,o=v)=>s(e-distance2(t,r),o),overlapConvexPolygonPoint:overlapConvexPolygonPoint,overlapConvexPolygons:overlapConvexPolygons,overlapLineLine:overlapLineLine,overlapLinePoint:overlapLinePoint});const nearestVertex=({vertices_coords:e},t)=>{if(!e)return;const r=getDimension({vertices_coords:e});if(void 0===r)return;const s=resize(r,t),o=e.map(((e,t)=>({d:distance(s,e),i:t}))).sort(((e,t)=>e.d-t.d)).shift();return o?o.i:void 0},nearestEdge=({vertices_coords:e,edges_vertices:t},r)=>{if(!e||!t)return;const s=t.map((t=>t.map((t=>e[t])))).map((e=>nearestPointOnLine({vector:subtract(e[1],e[0]),origin:e[0]},r,clampSegment)));return smallestComparisonSearch(s,r,distance)},facesContainingPoint=({vertices_coords:e,faces_vertices:t},r)=>e&&t?t.map(((t,r)=>({face:t.map((t=>e[t])),i:r}))).filter((e=>overlapConvexPolygonPoint(e.face,r))).map((e=>e.i)):[],faceContainingPoint=({vertices_coords:e,faces_vertices:t},r)=>{const s=facesContainingPoint({vertices_coords:e,faces_vertices:t},r);return s.length?s.shift():void 0},nearestFace=(e,t)=>{const r=faceContainingPoint(e,t);if(void 0!==r)return r;if(e.edges_faces){const r=nearestEdge(e,t);if(void 0===r)return;const s=e.edges_faces[r];if(1===s.length)return s[0];if(s.length>1){const r=makeFacesConvexCenter({vertices_coords:e.vertices_coords,faces_vertices:s.map((t=>e.faces_vertices[t]))}).map((e=>distance(e,t)));let o=0;for(let e=0;e<r.length;e+=1)r[e]<r[o]&&(o=e);return s[o]}}},nearest=(e,...t)=>{const r={vertices:nearestVertex,edges:nearestEdge,faces:nearestFace},s=getVector(...t),o=Object.create(null);return["vertices","edges","faces"].forEach((t=>{Object.defineProperty(o,T[t],{enumerable:!0,get:()=>r[t](e,s)}),filterKeysWithPrefix(e,t).forEach((r=>Object.defineProperty(o,r,{enumerable:!0,get:()=>e[r][o[T[t]]]})))})),o};var ge=Object.freeze({__proto__:null,faceContainingPoint:faceContainingPoint,facesContainingPoint:facesContainingPoint,nearest:nearest,nearestEdge:nearestEdge,nearestFace:nearestFace,nearestVertex:nearestVertex});const edgeifyFaces=({vertices_coords:e,faces_vertices:t},r=0)=>t.map((t=>[t.reduce(((t,s)=>e[t][r]<e[s][r]?t:s)),t.reduce(((t,s)=>e[t][r]>e[s][r]?t:s))])),sweepValues=(e,{edges_vertices:t,vertices_edges:r},s=v)=>{r||(r=makeVerticesEdgesUnsorted({edges_vertices:t}));const o=t.map((t=>t.map((t=>e[t])))),a=o.map((e=>epsilonEqual(...e,s))),n=o.map((([e,t])=>Math.sign(e-t))),c=t.map((([e,t],r)=>a[r]?{[e]:0,[t]:0}:{[e]:n[r],[t]:-n[r]}));return clusterScalars(e,s).map((e=>e.filter((e=>r[e])))).filter((e=>e.length)).map((t=>({vertices:t,t:t.reduce(((t,r)=>t+e[r]),0)/t.length,start:uniqueElements(t.flatMap((e=>r[e].filter((t=>c[t][e]<=0))))),end:uniqueElements(t.flatMap((e=>r[e].filter((t=>c[t][e]>=0)))))})))},sweepFaces=({vertices_coords:e,faces_vertices:t},r=0,s=v)=>sweepValues(e.map((e=>e[r])),{edges_vertices:edgeifyFaces({vertices_coords:e,faces_vertices:t},r)},s);var pe=Object.freeze({__proto__:null,sweep:({vertices_coords:e,edges_vertices:t,faces_vertices:r},s=0,o=v)=>{const a=e.map((e=>e[s])),n=edgeifyFaces({vertices_coords:e,faces_vertices:r},s),c=makeVerticesEdgesUnsorted({edges_vertices:t}),i=makeVerticesEdgesUnsorted({edges_vertices:n}),l=t.map((e=>e.map((e=>a[e])))),d=n.map((e=>e.map((e=>a[e])))),m=l.map((e=>epsilonEqual(...e,o))),g=d.map((e=>epsilonEqual(...e,o))),p=l.map((([e,t])=>Math.sign(e-t))),_=d.map((([e,t])=>Math.sign(e-t))),u=t.map((([e,t],r)=>m[r]?{[e]:0,[t]:0}:{[e]:p[r],[t]:-p[r]})),h=r.map((([e,t],r)=>g[r]?{[e]:0,[t]:0}:{[e]:_[r],[t]:-_[r]}));return clusterScalars(a,o).map((e=>({vertices:e,t:e.reduce(((e,t)=>e+a[t]),0)/e.length,edges:{start:uniqueElements(e.filter((e=>void 0!==c[e])).flatMap((e=>c[e].filter((t=>u[t][e]<=0))))),end:uniqueElements(e.filter((e=>void 0!==c[e])).flatMap((e=>c[e].filter((t=>u[t][e]>=0)))))},faces:{start:uniqueElements(e.filter((e=>void 0!==i[e])).flatMap((e=>i[e].filter((t=>h[t][e]<=0))))),end:uniqueElements(e.filter((e=>void 0!==i[e])).flatMap((e=>i[e].filter((t=>h[t][e]>=0)))))}})))},sweepEdges:({vertices_coords:e,edges_vertices:t,vertices_edges:r},s=0,o=v)=>sweepValues(e.map((e=>e[s])),{edges_vertices:t,vertices_edges:r},o),sweepFaces:sweepFaces,sweepValues:sweepValues,sweepVertices:({vertices_coords:e},t=0,r=v)=>clusterScalars(e.map((e=>e[t])),r).map((r=>({vertices:r,t:r.reduce(((r,s)=>r+e[s][t]),0)/r.length})))});const collinearBetween=(e,t,r,s=!1,o=v)=>{if([e,r].map((e=>epsilonEqualVectors(t,e,o))).reduce(((e,t)=>e||t),!1))return s;const a=[[e,t],[t,r]].map((e=>subtract(e[1],e[0]))).map((e=>normalize(e)));return epsilonEqual(1,dot(...a),v)},pleat$2=(e,t,r,s=v)=>{const o=dot(e.vector,t.vector),a=cross2(e.vector,t.vector),n=cross2(subtract2(t.origin,e.origin),t.vector)/a,c=[e.vector,t.vector].map((e=>normalize(e))),i=(a>-s?[[e.vector,t.vector],[flip(t.vector),e.vector]]:[[t.vector,e.vector],[flip(e.vector),t.vector]]).map((e=>counterClockwiseSubsect2(e[0],e[1],r))),l=Math.abs(cross2(...c))<s,d=l?void 0:add2(e.origin,scale2(e.vector,n)),m=Array.from(Array(r-1)),g=l?m.map(((s,o)=>lerp(e.origin,t.origin,(o+1)/r))):m.map((()=>d)),p=i.map((e=>e.map(((e,t)=>({vector:e,origin:[...g[t]]})))));return l&&(p[o>-s?1:0]=[]),p},bisectLines2=(e,t,r=v)=>{const s=pleat$2(e,t,2,r).map((e=>e[0]));return s.forEach(((e,t)=>{void 0===e&&delete s[t]})),s};var ve=Object.freeze({__proto__:null,bisectLines2:bisectLines2,collinearBetween:collinearBetween,lerpLines:(e,t,r)=>({vector:lerp(e.vector,t.vector,r),origin:lerp(e.origin,t.origin,r)}),pleat:pleat$2});const getOtherVerticesInEdges=({edges_vertices:e},t,r)=>r.map((r=>e[r][0]===t?e[r][1]:e[r][0]));var _e=Object.freeze({__proto__:null,getOtherVerticesInEdges:getOtherVerticesInEdges});const isVertexCollinear=({vertices_coords:e,vertices_edges:t,edges_vertices:r},s,o=v)=>{if(!e||!r)return!1;t||(t=makeVerticesEdgesUnsorted({edges_vertices:r}));const a=t[s];if(void 0===a||2!==a.length)return!1;const n=getOtherVerticesInEdges({edges_vertices:r},s,a),c=[n[0],s,n[1]].map((t=>e[t]));return collinearBetween(...c,!1,o)};var ue=Object.freeze({__proto__:null,isVertexCollinear:isVertexCollinear});const getEdgesLine=({vertices_coords:e,edges_vertices:t},r=v)=>{if(!e||!t||!t.length)return{edges_line:[],lines:[]};const s=makeEdgesCoords({vertices_coords:e,edges_vertices:t}),o=s.map((e=>subtract(e[1],e[0]))).map(normalize),a=o.map(((e,t)=>({vector:e,origin:s[t][0]}))),n=a.map((e=>nearestPointOnLine(e,[0,0,0],clampLine,r))),c=n.map((e=>magnitude(e))),i=clusterScalars(c,r),l=i.map((e=>e.map((e=>o[e])))).map((e=>clusterParallelVectors(e,r))).map(((e,t)=>e.map((e=>e.map((e=>i[t][e])))))).map((s=>s.map((s=>{if(Math.abs(c[s[0]])<r)return[s];const o=a[s[0]].vector,n=s.map((r=>e[t[r][0]])).map((e=>projectPointOnPlane(e,o))),i=radialSortPointIndices3(n,o),compareFn=(e,t)=>epsilonEqualVectors(n[e],n[t],r),remap=e=>e.map((e=>i[e])).map((e=>s[e])),l=clusterSortedGeneric(i,compareFn);if(1===l.length)return l.map(remap);const d=l[0][0],m=l[l.length-1];if(compareFn(...[d,m[m.length-1]].map((e=>i[e])))){const e=l.pop();l[0]=e.concat(l[0])}return l.map(remap)})))),d=l.flatMap((e=>e.flatMap((e=>e.map((e=>e[0])).map((e=>({vector:o[e],origin:n[e]}))))))),m=[];let g=0;return l.forEach((e=>e.forEach((e=>e.forEach((e=>{e.forEach((e=>{m[e]=g})),g+=1})))))),{lines:d,edges_line:m}};var he=Object.freeze({__proto__:null,getEdgesLine:getEdgesLine});const lineLine=(e,t,r=v)=>{const s=cross2(e.vector,t.vector);if(Math.abs(s)<r)return;const o=-s,a=subtract2(t.origin,e.origin),n=[-a[0],-a[1]];return[cross2(a,t.vector)/s,cross2(n,e.vector)/o]},planarize=({vertices_coords:e,edges_vertices:t,edges_assignment:r,edges_foldAngle:s},o=v)=>{const{lines:a,edges_line:n}=getEdgesLine({vertices_coords:e,edges_vertices:t}),c=invertMap(n).map((e=>e.constructor===Array?e:[e])),i=t.map((t=>t.map((t=>e[t])))).map(((e,t)=>e.map((e=>dot2(subtract2(e,a[n[t]].origin),a[n[t]].vector))))),l=c.map((e=>e.flatMap((e=>i[e])))).map((e=>epsilonUniqueSortedNumbers(e,o))),d=l.map((e=>[e[0],e[e.length-1]])),m=((e,t,r=v)=>{const isInside=(e,t)=>e>t[0]-r&&e<t[1]+r,s=e.map((()=>[]));for(let o=0;o<e.length-1;o+=1)for(let a=o+1;a<e.length;a+=1){const n=lineLine(e[o],e[a],r);if(void 0===n)continue;const[c,i]=n;isInside(c,t[o])&&isInside(i,t[a])&&(s[o].push(c),s[a].push(i))}return s})(a,d,o).map((e=>epsilonUniqueSortedNumbers(e,o))).map(((e,t)=>((e,t,r=v)=>{const s=[];let o=0,a=0;for(;o<e.length&&a<t.length;)epsilonEqual(e[o],t[a],r)?o+=1:e[o]>t[a]?a+=1:t[a]>e[o]&&(s.push(e[o]),o+=1);return s})(e,l[t],o))),g=c.map((e=>e.flatMap((e=>i[e])))),p=c.map((e=>{const t=[];return e.forEach(((e,r)=>{t[e]=[2*r,2*r+1]})),t})),_=c.map(((e,t)=>sweepValues(g[t],{edges_vertices:p[t]},o))),u=_.map((e=>e.map((e=>e.t)))),h=_.map((e=>{const t={},r=e.map((e=>(e.start.forEach((e=>{t[e]=!0})),e.end.forEach((e=>{delete t[e]})),Object.keys(t).map((e=>parseInt(e,10))))));return r.pop(),r}));m.forEach(((e,t)=>{const r=u[t],s=h[t];let a=0,n=0;for(;a<e.length&&n<r.length-1;){if(epsilonEqual(r[n],e[a],o))throw new Error("bad algorithm");e[a]>r[n+1]?n+=1:(r.splice(n+1,0,e[a]),s.splice(n+1,0,s[n]),a+=1)}}));const b=u.flatMap(((e,t)=>e.map((e=>add2(a[t].origin,scale2(a[t].vector,e))))));let y=0;const E={vertices_coords:b,edges_vertices:h.map((e=>{const t=e.map((()=>[y,++y]));return y+=1,t})).flatMap(((e,t)=>e.filter(((e,r)=>h[t][r].length))))};if(r||s){const e=h.flatMap((e=>e.filter((e=>e.length))));r&&(E.edges_assignment=e.map((e=>r[e[0]]))),s&&(E.edges_foldAngle=e.map((e=>s[e[0]])))}removeIsolatedVertices(E,edgeIsolatedVertices(E)),removeDuplicateVertices(E,2*o),removeCircularEdges(E),E.vertices_edges=makeVerticesEdgesUnsorted(E);const A=E.vertices_edges.map(((e,t)=>2===e.length?t:void 0)).filter((e=>void 0!==e)).filter((e=>isVertexCollinear(E,e,o))).reverse(),x=A.map((e=>(({edges_vertices:e,vertices_edges:t},r)=>{const s=t[r].sort(((e,t)=>e-t)),o=s.flatMap((t=>e[t])).filter((e=>e!==r)).slice(0,2);return e[s[0]]=o,e[s[1]]=void 0,o.forEach((e=>{const r=t[e].indexOf(s[1]);-1!==r&&(t[e][r]=s[0])})),s[1]})(E,e)));removeGeometryIndices(E,"edges",x),removeGeometryIndices(E,"vertices",A);const M=duplicateEdges(E);return M.length&&removeDuplicateEdges(E,M),circularEdges(E).length&&console.error("planarize: found circular edges. place 3."),delete E.vertices_edges,E},populate=(e,t)=>"object"!=typeof e?e:e.edges_vertices?(e.vertices_edges=makeVerticesEdgesUnsorted(e),e.vertices_vertices=makeVerticesVertices(e),e.vertices_edges=makeVerticesEdges(e),(e=>{const t=e.edges_vertices.length;if(e.edges_assignment||(e.edges_assignment=[]),e.edges_foldAngle||(e.edges_foldAngle=[]),e.edges_assignment.length>e.edges_foldAngle.length)for(let t=e.edges_foldAngle.length;t<e.edges_assignment.length;t+=1)e.edges_foldAngle[t]=edgeAssignmentToFoldAngle(e.edges_assignment[t]);if(e.edges_foldAngle.length>e.edges_assignment.length)for(let t=e.edges_assignment.length;t<e.edges_foldAngle.length;t+=1)e.edges_assignment[t]=edgeFoldAngleToAssignment(e.edges_foldAngle[t]);for(let r=e.edges_assignment.length;r<t;r+=1)e.edges_assignment[r]="U",e.edges_foldAngle[r]=0})(e),((e,t)=>{if(void 0!==t||e.faces_vertices||e.faces_edges||(t=!0),t&&e.vertices_coords){const t=makePlanarFaces(e);return e.faces_vertices=t.faces_vertices,void(e.faces_edges=t.faces_edges)}e.faces_vertices&&e.faces_edges||(e.faces_vertices&&!e.faces_edges?e.faces_edges=makeFacesEdgesFromVertices(e):e.faces_edges&&!e.faces_vertices?e.faces_vertices=makeFacesVerticesFromEdges(e):(e.faces_vertices=[],e.faces_edges=[]))})(e,t),e.vertices_faces=makeVerticesFaces(e),e.edges_faces=makeEdgesFacesUnsorted(e),e.faces_faces=makeFacesFaces(e),e):e,splitEdge=(e,t,r,s=v)=>{if(e.edges_vertices.length<t)return{};const o=e.edges_vertices[t];r||(r=midpoint(...o.map((t=>e.vertices_coords[t]))));const a=o.map((t=>e.vertices_coords[t])).map((e=>distance(e,r)<s));if(a[0])return{vertex:o[0],edges:{}};if(a[1])return{vertex:o[1],edges:{}};const n=e.vertices_coords.length;e.vertices_coords[n]=r;const c=[0,1].map((t=>t+e.edges_vertices.length));((e,t,r)=>{const s=e.edges_vertices[t],o=[{edges_vertices:[s[0],r]},{edges_vertices:[r,s[1]]}];return o.forEach((r=>["edges_assignment","edges_foldAngle"].filter((r=>e[r]&&void 0!==e[r][t])).forEach((s=>{r[s]=e[s][t]})))),o})(e,t,n).forEach(((t,r)=>Object.keys(t).forEach((s=>{e[s][c[r]]=t[s]})))),(({vertices_vertices:e},t,r)=>{e&&(e[t]=[...r],r.forEach(((r,s,o)=>{const a=o[(s+1)%o.length],n=e[r].indexOf(a);e[r][n]=t})))})(e,n,o),(({vertices_coords:e,vertices_vertices:t,vertices_sectors:r},s)=>{r&&(r[s]=1===t[s].length?[h]:counterClockwiseSectors2(t[s].map((t=>subtract2(e[t],e[s])))))})(e,n),(({vertices_edges:e},t,r,s,o)=>{e&&(e[r]=[...o],s.map((r=>e[r].indexOf(t))).forEach(((t,r)=>{e[s[r]][t]=o[r]})))})(e,t,n,o,c);const i=(({vertices_faces:e,edges_vertices:t,edges_faces:r,faces_edges:s,faces_vertices:o},a)=>{if(r&&r[a])return r[a];const n=t[a];if(void 0!==e){const t=[];for(let r=0;r<e[n[0]].length;r+=1)for(let s=0;s<e[n[1]].length;s+=1)if(e[n[0]][r]===e[n[1]][s]){if(void 0===e[n[0]][r])continue;t.push(e[n[0]][r])}return t}if(s){const e=[];for(let t=0;t<s.length;t+=1)for(let r=0;r<s[t].length;r+=1)s[t][r]===a&&e.push(t);return e}o&&console.warn("todo: findAdjacentFacesToEdge")})(e,t);i&&((({vertices_faces:e},t,r)=>{e&&(e[t]=[...r])})(e,n,i),(({edges_faces:e},t,r)=>{e&&t.forEach((t=>{e[t]=[...r]}))})(e,c,i),(({faces_vertices:e},t,r,s)=>{e&&s.map((t=>e[t])).forEach((e=>e.map(((e,t,s)=>{const o=(t+1)%s.length;return e===r[0]&&s[o]===r[1]||e===r[1]&&s[o]===r[0]?o:void 0})).filter((e=>void 0!==e)).sort(((e,t)=>t-e)).forEach((r=>e.splice(r,0,t)))))})(e,n,o,i),(({edges_vertices:e,faces_vertices:t,faces_edges:r},s)=>{const o=makeVerticesToEdgeBidirectional({edges_vertices:e});s.map((e=>t[e].map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>o[e.join(" ")])))).forEach(((e,t)=>{r[s[t]]=e}))})(e,i));const l=removeGeometryIndices(e,"edges",[t]);return c.forEach(((e,t)=>{c[t]=l[c[t]]})),l.splice(-2),l[t]=c,{vertex:n,edges:{map:l,new:c,remove:t}}},rebuild_edge=(e,t,r)=>{const s=e.edges_vertices.length,o=(({vertices_coords:e},t,r)=>{const s=t.map((t=>e[t])).reverse();return{edges_vertices:[...t],edges_foldAngle:0,edges_assignment:"U",edges_length:distance(...s),edges_vector:subtract(...s),edges_faces:[r,r]}})(e,r,t);return Object.keys(o).filter((t=>void 0!==e[t])).forEach((t=>{e[t][s]=o[t]})),s},build_faces=(e,t,r)=>{const s=[0,1].map((t=>e.faces_vertices.length+t));return(({edges_vertices:e,faces_vertices:t,faces_edges:r},s,o)=>{const a=o.map((e=>t[s].indexOf(e))),n=splitCircularArray(t[s],a).map((e=>({faces_vertices:e})));if(r){const t=makeVerticesToEdgeBidirectional({edges_vertices:e});n.map((e=>e.faces_vertices.map(((e,t,r)=>`${e} ${r[(t+1)%r.length]}`)).map((e=>t[e])))).forEach(((e,t)=>{n[t].faces_edges=e}))}return n})(e,t,r).forEach(((t,r)=>Object.keys(t).forEach((o=>{e[o][s[r]]=t[o]})))),s},intersectLineLine=(e,t,r=includeL,s=includeL,o=v)=>{const a=cross2(normalize2(e.vector),normalize2(t.vector));if(Math.abs(a)<o)return;const n=cross2(e.vector,t.vector),c=-n,i=[t.origin[0]-e.origin[0],t.origin[1]-e.origin[1]],l=[-i[0],-i[1]],d=cross2(i,t.vector)/n,m=cross2(l,e.vector)/c;return r(d,o/magnitude2(e.vector))&&s(m,o/magnitude2(t.vector))?add2(e.origin,scale2(e.vector,d)):void 0},intersectCircleLine=(e,t,r=include,s=includeL,o=v)=>{const a=t.vector[0]**2+t.vector[1]**2,n=Math.sqrt(a),c=0===n?t.vector:t.vector.map((e=>e/n)),i=rotate90(c),l=subtract2(t.origin,e.origin),d=cross2(l,c);if(Math.abs(d)>e.radius+o)return;const m=Math.sqrt(e.radius**2-d**2),f=(t,r)=>e.origin[r]-i[r]*d+c[r]*t,g=Math.abs(e.radius-Math.abs(d))<o?[m].map((e=>[e,e].map(f))):[-m,m].map((e=>[e,e].map(f))),p=g.map((e=>e.map(((e,r)=>e-t.origin[r])))).map((e=>e[0]*t.vector[0]+t.vector[1]*e[1])).map((e=>e/a));return g.filter(((e,t)=>s(p[t],o)))},rotateVector2=(e,t,r)=>{const s=t[0]-e[0],o=t[1]-e[1],a=s*Math.cos(r)+o*Math.sin(r),n=o*Math.cos(r)-s*Math.sin(r);return[e[0]+a,e[1]+n]},getUniquePair=e=>{for(let t=1;t<e.length;t+=1)if(!epsilonEqualVectors(e[0],e[t]))return[e[0],e[t]]},intersectConvexPolygonLineInclusive=(e,{vector:t,origin:r},s=includeS,o=includeL,a=v)=>{const n=e.map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>intersectLineLine({vector:subtract2(e[1],e[0]),origin:e[0]},{vector:t,origin:r},s,o,a))).filter((e=>void 0!==e));switch(n.length){case 0:return;case 1:return[n];default:return getUniquePair(n)||[n[0]]}},intersectConvexPolygonLine=(e,{vector:t,origin:r},s=includeS,o=excludeL,a=v)=>{const n=intersectConvexPolygonLineInclusive(e,{vector:t,origin:r},s,o,a);let c;switch(o){case P:c=S;break;case excludeS:c=includeS;break;default:return n}const i=intersectConvexPolygonLineInclusive(e,{vector:t,origin:r},includeS,c,a);if(void 0===i)return;const l=getUniquePair(i);if(void 0===l)switch(o){case P:return overlapConvexPolygonPoint(e,r,exclude,.001)?i:void 0;case excludeS:return overlapConvexPolygonPoint(e,add2(r,t),exclude,.001)||overlapConvexPolygonPoint(e,r,exclude,.001)?i:void 0;default:return}return overlapConvexPolygonPoint(e,midpoint2(...l),exclude,.001)?l:n};var be=Object.freeze({__proto__:null,intersectCircleCircle:(e,t,r=include,s=include,o=v)=>{const a=e.radius<t.radius?e.radius:t.radius,n=e.radius<t.radius?t.radius:e.radius,c=e.radius<t.radius?e.origin:t.origin,i=e.radius<t.radius?t.origin:e.origin,l=[c[0]-i[0],c[1]-i[1]],d=Math.sqrt(l[0]**2+l[1]**2);if(d<o)return;const m=l.map(((e,t)=>e/d*n+i[t]));if(Math.abs(n+a-d)<o||Math.abs(n-(a+d))<o)return[m];if(d+a<n||n+a<d)return;const g=(p=(a*a-d*d-n*n)/(-2*d*n))>=1?0:p<=-1?Math.PI:Math.acos(p);var p;return[rotateVector2(i,m,+g),rotateVector2(i,m,-g)]},intersectCircleLine:intersectCircleLine,intersectConvexPolygonLine:intersectConvexPolygonLine,intersectLineLine:intersectLineLine});const signLine=()=>0,signRay=(e,t)=>e<-t?-1:0,signSegment=(e,t)=>e<-t?-1:e>1+t?1:0,facesLineTypeOverlap=({vertices_coords:e,faces_vertices:t},{vector:r,origin:s},o=signLine,a=v)=>{const n=dot2(r,r),c=normalize2(r),i=e.map((e=>subtract2(e,s))).map((e=>normalize2(e))).map((e=>cross2(c,e))).map((e=>Math.abs(e)<a?0:Math.sign(e))),l=e.map((e=>subtract2(e,s))).map((e=>dot2(e,r))).map((e=>e/n)).map((e=>o(e,a))),d=t.map((e=>e.map((e=>i[e])).map(((e,t,r)=>e===r[0])).reduce(((e,t)=>e&&t),!0))).map((e=>!e)),m=t.map((e=>e.map((e=>l[e])).map(((e,t,r)=>e===r[0])).reduce(((e,t)=>e&&t),!0))).map((e=>!e)).map(((e,r)=>e||0===l[t[r][0]]));return t.map(((e,t)=>t)).filter((e=>d[e]&&m[e]))},getFacesLineOverlap=(e,{vector:t,origin:r},s=v)=>facesLineTypeOverlap(e,{vector:t,origin:r},signLine,s),getFacesRayOverlap=(e,{vector:t,origin:r},s=v)=>facesLineTypeOverlap(e,{vector:t,origin:r},signRay,s),getFacesSegmentOverlap=(e,t,r=v)=>{const s=subtract2(t[1],t[0]),o=t[0];return facesLineTypeOverlap(e,{vector:s,origin:o},signSegment,r)},intersectConvexFaceLine=({vertices_coords:e,edges_vertices:t,faces_vertices:r,faces_edges:s},o,{vector:a,origin:n},c=v)=>{const i=r[o].map((t=>e[t])).map((e=>overlapLinePoint({vector:a,origin:n},e,(()=>!0),c))).map(((e,t)=>e?t:void 0)).filter((e=>void 0!==e)),l=i.map((e=>r[o][e]));if(i.concat(i.map((e=>e+r[o].length))).map(((e,t,r)=>r[t+1]-e==1)).reduce(((e,t)=>e||t),!1))return;if(l.length>1)return{vertices:l,edges:[]};const d=s[o].map((r=>t[r].map((t=>e[t])))).map((e=>intersectLineLine({vector:a,origin:n},{vector:subtract2(e[1],e[0]),origin:e[0]},includeL,excludeS,c))).map(((e,t)=>({coords:e,edge:s[o][t]}))).filter((e=>void 0!==e.coords)).filter((e=>!l.map((r=>t[e.edge].includes(r))).reduce(((e,t)=>e||t),!1)));return d.length+l.length===2?{vertices:l,edges:d}:void 0};var ye=Object.freeze({__proto__:null,facesLineTypeOverlap:facesLineTypeOverlap,getFacesLineOverlap:getFacesLineOverlap,getFacesRayOverlap:getFacesRayOverlap,getFacesSegmentOverlap:getFacesSegmentOverlap,intersectConvexFaceLine:intersectConvexFaceLine});const splitFace=(e,t,r,s)=>{const o=intersectConvexFaceLine(e,t,r,s);if(void 0===o)return;const a=((e,{vertices:t,edges:r})=>{let s;const o=r.map((t=>{const r=splitEdge(e,s?s[t.edge]:t.edge,t.coords);return s=s?mergeNextmaps(s,r.edges.map):r.edges.map,r}));let a;return t.push(...o.map((e=>e.vertex))),o.forEach((e=>{e.edges.remove=a?a[e.edges.remove]:e.edges.remove;const t=invertSimpleMap(e.edges.map);a=a?mergeBackmaps(a,t):t})),{vertices:t,edges:{map:s,remove:o.map((e=>e.edges.remove))}}})(e,o);a.edges.new=rebuild_edge(e,t,a.vertices),(({vertices_coords:e,vertices_vertices:t,edges_vertices:r},s)=>{const o=r[s][0],a=r[s][1];t[o]=sortVerticesCounterClockwise({vertices_coords:e},t[o].concat(a),o),t[a]=sortVerticesCounterClockwise({vertices_coords:e},t[a].concat(o),a)})(e,a.edges.new),(({edges_vertices:e,vertices_edges:t,vertices_vertices:r},s)=>{if(!t||!r)return;const o=e[s];o.map((e=>r[e])).map(((e,t)=>e.indexOf(o[(t+1)%o.length]))).forEach(((e,r)=>t[o[r]].splice(e,0,s)))})(e,a.edges.new);const n=build_faces(e,t,a.vertices);((e,t,r)=>{const s={};r.forEach((t=>e.faces_vertices[t].forEach((e=>{s[e]||(s[e]=[]),s[e].push(t)})))),e.faces_vertices[t].forEach((r=>{const o=e.vertices_faces[r].indexOf(t),a=s[r];if(-1===o||!a)throw new Error(i);e.vertices_faces[r].splice(o,1,...a)}))})(e,t,n),((e,t,r,s)=>{const o={};s.forEach((t=>e.faces_edges[t].forEach((e=>{o[e]||(o[e]=[]),o[e].push(t)})))),[...e.faces_edges[t],r].forEach((r=>{const s=o[r],a=[];for(let s=0;s<e.edges_faces[r].length;s+=1)e.edges_faces[r][s]===t&&a.push(s);if(0===a.length||!s)throw new Error(i);a.reverse().forEach((t=>e.edges_faces[r].splice(t,1)));const n=a[a.length-1];e.edges_faces[r].splice(n,0,...s)}))})(e,t,a.edges.new,n),(({faces_vertices:e,faces_faces:t},r,s)=>{const o=t[r],a=s.map((t=>e[t])),n=o.map((t=>{const r=e[t],o=[0,0];for(let e=0;e<a.length;e+=1){let t=0;for(let s=0;s<r.length;s+=1)-1!==a[e].indexOf(r[s])&&(t+=1);o[e]=t}return o[0]>=2?s[0]:o[1]>=2?s[1]:void 0}));s.forEach(((e,r,o)=>{t[e]=[o[(r+1)%s.length]]})),o.forEach(((e,s)=>{for(let o=0;o<t[e].length;o+=1)t[e][o]===r&&(t[e][o]=n[s],t[n[s]].push(e))}))})(e,t,n);const c=removeGeometryIndices(e,"faces",[t]);return n.forEach(((e,t)=>{n[t]=c[n[t]]})),c.splice(-2),c[t]=n,a.faces={map:c,new:n,remove:t},a},selfRelationalArraySubset=(e,t)=>{const r={};t.forEach((e=>{r[e]=!0}));const s=[];return t.forEach((t=>{s[t]=e[t].filter((e=>r[e]))})),s},subgraph=(e,t={})=>{const r={vertices:[],edges:[],faces:[],...t},s=Object.keys(r),o={...e};N.graph.forEach((e=>delete o[e])),delete o.file_frames;const a={};s.forEach((e=>{a[e]={}})),s.forEach((e=>r[e].forEach((t=>{a[e][t]=!0}))));const n={};return s.forEach((t=>{filterKeysWithPrefix(e,t).forEach((e=>{n[e]={}})),filterKeysWithSuffix(e,t).forEach((e=>{n[e]={}}))})),s.forEach((t=>{filterKeysWithPrefix(e,t).forEach((e=>{n[e].prefix=t})),filterKeysWithSuffix(e,t).forEach((e=>{n[e].suffix=t}))})),Object.keys(n).forEach((e=>{o[e]=[]})),Object.keys(n).forEach((t=>{const{prefix:s,suffix:c}=n[t];s&&c?r[s].forEach((r=>{o[t][r]=e[t][r].filter((e=>a[c][e]))})):s?r[s].forEach((r=>{o[t][r]=e[t][r]})):o[t]=c?e[t].map((e=>e.filter((e=>a[c][e])))):e[t]})),o},subgraphWithFaces=(e,t)=>{let r=[];e.faces_vertices&&(r=uniqueSortedNumbers(t.flatMap((t=>e.faces_vertices[t]))));let s=[];if(e.faces_edges)s=uniqueSortedNumbers(t.flatMap((t=>e.faces_edges[t])));else if(e.edges_vertices){const t={};r.forEach((e=>{t[e]=!0})),s=e.edges_vertices.map(((e,r)=>t[e[0]]&&t[e[1]]?r:void 0)).filter((e=>void 0!==e))}return subgraph(e,{vertices:r,edges:s,faces:t})};var Ee=Object.freeze({__proto__:null,selfRelationalArraySubset:selfRelationalArraySubset,subgraph:subgraph,subgraphWithFaces:subgraphWithFaces});const validate=(e,t)=>{const r=duplicateEdges(e),s=circularEdges(e),o=isolatedVertices(e),a=duplicateVertices(e,t),n=(e=>{const t=count.vertices(e),r=count.edges(e),s=count.faces(e);return{vertices:t>=countImplied.vertices(e),edges:r>=countImplied.edges(e),faces:s>=countImplied.faces(e)}})(e);return{summary:0===r.length&&0===s.length&&0===o.length&&n.vertices&&n.edges&&n.faces?"valid":"problematic",vertices:{isolated:o,duplicate:a,references:n.vertices},edges:{circular:s,duplicate:r,references:n.edges},faces:{references:n.faces}}},boundingBox=({vertices_coords:e},t)=>boundingBox$1(e,t),boundaryVertices=({edges_vertices:e,edges_assignment:t=[]})=>uniqueElements(e.filter(((e,r)=>U[t[r]])).flat()),boundary=({vertices_coords:e,vertices_edges:t,edges_vertices:r,edges_assignment:s})=>{if(!s||!r)return{vertices:[],edges:[],polygon:[]};t||(t=makeVerticesEdgesUnsorted({edges_vertices:r}));const o=s.map((e=>"B"===e||"b"===e)),a=[],n=[];let c=-1;for(let e=0;e<o.length;e+=1)if(o[e]){c=e;break}if(-1===c)return{vertices:[],edges:[],polygon:[]};o[c]=!1,a.push(c),n.push(r[c][0]);let i=r[c][1];for(;n[0]!==i;){if(n.push(i),c=t[i].filter((e=>o[e])).shift(),void 0===c)return{vertices:[],edges:[],polygon:[]};r[c][0]===i?[,i]=r[c]:[i]=r[c],o[c]=!1,a.push(c)}return{vertices:n,edges:a,polygon:e?n.map((t=>e[t])):[]}},planarBoundary=({vertices_coords:e,vertices_edges:t,vertices_vertices:r,edges_vertices:s})=>{r||(r=makeVerticesVertices({vertices_coords:e,vertices_edges:t,edges_vertices:s}));const o=makeVerticesToEdgeBidirectional({edges_vertices:s}),a=[],n=[],c={vertices:n,edges:a};let i=-1/0,l=-1;if(e.forEach(((e,t)=>{e[0]>i&&(i=e[0],l=t)})),-1===l)return c;n.push(l);const d=e[l],m=r[l];if(!m)return c;const g=m.map((t=>e[t])).map((e=>[e[0]-d[0],e[1]-d[1]])).map((e=>Math.atan2(e[1],e[0]))).map((e=>e<0?e+2*Math.PI:e)).map(((e,t)=>({a:e,i:t}))).sort(((e,t)=>e.a-t.a)).shift().i,p=m[g],v=o[l<p?`${l} ${p}`:`${p} ${l}`];a.push(v);let _=l,u=p;const h={[`${_} ${u}`]:!0};for(;;){const e=r[u],t=e.indexOf(_),s=e[(t+1)%e.length],i=o[u<s?`${u} ${s}`:`${s} ${u}`];if(h[`${u} ${s}`])return i!==a[0]&&console.warn("bad boundary"),c;h[`${u} ${s}`]=!0,n.push(u),a.push(i),_=u,u=s}};var Ae=Object.freeze({__proto__:null,boundary:boundary,boundaryVertices:boundaryVertices,boundingBox:boundingBox,planarBoundary:planarBoundary});const getFaceFaceSharedVertices=(e,t)=>{const r={};t.forEach((e=>{r[e]=!0}));const s=e.map((e=>!!r[e])),o=[],a=s.indexOf(!1),n={};for(let t=a+1;t<s.length;t+=1)s[t]&&!n[e[t]]&&(o.push(e[t]),n[e[t]]=!0);for(let t=0;t<a;t+=1)s[t]&&!n[e[t]]&&(o.push(e[t]),n[e[t]]=!0);return o};var xe=Object.freeze({__proto__:null,getFaceFaceSharedVertices:getFaceFaceSharedVertices});const minimumSpanningTrees=(e=[],t=0)=>{if(0===e.length)return[];const r=[],s={};e.forEach(((e,t)=>{s[t]=!0}));do{const o=void 0!==t?t:parseInt(Object.keys(s).shift(),10);t=void 0;const a=[];delete s[o];let n=[{index:o}];do{a.push(n);const t=n.flatMap((t=>e[t.index].filter((e=>s[e])).map((e=>({index:e,parent:t.index}))))),r={};t.forEach(((e,t)=>{s[e.index]||(r[t]=!0),delete s[e.index]})),n=t.filter(((e,t)=>!r[t]))}while(n.length);r.push(a)}while(Object.keys(s).length);return r},minimumSpanningTree=(e,t)=>minimumSpanningTrees(e,t).shift();var Me=Object.freeze({__proto__:null,minimumSpanningTree:minimumSpanningTree,minimumSpanningTrees:minimumSpanningTrees});const multiplyVerticesFacesMatrix2=({vertices_coords:e,vertices_faces:t,faces_vertices:r},s)=>{t||(t=makeVerticesFaces({faces_vertices:r}));const o=t.map((e=>e.filter((e=>null!=e)).shift())).map((e=>void 0===e?A:s[e]));return e.map(((e,t)=>multiplyMatrix2Vector2(o[t],e)))},ke={U:!0,u:!0},makeFacesMatrix=({vertices_coords:e,edges_vertices:t,edges_foldAngle:r,edges_assignment:s,faces_vertices:o,faces_faces:a},n=0)=>{!s&&r&&(s=makeEdgesAssignmentSimple({edges_foldAngle:r})),r||(r=s?makeEdgesFoldAngle({edges_assignment:s}):Array(t.length).fill(0)),a||(a=makeFacesFaces({faces_vertices:o}));const c=makeVerticesToEdgeBidirectional({edges_vertices:t}),i=o.map((()=>O));return minimumSpanningTrees(a,n).forEach((t=>t.slice(1).forEach((t=>t.forEach((t=>{const a=getFaceFaceSharedVertices(o[t.index],o[t.parent]).slice(0,2),n=a.map((t=>e[t])),l=a.join(" "),d=c[l],m=ke[s[d]]?Math.PI:r[d]*Math.PI/180,g=makeMatrix3Rotate(m,subtract(...resizeUp(n[1],n[0])),n[0]);i[t.index]=multiplyMatrices3(i[t.parent],g)})))))),i},makeFacesMatrix2=({vertices_coords:e,edges_vertices:t,edges_foldAngle:r,edges_assignment:s,faces_vertices:o,faces_faces:a},n=0)=>{r||(r=s?makeEdgesFoldAngle({edges_assignment:s}):Array(t.length).fill(0)),a||(a=makeFacesFaces({faces_vertices:o}));const c=makeEdgesIsFolded({edges_vertices:t,edges_foldAngle:r,edges_assignment:s}),i=makeVerticesToEdgeBidirectional({edges_vertices:t}),l=o.map((()=>A));return minimumSpanningTrees(a,n).forEach((t=>t.slice(1).forEach((t=>t.forEach((t=>{const r=getFaceFaceSharedVertices(o[t.index],o[t.parent]).slice(0,2),s=r.map((t=>e[t])),a=r.join(" "),n=i[a],d=subtract2(s[1],s[0]),m=s[0],g=c[n]?makeMatrix2Reflect(d,m):A;l[t.index]=multiplyMatrices2(l[t.parent],g)})))))),l};var Oe=Object.freeze({__proto__:null,makeFacesMatrix:makeFacesMatrix,makeFacesMatrix2:makeFacesMatrix2,multiplyVerticesFacesMatrix2:multiplyVerticesFacesMatrix2});const makeVerticesCoordsFolded=({vertices_coords:e,vertices_faces:t,edges_vertices:r,edges_foldAngle:s,edges_assignment:o,faces_vertices:a,faces_faces:n,faces_matrix:c},i)=>{c=makeFacesMatrix({vertices_coords:e,edges_vertices:r,edges_foldAngle:s,edges_assignment:o,faces_vertices:a,faces_faces:n},i),t||(t=makeVerticesFaces({faces_vertices:a}));const l=t.map((e=>e.filter((e=>null!=e)).shift())).map((e=>void 0===e?O:c[e]));return e.map((e=>resize(3,e))).map(((e,t)=>multiplyMatrix3Vector3(l[t],e)))},makeVerticesCoordsFlatFolded=({vertices_coords:e,edges_vertices:t,edges_foldAngle:r,edges_assignment:s,faces_vertices:o,faces_faces:a},n=0)=>{a||(a=makeFacesFaces({faces_vertices:o}));const c=makeEdgesIsFolded({edges_vertices:t,edges_foldAngle:r,edges_assignment:s}),i=[];o[n].forEach((t=>{i[t]=[...e[t]]}));const l=[];l[n]=!1;const d=makeVerticesToEdgeBidirectional({edges_vertices:t});return minimumSpanningTree(a,n).slice(1).forEach((r=>r.forEach((r=>{const s=getFaceFaceSharedVertices(o[r.index],o[r.parent]).slice(0,2).join(" "),a=d[s],n=t[a].map((e=>i[e]));if(void 0===n[0]||void 0===n[1])return;const m=t[a].map((t=>e[t])),g=m[0],p=normalize2(subtract2(m[1],m[0])),v=rotate90(p);l[r.index]=c[a]?!l[r.parent]:l[r.parent];const _=normalize2(subtract2(n[1],n[0])),u=n[0],h=l[r.index]?rotate270(_):rotate90(_);o[r.index].filter((e=>void 0===i[e])).forEach((t=>{const r=subtract2(e[t],g),s=dot(r,v),o=dot(r,p),a=scale2(_,o),n=scale2(h,s),c=add2(add2(u,a),n);i[t]=c}))})))),i};var we=Object.freeze({__proto__:null,makeVerticesCoordsFlatFolded:makeVerticesCoordsFlatFolded,makeVerticesCoordsFolded:makeVerticesCoordsFolded});const clone=function(e){let t,r;if("object"!=typeof e)return e;if(!e)return e;if("[object Array]"===Object.prototype.toString.apply(e)){for(t=[],r=0;r<e.length;r+=1)t[r]=clone(e[r]);return t}for(r in t={},e)e.hasOwnProperty(r)&&(t[r]=clone(e[r]));return t},je="class",Fe="function",Ce="undefined",Se="number",Pe="string",Ve="object",Ne="svg",ze="path",Te="id",$e="style",Be="viewBox",Le="transform",Ie="points",Ue="stroke",Re="none",qe="arrow",De="head",We="tail",Ge=typeof window!==Ce&&typeof window.document!==Ce;typeof process!==Ce&&null!=process.versions&&process.versions.node;const He="window not set; svg.window = @xmldom/xmldom",Je={window:void 0};Ge&&(Je.window=window);const SVGWindow=()=>{if(void 0===Je.window)throw He;return Je.window},Qe="http://www.w3.org/2000/svg",Ze={presentation:["color","color-interpolation","cursor","direction","display","fill","fill-opacity","fill-rule","font-family","font-size","font-size-adjust","font-stretch","font-style","font-variant","font-weight","image-rendering","letter-spacing","opacity","overflow","paint-order","pointer-events","preserveAspectRatio","shape-rendering","stroke","stroke-dasharray","stroke-dashoffset","stroke-linecap","stroke-linejoin","stroke-miterlimit","stroke-opacity","stroke-width","tabindex","transform-origin","user-select","vector-effect","visibility"],animation:["accumulate","additive","attributeName","begin","by","calcMode","dur","end","from","keyPoints","keySplines","keyTimes","max","min","repeatCount","repeatDur","restart","to","values"],effects:["azimuth","baseFrequency","bias","color-interpolation-filters","diffuseConstant","divisor","edgeMode","elevation","exponent","filter","filterRes","filterUnits","flood-color","flood-opacity","in","in2","intercept","k1","k2","k3","k4","kernelMatrix","lighting-color","limitingConeAngle","mode","numOctaves","operator","order","pointsAtX","pointsAtY","pointsAtZ","preserveAlpha","primitiveUnits","radius","result","seed","specularConstant","specularExponent","stdDeviation","stitchTiles","surfaceScale","targetX","targetY","type","xChannelSelector","yChannelSelector"],text:["dx","dy","alignment-baseline","baseline-shift","dominant-baseline","lengthAdjust","method","overline-position","overline-thickness","rotate","spacing","startOffset","strikethrough-position","strikethrough-thickness","text-anchor","text-decoration","text-rendering","textLength","underline-position","underline-thickness","word-spacing","writing-mode"],gradient:["gradientTransform","gradientUnits","spreadMethod"]},Ye={svg:["svg"],defs:["defs"],header:["desc","filter","metadata","style","script","title","view"],cdata:["cdata"],group:["g"],visible:["circle","ellipse","line","path","polygon","polyline","rect","arc","arrow","curve","parabola","roundRect","wedge","origami"],text:["text"],invisible:["marker","symbol","clipPath","mask"],patterns:["linearGradient","radialGradient","pattern"],childrenOfText:["textPath","tspan"],gradients:["stop"],filter:["feBlend","feColorMatrix","feComponentTransfer","feComposite","feConvolveMatrix","feDiffuseLighting","feDisplacementMap","feDistantLight","feDropShadow","feFlood","feFuncA","feFuncB","feFuncG","feFuncR","feGaussianBlur","feImage","feMerge","feMergeNode","feMorphology","feOffset","fePointLight","feSpecularLighting","feSpotLight","feTile","feTurbulence"]},Xe={svg:[Be],line:["x1","y1","x2","y2"],rect:["x","y","width","height"],circle:["cx","cy","r"],ellipse:["cx","cy","rx","ry"],polygon:[Ie],polyline:[Ie],path:["d"],text:["x","y"],mask:[Te],symbol:[Te],clipPath:[Te,"clip-rule"],marker:[Te,"markerHeight","markerUnits","markerWidth","orient","refX","refY"],linearGradient:["x1","x2","y1","y2"],radialGradient:["cx","cy","r","fr","fx","fy"],stop:["offset","stop-color","stop-opacity"],pattern:["patternContentUnits","patternTransform","patternUnits"]};[{nodes:[Ne,"defs","g"].concat(Ye.visible,Ye.text),attr:Ze.presentation},{nodes:["filter"],attr:Ze.effects},{nodes:Ye.childrenOfText.concat("text"),attr:Ze.text},{nodes:Ye.filter,attr:Ze.effects},{nodes:Ye.gradients,attr:Ze.gradient}].forEach((e=>e.nodes.forEach((t=>{Xe[t]||(Xe[t]=[]),Xe[t].push(...e.attr)}))));const Ke=[Ye.header,Ye.invisible,Ye.patterns].flat(),et=[Ye.group,Ye.visible,Ye.text].flat(),tt={svg:[["svg","defs"],Ke,et].flat(),defs:Ke,filter:Ye.filter,g:et,text:Ye.childrenOfText,marker:et,symbol:et,clipPath:et,mask:et,linearGradient:Ye.gradients,radialGradient:Ye.gradients},rt=Object.values(Ye).flat(),st={black:"#000000",silver:"#c0c0c0",gray:"#808080",white:"#ffffff",maroon:"#800000",red:"#ff0000",purple:"#800080",fuchsia:"#ff00ff",green:"#008000",lime:"#00ff00",olive:"#808000",yellow:"#ffff00",navy:"#000080",blue:"#0000ff",teal:"#008080",aqua:"#00ffff",orange:"#ffa500",aliceblue:"#f0f8ff",antiquewhite:"#faebd7",aquamarine:"#7fffd4",azure:"#f0ffff",beige:"#f5f5dc",bisque:"#ffe4c4",blanchedalmond:"#ffebcd",blueviolet:"#8a2be2",brown:"#a52a2a",burlywood:"#deb887",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",cornflowerblue:"#6495ed",cornsilk:"#fff8dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",darkkhaki:"#bdb76b",darkmagenta:"#8b008b",darkolivegreen:"#556b2f",darkorange:"#ff8c00",darkorchid:"#9932cc",darkred:"#8b0000",darksalmon:"#e9967a",darkseagreen:"#8fbc8f",darkslateblue:"#483d8b",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",darkturquoise:"#00ced1",darkviolet:"#9400d3",deeppink:"#ff1493",deepskyblue:"#00bfff",dimgray:"#696969",dimgrey:"#696969",dodgerblue:"#1e90ff",firebrick:"#b22222",floralwhite:"#fffaf0",forestgreen:"#228b22",gainsboro:"#dcdcdc",ghostwhite:"#f8f8ff",gold:"#ffd700",goldenrod:"#daa520",greenyellow:"#adff2f",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",indianred:"#cd5c5c",indigo:"#4b0082",ivory:"#fffff0",khaki:"#f0e68c",lavender:"#e6e6fa",lavenderblush:"#fff0f5",lawngreen:"#7cfc00",lemonchiffon:"#fffacd",lightblue:"#add8e6",lightcoral:"#f08080",lightcyan:"#e0ffff",lightgoldenrodyellow:"#fafad2",lightgray:"#d3d3d3",lightgreen:"#90ee90",lightgrey:"#d3d3d3",lightpink:"#ffb6c1",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",lightskyblue:"#87cefa",lightslategray:"#778899",lightslategrey:"#778899",lightsteelblue:"#b0c4de",lightyellow:"#ffffe0",limegreen:"#32cd32",linen:"#faf0e6",magenta:"#ff00ff",mediumaquamarine:"#66cdaa",mediumblue:"#0000cd",mediumorchid:"#ba55d3",mediumpurple:"#9370db",mediumseagreen:"#3cb371",mediumslateblue:"#7b68ee",mediumspringgreen:"#00fa9a",mediumturquoise:"#48d1cc",mediumvioletred:"#c71585",midnightblue:"#191970",mintcream:"#f5fffa",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",navajowhite:"#ffdead",oldlace:"#fdf5e6",olivedrab:"#6b8e23",orangered:"#ff4500",orchid:"#da70d6",palegoldenrod:"#eee8aa",palegreen:"#98fb98",paleturquoise:"#afeeee",palevioletred:"#db7093",papayawhip:"#ffefd5",peachpuff:"#ffdab9",peru:"#cd853f",pink:"#ffc0cb",plum:"#dda0dd",powderblue:"#b0e0e6",rosybrown:"#bc8f8f",royalblue:"#4169e1",saddlebrown:"#8b4513",salmon:"#fa8072",sandybrown:"#f4a460",seagreen:"#2e8b57",seashell:"#fff5ee",sienna:"#a0522d",skyblue:"#87ceeb",slateblue:"#6a5acd",slategray:"#708090",slategrey:"#708090",snow:"#fffafa",springgreen:"#00ff7f",steelblue:"#4682b4",tan:"#d2b48c",thistle:"#d8bfd8",tomato:"#ff6347",turquoise:"#40e0d0",violet:"#ee82ee",wheat:"#f5deb3",whitesmoke:"#f5f5f5",yellowgreen:"#9acd32"},hslToRgb=(e,t,r,s)=>{const o=r/100,k=t=>(t+e/30)%12,a=t/100*Math.min(o,1-o),f=e=>o-a*Math.max(-1,Math.min(k(e)-3,Math.min(9-k(e),1)));return void 0===s?[255*f(0),255*f(8),255*f(4)]:[255*f(0),255*f(8),255*f(4),s]},mapHexNumbers=(e,t)=>{const r=Array.from(Array(t.length)).map(((t,r)=>e[r]||"0"));return e.length<=4?t.map((e=>r[e])).join(""):r.join("")},hexToRgb=e=>{const t=e.replace(/#(?=\S)/g,""),r=4===t.length||8===t.length,s=mapHexNumbers(t,r?[0,0,1,1,2,2,3,3]:[0,0,1,1,2,2]),o=parseInt(s,16);return r?[o>>24&255,o>>16&255,o>>8&255,(a=(255&o)/256,Math.round(100*a)/100)]:[o>>16&255,o>>8&255,255&o];var a},rgbToHex=(e,t,r,s)=>{const to16=e=>`00${Math.max(0,Math.min(Math.round(e),255)).toString(16)}`.slice(-2),o=`#${[e,t,r].map(to16).join("")}`;return void 0===s?o:`${o}${to16(255*s)}`};const getParenNumbers=e=>{const t=e.match(/\(([^\)]+)\)/g);return null!=t&&t.length?t[0].substring(1,t[0].length-1).split(/[\s,]+/).map(parseFloat):[]},parseColorToRgb=e=>{if(st[e])return hexToRgb(st[e]);if("#"===e[0])return hexToRgb(e);if("rgba"===e.substring(0,4)||"rgb"===e.substring(0,3)){const t=getParenNumbers(e);return[0,1,2].filter((e=>void 0===t[e])).forEach((e=>{t[e]=0})),t}if("hsla"===e.substring(0,4)||"hsl"===e.substring(0,3)){const t=getParenNumbers(e);return[0,1,2].filter((e=>void 0===t[e])).forEach((e=>{t[e]=0})),hslToRgb(...t)}},parseColorToHex=e=>{if(st[e])return st[e].toUpperCase();if("#"===e[0])return rgbToHex(...hexToRgb(e));if("rgba"===e.substring(0,4)||"rgb"===e.substring(0,3))return rgbToHex(...getParenNumbers(e));if("hsla"===e.substring(0,4)||"hsl"===e.substring(0,3)){const t=getParenNumbers(e);[0,1,2].filter((e=>void 0===t[e])).forEach((e=>{t[e]=0}));const r=hslToRgb(...t);return 4===t.length&&r.push(t[3]),rgbToHex(...r)}};const ot={cssColors:st,...Object.freeze({__proto__:null,hexToRgb:hexToRgb,hslToRgb:hslToRgb,rgbToHex:rgbToHex}),...Object.freeze({__proto__:null,parseColorToHex:parseColorToHex,parseColorToRgb:parseColorToRgb})},svg_add2=(e,t)=>[e[0]+t[0],e[1]+t[1]],svg_sub2=(e,t)=>[e[0]-t[0],e[1]-t[1]],svg_scale2=(e,t)=>[e[0]*t,e[1]*t],svg_magnitudeSq2=e=>e[0]**2+e[1]**2,svg_magnitude2=e=>Math.sqrt(svg_magnitudeSq2(e)),svg_distanceSq2=(e,t)=>svg_magnitudeSq2(svg_sub2(e,t)),svg_distance2=(e,t)=>Math.sqrt(svg_distanceSq2(e,t)),svg_polar_to_cart=(e,t)=>[Math.cos(e)*t,Math.sin(e)*t],svg_multiplyMatrices2=(e,t)=>[e[0]*t[0]+e[2]*t[1],e[1]*t[0]+e[3]*t[1],e[0]*t[2]+e[2]*t[3],e[1]*t[2]+e[3]*t[3],e[0]*t[4]+e[2]*t[5]+e[4],e[1]*t[4]+e[3]*t[5]+e[5]];var at=Object.freeze({__proto__:null,svg_add2:svg_add2,svg_distance2:svg_distance2,svg_distanceSq2:svg_distanceSq2,svg_magnitude2:svg_magnitude2,svg_magnitudeSq2:svg_magnitudeSq2,svg_multiplyMatrices2:svg_multiplyMatrices2,svg_polar_to_cart:svg_polar_to_cart,svg_scale2:svg_scale2,svg_sub2:svg_sub2});const matrixForm=function(e,t){switch(e){case"translate":return function(e){switch(e.length){case 1:return[1,0,0,1,e[0],0];case 2:return[1,0,0,1,e[0],e[1]];default:console.warn(`improper translate, ${e}`)}}(t);case"rotate":return function(e){const t=Math.cos(e[0]/(180*Math.PI)),r=Math.sin(e[0]/(180*Math.PI));switch(e.length){case 1:return[t,r,-r,t,0,0];case 3:return[t,r,-r,t,-e[1]*t+e[2]*r+e[1],-e[1]*r-e[2]*t+e[2]];default:console.warn(`improper rotate, ${e}`)}}(t);case"scale":return function(e){switch(e.length){case 1:return[e[0],0,0,e[0],0,0];case 2:return[e[0],0,0,e[1],0,0];default:console.warn(`improper scale, ${e}`)}}(t);case"skewX":return function(e){return[1,0,Math.tan(e[0]/(180*Math.PI)),1,0,0]}(t);case"skewY":return function(e){return[1,Math.tan(e[0]/(180*Math.PI)),0,1,0,0]}(t);case"matrix":return t;default:console.warn(`unknown transform type ${e}`)}},transformStringToMatrix=function(e){return function(e){const t=e.match(/(\w+\((\-?\d+\.?\d*e?\-?\d*,?\s*)+\))+/g);return t?t.map((e=>e.match(/[\w\.\-]+/g))).map((e=>({transform:e.shift(),parameters:e.map((e=>parseFloat(e)))}))):[]}(e).map((e=>matrixForm(e.transform,e.parameters))).filter((e=>void 0!==e)).reduce(((e,t)=>svg_multiplyMatrices2(e,t)),[1,0,0,1,0,0])};var nt=Object.freeze({__proto__:null,transformStringToMatrix:transformStringToMatrix});const xmlStringToElement=(e,t="text/xml")=>{const r=(new(SVGWindow().DOMParser)).parseFromString(e,t);return r?r.documentElement:null},getRootParent=e=>{let t=e;for(;null!=t.parentNode;)t=t.parentNode;return t},findElementTypeInParents=(e,t)=>(e.nodeName||"")===t?e:e.parentNode?findElementTypeInParents(e.parentNode,t):void 0,addClass=(e,...t)=>{if(e&&t.length)return e.classList?e.classList.add(...t):((e,...t)=>{const r={},s=e.getAttribute("class"),o=s?s.split(" "):[];o.push(...t),o.forEach((e=>{r[e]=!0}));const a=Object.keys(r).join(" ");e.setAttribute("class",a)})(e,...t)},flattenDomTree=e=>null!=e.childNodes&&e.childNodes.length?Array.from(e.childNodes).flatMap((e=>flattenDomTree(e))):[e],ct={svg:["viewBox","xmlns","version"],line:["x1","y1","x2","y2"],rect:["x","y","width","height"],circle:["cx","cy","r"],ellipse:["cx","cy","rx","ry"],polygon:["points"],polyline:["points"],path:["d"]},attrAssign=(e,t)=>{const r=(e=>{const t={};return e.forEach((e=>{t[e.nodeName]=e.value})),t})((e=>{const t=e.attributes;if(null==t)return[];const r=Array.from(t);return ct[e.nodeName]?r.filter((t=>!ct[e.nodeName].includes(t.name))):r})(t));if(!r.transform&&!e.transform)return{...e,...r};const s=r.transform||"",o=e.transform||"",a=transformStringToMatrix(s),n=transformStringToMatrix(o),c=`matrix(${svg_multiplyMatrices2(n,a).join(", ")})`;return{...e,...r,transform:c}},flattenDomTreeWithStyle=(e,t={})=>null!=e.childNodes&&e.childNodes.length?Array.from(e.childNodes).flatMap((e=>flattenDomTreeWithStyle(e,attrAssign(t,e)))):[{element:e,attributes:t}];var it=Object.freeze({__proto__:null,addClass:addClass,findElementTypeInParents:findElementTypeInParents,flattenDomTree:flattenDomTree,flattenDomTreeWithStyle:flattenDomTreeWithStyle,getRootParent:getRootParent,xmlStringToElement:xmlStringToElement});const makeCDATASection=e=>(new(SVGWindow().DOMParser)).parseFromString("<root></root>","text/xml").createCDATASection(e),lt=/[MmLlSsQqLlHhVvCcSsQqTtAaZz]/g,ft=/-?[0-9]*\.?\d+/g,dt={m:"move",l:"line",v:"vertical",h:"horizontal",a:"ellipse",c:"curve",s:"smoothCurve",q:"quadCurve",t:"smoothQuadCurve",z:"close"};Object.keys(dt).forEach((e=>{const t=dt[e];dt[e.toUpperCase()]=t.charAt(0).toUpperCase()+t.slice(1)}));const add2path=(e,t)=>[e[0]+(t[0]||0),e[1]+(t[1]||0)],parsePathCommands=e=>{const t=[];let r;for(;null!==(r=lt.exec(e));)t.push(r);return t.map(((t,r,s)=>[t[0],t.index,r===s.length-1?e.length-1:s[(r+1)%s.length].index-1])).map((t=>{const r=t[0],s=e.substring(t[1]+1,t[2]+1).match(ft);return{command:r,values:s?s.map(parseFloat):[]}}))},parsePathCommandsWithEndpoints=e=>{let t=[0,0];const r=parsePathCommands(e);if(!r.length)return r;r.forEach(((e,s)=>{r[s].end=((e,t,r=[0,0])=>{const s=e.toUpperCase();let o=e===s?[0,0]:r;switch("V"===e&&(o=[r[0],0]),"H"===e&&(o=[0,r[1]]),s){case"V":return add2path(o,[0,t[0]]);case"H":return add2path(o,[t[0],0]);case"M":case"L":case"T":return add2path(o,t);case"A":return add2path(o,[t[5],t[6]]);case"C":return add2path(o,[t[4],t[5]]);case"S":case"Q":return add2path(o,[t[2],t[3]]);case"Z":return;default:return o}})(e.command,e.values,t),r[s].start=0===s?t:r[s-1].end,t=r[s].end}));const s=r[r.length-1],o=r.filter((e=>"M"!==e.command.toUpperCase()&&"Z"!==e.command.toUpperCase())).shift();return"Z"===s.command.toUpperCase()&&(s.end=[...o.start]),r};const makeCoordinates=(...e)=>e.filter((e=>typeof e===Se)).concat(e.filter((e=>typeof e===Ve&&null!==e)).map((e=>typeof e.x===Se?[e.x,e.y]:typeof e[0]===Se?[e[0],e[1]]:void 0)).filter((e=>void 0!==e)).reduce(((e,t)=>e.concat(t)),[])),makeViewBox=(...e)=>{const t=makeCoordinates(...e.flat());return 2===t.length&&t.unshift(0,0),4===t.length?function(e,t,r,s,o=0){const a=r/1-r;return[e-a-o,t-a-o,r+2*a+2*o,s+2*a+2*o].join(" ")}(...t):void 0},setViewBox=(e,...t)=>{const r=1===t.length&&typeof t[0]===Pe?t[0]:makeViewBox(...t);return r&&e.setAttribute(Be,r),e},getViewBox$1=function(e){const t=e.getAttribute(Be);return null==t?void 0:t.split(" ").map((e=>parseFloat(e)))},convertToViewBox=function(e,t,r){const s=e.createSVGPoint();s.x=t,s.y=r;const o=s.matrixTransform(e.getScreenCTM().inverse());return[o.x,o.y]};const mt={...at,...it,makeCDATASection:makeCDATASection,...Object.freeze({__proto__:null,parsePathCommands:parsePathCommands,parsePathCommandsWithEndpoints:parsePathCommandsWithEndpoints,pathCommandNames:dt}),...nt,...Object.freeze({__proto__:null,convertToViewBox:convertToViewBox,getViewBox:getViewBox$1,setViewBox:setViewBox})},getSVGFrame=function(e){const t=getViewBox$1(e);if(void 0!==t)return t;if(typeof e.getBoundingClientRect===Fe){const t=e.getBoundingClientRect();return[t.x,t.y,t.width,t.height]}return[]},gt="svg-background-rectangle",getAttr=e=>{const t=e.getAttribute(Le);return null==t||""===t?void 0:t},pt={clearTransform:e=>(e.removeAttribute(Le),e)};["translate","rotate","scale","matrix"].forEach((e=>{pt[e]=(t,...r)=>(t.setAttribute(Le,[getAttr(t),`${e}(${r.join(" ")})`].filter((e=>void 0!==e)).join(" ")),t)}));const toCamel=e=>e.replace(/([-_][a-z])/gi,(e=>e.toUpperCase().replace("-","").replace("_",""))),removeChildren=e=>{for(;e.lastChild;)e.removeChild(e.lastChild);return e},appendTo=(e,t)=>(t&&t.appendChild&&t.appendChild(e),e),setAttributes=(e,t)=>(Object.keys(t).forEach((r=>e.setAttribute(r.replace(/([a-z0-9])([A-Z])/g,"$1-$2").replace(/([A-Z])([A-Z])(?=[a-z])/g,"$1-$2").toLowerCase(),t[r]))),e);var vt=Object.freeze({__proto__:null,appendTo:appendTo,removeChildren:removeChildren,setAttributes:setAttributes});const stylesheet=function(e,t){let r=function(e,t){const r=e.getElementsByTagName(t);return r.length?r[0]:null}(e,$e);return null==r&&(r=SVGWindow().document.createElementNS(Qe,$e),r.setTextContent=e=>(r.textContent="",r.appendChild(makeCDATASection(e)),r),e.insertBefore(r,e.firstChild)),r.textContent="",r.appendChild(makeCDATASection(t)),r},_t={clear:e=>(Array.from(e.attributes).filter((e=>"xmlns"!==e.name&&"version"!==e.name)).forEach((t=>e.removeAttribute(t.name))),removeChildren(e)),size:setViewBox,setViewBox:setViewBox,getViewBox:getViewBox$1,padding:function(e,t){const r=getViewBox$1(e);return void 0!==r&&setViewBox(e,...[-t,-t,2*t,2*t].map(((e,t)=>r[t]+e))),e},background:function(e,t){let r=Array.from(e.childNodes).filter((e=>e.getAttribute(je)===gt)).shift();return null==r&&(r=SVGWindow().document.createElementNS(Qe,"rect"),getSVGFrame(e).forEach(((e,t)=>r.setAttribute(Xe.rect[t],e))),r.setAttribute(je,gt),r.setAttribute(Ue,Re),e.insertBefore(r,e.firstChild)),r.setAttribute("fill",t),e},getWidth:e=>getSVGFrame(e)[2],getHeight:e=>getSVGFrame(e)[3],stylesheet:function(e,t){return stylesheet.call(this,e,t)},...pt,...vt},ut={move:["mousemove","touchmove"],press:["mousedown","touchstart"],release:["mouseup","touchend"],leave:["mouseleave","touchcancel"]},defineGetter=(e,t,r)=>Object.defineProperty(e,t,{get:()=>r,enumerable:!0,configurable:!0}),TouchEvents=function(e){const t=[];Object.keys(ut).forEach((e=>{ut[e].forEach((e=>{t[e]=[]}))}));Object.keys(ut).forEach((r=>{var s;Object.defineProperty(e,`on${s=r,s.charAt(0).toUpperCase()+s.slice(1)}`,{set:s=>{e.addEventListener&&(null!=s?ut[r].forEach((r=>{const handlerFunc=t=>{const r=null!=t.touches?t.touches[0]:t;if(void 0!==r){const{clientX:s,clientY:o}=r,[a,n]=convertToViewBox(e,s,o);defineGetter(t,"x",a),defineGetter(t,"y",n)}s(t)};t[r].push(handlerFunc),e.addEventListener(r,handlerFunc)})):(r=>{ut[r].forEach((r=>t[r].forEach((t=>e.removeEventListener(r,t)))))})(r))},enumerable:!0})})),Object.defineProperty(e,"off",{value:()=>((e,t)=>Object.values(ut).flat().forEach((r=>{t[r].forEach((t=>e.removeEventListener(r,t))),t[r]=[]})))(e,t)})},makeUUID=()=>Math.random().toString(36).replace(/[^a-z]+/g,"").concat("aaaaa").substr(0,5),ht=[["cx","cy"],["x","y"]],controlPoint=function(e,t={}){const r=[0,0],s={selected:!1,svg:void 0,updatePosition:e=>e},updateSVG=()=>{s.svg&&(s.svg.parentNode||e.appendChild(s.svg),ht.filter((e=>null!=s.svg[e[0]])).forEach((e=>e.forEach(((e,t)=>{s.svg.setAttribute(e,r[t])})))))},o=new Proxy(r,{set:(e,t,r)=>(e[t]=r,updateSVG(),!0)}),setPosition=function(...e){makeCoordinates(...e.flat()).forEach(((e,t)=>{r[t]=e})),updateSVG(),typeof r.delegate===Fe&&r.delegate.apply(r.pointsContainer,[o,r.pointsContainer])};return r.delegate=void 0,r.setPosition=setPosition,r.onMouseMove=e=>s.selected?setPosition(s.updatePosition(e)):void 0,r.onMouseUp=()=>{s.selected=!1},r.distance=e=>Math.sqrt(svg_distanceSq2(e,r)),["x","y"].forEach(((e,t)=>Object.defineProperty(r,e,{get:()=>r[t],set:e=>{r[t]=e}}))),[Ne,"updatePosition","selected"].forEach((e=>Object.defineProperty(r,e,{get:()=>s[e],set:t=>{s[e]=t}}))),Object.defineProperty(r,"remove",{value:()=>{var e;(e=s.svg)&&e.parentNode&&e.parentNode.removeChild(e),r.delegate=void 0}}),o},controls=function(e,t,r){let s,o;const a=Array.from(Array(t)).map((()=>controlPoint(e,r))),protocol=e=>typeof o===Fe?o.call(a,e,s,a):void 0;a.forEach((e=>{e.delegate=protocol,e.pointsContainer=a}));e.onPress=function(e){a.length>0&&(s=a.map(((t,r)=>({i:r,d:svg_distanceSq2(t,[e.x,e.y])}))).sort(((e,t)=>e.d-t.d)).shift().i,a[s].selected=!0)},e.onMove=function(e){a.forEach((t=>t.onMouseMove(e)))},e.onRelease=function(){a.forEach((e=>e.onMouseUp())),s=void 0},Object.defineProperty(a,"selectedIndex",{get:()=>s}),Object.defineProperty(a,"selected",{get:()=>a[s]}),Object.defineProperty(a,"add",{value:t=>{a.push(controlPoint(e,t))}}),a.removeAll=()=>{for(;a.length>0;)a.pop().remove()};const n={onChange:(e,t)=>{if(o=e,!0===t){const t=a.length-1;e.call(a,a[t],t,a)}},position:e=>a.forEach(((t,r)=>t.setPosition(e.call(a,t,r,a)))),svg:e=>a.forEach(((t,r)=>{t.svg=e.call(a,t,r,a)}))};return Object.keys(n).forEach((e=>{a[e]=function(){return typeof arguments[0]===Fe&&n[e](...arguments),a}})),a.parent=function(e){return null!=e&&null!=e.appendChild&&a.forEach((t=>{e.appendChild(t.svg)})),a},a},applyControlsToSVG=e=>{e.controls=(...t)=>controls.call(e,e,...t)},bt={svg:{args:(...e)=>[makeViewBox(makeCoordinates(...e))].filter((e=>null!=e)),methods:_t,init:(...e)=>{const t=SVGWindow().document.createElementNS(Qe,"svg");return t.setAttribute("version","1.1"),t.setAttribute("xmlns",Qe),e.filter((e=>null!=e)).filter((e=>e.appendChild)).forEach((e=>e.appendChild(t))),TouchEvents(t),function(e){let t,r,s=0;const o={},stop=()=>{SVGWindow().cancelAnimationFrame&&SVGWindow().cancelAnimationFrame(r),Object.keys(o).forEach((e=>delete o[e]))};Object.defineProperty(e,"play",{set:e=>{if(stop(),!e||!SVGWindow().requestAnimationFrame)return;t=performance.now(),s=0;const a=makeUUID();o[a]=n=>{e({time:.001*(n-t),frame:s}),s+=1,o[a]&&(r=SVGWindow().requestAnimationFrame(o[a]))},r=SVGWindow().requestAnimationFrame(o[a])},enumerable:!0}),Object.defineProperty(e,"stop",{value:stop,enumerable:!0})}(t),applyControlsToSVG(t),t}}},yt={};["clip-path","mask","symbol","marker-end","marker-mid","marker-start"].forEach((e=>{yt[toCamel(e)]=(t,r)=>(t.setAttribute(e,function(e){if(null==e)return"";if(typeof e===Pe)return"url"===e.slice(0,3)?e:`url(#${e})`;if(null!=e.getAttribute)return`url(#${e.getAttribute(Te)})`;return""}(r)),t)}));const Et={g:{methods:{...pt,...yt,...vt}}},setRadius=(e,t)=>(e.setAttribute(Xe.circle[2],t),e),setOrigin$1=(e,t,r)=>([...makeCoordinates(...[t,r].flat()).slice(0,2)].forEach(((t,r)=>e.setAttribute(Xe.circle[r],t))),e),At={circle:{args:(e,t,r,s)=>{const o=makeCoordinates(...[e,t,r,s].flat());switch(o.length){case 0:case 1:return[,,...o];case 2:case 3:return o;default:return((e,t,r,s)=>[e,t,svg_distance2([e,t],[r,s])])(...o)}},methods:{radius:setRadius,setRadius:setRadius,origin:setOrigin$1,setOrigin:setOrigin$1,center:setOrigin$1,setCenter:setOrigin$1,position:setOrigin$1,setPosition:setOrigin$1,...pt,...yt,...vt}}},setRadii=(e,t,r)=>([,,t,r].forEach(((t,r)=>e.setAttribute(Xe.ellipse[r],t))),e),setOrigin=(e,t,r)=>([...makeCoordinates(...[t,r].flat()).slice(0,2)].forEach(((t,r)=>e.setAttribute(Xe.ellipse[r],t))),e),xt={ellipse:{args:(e,t,r,s)=>{const o=makeCoordinates(...[e,t,r,s].flat()).slice(0,4);switch(o.length){case 0:case 1:case 2:return[,,...o];default:return o}},methods:{radius:setRadii,setRadius:setRadii,origin:setOrigin,setOrigin:setOrigin,center:setOrigin,setCenter:setOrigin,position:setOrigin,setPosition:setOrigin,...pt,...yt,...vt}}},svgIsIterable=e=>null!=e&&typeof e[Symbol.iterator]===Fe,svgSemiFlattenArrays=function(){switch(arguments.length){case 0:return Array.from(arguments);case 1:return svgIsIterable(arguments[0])&&typeof arguments[0]!==Pe?svgSemiFlattenArrays(...arguments[0]):[arguments[0]];default:return Array.from(arguments).map((e=>svgIsIterable(e)?[...svgSemiFlattenArrays(e)]:e))}},Args$1=(...e)=>makeCoordinates(...svgSemiFlattenArrays(...e)).slice(0,4),Mt={line:{args:Args$1,methods:{setPoints:(e,...t)=>(Args$1(...t).forEach(((t,r)=>e.setAttribute(Xe.line[r],t))),e),...pt,...yt,...vt}}},getD=e=>{const t=e.getAttribute("d");return null==t?"":t},appendPathCommand=(e,t,...r)=>(e.setAttribute("d",`${getD(e)}${t}${r.flat().join(" ")}`),e),getCommands=e=>parsePathCommands(getD(e)),kt={addCommand:appendPathCommand,appendCommand:appendPathCommand,clear:e=>(e.removeAttribute("d"),e),getCommands:getCommands,get:getCommands,getD:e=>e.getAttribute("d"),...pt,...yt,...vt};Object.keys(dt).forEach((e=>{kt[dt[e]]=(t,...r)=>appendPathCommand(t,e,...r)}));const Ot={path:{methods:kt}},setRectSize=(e,t,r)=>([,,t,r].forEach(((t,r)=>e.setAttribute(Xe.rect[r],t))),e),setRectOrigin=(e,t,r)=>([...makeCoordinates(...[t,r].flat()).slice(0,2)].forEach(((t,r)=>e.setAttribute(Xe.rect[r],t))),e),fixNegatives=function(e){return[0,1].forEach((t=>{e[2+t]<0&&(void 0===e[0+t]&&(e[0+t]=0),e[0+t]+=e[2+t],e[2+t]=-e[2+t])})),e},wt={rect:{args:(e,t,r,s)=>{const o=makeCoordinates(...[e,t,r,s].flat()).slice(0,4);switch(o.length){case 0:case 1:case 2:case 3:return fixNegatives([,,...o]);default:return fixNegatives(o)}},methods:{origin:setRectOrigin,setOrigin:setRectOrigin,center:setRectOrigin,setCenter:setRectOrigin,size:setRectSize,setSize:setRectSize,...pt,...yt,...vt}}},jt={style:{init:e=>{const t=SVGWindow().document.createElementNS(Qe,"style");return t.setAttribute("type","text/css"),t.textContent="",t.appendChild(makeCDATASection(e)),t},methods:{setTextContent:(e,t)=>(e.textContent="",e.appendChild(makeCDATASection(t)),e)}}},Ft={text:{args:(e,t,r)=>makeCoordinates(...[e,t,r].flat()).slice(0,2),init:(e,t,r,s)=>{const o=SVGWindow().document.createElementNS(Qe,"text"),a=[e,t,r,s].filter((e=>typeof e===Pe)).shift();return o.appendChild(SVGWindow().document.createTextNode(a||"")),o},methods:{...pt,...yt,appendTo:appendTo,setAttributes:setAttributes}}},makeIDString=function(){return Array.from(arguments).filter((e=>typeof e===Pe||e instanceof String)).shift()||makeUUID()},maskArgs=(...e)=>[makeIDString(...e)],Ct={mask:{args:maskArgs,methods:{...pt,...yt,...vt}},clipPath:{args:maskArgs,methods:{...pt,...yt,...vt}},symbol:{args:maskArgs,methods:{...pt,...yt,...vt}},marker:{args:maskArgs,methods:{size:setViewBox,setViewBox:setViewBox,...pt,...yt,...vt}}},getPoints=e=>{const t=e.getAttribute(Ie);return null==t?"":t},polyString=function(){return Array.from(Array(Math.floor(arguments.length/2))).map(((e,t)=>`${arguments[2*t+0]},${arguments[2*t+1]}`)).join(" ")},stringifyArgs=(...e)=>[polyString(...makeCoordinates(...svgSemiFlattenArrays(...e)))],setPoints$2=(e,...t)=>(e.setAttribute(Ie,stringifyArgs(...t)[0]),e),addPoint=(e,...t)=>(e.setAttribute(Ie,[getPoints(e),stringifyArgs(...t)[0]].filter((e=>""!==e)).join(" ")),e),Args=function(...e){return 1===e.length&&typeof e[0]===Pe?[e[0]]:stringifyArgs(...e)},St={polyline:{args:Args,methods:{setPoints:setPoints$2,addPoint:addPoint,...pt,...yt,...vt}},polygon:{args:Args,methods:{setPoints:setPoints$2,addPoint:addPoint,...pt,...yt,...vt}}},arcPath=(e,t,r,s,o,a=!1)=>{if(null==o)return"";const n=svg_polar_to_cart(s,r),c=svg_polar_to_cart(o,r),i=[c[0]-n[0],c[1]-n[1]],l=n[0]*c[1]-n[1]*c[0],d=n[0]*c[0]+n[1]*c[1],m=Math.atan2(l,d)>0?0:1;let g=a?`M ${e},${t} l ${n[0]},${n[1]} `:`M ${e+n[0]},${t+n[1]} `;return g+=["a ",r,r,0,m,1,i[0],i[1]].join(" "),a&&(g+=" Z"),g},arcArguments=(e,t,r,s,o)=>[arcPath(e,t,r,s,o,!1)],Pt={arc:{nodeName:ze,attributes:["d"],args:arcArguments,methods:{setArc:(e,...t)=>e.setAttribute("d",arcArguments(...t)),...pt}}},Vt=[We,De],stringifyPoint=e=>e.join(","),pointsToPath=e=>"M"+e.map((e=>e.join(","))).join("L")+"Z",setArrowheadOptions=(e,t,r)=>{"boolean"==typeof t?e.options[r].visible=t:typeof t===Ve?(Object.assign(e.options[r],t),null==t.visible&&(e.options[r].visible=!0)):null==t&&(e.options[r].visible=!0)},setArrowStyle=(e,t={},r=De)=>{const s=e.getElementsByClassName(`${qe}-${r}`)[0];Object.keys(t).map((e=>({key:e,fn:s[toCamel(e)]}))).filter((e=>typeof e.fn===Fe&&"class"!==e.key)).forEach((e=>e.fn(t[e.key]))),Object.keys(t).filter((e=>"class"===e)).forEach((e=>s.classList.add(t[e])))},redraw=e=>{const t=function(e){let t=[[0,1],[2,3]].map((t=>t.map((t=>e.points[t]||0)))),r=svg_sub2(t[1],t[0]),s=svg_add2(t[0],svg_scale2(r,.5));const o=svg_magnitude2(r),a=Vt.map((t=>e[t].visible?(1+e[t].padding)*e[t].height*2.5:0)).reduce(((e,t)=>e+t),0);if(o<a){const e=0===o?[a,0]:svg_scale2(r,a/o);t=[svg_sub2,svg_add2].map((t=>t(s,svg_scale2(e,.5)))),r=svg_sub2(t[1],t[0])}let n=[r[1],-r[0]],c=svg_add2(s,svg_scale2(n,e.bend));const i=t.map((e=>svg_sub2(c,e))),l=i.map((e=>svg_magnitude2(e))),d=i.map(((e,t)=>0===l[t]?e:svg_scale2(e,1/l[t]))),m=d.map((e=>svg_scale2(e,-1))),g=m.map((e=>[e[1],-e[0]])),p=Vt.map(((t,r)=>e[t].padding?e[t].padding:e.padding?e.padding:0)),v=Vt.map(((t,r)=>e[t].height*(e[t].visible?1:0))).map(((e,t)=>e+p[t])),_=t.map(((e,t)=>svg_add2(e,svg_scale2(d[t],v[t]))));r=svg_sub2(_[1],_[0]),n=[r[1],-r[0]],s=svg_add2(_[0],svg_scale2(r,.5)),c=svg_add2(s,svg_scale2(n,e.bend));const u=_.map(((t,r)=>svg_add2(t,svg_scale2(svg_sub2(c,t),e.pinch)))),h=Vt.map(((t,r)=>[svg_add2(_[r],svg_scale2(m[r],e[t].height)),svg_add2(_[r],svg_scale2(g[r],e[t].width/2)),svg_add2(_[r],svg_scale2(g[r],-e[t].width/2))]));return{line:`M${stringifyPoint(_[0])}C${stringifyPoint(u[0])},${stringifyPoint(u[1])},${stringifyPoint(_[1])}`,tail:pointsToPath(h[0]),head:pointsToPath(h[1])}}(e.options);return Object.keys(t).map((t=>({path:t,element:e.getElementsByClassName(`${qe}-${t}`)[0]}))).filter((e=>e.element)).map((e=>(e.element.setAttribute("d",t[e.path]),e))).filter((t=>e.options[t.path])).forEach((t=>t.element.setAttribute("visibility",e.options[t.path].visible?"visible":"hidden"))),e},setPoints$1=(e,...t)=>(e.options.points=makeCoordinates(...svgSemiFlattenArrays(...t)).slice(0,4),redraw(e)),Nt={setPoints:setPoints$1,points:setPoints$1,bend:(e,t)=>(e.options.bend=t,redraw(e)),pinch:(e,t)=>(e.options.pinch=t,redraw(e)),padding:(e,t)=>(e.options.padding=t,redraw(e)),head:(e,t)=>(setArrowheadOptions(e,t,De),setArrowStyle(e,t,De),redraw(e)),tail:(e,t)=>(setArrowheadOptions(e,t,We),setArrowStyle(e,t,We),redraw(e)),getLine:e=>e.getElementsByClassName(`${qe}-line`)[0],getHead:e=>e.getElementsByClassName(`${qe}-${De}`)[0],getTail:e=>e.getElementsByClassName(`${qe}-${We}`)[0],...pt},zt=Object.keys({head:{visible:!1,width:8,height:10,padding:0},tail:{visible:!1,width:8,height:10,padding:0},bend:0,padding:0,pinch:.618,points:[]}),Tt={arrow:{nodeName:"g",attributes:[],args:()=>[],methods:Nt,init:function(e,...t){e.classList.add(qe);const r=["line",We,De].map((t=>{const r=SVGWindow().document.createElementNS(Qe,ze);return r.className=`${qe}-${t}`,e.appendChild(r),r}));r[0].setAttribute($e,"fill:none;"),r[1].setAttribute(Ue,Re),r[2].setAttribute(Ue,Re),e.options={head:{visible:!1,width:8,height:10,padding:0},tail:{visible:!1,width:8,height:10,padding:0},bend:0,padding:0,pinch:.618,points:[]},Nt.setPoints(e,...t);const s=((...e)=>{for(let t=0;t<e.length;t+=1){if(typeof e[t]!==Ve)continue;const r=Object.keys(e[t]);for(let s=0;s<r.length;s+=1)if(zt.includes(r[s]))return e[t]}})(...t);return s&&Object.keys(s).filter((e=>Nt[e])).forEach((t=>Nt[t](e,s[t]))),e}}},makeCurvePath=(e=[],t=0,r=.5)=>{const s=[e[0]||0,e[1]||0],o=[e[2]||0,e[3]||0],a=svg_sub2(o,s),n=svg_add2(s,svg_scale2(a,.5)),c=[a[1],-a[0]],i=svg_add2(n,svg_scale2(c,t)),l=svg_add2(s,svg_scale2(svg_sub2(i,s),r)),d=svg_add2(o,svg_scale2(svg_sub2(i,o),r));return`M${s[0]},${s[1]}C${l[0]},${l[1]} ${d[0]},${d[1]} ${o[0]},${o[1]}`},getNumbersFromPathCommand=e=>e.slice(1).split(/[, ]+/).map((e=>parseFloat(e))),getCurveEndpoints=e=>{const t=(e=>e.match(/[Mm][(0-9), .-]+/).map((e=>getNumbersFromPathCommand(e))))(e).shift(),r=(e=>e.match(/[Cc][(0-9), .-]+/).map((e=>getNumbersFromPathCommand(e))))(e).shift();return[...t?[t[t.length-2],t[t.length-1]]:[0,0],...r?[r[r.length-2],r[r.length-1]]:[0,0]]},setPoints=(e,...t)=>{const r=makeCoordinates(...t.flat()).slice(0,4);return e.setAttribute("d",makeCurvePath(r,e._bend,e._pinch)),e},$t={setPoints:setPoints,bend:(e,t)=>(e._bend=t,setPoints(e,...getCurveEndpoints(e.getAttribute("d")))),pinch:(e,t)=>(e._pinch=t,setPoints(e,...getCurveEndpoints(e.getAttribute("d")))),...pt},Bt={curve:{nodeName:ze,attributes:["d"],args:(...e)=>[makeCurvePath(makeCoordinates(...e.flat()))],methods:$t}},wedgeArguments=(e,t,r,s,o)=>[arcPath(e,t,r,s,o,!0)],Lt={wedge:{nodeName:ze,args:wedgeArguments,attributes:["d"],methods:{setArc:(e,...t)=>e.setAttribute("d",wedgeArguments(...t)),...pt}}},It={},Ut={origami:{nodeName:"g",init:(e,...t)=>{const r=SVGWindow().document.createElementNS(Qe,"g");return It.ear.convert.foldToSvg.render(e,r,...t),r},args:()=>[],methods:{...pt,...yt,...vt}}},Rt={...bt,...Et,...At,...xt,...Mt,...Ot,...wt,...jt,...Ft,...Ct,...St,...Pt,...Tt,...Bt,...Lt,...Ut},passthroughArgs=(...e)=>e,Constructor=(e,t,...r)=>{const s=Rt[e]&&Rt[e].nodeName?Rt[e].nodeName:e,{init:o,args:a,methods:n}=Rt[e]||{},c=Xe[s]||[],i=tt[s]||[],l=o?o(...r):SVGWindow().document.createElementNS(Qe,s);t&&t.appendChild(l);return(a||passthroughArgs)(...r).forEach(((e,t)=>{l.setAttribute(Xe[s][t],e)})),n&&Object.keys(n).forEach((e=>Object.defineProperty(l,e,{value:function(){return n[e](l,...arguments)}}))),c.forEach((e=>{const t=toCamel(e);l[t]||Object.defineProperty(l,t,{value:function(){return l.setAttribute(e,...arguments),l}})})),i.forEach((e=>{if(l[e])return;Object.defineProperty(l,e,{value:function(){return Constructor(e,l,...arguments)}})})),l},SVG=(...e)=>{const t=Constructor(Ne,null,...e),initialize=()=>e.filter((e=>typeof e===Fe)).forEach((e=>e.call(t,t)));return"loading"===SVGWindow().document.readyState?SVGWindow().document.addEventListener("DOMContentLoaded",initialize):initialize(),t};Object.assign(SVG,{NS:Qe,nodes_attributes:Xe,nodes_children:tt,extensions:Rt,...ot,...mt}),rt.forEach((e=>{SVG[e]=(...t)=>Constructor(e,null,...t)})),Object.defineProperty(SVG,"window",{enumerable:!1,set:e=>(e.document||(e.document=(e=>(new e.DOMParser).parseFromString("<!DOCTYPE html><title>.</title>","text/html"))(e)),Je.window=e,Je.window)});const boundingBoxToViewBox=e=>[e.min,e.span].flatMap((e=>[e[0],e[1]])).join(" "),qt={min:[0,0],span:[1,1]},getStrokeWidth=(e,{vmax:t}={})=>{if(!t){const r=boundingBox(e)||qt;t=Math.max(...r.span)}const r=(({vertices_coords:e,edges_vertices:t,edges_length:r},s=.1)=>{if(!e||!t)return;r||(r=makeEdgesLength({vertices_coords:e,edges_vertices:t}));const o=r.slice().sort(((e,t)=>e-t));return o[Math.max(0,Math.min(Math.floor(o.length*s),o.length-1))]})(e,.1);return r?.01*r*10:.01*t},Dt={},Wt={stroke:"black"},Gt={},Ht={B:{stroke:"black"},b:{stroke:"black"},M:{stroke:"crimson"},m:{stroke:"crimson"},V:{stroke:"royalblue"},v:{stroke:"royalblue"},F:{stroke:"lightgray"},f:{stroke:"lightgray"},J:{stroke:"gold"},j:{stroke:"gold"},C:{stroke:"limegreen"},c:{stroke:"limegreen"},U:{stroke:"orchid"},u:{stroke:"orchid"}},setDataValue$1=(e,t,r)=>e.setAttribute(`data-${t}`,r),edgesPathData=e=>(({vertices_coords:e,edges_vertices:t})=>e&&t?t.map((t=>t.map((t=>e[t])))):[])(e).map((e=>{return`M${(t=e)[0][0]} ${t[0][1]}L${t[1][0]} ${t[1][1]}`;var t})).join(""),edgesPathsAssign=({vertices_coords:e,edges_vertices:t,edges_assignment:r})=>{const s=(({vertices_coords:e,edges_vertices:t,edges_assignment:r})=>{if(!e||!t)return{};if(!r)return{u:edgesPathData({vertices_coords:e,edges_vertices:t})};const s=(e=>{const t={u:[],c:[],j:[],f:[],v:[],m:[],b:[]},r=e.edges_assignment.map((e=>e.toLowerCase()));return e.edges_vertices.map(((e,t)=>r[t]||"u")).forEach(((e,r)=>t[e].push(r))),t})({vertices_coords:e,edges_vertices:t,edges_assignment:r});return Object.keys(s).forEach((r=>{s[r]=edgesPathData({vertices_coords:e,edges_vertices:s[r].map((e=>t[e]))})})),Object.keys(s).forEach((e=>{""===s[e]&&delete s[e]})),s})({vertices_coords:e,edges_vertices:t,edges_assignment:r});return Object.keys(s).forEach((e=>{const t=SVG.path(s[e]);addClass(t,B[e]),s[e]=t})),s},applyEdgesStyle=(e,t={})=>Object.keys(t).forEach((r=>e.setAttributeNS(null,r,t[r]))),edgesPaths=(e,t={})=>{const r=SVG.g();if(!e)return r;const s=isFoldedForm(e),o=edgesPathsAssign(e);return Object.keys(o).forEach((e=>{addClass(o[e],B[e]),applyEdgesStyle(o[e],s?Gt[e]:Ht[e]),applyEdgesStyle(o[e],t[e]),applyEdgesStyle(o[e],t[B[e]]),r.appendChild(o[e]),Object.defineProperty(r,B[e],{get:()=>o[e]})})),Object.keys(o).forEach((e=>setDataValue$1(o[e],"assignment",e))),Object.keys(o).forEach((e=>setDataValue$1(o[e],"foldAngle",L[e]))),applyEdgesStyle(r,s?Dt:Wt),applyEdgesStyle(r,t.stroke?{stroke:t.stroke}:{}),r},edgesLines=(e,t={})=>{const r=SVG.g();if(!e)return r;const s=isFoldedForm(e),o=(e.edges_assignment?e.edges_assignment:makeEdgesAssignment(e)).map((e=>e.toLowerCase())),a={};["b","m","v","f","j","c","u"].forEach((e=>{const o=SVG.g();r.appendChild(o),addClass(o,B[e]),applyEdgesStyle(o,s?Gt[e]:Ht[e]),applyEdgesStyle(o,t[B[e]]),Object.defineProperty(r,B[e],{get:()=>o}),a[e]=o}));const n=e.edges_vertices.map((t=>t.map((t=>e.vertices_coords[t])))).map((e=>SVG.line(e[0][0],e[0][1],e[1][0],e[1][1])));return e.edges_foldAngle&&e.edges_foldAngle.forEach(((e,t)=>setDataValue$1(n[t],"foldAngle",e))),e.edges_assignment&&e.edges_assignment.forEach(((e,t)=>setDataValue$1(n[t],"assignment",e))),e.edges_foldAngle&&n.forEach(((t,r)=>{const s=e.edges_foldAngle[r];var o;0!==s&&180!==s&&-180!==s&&t.setAttributeNS(null,"opacity",(o=s,Math.abs(o)/180))})),n.forEach(((e,t)=>a[o[t]].appendChild(e))),applyEdgesStyle(r,s?Dt:Wt),applyEdgesStyle(r,t.stroke?{stroke:t.stroke}:{}),r},makeFacesWindingFromMatrix2=e=>e.map((e=>e[0]*e[3]-e[1]*e[2])).map((e=>e>=0)),makeFacesWinding=({vertices_coords:e,faces_vertices:t})=>t.map((t=>t.map((t=>e[t])).map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>(e[1][0]-e[0][0])*(e[1][1]+e[0][1]))).reduce(((e,t)=>e+t),0))).map((e=>e<0));var Jt=Object.freeze({__proto__:null,makeFacesWinding:makeFacesWinding,makeFacesWindingFromMatrix:e=>e.map((e=>e[0]*e[4]-e[1]*e[3])).map((e=>e>=0)),makeFacesWindingFromMatrix2:makeFacesWindingFromMatrix2});const topologicalSort=e=>{const t=uniqueSortedNumbers(e.flat()),r=[];t.forEach((e=>{r[e]=[]})),e.forEach((e=>{r[e[1]].push(e[0])}));const s=[],o={},recurse=e=>{o[e]||(o[e]=!0,r[e].forEach(recurse),s.push(e))};return t.forEach(recurse),s};var Qt=Object.freeze({__proto__:null,topologicalSort:topologicalSort});const connectedComponents=e=>{const t=[],recurse=(r,s)=>void 0!==t[r]?0:(t[r]=s,e[r].forEach((e=>recurse(e,s))),1);for(let t=0,r=0;t<e.length;t+=1)t in e&&(r+=recurse(t,r));return t},faceOrdersSubset=(e,t)=>{const r={};return t.forEach((e=>{r[e]=!0})),e.filter((e=>r[e[0]]&&r[e[1]]))},linearizeFaceOrders=({vertices_coords:e,faces_vertices:t,faceOrders:r,faces_normal:s})=>{if(!r||!r.length)return[];s||(s=makeFacesNormal({vertices_coords:e,faces_vertices:t}));const o=r.flatMap((e=>[e[0],e[1]])),a=uniqueSortedNumbers(o),n=[];a.forEach((e=>{n[e]=dot(s[e],s[a[0]])>0}));const c=r.map((e=>-1===e[2]^!n[e[1]]?[e[0],e[1]]:[e[1],e[0]]));return topologicalSort(c)},nudgeFacesWithFaceOrders=({vertices_coords:e,faces_vertices:t,faceOrders:r})=>{const s=makeFacesNormal({vertices_coords:e,faces_vertices:t}),o=connectedComponents(makeVerticesVerticesUnsorted({edges_vertices:r.map((e=>[e[0],e[1]]))})),a=invertMap(o).map((e=>e.constructor===Array?e:[e])),n=a.map((e=>faceOrdersSubset(r,e))).map((e=>linearizeFaceOrders({faceOrders:e,faces_normal:s}))),c=a.map((e=>s[e[0]])),i=[];return n.forEach(((e,t)=>e.forEach(((e,r)=>{i[e]={vector:c[t],layer:r}})))),i},nudgeFacesWithFacesLayer=({faces_layer:e})=>{const t=[];return invertMap(e).forEach(((e,r)=>{t[e]={vector:[0,0,1],layer:r}})),t};var Zt=Object.freeze({__proto__:null,faceOrdersSubset:faceOrdersSubset,linearizeFaceOrders:linearizeFaceOrders,makeFacesLayer:({vertices_coords:e,faces_vertices:t,faceOrders:r,faces_normal:s})=>(s||(s=makeFacesNormal({vertices_coords:e,faces_vertices:t})),invertMap(linearizeFaceOrders({faceOrders:r,faces_normal:s}))),nudgeFacesWithFaceOrders:nudgeFacesWithFaceOrders,nudgeFacesWithFacesLayer:nudgeFacesWithFacesLayer});const Yt={back:{fill:"white"},front:{fill:"#ddd"}},Xt={back:{opacity:.1},front:{opacity:.1}},Kt={},er={stroke:"black","stroke-linejoin":"bevel"},tr={stroke:"none",fill:"black","stroke-linejoin":"bevel"},rr={fill:"none"},fillInMissingFaces=(e,t)=>e.faces_vertices.map(((e,t)=>t)).filter((e=>null==t[e])).concat(invertMap(t)),applyFacesStyle=(e,t={})=>Object.keys(t).forEach((r=>e.setAttributeNS(null,r,t[r]))),finalize_faces=(e,t,r,s)=>{const o=isFoldedForm(e),a=!(!e.faceOrders&&!e.faces_layer),n=[["front"],["back"]],c=makeFacesWinding(e);return c.map((e=>e?n[0]:n[1])).forEach(((e,r)=>{var n,c,i;addClass(t[r],e),n=t[r],c="side",i=e,n.setAttribute(`data-${c}`,i),applyFacesStyle(t[r],o?a?Yt[e]:Xt[e]:Kt[e]),applyFacesStyle(t[r],s[e])})),(e=>e.faceOrders?fillInMissingFaces(e,invertMap(linearizeFaceOrders(e))):e.faces_layer?fillInMissingFaces(e,e.faces_layer):e.faces_vertices.map(((e,t)=>t)).filter((()=>!0)))(e).forEach((e=>r.appendChild(t[e]))),Object.defineProperty(r,"front",{get:()=>t.filter(((e,t)=>c[t]))}),Object.defineProperty(r,"back",{get:()=>t.filter(((e,t)=>!c[t]))}),applyFacesStyle(r,o?a?er:tr:rr),r},facesVerticesPolygon=(e,t={})=>{const r=SVG.g();if(!e||!e.vertices_coords||!e.faces_vertices)return r;const s=e.faces_vertices.map((t=>t.map((t=>[0,1].map((r=>e.vertices_coords[t][r])))))).map((e=>SVG.polygon(e)));return s.forEach(((e,t)=>e.setAttributeNS(null,"index",t))),r.setAttributeNS(null,"fill","white"),finalize_faces(e,s,r,t)},facesEdgesPolygon=function(e,t={}){const r=SVG.g();if(!e||"faces_edges"in e==!1||"edges_vertices"in e==!1||"vertices_coords"in e==!1)return r;const s=e.faces_edges.map((t=>t.map((t=>e.edges_vertices[t])).map(((e,t,r)=>{const s=r[(t+1)%r.length];return e[1]===s[0]||e[1]===s[1]?e[0]:e[1]})).map((t=>[0,1].map((r=>e.vertices_coords[t][r])))))).map((e=>SVG.polygon(e)));return s.forEach(((e,t)=>e.setAttributeNS(null,"index",t))),r.setAttributeNS(null,"fill","white"),finalize_faces(e,s,r,t)},sr={fill:"none"},or={stroke:"black",fill:"white"};var ar={vertices:(e,t={})=>{const r=SVG.g();return e&&e.vertices_coords?(e.vertices_coords.map((e=>SVG.circle(e[0],e[1],.01))).forEach((e=>r.appendChild(e))),r.setAttributeNS(null,"fill","none"),Object.keys(t).forEach((e=>r.setAttributeNS(null,e,t[e]))),r):r},edges:(e,t)=>edgesFoldAngleAreAllFlat(e)?edgesPaths(e,t):edgesLines(e,t),faces:(e,t)=>e&&e.faces_vertices?facesVerticesPolygon(e,t):e&&e.faces_edges?facesEdgesPolygon(e,t):SVG.g(),boundaries:(e,t={})=>{const r=SVG.g();if(!e)return r;const s=boundary(e).polygon;if(!s.length)return r;const o=SVG.polygon(s);return addClass(o,"boundary"),r.appendChild(o),((e,t={})=>{Object.keys(t).forEach((r=>e.setAttributeNS(null,r,t[r])))})(r,isFoldedForm(e)?sr:or),Object.keys(t).forEach((e=>r.setAttributeNS(null,e,t[e]))),r},edgesPaths:edgesPaths,edgesLines:edgesLines,facesVerticesPolygon:facesVerticesPolygon,facesEdgesPolygon:facesEdgesPolygon};const nr={min:[0,0],span:[1,1]},cr=["boundaries","faces","edges","vertices"],render=(e,t,r={})=>{isFoldedForm(e)||void 0===r.faces&&(r.faces=!1);const s=((e,t={})=>cr.map((r=>!1===t[r]?SVG.g():ar[r](e,t))).map(((e,t)=>(addClass(e,cr[t]),e))))(e,r);return s.filter((e=>e.childNodes.length>0)).forEach((e=>t.appendChild(e))),((e,t,r,s)=>{const o=t[3]&&t[3].childNodes.length;if(!(s.strokeWidth||s.viewBox||o))return;const a=boundingBox(r)||nr,n=Math.max(...a.span),c=findElementTypeInParents(e,"svg");if(c&&s.viewBox){const e=boundingBoxToViewBox(a);c.setAttributeNS(null,"viewBox",e)}if(c&&s.padding){const e=c.getAttribute("viewBox");if(null!=e){const t=s.padding*n,r=e.split(" ").map((e=>parseFloat(e))),o=[-t,-t,2*t,2*t].map(((e,t)=>r[t]+e)).join(" ");c.setAttributeNS(null,"viewBox",o)}}if(s.strokeWidth||s["stroke-width"]){const t=s.strokeWidth?s.strokeWidth:s["stroke-width"],o="number"==typeof t?n*t:getStrokeWidth(r);e.setAttributeNS(null,"stroke-width",o)}if(o){const e=s.vertices&&null!=s.vertices.radius?s.vertices.radius:s.radius,r="string"==typeof e?parseFloat(e):e,o="number"!=typeof r||Number.isNaN(r)?.02*n:n*r;((e,t)=>{for(let r=0;r<e.childNodes.length;r+=1)e.childNodes[r].setAttributeNS(null,"r",t)})(t[3],o)}})(t,s,e,r),addClass(t,...[e.file_classes||[],e.frame_classes||[]].flat()),t},foldToSvg=(e,t={})=>{const r=render("string"==typeof e?JSON.parse(e):e,SVG.svg(),{viewBox:!0,strokeWidth:!0,...t});return t&&t.string?(new(RabbitEarWindow().XMLSerializer)).serializeToString(r):r};Object.assign(foldToSvg,{...ar,render:render,getViewBox:e=>{const t=boundingBox(e);return void 0===t?"":boundingBoxToViewBox(t)},getStrokeWidth:getStrokeWidth,boundingBoxToViewBox:boundingBoxToViewBox});const foldToObj=e=>{const t="string"==typeof e?JSON.parse(e):e,r=(e=>["file_title","file_author","file_description","frame_title","frame_author","frame_description"].filter((t=>e[t])).map((t=>`# ${t.split("_")[1]}: ${e[t]}`)).join("\n"))(t);return`${[r,(t.vertices_coords||[]).map((e=>e.join(" "))).map((e=>`v ${e}`)).join("\n"),(t.faces_vertices||[]).map((e=>e.map((e=>e+1)).join(" "))).map((e=>`f ${e}`)).join("\n")].filter((e=>""!==e)).join("\n")}\n`},ir={};ir.prototype=Object.create(Object.prototype),ir.prototype.constructor=ir,Object.entries({clean:clean,validate:validate,populate:populate,subgraph:subgraph,boundary:boundary,boundingBox:boundingBox,nearest:nearest,splitEdge:splitEdge,splitFace:splitFace,invertAssignments:invertAssignments,svg:foldToSvg,obj:foldToObj,...fe,...W}).forEach((([e,t])=>{ir.prototype[e]=function(){return t(this,...arguments)}})),ir.prototype.clone=function(){return Object.assign(Object.create(Object.getPrototypeOf(this)),clone(this))},ir.prototype.folded=function(){const e=this.faces_matrix2?multiplyVerticesFacesMatrix2(this,this.faces_matrix2):makeVerticesCoordsFolded(this,...arguments);return{...this,vertices_coords:e,frame_classes:["foldedForm"]}},ir.prototype.flatFolded=function(){const e=this.faces_matrix2?multiplyVerticesFacesMatrix2(this,this.faces_matrix2):makeVerticesCoordsFlatFolded(this,...arguments);return{...this,vertices_coords:e,frame_classes:["foldedForm"]}};const setAssignment=(e,t,r,s)=>(t.forEach((t=>{e.edges_assignment[t]=r,e.edges_foldAngle[t]=s})),t);ir.prototype.setValley=function(e=[],t=180){return setAssignment(this,e,"V",Math.abs(t))},ir.prototype.setMountain=function(e=[],t=-180){return setAssignment(this,e,"M",-Math.abs(t))},ir.prototype.setFlat=function(e=[]){return setAssignment(this,e,"F",0)},ir.prototype.setUnassigned=function(e=[]){return setAssignment(this,e,"U",0)},ir.prototype.setCut=function(e=[]){return setAssignment(this,e,"C",0)};var lr=ir.prototype;const linePointFromParameter=(e,t,r)=>add2(t,scale2(e,r)),getIntersectParameters=(e,t,r,s,o)=>e.map(((e,t,r)=>[subtract2(r[(t+1)%r.length],e),e])).map((e=>((e,t,r,s,o=includeS,a=v)=>{const n=cross2(normalize2(e),normalize2(r));if(Math.abs(n)<a)return;const c=cross2(e,r),i=-c,l=subtract2(s,t),d=flip(l),m=cross2(l,r)/c;return o(cross2(d,e)/i,a/magnitude2(r))?m:void 0})(t,r,e[0],e[1],s,o))).filter((e=>void 0!==e)).sort(((e,t)=>e-t)),clipLineConvexPolygon=(e,{vector:t,origin:r},s=include,o=includeL,a=v)=>{const n=getIntersectParameters(e,t,r,includeS,a);if(n.length<2)return;const c=((e,t,r)=>{let s=0,o=e.length-1;for(;s<o&&!t(e[s+1]-e[s],r);)s+=1;for(;o>s&&!t(e[o]-e[o-1],r);)o-=1;if(!(s>=o))return[e[s],e[o]]})(n,s,2*a/magnitude2(t));if(void 0===c)return;const i=c.map((e=>o(e)?e:e<.5?0:1));if(Math.abs(i[0]-i[1])<2*a/magnitude2(t))return;const l=linePointFromParameter(t,r,(i[0]+i[1])/2);return overlapConvexPolygonPoint(e,l,s,a)?i.map((e=>linePointFromParameter(t,r,e))):void 0},clipPolygonPolygon=(e,t,r=v)=>{const inside=(e,t,s)=>(s[0]-t[0])*(e[1]-t[1])>(s[1]-t[1])*(e[0]-t[0])+r,intersection=(e,t,r,s)=>{const o=subtract2(e,t),a=subtract2(s,r),n=cross2(e,t),c=cross2(s,r),i=1/cross2(o,a);return scale2(subtract2(scale2(a,n),scale2(o,c)),i)};let s=e,o=t[t.length-1];for(let e=0;e<t.length;e+=1){const r=t[e],a=s;s=[];let n=a[a.length-1];for(let e=0;e<a.length;e+=1){const t=a[e];inside(t,o,r)?(inside(n,o,r)||s.push(intersection(o,r,t,n)),s.push(t)):inside(n,o,r)&&s.push(intersection(o,r,t,n)),n=t}o=r}return 0===s.length?void 0:s};var fr=Object.freeze({__proto__:null,clipLineConvexPolygon:clipLineConvexPolygon,clipLineInBoundingBox:({vector:e,origin:t},{min:r,max:s,span:o})=>clipLineConvexPolygon(),clipPolygonPolygon:clipPolygonPolygon});const clipAndJoin=(e,t,r,s=includeL,o=v)=>((e,{vector:t,origin:r},s)=>{if(e.length<2)return e;const o=e.map((e=>subtract2(e[1],e[0]))).map((e=>dot2(e,t)<s));e.map(((e,t)=>t)).filter((e=>o[e])).forEach((t=>{e[t]=[e[t][1],e[t][0]]}));const a=normalize2(t),n=e.map((e=>e.map((e=>dot2(subtract2(e,r),a))))).sort(((e,t)=>e[0]-t[0])),c=[[n[0][0],n[0][1]]];for(let e=1;e<n.length;e+=1){const t=n[e];t[0]-s<c[c.length-1][1]+s?c[c.length-1][1]=Math.max(t[1],c[c.length-1][1]):c.push([t])}return c.map((e=>e.map((e=>add2(r,scale2(a,e))))))})(t.map((t=>e.faces_vertices[t].map((t=>e.vertices_coords[t])))).map((e=>clipLineConvexPolygon(e,r,include,s,o))).filter((e=>void 0!==e)),r,o),clip=function(e,t){const r=boundary(e).vertices.map((t=>e.vertices_coords[t])),s=t.vector?t.vector:subtract2(t[1],t[0]),o=t.origin?t.origin:t[0],a=t.domain?t.domain:includeL;return clipLineConvexPolygon(r,{vector:s,origin:o},include,a)};var dr=Object.freeze({__proto__:null,clip:clip,clipLine:(e,t,r=v)=>{const s=getFacesLineOverlap(e,t,r);return clipAndJoin(e,s,t,includeL,r)},clipRay:(e,t,r=v)=>{const s=getFacesRayOverlap(e,t,r);return clipAndJoin(e,s,t,S,r)},clipSegment:(e,t,r=v)=>{const s=subtract2(t[1],t[0]),o=t[0],a=getFacesSegmentOverlap(e,t,r);return clipAndJoin(e,a,{vector:s,origin:o},includeS,r)}});const getVerticesCollinearToLine=({vertices_coords:e},{vector:t,origin:r},s=v)=>{const o=normalize(t);return e.map((e=>{const t=subtract(e,r),a=magnitude(t);if(Math.abs(a)<s)return!0;const n=t.map((e=>e/a)),c=Math.abs(dot(n,o));return Math.abs(1-c)<s})).map(((e,t)=>({a:e,i:t}))).filter((e=>e.a)).map((e=>e.i))};var mr=Object.freeze({__proto__:null,getVerticesCollinearToLine:getVerticesCollinearToLine});const getEdgesCollinearToLine=({vertices_coords:e,edges_vertices:t,vertices_edges:r},{vector:s,origin:o},a=v)=>{r||(r=makeVerticesEdgesUnsorted({edges_vertices:t}));const n=getVerticesCollinearToLine({vertices_coords:e},{vector:s,origin:o},a),c=t.map((()=>0));return n.forEach((e=>r[e].forEach((e=>{c[e]+=1})))),c.map(((e,t)=>({count:e,i:t}))).filter((e=>2===e.count)).map((e=>e.i))},getEdgesRectOverlap=({vertices_coords:e,edges_vertices:t},{min:r,max:s},o=v)=>{const a=makeEdgesCoords({vertices_coords:e,edges_vertices:t}),n=r.map((e=>e-o)),c=s.map((e=>e+o));return t.map(((e,t)=>t)).filter((e=>!(a[e][0][0]<n[0]&&a[e][1][0]<n[0]))).filter((e=>!(a[e][0][0]>c[0]&&a[e][1][0]>c[0]))).filter((e=>!(a[e][0][1]<n[1]&&a[e][1][1]<n[1]))).filter((e=>!(a[e][0][1]>c[1]&&a[e][1][1]>c[1])))},getEdgesSegmentIntersection=({vertices_coords:e,edges_vertices:t},r,s,o=v)=>{const a=boundingBox$1([r,s]),n={vector:subtract2(s,r),origin:r},c=getEdgesRectOverlap({vertices_coords:e,edges_vertices:t},a,o),i=[];return c.forEach((r=>{const s=t[r].map((t=>e[t])),a={vector:subtract2(s[1],s[0]),origin:s[0]},c=intersectLineLine(n,a,includeS,includeS,o);c&&(i[r]=c)})),i},getEdgesLineIntersection$1=({vertices_coords:e,edges_vertices:t},{vector:r,origin:s},o=v,a=includeS)=>t.map((t=>{const n=t.map((t=>e[t])),c={vector:subtract2(n[1],n[0]),origin:n[0]};return intersectLineLine({vector:r,origin:s},c,includeL,a,o)}));var gr=Object.freeze({__proto__:null,getEdgesCollinearToLine:getEdgesCollinearToLine,getEdgesLineIntersection:getEdgesLineIntersection$1,getEdgesRectOverlap:getEdgesRectOverlap,getEdgesSegmentIntersection:getEdgesSegmentIntersection});const addPlanarSegment=(e,t,r,s=v)=>{e.vertices_sectors||(e.vertices_sectors=makeVerticesSectors(e));const o=[t,r].map((e=>[e[0],e[1]])),a=subtract2(o[1],o[0]),n=getEdgesSegmentIntersection(e,o[0],o[1],s),c=n.map(((e,t)=>t)).filter(includeL),i={};c.forEach((t=>e.edges_faces[t].forEach((e=>{i[e]=!0}))));const l=Object.keys(i).map((e=>parseInt(e,10))).sort(((e,t)=>e-t)),d=c.reverse().map((t=>splitEdge(e,t,n[t],s))).map((e=>e.vertex)),m=((e,t,r=v)=>{e.vertices_coords||(e.vertices_coords=[]),"number"==typeof t[0]&&(t=[t]);const s=t.map((t=>e.vertices_coords.map((e=>distance(e,t)<r)).map(((e,t)=>e?t:void 0)).filter((e=>void 0!==e)).shift()));let o=e.vertices_coords.length;const a=t.filter(((e,t)=>void 0===s[t]));return e.vertices_coords.push(...a),s.map((e=>void 0===e?o++:e))})(e,o,s),g={};d.forEach((e=>{g[e]=!0})),m.forEach((e=>{g[e]=!0}));const p=Object.keys(g).map((e=>parseInt(e,10))),_=sortVerticesAlongVector(e,p,a),u=makeVerticesToEdgeBidirectional(e),b=((e,t,r)=>{const s=Array.from(Array(t.length-1)).map(((e,r)=>[t[r],t[r+1]])),o=s.map((e=>e.join(" "))).map((e=>void 0===r[e])),a=s.filter(((e,t)=>o[t])),n=Array.from(Array(a.length)).map(((t,r)=>e.edges_vertices.length+r));n.forEach(((t,r)=>{e.edges_vertices[t]=a[r]})),e.edges_assignment&&n.forEach((t=>{e.edges_assignment[t]="U"})),e.edges_foldAngle&&n.forEach((t=>{e.edges_foldAngle[t]=0}));for(let r=0;r<t.length;r+=1){const s=t[r],a=[o[r-1]?t[r-1]:void 0,o[r]?t[r+1]:void 0].filter((e=>void 0!==e)),n=(e.vertices_vertices[s]?e.vertices_vertices[s]:[]).concat(a);e.vertices_vertices[s]=sortVerticesCounterClockwise(e,n,t[r])}const c=makeVerticesToEdgeBidirectional(e);for(let r=0;r<t.length;r+=1){const s=t[r];e.vertices_edges[s]=e.vertices_vertices[s].map((e=>c[`${s} ${e}`]))}return t.map((t=>1===e.vertices_vertices[t].length?[h]:counterClockwiseSectors2(e.vertices_vertices[t].map((r=>subtract2(e.vertices_coords[r],e.vertices_coords[t])))))).forEach(((r,s)=>{e.vertices_sectors[t[s]]=r})),n})(e,_,u);b.forEach((t=>{const r=e.edges_vertices[t];u[`${r[0]} ${r[1]}`]=t,u[`${r[1]} ${r[0]}`]=t}));const y=_.map((t=>e.vertices_vertices[t].map((e=>[[e,t],[t,e]])))).reduce(((e,t)=>e.concat(t)),[]).reduce(((e,t)=>e.concat(t)),[]),E={},A=y.map((t=>counterClockwiseWalk(e,t[0],t[1],E))).filter((e=>void 0!==e)),x=filterWalkedBoundaryFace(A);removeGeometryIndices(e,"faces",l);const M=x.map(((t,r)=>e.faces_vertices.length+r));return e.faces_vertices&&M.forEach(((t,r)=>{e.faces_vertices[t]=x[r].vertices})),e.faces_edges&&M.forEach(((t,r)=>{e.faces_edges[t]=x[r].edges.map((e=>u[e]))})),e.faces_angles&&M.forEach(((t,r)=>{e.faces_angles[t]=x[r].faces_angles})),e.vertices_faces&&(e.vertices_faces=makeVerticesFaces(e)),e.edges_faces&&(e.edges_faces=makeEdgesFacesUnsorted(e)),e.faces_faces&&(e.faces_faces=makeFacesFaces(e)),e.vertices_coords.length===e.vertices_vertices.length&&e.vertices_coords.length===e.vertices_edges.length&&e.vertices_coords.length===e.vertices_faces.length||console.warn("vertices mismatch",JSON.parse(JSON.stringify(e))),e.edges_vertices.length===e.edges_faces.length&&e.edges_vertices.length===e.edges_assignment.length||console.warn("edges mismatch",JSON.parse(JSON.stringify(e))),e.faces_vertices.length===e.faces_edges.length&&e.faces_vertices.length===e.faces_faces.length||console.warn("faces mismatch",JSON.parse(JSON.stringify(e))),b},removePlanarEdge=(e,t)=>{const r=[...e.edges_vertices[t]].sort(((e,t)=>t-e)),s=[...e.edges_faces[t]];(({vertices_vertices:e},t)=>{const r=[t[1],t[0]];t.map(((t,s)=>e[t].indexOf(r[s]))).forEach(((r,s)=>e[t[s]].splice(r,1)))})(e,r),(({vertices_edges:e},t,r)=>{r.map(((r,s)=>e[r].indexOf(t))).forEach(((t,s)=>e[r[s]].splice(t,1)))})(e,t,r);const o=r.map((t=>0===e.vertices_vertices[t].length)),a=r.filter(((e,t)=>o[t]));if(2===s.length&&s[0]!==s[1]){const o=e.faces_vertices.length,a=((e,t,r,s)=>{const o=t.map((t=>e.faces_edges[t].indexOf(r))),a=[];t.forEach(((t,r)=>e.faces_vertices[t].forEach(((e,t,o)=>{const n=o[(t+1)%o.length];(e===s[0]&&n===s[1]||e===s[1]&&n===s[0])&&(a[r]=t)})))),void 0!==a[0]&&void 0!==a[1]||console.warn("removePlanarEdge error joining faces");const n=t.map((t=>e.faces_edges[t].length)),c=t.map((t=>e.faces_vertices[t].length)),i=n.map((e=>e-1)),l=c.map((e=>e-1)),d=o.map(((e,t)=>(e+1)%n[t])),m=a.map(((e,t)=>(e+1)%c[t])),g=t.map(((t,r)=>Array.from(Array(i[r])).map(((e,t)=>(d[r]+t)%n[r])).map((r=>e.faces_edges[t][r])))),p=t.map(((t,r)=>Array.from(Array(l[r])).map(((e,t)=>(m[r]+t)%c[r])).map((r=>e.faces_vertices[t][r])))),v=t.map((t=>e.faces_faces[t])).reduce(((e,t)=>e.concat(t)),[]).filter((e=>e!==t[0]&&e!==t[1]));return{vertices:p[0].concat(p[1]),edges:g[0].concat(g[1]),faces:v}})(e,s,t,r);e.faces_vertices.push(a.vertices),e.faces_edges.push(a.edges),e.faces_faces.push(a.faces),e.vertices_faces.forEach(((t,r)=>{let a=!1;t.forEach(((n,c)=>{if(n===s[0]||n===s[1]){e.vertices_faces[r][c]=o;const s=a?[r,1]:[r,1,o];t.splice(...s),a=!0}}))})),e.edges_faces.forEach(((t,r)=>t.forEach(((t,a)=>{t!==s[0]&&t!==s[1]||(e.edges_faces[r][a]=o)})))),e.faces_faces.forEach(((t,r)=>t.forEach(((t,a)=>{t!==s[0]&&t!==s[1]||(e.faces_faces[r][a]=o)})))),e.faces_vertices.forEach((t=>t.forEach((t=>{void 0===t&&console.log("FOUND ONE before remove",e.faces_vertices)})))),removeGeometryIndices(e,"faces",s)}if(2===s.length&&s[0]===s[1]&&a.length){const r=s[0];e.faces_vertices[r]=e.faces_vertices[r].filter((e=>!a.includes(e))).filter(((e,t,r)=>e!==r[(t+1)%r.length])),e.faces_edges[r]=e.faces_edges[r].filter((e=>e!==t))}removeGeometryIndices(e,"edges",[t]),removeGeometryIndices(e,"vertices",a)},removePlanarVertex=(e,t)=>{const r=e.vertices_edges[t],s=uniqueSortedNumbers(e.vertices_faces[t].filter((e=>null!=e)));if(2!==r.length||s.length>2)return void console.warn("cannot remove non 2-degree vertex yet (e,f)",r,s);const o=getOtherVerticesInEdges(e,t,r),a=o.slice().reverse();r.sort(((e,t)=>e-t)),o.forEach((t=>{const s=e.vertices_edges[t].indexOf(r[1]);-1!==s&&(e.vertices_edges[t][s]=r[0])})),o.forEach(((r,s)=>{const o=e.vertices_vertices[r].indexOf(t);-1!==o?e.vertices_vertices[r][o]=a[s]:console.warn("removePlanarVertex unknown vertex issue")})),e.edges_vertices[r[0]]=[...o],s.forEach((r=>{const s=e.faces_vertices[r].indexOf(t);-1!==s?e.faces_vertices[r].splice(s,1):console.warn("removePlanarVertex unknown face_vertex issue")})),s.forEach((t=>{const s=e.faces_edges[t].indexOf(r[1]);-1!==s?e.faces_edges[t].splice(s,1):console.warn("removePlanarVertex unknown face_edge issue")})),removeGeometryIndices(e,"vertices",[t]),removeGeometryIndices(e,"edges",[r[1]])},alternatingSum=e=>[0,1].map((t=>e.filter(((e,r)=>r%2===t)).reduce(((e,t)=>e+t),0))),kawasakiSolutionsRadians=e=>e.map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>counterClockwiseAngleRadians(...e))).map(((e,t,r)=>r.slice(t+1,r.length).concat(r.slice(0,t)))).map((e=>alternatingSum(e).map((e=>Math.PI-e)))).map(((t,r)=>e[r]+t[0])).map(((t,r)=>isCounterClockwiseBetween(t,e[r],e[(r+1)%e.length])?t:void 0)),kawasakiSolutionsVectors=e=>{const t=e.map((e=>Math.atan2(e[1],e[0])));return kawasakiSolutionsRadians(t).map((e=>void 0===e?void 0:[Math.cos(e),Math.sin(e)]))};var pr=Object.freeze({__proto__:null,alternatingSum:alternatingSum,alternatingSumDifference:e=>{const t=e.reduce(((e,t)=>e+t),0)/2;return alternatingSum(e).map((e=>e-t))},kawasakiSolutions:({vertices_coords:e,vertices_edges:t,edges_assignment:r,edges_vertices:s},o)=>{t||(t=makeVerticesEdgesUnsorted({edges_vertices:s}));const a=r?t[o].filter((e=>I[r[e]])):t[o];if(a.length%2==0)return[];const n=a.map((e=>s[e][0]===o?s[e]:[s[e][1],s[e][0]])).map((t=>t.map((t=>e[t])))).map((e=>subtract2(e[1],e[0]))),c=counterClockwiseOrder2(n).map((e=>n[e])),i=kawasakiSolutionsVectors(c),l=c.map(normalize2),d=i.filter((e=>void 0!==e)).filter((e=>!l.map((t=>dot2(e,t))).map((e=>Math.abs(1-e)<.001)).reduce(((e,t)=>e||t),!1)));return d},kawasakiSolutionsRadians:kawasakiSolutionsRadians,kawasakiSolutionsVectors:kawasakiSolutionsVectors});const getAllFlatVertices=({vertices_edges:e,edges_assignment:t})=>e.map((e=>e.map((e=>!I[t[e]])).reduce(((e,t)=>e&&t),!0))).map(((e,t)=>e?t:void 0)).filter((e=>void 0!==e)),validateMaekawa=({edges_vertices:e,vertices_edges:t,edges_assignment:r})=>{t||(t=makeVerticesEdgesUnsorted({edges_vertices:e}));const s=t.map((e=>e.map((e=>L[r[e]])).filter((e=>0!==e)).map(Math.sign).reduce(((e,t)=>e+t),0))).map((e=>2===e||-2===e));return boundaryVertices({edges_vertices:e,edges_assignment:r}).forEach((e=>{s[e]=!0})),getAllFlatVertices({vertices_edges:t,edges_assignment:r}).forEach((e=>{s[e]=!0})),s.map(((e,t)=>e?void 0:t)).filter((e=>void 0!==e))},validateKawasaki=({vertices_coords:e,vertices_vertices:t,vertices_edges:r,edges_vertices:s,edges_assignment:o},a=v)=>{t||(t=makeVerticesVertices({vertices_coords:e,vertices_edges:r,edges_vertices:s})),r||(r=makeVerticesEdgesUnsorted({edges_vertices:s}));const n=makeVerticesVerticesVector({vertices_coords:e,vertices_vertices:t,edges_vertices:s}).map(((e,t)=>e.filter(((e,s)=>I[o[r[t][s]]])))).map((e=>e.length>1?counterClockwiseSectors2(e):[0,0])).map((e=>alternatingSum(e))).map((e=>Math.abs(e[0]-e[1])<a));return boundaryVertices({edges_vertices:s,edges_assignment:o}).forEach((e=>{n[e]=!0})),getAllFlatVertices({vertices_edges:r,edges_assignment:o}).forEach((e=>{n[e]=!0})),n.map(((e,t)=>e?void 0:t)).filter((e=>void 0!==e))};var vr=Object.freeze({__proto__:null,validateKawasaki:validateKawasaki,validateMaekawa:validateMaekawa});const _r={};_r.prototype=Object.create(lr),_r.prototype.constructor=_r;const makeEdgesReturnObject=function(e){return e.valley=t=>this.setValley(e,t),e.mountain=t=>this.setMountain(e,t),e.flat=()=>this.setFlat(e),e.unassigned=()=>this.setUnassigned(e),e.cut=()=>this.setCut(e),e},clipLineTypeToCP=(e,t)=>{const r=clip(e,t);if(!r)return;const s=addPlanarSegment(e,r[0],r[1]);return makeEdgesReturnObject.call(e,s)};_r.prototype.line=function(...e){const t=getLine$1(...e);if(t)return t.domain=includeL,clipLineTypeToCP(this,t)},_r.prototype.ray=function(...e){const t=getLine$1(...e);if(t)return t.domain=S,clipLineTypeToCP(this,t)},_r.prototype.segment=function(...e){const t=pointsToLine(...getSegment(...e));if(t)return t.domain=includeS,clipLineTypeToCP(this,t)},_r.prototype.polygon=function(...e){const t=getArrayOfVectors(...e);if(!t)return;const r=t.map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>pointsToLine(...e))).map((e=>({...e,domain:includeS}))).map((e=>clip(this,e))).filter((e=>void 0!==e));if(!r)return;const s=r.flatMap((e=>addPlanarSegment(this,e[0],e[1])));return makeEdgesReturnObject.call(this,s)},_r.prototype.removeEdge=function(e){const t=this.edges_vertices[e];return removePlanarEdge(this,e),t.map((e=>isVertexCollinear(this,e))).map(((e,r)=>e?t[r]:void 0)).filter((e=>void 0!==e)).sort(((e,t)=>t-e)).forEach((e=>removePlanarVertex(this,e))),!0},_r.prototype.validate=function(e){const t=validate(this,e);return t.vertices.kawasaki=validateKawasaki(this,e),t.vertices.maekawa=validateMaekawa(this),this.edges_foldAngle&&(t.edges.not_flat=this.edges_foldAngle.map(((e,t)=>edgeFoldAngleIsFlat(e)?void 0:t)).filter((e=>void 0!==e))),"valid"===t.summary&&(t.vertices.kawasaki.length||t.vertices.maekawa.length?t.summary="invalid":t.edges.not_flat.length&&(t.summary="not flat")),t},_r.prototype.defer=!1;var ur=_r.prototype;const make_face_side=(e,t,r,s)=>{const o=subtract2(r,t),a=cross2(e,o);return s?a>0:a<0},make_face_center=(e,t)=>e.faces_vertices[t]?e.faces_vertices[t].map((t=>e.vertices_coords[t])).reduce(((e,t)=>[e[0]+t[0],e[1]+t[1]]),[0,0]).map((r=>r/e.faces_vertices[t].length)):[0,0],hr={F:!0,f:!0,U:!0,u:!0},br={M:"V",m:"V",V:"M",v:"M"},face_snapshot=(e,t)=>({center:e.faces_center[t],matrix:e.faces_matrix2[t],winding:e.faces_winding[t],crease:e.faces_crease[t],side:e.faces_side[t],layer:e.faces_layer[t]}),flatFold=(e,{vector:t,origin:r},s="V",o=v)=>{const a=br[n=s]||n;var n;populate(e),e.faces_layer||(e.faces_layer=Array(e.faces_vertices.length).fill(0)),e.faces_center=e.faces_vertices.map(((t,r)=>make_face_center(e,r))),e.faces_matrix2||(e.faces_matrix2=makeFacesMatrix2(e,((e,t,r,s=v)=>{const o=facesContainingPoint(e,t);if(0!==o.length)return o.length,o[0]})(e,r,0,o))),e.faces_winding=makeFacesWindingFromMatrix2(e.faces_matrix2),e.faces_crease=e.faces_matrix2.map(invertMatrix2).map((e=>multiplyMatrix2Line2(e,t,r))),e.faces_side=e.faces_vertices.map(((t,r)=>make_face_side(e.faces_crease[r].vector,e.faces_crease[r].origin,e.faces_center[r],e.faces_winding[r])));const c=multiplyVerticesFacesMatrix2(e,e.faces_matrix2),i=getEdgesCollinearToLine({vertices_coords:c,edges_vertices:e.edges_vertices},{vector:t,origin:r},o).filter((t=>hr[e.edges_assignment[t]]));i.map((t=>e.edges_faces[t].find((e=>null!=e)))).map((t=>e.faces_winding[t])).map((e=>e?s:a)).forEach(((t,r)=>{e.edges_assignment[i[r]]=t,e.edges_foldAngle[i[r]]=edgeAssignmentToFoldAngle(t)}));const l=face_snapshot(e,0),d=e.faces_vertices.map(((e,t)=>t)).reverse().map((t=>{const r=face_snapshot(e,t),n=splitFace(e,t,r.crease,o);if(void 0===n)return;e.edges_assignment[n.edges.new]=r.winding?s:a,e.edges_foldAngle[n.edges.new]=edgeAssignmentToFoldAngle(e.edges_assignment[n.edges.new]);return n.faces.map[n.faces.remove].forEach((t=>{e.faces_center[t]=make_face_center(e,t),e.faces_side[t]=make_face_side(r.crease.vector,r.crease.origin,e.faces_center[t],r.winding),e.faces_layer[t]=r.layer})),n})).filter((e=>void 0!==e)),m=mergeNextmaps(...d.map((e=>e.faces.map))),g=mergeNextmaps(...d.map((e=>e.edges.map)).filter((e=>void 0!==e))),p=d.map((e=>e.faces.remove)).reverse();e.faces_layer=((e,t)=>{const r=[],s=e.map(((e,t)=>t)),o=s.filter((e=>t[e])),a=s.filter((e=>!t[e]));return a.sort(((t,r)=>e[t]-e[r])).forEach(((e,t)=>{r[e]=t})),o.sort(((t,r)=>e[r]-e[t])).forEach(((e,t)=>{r[e]=a.length+t})),r})(e.faces_layer,e.faces_side);const _=m&&m[0]&&2===m[0].length,u=_?m[0].filter((t=>e.faces_side[t])).shift():0;let h=l.matrix;return s!==a&&(h=_||e.faces_side[0]?multiplyMatrices2(l.matrix,makeMatrix2Reflect(l.crease.vector,l.crease.origin)):l.matrix),e.faces_matrix2=makeFacesMatrix2(e,u).map((e=>multiplyMatrices2(h,e))),delete e.faces_center,delete e.faces_winding,delete e.faces_crease,delete e.faces_side,{faces:{map:m,remove:p},edges:{map:g}}},yr={};yr.prototype=Object.create(lr),yr.prototype.constructor=yr,yr.prototype.flatFold=function(){return flatFold(this,getLine$1(arguments)),this};var Er=yr.prototype;const Ar=1.1,xr="Rabbit Ear",make_rect_vertices_coords=(e,t)=>[[0,0],[e,0],[e,t],[0,t]],make_closed_polygon=e=>populate({vertices_coords:e,edges_vertices:e.map(((e,t,r)=>[t,(t+1)%r.length])),edges_assignment:Array(e.length).fill("B")}),square=(e=1)=>make_closed_polygon(make_rect_vertices_coords(e,e));var Mr=Object.freeze({__proto__:null,bird:()=>populate({vertices_coords:[[0,0],[.5,0],[1,0],[1,.5],[1,1],[.5,1],[0,1],[0,.5],[.5,.5],[.5,(Math.sqrt(2)-1)/2],[(3-Math.sqrt(2))/2,.5],[.5,(3-Math.sqrt(2))/2],[(Math.sqrt(2)-1)/2,.5]],edges_vertices:[[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,0],[0,8],[2,8],[4,8],[6,8],[1,9],[9,8],[3,10],[10,8],[5,11],[11,8],[7,12],[12,8],[0,9],[9,2],[2,10],[10,4],[4,11],[11,6],[6,12],[12,0]],edges_assignment:Array.from("BBBBBBBBFMFMMVMVMVMVVVVVVVVV")}),fish:()=>populate({vertices_coords:[[0,0],[Math.SQRT1_2,0],[1,0],[1,1-Math.SQRT1_2],[1,1],[1-Math.SQRT1_2,1],[0,1],[0,Math.SQRT1_2],[.5,.5],[Math.SQRT1_2,1-Math.SQRT1_2],[1-Math.SQRT1_2,Math.SQRT1_2]],edges_vertices:[[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,0],[9,0],[9,2],[9,4],[10,0],[10,6],[10,4],[9,1],[10,7],[9,3],[10,5],[8,0],[8,2],[8,4],[8,6]],edges_assignment:Array.from("BBBBBBBBVVVVVVMMFFFFFF")}),kite:()=>populate({vertices_coords:[[0,0],[1,0],[1,Math.SQRT2-1],[1,1],[Math.SQRT2-1,1],[0,1]],edges_vertices:[[0,1],[1,2],[2,3],[3,4],[4,5],[5,0],[0,2],[0,4],[0,3]],edges_assignment:Array.from("BBBBBBVVF")}),polygon:(e=3,t=1)=>make_closed_polygon(makePolygonCircumradius(e,t)),rectangle:(e=1,t=1)=>make_closed_polygon(make_rect_vertices_coords(e,t)),square:square});const graph=(...e)=>populate(Object.assign(Object.create(lr),{...e.reduce(((e,t)=>({...e,...t})),{}),file_spec:Ar,file_creator:xr})),cp=(...e)=>populate(Object.assign(Object.create(ur),{...e.length?e.reduce(((e,t)=>({...e,...t})),{}):square(),file_spec:Ar,file_creator:xr,frame_classes:["creasePattern"]})),origami=(...e)=>populate(Object.assign(Object.create(Er),{...e.length?e.reduce(((e,t)=>({...e,...t})),{}):square(),file_spec:Ar,file_creator:xr,frame_classes:["foldedForm"]}));(graph.prototype=lr).constructor=graph,(cp.prototype=ur).constructor=cp,(origami.prototype=Er).constructor=origami,Object.keys(Mr).forEach((e=>{graph[e]=(...t)=>graph(Mr[e](...t)),cp[e]=(...t)=>cp(Mr[e](...t)),origami[e]=(...t)=>origami(Mr[e](...t))}));const normalAxiom1=(e,t)=>{const r=normalize2(rotate90(subtract2(t,e)));return[{normal:r,distance:dot2(add2(e,t),r)/2}]},normalAxiom2=(e,t)=>{const r=normalize2(subtract2(t,e));return[{normal:r,distance:dot2(add2(e,t),r)/2}]},normalAxiom3=(e,t)=>{const r=((e,t)=>{const r=cross2(e.normal,t.normal);if(Math.abs(r)<v)return;return[(e.distance*t.normal[1]-t.distance*e.normal[1])/r,(t.distance*e.normal[0]-e.distance*t.normal[0])/r]})(e,t);return void 0===r?[{normal:e.normal,distance:(e.distance+t.distance*dot2(e.normal,t.normal))/2}]:[add2,subtract2].map((r=>normalize2(r(e.normal,t.normal)))).map((e=>({normal:e,distance:dot2(r,e)})))},normalAxiom4=(e,t)=>{const r=rotate90(e.normal);return[{normal:r,distance:dot2(t,r)}]},normalAxiom5=(e,t,r)=>{const s=dot2(t,e.normal),o=e.distance-s,a=distance2(t,r);if(o>a)return[];const n=Math.sqrt(a*a-o*o),c=scale2(e.normal,o),i=add2(t,c),l=scale2(rotate90(e.normal),n);return(n<v?[i]:[add2(i,l),subtract2(i,l)]).map((e=>normalize2(subtract2(r,e)))).map((e=>({normal:e,distance:dot2(t,e)})))},cubrt=e=>e<0?-((-e)**(1/3)):e**(1/3),normalAxiom6=(e,t,r,s)=>{if(Math.abs(1-dot2(e.normal,r)/e.distance)<.02)return[];const o=rotate90(e.normal),a=subtract2(add2(r,scale2(e.normal,e.distance)),scale2(s,2)),n=subtract2(scale2(e.normal,e.distance),r),c=dot2(s,t.normal)-t.distance,i=2*dot2(n,o),l=dot2(n,n),d=dot2(add2(a,n),o),m=dot2(a,n),g=dot2(o,t.normal),p=dot2(n,t.normal),_=g,u=c+d*g+p,h=c*i+m*g+d*p,b=c*l+m*p;let y=0;return Math.abs(h)>v&&(y=1),Math.abs(u)>v&&(y=2),Math.abs(_)>v&&(y=3),((e,t,r,s,o)=>{switch(e){case 1:return[-o/s];case 2:{const e=s**2-4*r*o;if(e<-v)return[];const t=-s/(2*r);if(e<v)return[t];const a=Math.sqrt(e)/(2*r);return[t+a,t-a]}case 3:{const e=r/t,a=s/t,n=(9*e*a-o/t*27-2*e**3)/54,c=((3*a-e**2)/9)**3+n**2,i=-e/3;if(c>0){const e=Math.sqrt(c);return[i+cubrt(n+e)+cubrt(n-e)]}if(Math.abs(c)<v){const e=n**(1/3);return n<0?[]:[i+2*e,i-e]}const l=Math.sqrt(-c),d=Math.atan2(l,n)/3,m=(n**2-c)**(1/6),g=m*Math.cos(d),p=m*Math.sin(d);return[i+2*g,i-g-Math.sqrt(3)*p,i-g+Math.sqrt(3)*p]}default:return[]}})(y,_,u,h,b).map((t=>add2(scale2(e.normal,e.distance),scale2(o,t)))).map((e=>({p:e,normal:normalize2(subtract2(e,r))}))).map((e=>({normal:e.normal,distance:dot2(e.normal,midpoint2(e.p,r))})))},normalAxiom7=(e,t,r)=>{const s=rotate90(e.normal),o=dot2(s,t.normal);if(Math.abs(o)<v)return;const a=dot2(r,s),n=dot2(r,t.normal);return[{normal:s,distance:(t.distance+2*a*o-n)/(2*o)}]},normalAxiom=(e,...t)=>[null,normalAxiom1,normalAxiom2,normalAxiom3,normalAxiom4,normalAxiom5,normalAxiom6,normalAxiom7][e](...t);var kr=Object.freeze({__proto__:null,normalAxiom:normalAxiom,normalAxiom1:normalAxiom1,normalAxiom2:normalAxiom2,normalAxiom3:normalAxiom3,normalAxiom4:normalAxiom4,normalAxiom5:normalAxiom5,normalAxiom6:normalAxiom6,normalAxiom7:normalAxiom7});const axiom1$1=(e,t)=>[{vector:normalize2(subtract2(...resizeUp(t,e))),origin:e}],axiom2$1=(e,t)=>[{vector:normalize2(rotate90(subtract2(...resizeUp(t,e)))),origin:midpoint2(e,t)}],axiom3$1=(e,t)=>bisectLines2(e,t),axiom4$1=(e,t)=>[{vector:rotate90(normalize2(e.vector)),origin:t}],axiom5$1=(e,t,r)=>(intersectCircleLine({radius:distance2(t,r),origin:t},e)||[]).map((e=>({vector:normalize2(rotate90(subtract2(...resizeUp(e,r)))),origin:midpoint2(r,e)}))),axiom6$1=(e,t,r,s)=>normalAxiom6(vecLineToUniqueLine(e),vecLineToUniqueLine(t),r,s).map(uniqueLineToVecLine),axiom7$1=(e,t,r)=>{const s=intersectLineLine(e,{vector:t.vector,origin:r},includeL,includeL);return void 0===s?[]:[{vector:normalize2(rotate90(subtract2(...resizeUp(s,r)))),origin:midpoint2(r,s)}]},axiom$2=(e,...t)=>[null,axiom1$1,axiom2$1,axiom3$1,axiom4$1,axiom5$1,axiom6$1,axiom7$1][e](...t);var Or=Object.freeze({__proto__:null,axiom:axiom$2,axiom1:axiom1$1,axiom2:axiom2$1,axiom3:axiom3$1,axiom4:axiom4$1,axiom5:axiom5$1,axiom6:axiom6$1,axiom7:axiom7$1});const reflectPoint=(e,t)=>{const r=makeMatrix2Reflect(e.vector,e.origin);return multiplyMatrix2Vector2(r,t)},validateAxiom1=(e,t,r,s)=>[[r,s].map((t=>overlapConvexPolygonPoint(e,t,include))).reduce(((e,t)=>e&&t),!0)],wr=validateAxiom1,validateAxiom3=(e,t,r,s)=>{const o=[r,s].map((t=>clipLineConvexPolygon(e,t,include,includeL)));if(void 0===o[0]||void 0===o[1])return[!1,!1];const a=t.map((t=>void 0===t?void 0:clipLineConvexPolygon(e,t,include,includeL))),n=[0,1].map((e=>void 0!==a[e])),c=t.map((e=>void 0===e?void 0:[reflectPoint(e,o[0][0]),reflectPoint(e,o[0][1])])).map((e=>void 0!==e&&(overlapLinePoint({vector:subtract(o[1][1],o[1][0]),origin:o[1][0]},e[0],includeS)||overlapLinePoint({vector:subtract(o[1][1],o[1][0]),origin:o[1][0]},e[1],includeS)||overlapLinePoint({vector:subtract(e[1],e[0]),origin:e[0]},o[1][0],includeS)||overlapLinePoint({vector:subtract(e[1],e[0]),origin:e[0]},o[1][1],includeS))));return[0,1].map((e=>!0===c[e]&&!0===n[e]))},validateAxiom4=(e,t,r,s)=>[[s,intersectLineLine(r,{vector:rotate90(r.vector),origin:s},includeL,includeL)].filter((e=>void 0!==e)).map((t=>overlapConvexPolygonPoint(e,t,include))).reduce(((e,t)=>e&&t),!0)],validateAxiom5=(e,t,r,s,o)=>{if(0===t.length)return[];const a=[s,o].map((t=>overlapConvexPolygonPoint(e,t,include))).reduce(((e,t)=>e&&t),!0);return t.map((e=>reflectPoint(e,o))).map((t=>overlapConvexPolygonPoint(e,t,include))).map((e=>e&&a))},validateAxiom6=function(e,t,r,s,o,a){if(0===t.length)return[];if(![o,a].map((t=>overlapConvexPolygonPoint(e,t,include))).reduce(((e,t)=>e&&t),!0))return t.map((()=>!1));const n=t.map((e=>reflectPoint(e,o))).map((t=>overlapConvexPolygonPoint(e,t,include))),c=t.map((e=>reflectPoint(e,a))).map((t=>overlapConvexPolygonPoint(e,t,include)));return t.map(((e,t)=>n[t]&&c[t]))},validateAxiom7=(e,t,r,s,o)=>{const a=overlapConvexPolygonPoint(e,o,include);if(!t.length)return[!1];const n=reflectPoint(t[0],o),c=overlapConvexPolygonPoint(e,n,include),i=void 0!==intersectConvexPolygonLine(e,s,includeS,includeL),l=intersectLineLine(s,t[0],includeL,includeL),d=!!l&&overlapConvexPolygonPoint(e,l,include);return[a&&c&&i&&d]},validateAxiom=(e,t,r,...s)=>[null,validateAxiom1,wr,validateAxiom3,validateAxiom4,validateAxiom5,validateAxiom6,validateAxiom7][e](t,r,...s);var jr=Object.freeze({__proto__:null,validateAxiom:validateAxiom,validateAxiom1:validateAxiom1,validateAxiom2:wr,validateAxiom3:validateAxiom3,validateAxiom4:validateAxiom4,validateAxiom5:validateAxiom5,validateAxiom6:validateAxiom6,validateAxiom7:validateAxiom7});var Fr=Object.freeze({__proto__:null,axiomWithBoundary:(e,t,...r)=>{const s=axiom$2(e,...r);return validateAxiom(e,t,s,...r).map(((e,t)=>e?void 0:t)).filter((e=>void 0!==e)).forEach((e=>delete s[e])),s},normalAxiomWithBoundary:(e,t,...r)=>{const s=normalAxiom(e,...r).map(uniqueLineToVecLine);return validateAxiom(e,t,s,...(e=>e.map((e=>"object"==typeof e&&e.vector?uniqueLineToVecLine(e):e)))(r)).map(((e,t)=>e?void 0:t)).filter((e=>void 0!==e)).forEach((e=>delete s[e])),s}}),Cr={...Or,...kr,...Fr,...jr};const pairify=e=>e.map(((e,t,r)=>[e,r[(t+1)%r.length]])),planarizeGraph=(e,t)=>{const r=planarize(e,t);r.vertices_vertices=makeVerticesVertices(r);const s=makePlanarFaces(r);return r.faces_vertices=s.faces_vertices,r.faces_edges=s.faces_edges,delete r.vertices_edges,r},makeEpsilon$1=({vertices_coords:e,edges_vertices:t})=>{const r=(({vertices_coords:e,edges_vertices:t})=>{const r=t.map((t=>t.map((t=>e[t])))).map((e=>distance(...e))).reduce(((e,t)=>Math.min(e,t)),1/0);return r===1/0?void 0:r})({vertices_coords:e,edges_vertices:t});if(r)return r/20;const s=boundingBox({vertices_coords:e});return s&&s.span?.001*Math.max(...s.span):.001},findEpsilonInObject=(e,t,r="epsilon")=>"object"==typeof t&&"number"==typeof t[r]?t[r]:"number"==typeof t?t:makeEpsilon$1(e),getContainingValue=(e,t)=>null==e?null:Array.from(e.childNodes).filter((e=>e.attributes&&e.attributes.length)).filter((e=>void 0!==Array.from(e.attributes).filter((e=>e.nodeValue===t)).shift())).shift(),getLines=e=>{const t=getContainingValue(e,"lines"),r=t?Array.from(t.childNodes).filter((e=>e.getAttribute)).filter((e=>e.getAttribute("class").split(" ").includes("oripa.OriLineProxy"))).shift():void 0;return r?Array.from(r.childNodes):[]},parseLines=e=>e.filter((e=>"void"===e.nodeName)).filter((e=>e.childNodes)).map((e=>getContainingValue(e,"oripa.OriLineProxy"))).filter((e=>e)).map((e=>["type","x0","x1","y0","y1"].map((t=>getContainingValue(e,t))).map((e=>e?Array.from(e.childNodes):[])).map((e=>e.filter((e=>"double"===e.nodeName||"int"===e.nodeName)).shift())).map((e=>e&&e.childNodes[0]?e.childNodes[0].data:"0")).map(parseFloat))),Sr=["F","B","M","V","U"],makeFOLD=e=>{const t={};return t.vertices_coords=e.flatMap((e=>[[e[1],e[3]],[e[2],e[4]]])),t.edges_vertices=e.map(((e,t)=>[2*t,2*t+1])),t.edges_assignment=e.map((e=>Sr[e[0]])),t.edges_foldAngle=makeEdgesFoldAngle(t),t},setMetadata=(e,t)=>{const r={file_description:"memo",file_author:"originalAuthorName",file_title:"title"};Object.keys(r).forEach((t=>{r[t]=((e,t)=>{const r=getContainingValue(e,t),s=r?Array.from(r.childNodes).shift():null;return s?s.textContent:void 0})(e,r[t])})),Object.keys(r).filter((e=>r[e])).forEach((e=>{t[e]=r[e]})),t.file_classes=["singleModel"],t.frame_classes=["creasePattern"]},opxToFold=(e,t)=>{const r=xmlStringToElement(e,"text/xml"),s=(r&&r.childNodes?Array.from(r.childNodes):[]).filter((e=>e.getAttribute)).filter((e=>e.getAttribute("class").split(" ").includes("oripa.DataSet"))).shift(),o=makeFOLD(parseLines(getLines(s))),a=findEpsilonInObject(o,t),n=planarizeGraph(o,a);return setMetadata(s,n),n};Object.assign(opxToFold,{opxEdgeGraph:e=>{const t=xmlStringToElement(e,"text/xml"),r=Array.from(t.childNodes).filter((e=>e.getAttribute)).filter((e=>e.getAttribute("class").split(" ").includes("oripa.DataSet"))).shift();return makeFOLD(parseLines(getLines(r)))}});const countPlaces=function(e){const t=`${e}`.match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);return Math.max(0,(t[1]?t[1].length:0)-(t[2]?+t[2]:0))},cleanNumber=function(e,t=15){if("number"!=typeof e)return e;const r=parseFloat(e.toFixed(t));return countPlaces(r)===Math.min(t,countPlaces(e))?e:r};var Pr=Object.freeze({__proto__:null,cleanNumber:cleanNumber});const Vr={M:[1,0,0],V:[0,0,1],J:[1,1,0],U:[1,0,1],C:[0,1,0]},rgbToAssignment=(e=0,t=0,r=0)=>{const s=scale3([e,t,r],1/255),o=magnitude3(s);if(o<.05)return"B";const a=s.reduce(((e,t)=>e+t),0)/3,n=distance3(s,[a,a,a]),c=Object.keys(Vr).map((e=>({key:e,dist:distance3(s,Vr[e])}))).sort(((e,t)=>e.dist-t.dist)).shift();return c.dist<4*n?c.key:o<.1?"B":"F"};var Nr=Object.freeze({__proto__:null,assignmentColor:Vr,rgbToAssignment:rgbToAssignment});const colorToAssignment=(e,t)=>{const r=parseColorToHex(e).toUpperCase();return t&&t[r]?t[r]:rgbToAssignment(...parseColorToRgb(e))},opacityToFoldAngle=(e,t)=>{switch(t){case"M":case"m":return-180*e;case"V":case"v":return 180*e;default:return 0}},getEdgeStroke=(e,t)=>{const r=null!=RabbitEarWindow().getComputedStyle?RabbitEarWindow().getComputedStyle(e).stroke:"";return""!==r&&"none"!==r?r:void 0!==t.stroke?t.stroke:void 0},getEdgeOpacity=(e,t)=>{const r=null!=RabbitEarWindow().getComputedStyle?RabbitEarWindow().getComputedStyle(e).opacity:"";if(""!==r){const e=parseFloat(r);if(!Number.isNaN(e))return e}if(void 0!==t.opacity){const e=parseFloat(t.opacity);if(!Number.isNaN(e))return e}};var zr=Object.freeze({__proto__:null,colorToAssignment:colorToAssignment,getEdgeOpacity:getEdgeOpacity,getEdgeStroke:getEdgeStroke,opacityToFoldAngle:opacityToFoldAngle});const getAttributesFloatValue=(e,t)=>t.map((t=>e.getAttribute(t))).map((e=>null==e?0:e)).map(parseFloat),PolygonToSegments=e=>(e=>{const t=e.split(/[\s,]+/).map(parseFloat);return Array.from(Array(Math.floor(t.length/2))).map(((e,r)=>[t[2*r+0],t[2*r+1]]))})(e.getAttribute("points")||"").map(((e,t,r)=>[r[t][0],r[t][1],r[(t+1)%r.length][0],r[(t+1)%r.length][1]])),Tr={L:!0,V:!0,H:!0,Z:!0},$r={line:e=>[getAttributesFloatValue(e,["x1","y1","x2","y2"])],rect:function(e){const[t,r,s,o]=getAttributesFloatValue(e,["x","y","width","height"]);return[[t,r,t+s,r],[t+s,r,t+s,r+o],[t+s,r+o,t,r+o],[t,r+o,t,r]]},polygon:PolygonToSegments,polyline:function(e){const t=PolygonToSegments(e);return t.pop(),t},path:e=>parsePathCommandsWithEndpoints(e.getAttribute("d")||"").filter((e=>Tr[e.command.toUpperCase()])).map((e=>[e.start,e.end])).filter((e=>!epsilonEqualVectors(...e))).map((e=>e.flat()))},flatSegments=e=>flattenDomTreeWithStyle(e).filter((e=>$r[e.element.nodeName])).flatMap((e=>$r[e.element.nodeName](e.element).map((t=>((e,t)=>{const r=[[e[0],e[1]],[e[2],e[3]]];if(!t)return r;const s=transformStringToMatrix(t);return s?r.map((e=>multiplyMatrix2Vector2(s,e))):r})(t,e.attributes.transform))).map((t=>({...e,segment:t}))))),svgSegments=e=>{const r="string"==typeof e?xmlStringToElement(e,"image/svg+xml"):e;(e=>flattenDomTree(e).map((e=>"style"===e.nodeName)).reduce(((e,t)=>e||t),!1))(r)&&t&&console.warn(m);const s=getRootParent(r)===RabbitEarWindow().document?void 0:(e=>{if(!RabbitEarWindow().document.body)return;const t=RabbitEarWindow().document.createElement("div");return t.setAttribute("display","none"),RabbitEarWindow().document.body.appendChild(t),t.appendChild(e),t})(r),o=flatSegments(r);return o.map((e=>({data:{assignment:e.attributes["data-assignment"],foldAngle:e.attributes["data-foldAngle"]},stroke:getEdgeStroke(e.element,e.attributes),opacity:getEdgeOpacity(e.element,e.attributes)}))).forEach(((e,t)=>{o[t]={...o[t],...e}})),s&&s.parentNode&&s.parentNode.removeChild(s),o},makeAssignmentFoldAngle=(e,t)=>{const r=(e=>{if(!e||!e.assignments)return;const t={};return Object.keys(e.assignments).forEach((r=>{const s=parseColorToHex(r).toUpperCase();t[s]=e.assignments[r]})),t})(t);r&&e.forEach((e=>{delete e.data.assignment,delete e.data.foldAngle}));const s=e.map((e=>((e,t="#f0f",r)=>e||colorToAssignment(t,r))(e.data.assignment,e.stroke,r))),o=e.map(((e,t)=>((e,t=1,r)=>e?parseFloat(e):opacityToFoldAngle(t,r))(e.data.foldAngle,e.opacity,s[t])));return{edges_assignment:s,edges_foldAngle:o}},svgEdgeGraph=(e,t)=>{const r=svgSegments(e),{edges_assignment:s,edges_foldAngle:o}=makeAssignmentFoldAngle(r,t),a=t&&t.fast?e=>e:cleanNumber;return{vertices_coords:r.flatMap((e=>e.segment)).map((e=>e.map((e=>a(e,12))))),edges_vertices:r.map(((e,t)=>[2*t,2*t+1])),edges_assignment:s,edges_foldAngle:o}},svgToFold=(e,t)=>{const r=svgEdgeGraph(e,t),s=findEpsilonInObject(r,t),o=planarizeGraph(r,s),a=t&&t.fast?e=>e:cleanNumber;if(o.vertices_coords=o.vertices_coords.map((e=>e.map((e=>a(e,12))))),"object"!=typeof t||!1!==t.boundary){o.edges_assignment.map(((e,t)=>t)).filter((e=>"B"===o.edges_assignment[e]||"b"===o.edges_assignment[e])).forEach((e=>{o.edges_assignment[e]="F"}));const{edges:e}=planarBoundary(o);e.forEach((e=>{o.edges_assignment[e]="B"}))}return{file_spec:1.1,file_creator:"Rabbit Ear",frame_classes:["creasePattern"],...o}};Object.assign(svgToFold,{...zr,svgSegments:svgSegments,svgEdgeGraph:svgEdgeGraph,planarizeGraph:planarizeGraph,makeEpsilon:makeEpsilon$1});var Br={objToFold:e=>{const t=e.split("\n").map((e=>e.trim().split(/\s+/))),r=(()=>{const e={};return e.file_spec=Ar,e.file_creator=xr,e.file_classes=["singleModel"],e.frame_classes=[],e.frame_attributes=[],e.vertices_coords=[],e.faces_vertices=[],e})();for(let e=0;e<t.length;e+=1)switch(t[e][0].toLowerCase()){case"f":r.faces_vertices.push(t[e].slice(1).map((e=>parseInt(e,10)-1)));break;case"v":r.vertices_coords.push(t[e].slice(1).map((e=>parseFloat(e))))}return r.faces_normal=makeFacesNormal(r),r.faces_center=makeFacesConvexCenter(r),r.edges_vertices=(({faces_vertices:e})=>{const t={},r=[];return e.flatMap(pairify).forEach((e=>{const s=[e.join(" "),`${e[1]} ${e[0]}`];s[0]in t||s[1]in t||(r.push(e),t[s[0]]=!0)})),r})(r),r.faces_edges=makeFacesEdgesFromVertices(r),r.edges_faces=makeEdgesFacesUnsorted(r),r.edges_foldAngle=makeEdgesFoldAngleFromFaces(r),r.edges_assignment=makeEdgesAssignment(r),r.vertices_vertices=makeVerticesVerticesFromFaces(r),delete r.faces_normal,delete r.faces_center,delete r.edges_faces,(e=>{if(!e.edges_foldAngle||!e.edges_foldAngle.length)return;let t=!0;for(let r=0;r<e.edges_foldAngle.length;r+=1)if(0!==e.edges_foldAngle[r]&&-180!==e.edges_foldAngle[r]&&180!==e.edges_foldAngle[r]){t=!1;break}e.frame_classes.push(t?"creasePattern":"foldedForm"),e.frame_attributes.push(t?"2D":"3D")})(r),r},opxToFold:opxToFold,svgToFold:svgToFold,foldToSvg:foldToSvg,foldToObj:foldToObj};const countFrames=e=>e.file_frames?e.file_frames.length+1:1,flattenFrame=(e,t=1)=>{if(!e.file_frames||e.file_frames.length<t)return e;const r=["frame_parent","frame_inherit"],o={visited_frames:[]},a={};filterKeysWithPrefix(e,"file").filter((e=>"file_frames"!==e)).forEach((t=>{a[t]=e[t]}));const recurse=(e,t,r)=>{if(-1!==o.visited_frames.indexOf(t))throw new Error(s);return o.visited_frames.push(t),r=[t].concat(r),0===t?r:e.file_frames[t-1].frame_inherit&&null!=e.file_frames[t-1].frame_parent?recurse(e,e.file_frames[t-1].frame_parent,r):r};return recurse(e,t,[]).map((t=>{if(0===t){const t=e.file_frames;e.file_frames=null;const s=clone(e);return e.file_frames=t,delete s.file_frames,r.forEach((e=>delete s[e])),s}const s=clone(e.file_frames[t-1]);return r.forEach((e=>delete s[e])),s})).reduce(((e,t)=>Object.assign(e,t)),a)},getTopLevelFrame=e=>{const t={...e};return delete t.file_frames,t};var Lr=Object.freeze({__proto__:null,countFrames:countFrames,flattenFrame:flattenFrame,getFramesAsFlatArray:e=>e.file_frames&&e.file_frames.length?[getTopLevelFrame(e),...e.file_frames]:[e],getFramesByClassName:(e,t)=>Array.from(Array(countFrames(e))).map(((t,r)=>flattenFrame(e,r))).filter((e=>e.frame_classes&&e.frame_classes.includes(t)))});const edgeToLine$1=({vertices_coords:e,edges_vertices:t},r)=>pointsToLine(t[r].map((t=>e[t]))),axiom1=({vertices_coords:e},t,r)=>axiom1$1(e[t],e[r]),axiom2=({vertices_coords:e},t,r)=>axiom2$1(e[t],e[r]),axiom3=({vertices_coords:e,edges_vertices:t},r,s)=>axiom3$1(...[r,s].map((r=>edgeToLine$1({vertices_coords:e,edges_vertices:t},r)))),axiom4=({vertices_coords:e,edges_vertices:t},r,s)=>axiom4$1(edgeToLine$1({vertices_coords:e,edges_vertices:t},r),e[s]),axiom5=({vertices_coords:e,edges_vertices:t},r,s,o)=>axiom5$1(edgeToLine$1({vertices_coords:e,edges_vertices:t},r),e[s],e[o]),axiom6=({vertices_coords:e,edges_vertices:t},r,s,o,a)=>axiom6$1(edgeToLine$1({vertices_coords:e,edges_vertices:t},r),edgeToLine$1({vertices_coords:e,edges_vertices:t},s),e[o],e[a]),axiom7=({vertices_coords:e,edges_vertices:t},r,s,o)=>axiom7$1(edgeToLine$1({vertices_coords:e,edges_vertices:t},r),edgeToLine$1({vertices_coords:e,edges_vertices:t},s),e[o]);var Ir=Object.freeze({__proto__:null,axiom:(e,...t)=>[null,axiom1,axiom2,axiom3,axiom4,axiom5,axiom6,axiom7][e](...t),axiom1:axiom1,axiom2:axiom2,axiom3:axiom3,axiom4:axiom4,axiom5:axiom5,axiom6:axiom6,axiom7:axiom7});const disjointGraphsIndices=e=>{const t=e.edges_vertices||[],r=e.faces_vertices||[],s=e.vertices_edges?e.vertices_edges:makeVerticesEdgesUnsorted({edges_vertices:t}),o=e.vertices_vertices?e.vertices_vertices:makeVerticesVerticesUnsorted({vertices_edges:s,edges_vertices:t}),a=e.vertices_faces?e.vertices_faces:makeVerticesFacesUnsorted({vertices_edges:s,faces_vertices:r}),n=invertMapArray(connectedComponents(o)),c=n.map((e=>e.flatMap((e=>s[e])))).map(uniqueElements),i=n.map((e=>e.flatMap((e=>a[e])))).map(uniqueElements);return Array.from(Array(n.length)).map(((e,t)=>({vertices:n[t]||[],edges:c[t]||[],faces:i[t]||[]})))};var Ur=Object.freeze({__proto__:null,disjointGraphs:e=>{const t=disjointGraphsIndices(e),r=filterKeysWithPrefix(e,"vertices"),s=filterKeysWithPrefix(e,"edges"),o=filterKeysWithPrefix(e,"faces");return t.map((({vertices:t,edges:a,faces:n})=>{const c={};return r.forEach((r=>{c[r]=[],t.forEach((t=>{c[r][t]=e[r][t]}))})),s.forEach((t=>{c[t]=[],a.forEach((r=>{c[t][r]=e[t][r]}))})),o.forEach((t=>{c[t]=[],n.forEach((r=>{c[t][r]=e[t][r]}))})),c}))},disjointGraphsIndices:disjointGraphsIndices});const getEdgesSide=({vertices_coords:e,edges_vertices:t},r,s=v)=>{const o=getEdgesLineIntersection$1({vertices_coords:e,edges_vertices:t},r,s,excludeS),a={};return getEdgesCollinearToLine({vertices_coords:e,edges_vertices:t},r,s).forEach((e=>{a[e]=!0})),t.map(((t,s)=>!0===a[s]?2:void 0!==o[s]?0:(t=>t.map((t=>e[t])).map((e=>subtract2(e,r.origin))).map((e=>cross2(r.vector,e))).sort(((e,t)=>Math.abs(t)-Math.abs(e))).map(Math.sign).shift())(t)))},getFacesSide=({vertices_coords:e,edges_vertices:t,faces_vertices:r,faces_edges:s},o,a=v)=>{s||(s=makeFacesEdgesFromVertices({edges_vertices:t,faces_vertices:r}));const n=getEdgesSide({vertices_coords:e,edges_vertices:t},o,a),c=s.map((e=>e.map((e=>n[e])).filter((e=>2!==e)))),i=c.map((e=>e.includes(0)));return c.map(((e,t)=>!i[t]&&e.reduce(((t,r)=>t&&r===e[0]),!0))).map(((e,t)=>e?c[t][0]:0))};var Rr=Object.freeze({__proto__:null,getEdgesSide:getEdgesSide,getFacesSide:getFacesSide,getFlapsThroughLine:({vertices_coords:e,edges_vertices:t,faces_vertices:r,faces_edges:s,faceOrders:o},a,n=v)=>{if(!o)throw new Error("faceOrders required");const c=getFacesSide({vertices_coords:e,edges_vertices:t,faces_vertices:r,faces_edges:s},a,n),i=[-1,1].map((e=>c.map(((e,t)=>({s:e,f:t}))).filter((t=>t.s===e||0===t.s)).map((e=>e.f)))),l=i.map((e=>faceOrdersSubset(o,e)));console.log("facesSide",c),console.log("sidesFaces",i),console.log("sidesFaceOrders",l);const d=makeFacesNormal({vertices_coords:e,faces_vertices:r}),m=l.map((t=>linearizeFaceOrders({vertices_coords:e,faces_vertices:r,faceOrders:t,faces_normal:d})));console.log("sidesLayersFace",m)}});const qr=Object.keys(T),updateSuffixes=(e,t,r,s)=>r.forEach((r=>t[r].forEach((t=>e[t].forEach(((o,a)=>o.forEach(((o,n)=>{e[t][a][n]=s[r][o]}))))))));var Dr=Object.freeze({__proto__:null,joinGraphs:(e,t,r=v)=>{const s={},o={},a={},n=[e,t].map((e=>e.vertices_coords)).map((e=>e&&e.length?e[0].length:0)).reduce(((e,t)=>Math.max(e,t)));e.vertices_coords=e.vertices_coords.map((e=>resize(n,e))),qr.forEach((e=>{s[e]=filterKeysWithPrefix(t,e),o[e]=filterKeysWithSuffix(t,e)})),qr.forEach((t=>s[t].filter((t=>!e[t])).forEach((t=>{e[t]=[]})))),a.vertices=((e,t,r=v)=>{let s=e.vertices_coords.length;return t.vertices_coords.map((t=>e.vertices_coords.map((e=>distance(e,t)<r)).map(((e,t)=>e?t:void 0)).filter((e=>void 0!==e)).shift())).map((e=>void 0===e?s++:e))})(e,t,r),updateSuffixes(t,o,["vertices"],a);const c=count.edges(e);a.edges=Array.from(Array(count.edges(t))).map(((e,t)=>c+t));const i=((e,t)=>{const r={},s={};for(let t=0;t<e.edges_vertices.length;t+=1)s[`${e.edges_vertices[t][0]} ${e.edges_vertices[t][1]}`]=t,s[`${e.edges_vertices[t][1]} ${e.edges_vertices[t][0]}`]=t;for(let e=0;e<t.edges_vertices.length;e+=1){const o=s[`${t.edges_vertices[e][0]} ${t.edges_vertices[e][1]}`];void 0!==o&&(r[e]=o)}return r})(e,t);Object.keys(i).forEach((e=>{a.edges[e]=i[e]}));const l=count.faces(e);return a.faces=Array.from(Array(count.faces(t))).map(((e,t)=>l+t)),updateSuffixes(t,o,["edges","faces"],a),qr.forEach((r=>s[r].forEach((s=>t[s].forEach(((t,o)=>{const n=a[r][o];e[s][n]=t})))))),a}});var Wr=Object.freeze({__proto__:null,pleat:({vertices_coords:e,edges_vertices:t},r,s,o,a)=>pleat$2(...[r,s].map((r=>(({vertices_coords:e,edges_vertices:t},r)=>pointsToLine(t[r].map((t=>e[t]))))({vertices_coords:e,edges_vertices:t},r))),o,a)});var Gr=Object.freeze({__proto__:null,getEdgesEdgesOverlapingSpans:({vertices_coords:e,edges_vertices:t,edges_coords:r},s=v)=>{const o=makeEdgesBoundingBox({vertices_coords:e,edges_vertices:t,edges_coords:r},s),a=t.map((()=>[]));for(let e=0;e<t.length-1;e+=1)for(let r=e+1;r<t.length;r+=1){const t=(o[e].max[0]<o[r].min[0]||o[r].max[0]<o[e].min[0])&&(o[e].max[1]<o[r].min[1]||o[r].max[1]<o[e].min[1]);a[e][r]=!t,a[r][e]=!t}for(let e=0;e<t.length;e+=1)a[e][e]=!0;return a},getEdgesVerticesOverlappingSpan:(e,t=v)=>makeEdgesBoundingBox(e,t).map((t=>e.vertices_coords.map((e=>e[0]>t.min[0]&&e[1]>t.min[1]&&e[0]<t.max[0]&&e[1]<t.max[1]))))});const fixLineDirection=({normal:e,distance:t})=>t<0?{normal:flip(e),distance:-t}:{normal:e,distance:t},findSymmetryLines=(e,t=v)=>{const{lines:r}=getEdgesLine(e,t),s=r.map(vecLineToUniqueLine).map(fixLineDirection),o=r.map((({vector:e,origin:t})=>makeMatrix2Reflect(e,t))),a=o.map((e=>r.map((({vector:t,origin:r})=>multiplyMatrix2Line2(e,t,r))))),n=a.map((e=>e.map((e=>e.vector[0]<0?{vector:flip(e.vector),origin:e.origin}:e)))).map((e=>e.map(vecLineToUniqueLine).map(fixLineDirection))).map((e=>e.concat(s))),c=n.map((e=>clusterScalars(e.map((e=>e.distance)))));return c.map(((e,r)=>e.map((e=>e.map((e=>n[r][e].normal)))).map((e=>clusterParallelVectors(e,t))))).map(((e,t)=>e.flatMap(((e,r)=>e.map((e=>e.map((e=>c[t][r][e])))))))).map((e=>(e.length-r.length)/r.length)).map(((e,t)=>({error:e,i:t}))).map((e=>({line:r[e.i],error:e.error}))).sort(((e,t)=>e.error-t.error))};var Hr=Object.freeze({__proto__:null,findSymmetryLine:(e,t=v)=>findSymmetryLines(e,t)[0],findSymmetryLines:findSymmetryLines});const triangulateConvexFacesVertices=({faces_vertices:e})=>e.flatMap((e=>{return e.length<4?[e]:(t=e,Array.from(Array(t.length-2)).map(((e,r)=>[t[0],t[r+1],t[r+2]])));var t})),triangulateNonConvexFacesVertices=({vertices_coords:e,faces_vertices:t},r)=>{if(!e||!e.length)throw new Error(d);const s=e.filter((()=>!0)).shift().length;return t.map((t=>t.flatMap((t=>e[t])))).map((e=>r(e,null,s))).map(((e,r)=>e.map((e=>t[r][e])))).flatMap((e=>(e=>3===e.length?[e]:Array.from(Array(Math.floor(e.length/3))).map(((t,r)=>[3*r+0,3*r+1,3*r+2].map((t=>e[t])))))(e)))},triangulate=(e,t)=>{if(!e.faces_vertices)return{};const r=e.edges_vertices?e.edges_vertices.length:0,s=(({faces_vertices:e})=>{let t=0;return e.map((e=>Math.max(3,e.length))).map((e=>Array.from(Array(e-2)).map((()=>t++))))})(e);e.faces_vertices=t?triangulateNonConvexFacesVertices(e,t):triangulateConvexFacesVertices(e),(e=>{e.edges_vertices||(e.edges_vertices=[]);const t=makeVerticesToEdgeBidirectional(e);let r=e.edges_vertices.length;const s=[];e.faces_edges=e.faces_vertices.map((e=>e.map(((e,o,a)=>{const n=[e,a[(o+1)%a.length]],c=n.join(" ");return c in t?t[c]:(s.push(n),t[c]=r,t[n.reverse().join(" ")]=r,r++)}))));const o=s.length;e.edges_vertices.push(...s),e.edges_assignment&&e.edges_assignment.push(...Array(o).fill("J")),e.edges_foldAngle&&e.edges_foldAngle.push(...Array(o).fill(0)),e.vertices_vertices&&delete e.vertices_vertices,e.vertices_edges&&delete e.vertices_edges,e.vertices_faces&&delete e.vertices_faces,e.edges_faces&&delete e.edges_faces,e.faces_faces&&delete e.faces_faces,e.faceOrders&&delete e.faceOrders})(e);return{faces:{map:s},edges:{new:Array.from(Array(e.edges_vertices.length-r)).map(((e,t)=>r+t))}}};var Jr=Object.freeze({__proto__:null,triangulate:triangulate,triangulateConvexFacesVertices:triangulateConvexFacesVertices,triangulateNonConvexFacesVertices:triangulateNonConvexFacesVertices});const Qr=Object.freeze([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),multiplyMatrix4Vector3=(e,t)=>[e[0]*t[0]+e[4]*t[1]+e[8]*t[2]+e[12],e[1]*t[0]+e[5]*t[1]+e[9]*t[2]+e[13],e[2]*t[0]+e[6]*t[1]+e[10]*t[2]+e[14]],multiplyMatrices4=(e,t)=>[e[0]*t[0]+e[4]*t[1]+e[8]*t[2]+e[12]*t[3],e[1]*t[0]+e[5]*t[1]+e[9]*t[2]+e[13]*t[3],e[2]*t[0]+e[6]*t[1]+e[10]*t[2]+e[14]*t[3],e[3]*t[0]+e[7]*t[1]+e[11]*t[2]+e[15]*t[3],e[0]*t[4]+e[4]*t[5]+e[8]*t[6]+e[12]*t[7],e[1]*t[4]+e[5]*t[5]+e[9]*t[6]+e[13]*t[7],e[2]*t[4]+e[6]*t[5]+e[10]*t[6]+e[14]*t[7],e[3]*t[4]+e[7]*t[5]+e[11]*t[6]+e[15]*t[7],e[0]*t[8]+e[4]*t[9]+e[8]*t[10]+e[12]*t[11],e[1]*t[8]+e[5]*t[9]+e[9]*t[10]+e[13]*t[11],e[2]*t[8]+e[6]*t[9]+e[10]*t[10]+e[14]*t[11],e[3]*t[8]+e[7]*t[9]+e[11]*t[10]+e[15]*t[11],e[0]*t[12]+e[4]*t[13]+e[8]*t[14]+e[12]*t[15],e[1]*t[12]+e[5]*t[13]+e[9]*t[14]+e[13]*t[15],e[2]*t[12]+e[6]*t[13]+e[10]*t[14]+e[14]*t[15],e[3]*t[12]+e[7]*t[13]+e[11]*t[14]+e[15]*t[15]],determinant4=e=>{const t=e[10]*e[15]-e[11]*e[14],r=e[9]*e[15]-e[11]*e[13],s=e[9]*e[14]-e[10]*e[13],o=e[8]*e[15]-e[11]*e[12],a=e[8]*e[14]-e[10]*e[12],n=e[8]*e[13]-e[9]*e[12];return e[0]*(e[5]*t-e[6]*r+e[7]*s)-e[1]*(e[4]*t-e[6]*o+e[7]*a)+e[2]*(e[4]*r-e[5]*o+e[7]*n)-e[3]*(e[4]*s-e[5]*a+e[6]*n)},invertMatrix4=e=>{const t=determinant4(e);if(Math.abs(t)<1e-12||Number.isNaN(t)||!Number.isFinite(e[12])||!Number.isFinite(e[13])||!Number.isFinite(e[14]))return;const r=e[10]*e[15]-e[11]*e[14],s=e[9]*e[15]-e[11]*e[13],o=e[9]*e[14]-e[10]*e[13],a=e[8]*e[15]-e[11]*e[12],n=e[8]*e[14]-e[10]*e[12],c=e[8]*e[13]-e[9]*e[12],i=e[6]*e[15]-e[7]*e[14],l=e[5]*e[15]-e[7]*e[13],d=e[5]*e[14]-e[6]*e[13],m=e[6]*e[11]-e[7]*e[10],g=e[5]*e[11]-e[7]*e[9],p=e[5]*e[10]-e[6]*e[9],v=e[4]*e[15]-e[7]*e[12],_=e[4]*e[14]-e[6]*e[12],u=e[4]*e[11]-e[7]*e[8],h=e[4]*e[10]-e[6]*e[8],b=e[4]*e[13]-e[5]*e[12],y=e[4]*e[9]-e[5]*e[8],E=[+(e[5]*r-e[6]*s+e[7]*o),-(e[1]*r-e[2]*s+e[3]*o),+(e[1]*i-e[2]*l+e[3]*d),-(e[1]*m-e[2]*g+e[3]*p),-(e[4]*r-e[6]*a+e[7]*n),+(e[0]*r-e[2]*a+e[3]*n),-(e[0]*i-e[2]*v+e[3]*_),+(e[0]*m-e[2]*u+e[3]*h),+(e[4]*s-e[5]*a+e[7]*c),-(e[0]*s-e[1]*a+e[3]*c),+(e[0]*l-e[1]*v+e[3]*b),-(e[0]*g-e[1]*u+e[3]*y),-(e[4]*o-e[5]*n+e[6]*c),+(e[0]*o-e[1]*n+e[2]*c),-(e[0]*d-e[1]*_+e[2]*b),+(e[0]*p-e[1]*h+e[2]*y)],A=1/t;return E.map((e=>e*A))},Zr=Object.freeze([1,0,0,0,0,1,0,0,0,0,1,0]),makeMatrix4Translate=(e=0,t=0,r=0)=>[...Zr,e,t,r,1],singleAxisRotate4=(e,t,r,s,o)=>{const a=makeMatrix4Translate(...t),n=Math.cos(e),c=Math.sin(e);return a[4*r+r]=n,a[4*r+s]=(o?1:-1)*c,a[4*s+r]=(o?-1:1)*c,a[4*s+s]=n,a},makeMatrix4Rotate=(e,t=[0,0,1],r=[0,0,0])=>{const s=[0,1,2].map((e=>r[e]||0)),[o,a,n]=resize(3,normalize(t)),c=Math.cos(e),i=Math.sin(e),l=1-c,d=makeMatrix4Translate(-s[0],-s[1],-s[2]),m=makeMatrix4Translate(s[0],s[1],s[2]);return multiplyMatrices4(m,multiplyMatrices4([l*o*o+c,l*a*o+n*i,l*n*o-a*i,0,l*o*a-n*i,l*a*a+c,l*n*a+o*i,0,l*o*n+a*i,l*a*n-o*i,l*n*n+c,0,0,0,0,1],d))},makeMatrix4Scale=(e=[1,1,1],t=[0,0,0])=>[e[0],0,0,0,0,e[1],0,0,0,0,e[2],0,e[0]*-t[0]+t[0],e[1]*-t[1]+t[1],e[2]*-t[2]+t[2],1],makePerspectiveMatrix4=(e,t,r,s)=>{const o=Math.tan(.5*Math.PI-.5*e),a=1/(r-s);return[o/t,0,0,0,0,o,0,0,0,0,(r+s)*a,-1,0,0,r*s*a*2,0]},makeOrthographicMatrix4=(e,t,r,s,o,a)=>[2/(t-s),0,0,0,0,2/(e-r),0,0,0,0,2/(o-a),0,(s+t)/(s-t),(r+e)/(r-e),(o+a)/(o-a),1];var Yr=Object.freeze({__proto__:null,determinant4:determinant4,identity4x4:Qr,invertMatrix4:invertMatrix4,isIdentity4x4:e=>Qr.map(((t,r)=>Math.abs(t-e[r])<v)).reduce(((e,t)=>e&&t),!0),makeLookAtMatrix4:(e,t,r)=>{const s=normalize3(subtract3(e,t)),o=normalize3(cross3(r,s)),a=normalize3(cross3(s,o));return[o[0],o[1],o[2],0,a[0],a[1],a[2],0,s[0],s[1],s[2],0,e[0],e[1],e[2],1]},makeMatrix4ReflectZ:(e,t=[0,0])=>{const r=makeMatrix2Reflect(e,t);return[r[0],r[1],0,0,r[2],r[3],0,0,0,0,1,0,r[4],r[5],0,1]},makeMatrix4Rotate:makeMatrix4Rotate,makeMatrix4RotateX:(e,t=[0,0,0])=>singleAxisRotate4(e,t,1,2,!0),makeMatrix4RotateY:(e,t=[0,0,0])=>singleAxisRotate4(e,t,0,2,!1),makeMatrix4RotateZ:(e,t=[0,0,0])=>singleAxisRotate4(e,t,0,1,!0),makeMatrix4Scale:makeMatrix4Scale,makeMatrix4Translate:makeMatrix4Translate,makeMatrix4UniformScale:(e=1,t=[0,0,0])=>makeMatrix4Scale([e,e,e],t),makeOrthographicMatrix4:makeOrthographicMatrix4,makePerspectiveMatrix4:makePerspectiveMatrix4,multiplyMatrices4:multiplyMatrices4,multiplyMatrix4Line3:(e,t,r)=>({vector:[e[0]*t[0]+e[4]*t[1]+e[8]*t[2],e[1]*t[0]+e[5]*t[1]+e[9]*t[2],e[2]*t[0]+e[6]*t[1]+e[10]*t[2]],origin:[e[0]*r[0]+e[4]*r[1]+e[8]*r[2]+e[12],e[1]*r[0]+e[5]*r[1]+e[9]*r[2]+e[13],e[2]*r[0]+e[6]*r[1]+e[10]*r[2]+e[14]]}),multiplyMatrix4Vector3:multiplyMatrix4Vector3});const quaternionFromTwoVectors=(e,t)=>{const r=cross3(e,t),s=[r[0],r[1],r[2],dot(e,t)];return s[3]+=magnitude(s),normalize(s)},matrix4FromQuaternion=e=>multiplyMatrices4([e[3],e[2],-e[1],e[0],-e[2],e[3],e[0],e[1],e[1],-e[0],e[3],e[2],-e[0],-e[1],-e[2],e[3]],[e[3],e[2],-e[1],-e[0],-e[2],e[3],e[0],-e[1],e[1],-e[0],e[3],-e[2],e[0],e[1],e[2],e[3]]);var Xr=Object.freeze({__proto__:null,matrix4FromQuaternion:matrix4FromQuaternion,quaternionFromTwoVectors:quaternionFromTwoVectors});const coplanarFacesGroups=({vertices_coords:e,faces_vertices:t},r=v)=>{const s=makeFacesNormal({vertices_coords:e,faces_vertices:t}),o=t.map((()=>[]));for(let e=0;e<t.length-1;e+=1)for(let a=e+1;a<t.length;a+=1)e!==a&&parallelNormalized(s[e],s[a],r)&&(o[e].push(a),o[a].push(e));const a=connectedComponents(o),n=invertMap(a).map((e=>"number"==typeof e?[e]:e)),c=n.map((e=>s[e[0]])),i=[];n.forEach(((e,t)=>e.forEach((e=>{i[e]=dot3(s[e],c[t])>0}))));const l=t.map((t=>e[t[0]])).map((e=>resize(3,e))),d=n.map(((e,t)=>e.map((e=>dot3(c[t],l[e]))))).map(((e,t)=>clusterScalars(e).map((e=>e.map((e=>n[t][e])))))),m=d.flatMap(((e,t)=>e.map((()=>[...c[t]])))),g=d.flat(),p=g.map((e=>e[0])).map((e=>l[e])).map(((e,t)=>dot3(m[t],e))).map(((e,t)=>scale3(m[t],e))),_=g.map(((e,t)=>({normal:m[t],origin:p[t]})));return g.map(((e,t)=>({faces:e,facesAligned:e.map((e=>i[e])),plane:_[t]})))},coplanarOverlappingFacesGroups=({vertices_coords:e,faces_vertices:t,faces_faces:r},s=v)=>{r||(r=makeFacesFaces({faces_vertices:t}));const o=coplanarFacesGroups({vertices_coords:e,faces_vertices:t},s),a=[];o.forEach((e=>e.facesAligned.forEach(((t,r)=>{a[e.faces[r]]=t}))));const n=[0,0,1],c=o.map((e=>e.plane.normal)).map((e=>{const t=dot(e,n);return Math.abs(t+1)<.01?makeMatrix4Rotate(Math.PI,[1,0,0]):matrix4FromQuaternion(quaternionFromTwoVectors(e,n))})),i=((e,t,r,s)=>{const o=e.vertices_coords.map((e=>resize(3,e))),a=t.map((t=>t.faces.map(((r,s)=>t.facesAligned[s]?e.faces_vertices[r]:e.faces_vertices[r].slice().reverse())).map((e=>e.map((e=>o[e])))).map((e=>makePolygonNonCollinear(e,s))))),n=[],c=a.map(((e,t)=>e.map((e=>e.map((e=>multiplyMatrix4Vector3(r[t],e))).map((e=>[e[0],e[1]]))))));return t.map((e=>e.faces)).forEach(((e,t)=>e.forEach(((e,r)=>{n[e]=c[t][r]})))),n})({vertices_coords:e,faces_vertices:t},o,c,s),l=o.map((e=>e.faces)).map((e=>selfRelationalArraySubset(r,e))).map((e=>connectedComponents(e))),d=l.map((e=>invertMap(e).map((e=>e.constructor===Array?e:[e])))),m=l.map((e=>{const t=e.map(((e,t)=>t));return e.map((r=>t.filter((t=>e[t]!==r))))})),g=t.map((()=>[]));m.forEach((e=>e.forEach(((e,t)=>{for(let r=0;r<e.length;r+=1){const o=e[r],a=[t,o].map((e=>i[e]));overlapConvexPolygons(...a,s)&&(g[t][o]=!0,g[o][t]=!0)}}))));const p=m.map((e=>e.map(((e,t)=>e.filter((e=>g[t][e])))))),_=[];p.forEach(((e,t)=>{_[t]=[],e.forEach(((e,r)=>{const s=l[t][r],o=e.map((e=>l[t][e]));_[t][s]||(_[t][s]=new Set),o.forEach((e=>{_[t][e]||(_[t][e]=new Set)})),o.forEach((e=>{_[t][s].add(e),_[t][e].add(s)}))}))})),_.forEach(((e,t)=>e.forEach(((e,r)=>{_[t][r]=[...e]}))));const u=_.map((e=>invertMap(connectedComponents(e)).map((e=>e.constructor===Array?e:[e])))),h=u.flatMap(((e,t)=>e.map((()=>t)))),b=o.map(((e,t)=>u[t].map((e=>e.flatMap((e=>d[t][e])))))).flatMap(((e,t)=>e.map((e=>({faces:e,facesAligned:e.map((e=>a[e])),plane:o[t].plane}))))),y=h.map((e=>o[e].plane)),E=h.map((e=>c[e])),A=b.map((e=>e.faces));return{sets_faces:A,sets_plane:y,sets_transformXY:E,faces_set:invertMap(A),faces_winding:a}};var Kr=Object.freeze({__proto__:null,coplanarFacesGroups:coplanarFacesGroups,coplanarOverlappingFacesGroups:coplanarOverlappingFacesGroups});const makeEdgesEdgesParallelOverlap=({vertices_coords:e,edges_vertices:t,edges_vector:r},s)=>{r||(r=makeEdgesVector({vertices_coords:e,edges_vertices:t}));const o=t.map((t=>e[t[0]])),a=r.map(((e,t)=>({vector:e,origin:o[t]})));return(({vertices_coords:e,edges_vertices:t,edges_vector:r},s=v)=>{r||(r=makeEdgesVector({vertices_coords:e,edges_vertices:t}));const o=r.map((e=>normalize(e))),a=t.map((()=>[]));return o.forEach(((e,t)=>{o.forEach(((e,r)=>{r>=t||1-Math.abs(dot(o[t],o[r]))<s&&(a[t].push(r),a[r].push(t))}))})),a})({vertices_coords:e,edges_vertices:t,edges_vector:r},.001).map(((e,t)=>e.filter((e=>overlapLineLine(a[t],a[e],excludeS,excludeS,s)))))};var es=Object.freeze({__proto__:null,makeEdgesEdgesParallelOverlap:makeEdgesEdgesParallelOverlap});const booleanMatrixToIndexedArray=e=>e.map((e=>e.map(((e,t)=>!0===e?t:void 0)).filter((e=>void 0!==e)))),getEdgesFacesOverlap=({vertices_coords:e,edges_vertices:t,edges_vector:r,edges_faces:s,faces_vertices:o},a=v)=>{r||(r=makeEdgesVector({vertices_coords:e,edges_vertices:t}));const n=t.map((t=>e[t[0]])),c=t.map((()=>Array.from(Array(o.length))));s.forEach(((e,t)=>e.forEach((e=>{c[t][e]=!1}))));const i=t.map((t=>t.map((t=>e[t])))),l=o.map((t=>t.map((t=>e[t]))));makeFacesWinding({vertices_coords:e,faces_vertices:o}).map(((e,t)=>e?void 0:t)).filter((e=>void 0!==e)).forEach((e=>l[e].reverse()));const d=makeEdgesBoundingBox({edges_coords:i}),m=l.map((e=>boundingBox$1(e)));for(let e=0;e<c.length;e+=1)if(d[e])for(let t=0;t<c[e].length;t+=1)!1!==c[e][t]&&m[t]&&(overlapBoundingBoxes(m[t],d[e],a)||(c[e][t]=!1));const g=(({vertices_coords:e,edges_vertices:t,edges_coords:r,edges_boundingBox:s},o=v)=>{r||(r=makeEdgesCoords({vertices_coords:e,edges_vertices:t})),s||(s=makeEdgesBoundingBox({vertices_coords:e,edges_vertices:t,edges_coords:r}));const a=t.map(((e,t)=>t)).shift(),n=Array.from(Array(r.length)).map((()=>[]));if(void 0===a)return booleanMatrixToIndexedArray(n);const c=s[a].min.length;for(let e=0;e<r.length-1;e+=1)if(s[e])for(let t=e+1;t<r.length;t+=1){if(!s[t])continue;let r=!0;for(let a=0;a<c;a+=1)epsilonEqual(s[e].min[a],s[t].min[a],o)&&epsilonEqual(s[e].max[a],s[t].max[a],o)||(r=!1);n[e][t]=r,n[t][e]=r}for(let e=0;e<r.length-1;e+=1)for(let t=e+1;t<r.length;t+=1){if(!n[e][t])continue;const s=epsilonEqualVectors(r[e][0],r[t][0],o)&&epsilonEqualVectors(r[e][1],r[t][1],o),a=epsilonEqualVectors(r[e][0],r[t][1],o)&&epsilonEqualVectors(r[e][1],r[t][0],o),c=s||a;n[e][t]=c,n[t][e]=c}return booleanMatrixToIndexedArray(n)})({vertices_coords:e,edges_vertices:t,edges_coords:i,edges_boundingBox:d}),p={};for(let e=0;e<c.length;e+=1)if(!p[e]&&i[e]){for(let t=0;t<c[e].length;t+=1){if(void 0!==c[e][t])continue;if(!l[t])continue;if(i[e].map((e=>overlapConvexPolygonPoint(l[t],e,exclude,.001))).reduce(((e,t)=>e||t),!1)){c[e][t]=!0;continue}intersectConvexPolygonLine(l[t],{vector:r[e],origin:n[e]},excludeS,excludeS,a)?c[e][t]=!0:c[e][t]=!1}g[e].forEach((t=>{c[t]=c[e].slice(),p[t]=!0}))}return c.map((e=>e.map(((e,t)=>e?t:void 0)).filter((e=>void 0!==e))))};var ts=Object.freeze({__proto__:null,getEdgesFacesOverlap:getEdgesFacesOverlap});const getFacesFacesOverlap=({vertices_coords:e,faces_vertices:t},r=v)=>{const s=makeFacesPolygon({vertices_coords:e,faces_vertices:t}),o=s.map((e=>boundingBox$1(e))),a=[],n=[];return sweepFaces({vertices_coords:e,faces_vertices:t},0,r).forEach((e=>{e.start.forEach((e=>{n[e]=!0})),n.forEach(((t,n)=>e.start.forEach((e=>{n!==e&&overlapBoundingBoxes(o[n],o[e],r)&&overlapConvexPolygons(s[n],s[e],r)&&(a[n]||(a[n]=[]),a[e]||(a[e]=[]),a[n][e]=!0,a[e][n]=!0)})))),e.end.forEach((e=>delete n[e]))})),a.map((e=>Object.keys(e).map((e=>parseInt(e,10)))))};var rs=Object.freeze({__proto__:null,getFacesFacesOverlap:getFacesFacesOverlap});const getEdgesLineIntersection=({vertices_coords:e,edges_vertices:t},{vector:r,origin:s},o=v,a=includeS)=>t.map((t=>{const n=t.map((t=>e[t]));return((e,t,r=includeL,s=includeL,o=v)=>{const a=cross2(normalize2(e.vector),normalize2(t.vector));if(Math.abs(a)<o)return;const n=cross2(e.vector,t.vector),c=-n,i=[t.origin[0]-e.origin[0],t.origin[1]-e.origin[1]],l=[-i[0],-i[1]],d=cross2(i,t.vector)/n,m=cross2(l,e.vector)/c;return r(d,o/magnitude2(e.vector))&&s(m,o/magnitude2(t.vector))?{point:add2(e.origin,scale2(e.vector,d)),a:d,b:m}:void 0})({vector:subtract2(n[1],n[0]),origin:n[0]},{vector:r,origin:s},a,includeL,o)}));var ss={count:count,countImplied:countImplied,validate:validate,clean:clean,populate:populate,remove:removeGeometryIndices,replace:replaceGeometryIndices,removePlanarVertex:removePlanarVertex,removePlanarEdge:removePlanarEdge,splitEdge:splitEdge,splitFace:splitFace,flatFold:flatFold,repeatFold:({vertices_coords:e,edges_vertices:t,edges_faces:r,edges_foldAngle:s,edges_assignment:o,faces_vertices:a,faces_edges:n,faces_faces:c},{vector:i,origin:l},d="V",m=v)=>{r||(n||(n=makeFacesEdgesFromVertices({edges_vertices:t,faces_vertices:a})),r=makeEdgesFacesUnsorted({edges_vertices:t,faces_edges:n}));const g=(({vertices_coords:e,faces_vertices:t},r)=>{const s=facesContainingPoint({vertices_coords:e,faces_vertices:t},r);if(0!==s.length)return s.length,s[0]})({vertices_coords:e,faces_vertices:a},l),p=invertAssignment(d),_=makeVerticesCoordsFlatFolded({vertices_coords:e,edges_vertices:t,edges_foldAngle:s,edges_assignment:o,faces_vertices:a,faces_faces:c},g),u=makeFacesWinding({vertices_coords:_,faces_vertices:a});u[g]||u.forEach(((e,t)=>{u[t]=!e}));const h=getEdgesLineIntersection({vertices_coords:_,edges_vertices:t},{vector:i,origin:l},m);h.forEach(((e,t)=>{void 0!==e&&(e.edge=t)}));const b=[],y=[];n.map((e=>e.map((e=>h[e])).filter((e=>void 0!==e)))).forEach(((e,t)=>{switch(e.length){case 0:case 1:break;case 2:b[t]=e;break;default:y[t]=e}})),y.forEach(((e,t)=>{e.sort(((e,t)=>e.b-t.b));const r=clusterSortedGeneric(e,((e,t)=>Math.abs(e.b-t.b)<2*m)).map((t=>t.map((t=>e[t]))));2===r.length&&(b[t]=[r[0][0],r[r.length-1][0]])}));const E=t.map((t=>e[t[0]])),A=makeEdgesVector({vertices_coords:e,edges_vertices:t});return b.map(((e,t)=>({edges:e.map((e=>e.edge)),assignment:u[t]?d:p,points:e.map((e=>add2(scale2(A[e.edge],e.a),E[e.edge])))})))},addVertex:(e,t)=>{e.vertices_coords||(e.vertices_coords=[]);const r=e.vertices_coords.length;return filterKeysWithPrefix(e,"vertices").forEach((t=>{e[t][r]=[]})),e.vertices_coords[r]=t,r},addNonPlanarEdge:(e,t)=>{if(2!==t.length)return;e.edges_vertices||(e.edges_vertices=[]);const r=e.edges_vertices.length;if(filterKeysWithPrefix(e,"edges").forEach((t=>{e[t][r]=[]})),e.edges_vertices[r]=t,e.edges_assignment&&(e.edges_assignment[r]="U"),e.edges_foldAngle&&(e.edges_foldAngle[r]=0),e.vertices_edges&&t.forEach((t=>{e.vertices_edges[t]=e.vertices_edges[t].filter((e=>e!==r)),e.vertices_edges[t].push(r)})),e.vertices_vertices){const r=[t[1],t[0]];t.forEach(((t,s)=>{e.vertices_vertices[t]=e.vertices_vertices[t].filter((e=>e!==r[s])),e.vertices_vertices[t].push(r[s])}))}return r},addPlanarLine:(e,{vector:t,origin:r},s=v)=>{const o=getEdgesLineIntersection$1(e,{vector:t,origin:r},s).filter(Boolean).map((e=>subtract(e,r))).map((e=>dot(e,t))),a=epsilonUniqueSortedNumbers(o).map((e=>add(scale$1(t,e),r)));return Array.from(Array(a.length-1)).map(((e,t)=>[a[t],a[t+1]])).map((t=>addPlanarSegment(e,t[0],t[1],s)))},addPlanarSegment:addPlanarSegment,addPlanarSegmentNew:(e,t,r=v)=>{const s=((e,t,r=v)=>{const s=subtract2(t[1],t[0]),o=t[0],a=getFacesSegmentOverlap(e,t,r),n=a.map((t=>e.faces_vertices[t].map((t=>e.vertices_coords[t])))).map((e=>clipLineConvexPolygon(e,{vector:s,origin:o},include,includeS,r))),c=[];return a.forEach(((e,t)=>{n[t]&&(c[e]=n[t])})),c})(e,t,r);console.log("facesSegment",s);const o=s.map(((t,s)=>((e,t,r,s=v)=>{e.faces_vertices[t].map((t=>e.vertices_coords[t])).map((e=>r.map((t=>epsilonEqualVectors(e,t,s))))),e.faces_vertices[t].map((t=>e.vertices_coords[t])).map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>pointsToLine(...e))).map((e=>r.map((t=>overlapLinePoint(e,t,excludeS,s)))))})(e,s,t,r)));return o},planarize:planarize,connectedComponents:connectedComponents,clone:clone,...Nr,...Lr,...z,...D,...Ir,...Ae,...dr,...fe,...Rr,...Dr,...ne,...le,...ge,...oe,...Zt,...Wr,...Gr,...Ee,...pe,...Hr,...Qt,...Ur,...W,...Me,...Jr,...K,...H,...G,...ue,...J,...we,...Q,...se,...ie,...ce,..._e,...he,...Kr,...xe,...Oe,...Jt,...mr,...gr,...es,...ts,...ye,...rs};const typeOf=e=>"object"!=typeof e?typeof e:void 0!==e.radius?"circle":e.min&&e.max&&e.span?"box":"number"==typeof e[0]?"vector":void 0!==e.vector&&void 0!==e.origin?"line":void 0!==e[0]&&e[0].length&&"number"==typeof e[0][0]?2===e.length?"segment":"polygon":"object",os={...b,...V,...F,...Z,...j,...Pr,...te,...re,typeof:typeOf},as={...y,...x,...w,...Yr,...Xr};const recurseSkeleton=(e,t,r)=>{const s=e.map(((e,t)=>({vector:r[t],origin:e}))).map(((e,t,r)=>intersectLineLine(e,r[(t+1)%r.length],P,P))),o=t.map(((e,t)=>nearestPointOnLine(e,s[t],(e=>e))));if(3===e.length)return e.map((e=>({type:"skeleton",points:[e,s[0]]}))).concat([{type:"perpendicular",points:[o[0],s[0]]}]);const a=s.map(((e,t)=>distance(e,o[t])));let n=0;a.forEach(((e,t)=>{e<a[n]&&(n=t)}));const c=[{type:"skeleton",points:[e[n],s[n]]},{type:"skeleton",points:[e[(n+1)%e.length],s[n]]},{type:"perpendicular",points:[o[n],s[n]]}],i=clockwiseBisect2(flip(t[(n+t.length-1)%t.length].vector),t[(n+1)%t.length].vector),l=n===e.length-1;return e.splice(n,2,s[n]),t.splice(n,1),r.splice(n,2,i),l&&(e.splice(0,1),r.splice(0,1),t.push(t.shift())),c.concat(recurseSkeleton(e,t,r))},ns={...Object.freeze({__proto__:null,convexHull:(e=[],t=!1,r=v)=>{if(e.length<2)return[];const s=radialSortPointIndices2(e,r).map((e=>1===e.length?e:(e=>e.concat(e.slice(0,-1).reverse()))(e))).flat();s.push(s[0]);const o=[s[0]];let a=1;const n={"-1":()=>o.pop(),1:e=>{o.push(e),a+=1},undefined:()=>{a+=1}};for(n[0]=t?n[1]:n[-1];a<s.length;){if(o.length<2){o.push(s[a]),a+=1;continue}const t=o[o.length-2],c=o[o.length-1],i=s[a];n[threePointTurnDirection(...[t,c,i].map((t=>e[t])),r)](i)}return o.pop(),o}}),...ve,...de,...ee,...C,...Y,straightSkeleton:e=>{const t=e.map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>({vector:subtract(e[1],e[0]),origin:e[0]}))),r=e.map(((e,t,r)=>[(t-1+r.length)%r.length,t,(t+1)%r.length].map((e=>r[e])))).map((e=>[subtract(e[0],e[1]),subtract(e[2],e[1])])).map((e=>clockwiseBisect2(...e)));return recurseSkeleton([...e],t,r)}};var cs=Object.freeze({__proto__:null,enclosingBoundingBoxes:(e,t,r=v)=>{const s=Math.min(e.min.length,t.min.length);for(let o=0;o<s;o+=1)if(t.min[o]<e.min[o]-r||t.max[o]>e.max[o]+r)return!1;return!0},enclosingPolygonPolygon:(e,t,r=include)=>{const s=e.map((e=>overlapConvexPolygonPoint(t,e,r))).reduce(((e,t)=>e||t),!1),o=t.map((e=>overlapConvexPolygonPoint(t,e,r))).reduce(((e,t)=>e&&t),!0);return!s&&o},pointInBoundingBox:(e,t,r=v)=>{for(let s=0;s<e.length;s+=1)if(e[s]<t.min[s]-r||e[s]>t.max[s]+r)return!1;return!0}});var is=Object.freeze({__proto__:null,splitConvexPolygon:(e,t)=>{const r=e.map(((e,r)=>({point:overlapLinePoint(t,e,includeL)?e:null,at_index:r}))).filter((e=>null!=e.point)),s=e.map(((e,t,r)=>({vector:subtract(e,r[(t+1)%r.length]),origin:r[(t+1)%r.length]}))).map(((e,r)=>({point:intersectLineLine(t,e,excludeL,excludeS),at_index:r}))).filter((e=>null!=e.point));if(2===s.length){const t=s.slice().sort(((e,t)=>e.at_index-t.at_index)),r=e.slice(t[1].at_index+1).concat(e.slice(0,t[0].at_index+1));r.push(t[0].point),r.push(t[1].point);const o=e.slice(t[0].at_index+1,t[1].at_index+1);return o.push(t[1].point),o.push(t[0].point),[r,o]}if(1===s.length&&1===r.length){r[0].type="v",s[0].type="e";const t=r.concat(s).sort(((e,t)=>e.at_index-t.at_index)),o=e.slice(t[1].at_index+1).concat(e.slice(0,t[0].at_index+1));"e"===t[0].type&&o.push(t[0].point),o.push(t[1].point);const a=e.slice(t[0].at_index+1,t[1].at_index+1);return"e"===t[1].type&&a.push(t[1].point),a.push(t[0].point),[o,a]}if(2===r.length){const t=r.slice().sort(((e,t)=>e.at_index-t.at_index));return[e.slice(t[1].at_index).concat(e.slice(0,t[0].at_index+1)),e.slice(t[0].at_index,t[1].at_index+1)]}return[e.slice()]}});const ls={polygon:includeS,circle:include,line:includeL,ray:S,segment:includeS},fs={...cs,...me,...be,...fr,...is,intersect:(e,t,r=v)=>{const nameType=e=>"polygon"===e?"ConvexPolygon":(e=>e.charAt(0).toUpperCase()+e.slice(1))(e),s=[e,t].map(typeOf),o=[s,s.slice().reverse()].map((e=>e.map(nameType).join(""))).map((e=>be[`intersect${e}`])),a=[e.domain,t.domain].map(((e,t)=>e||ls[s[t]])),n=[[e,t,...a],[t,e,...a.slice().reverse()]],c=o.map(((e,t)=>({fn:e,params:n[t]}))).filter((e=>e.fn)).shift();return c?c.fn(...c.params,r):void 0}},ds={...os,...as,...ns,...fs};const ms={U:!0,u:!0},maekawaSolver=e=>{const t=(r=e).map(((e,t)=>t)).filter((e=>ms[r[e]]));var r;const s=Array.from(Array(2**t.length)).map(((e,t)=>t.toString(2))).map((e=>Array(t.length-e.length+1).join("0")+e)).map((e=>Array.from(e).map((e=>"0"===e?"V":"M")))).map((r=>{const s=e.slice();return t.forEach(((e,t)=>{s[e]=r[t]})),s}));if(e.filter((e=>U[e])).length>0)return s;const o=s.map((e=>e.filter((e=>"M"===e||"m"===e)).length)),a=s.map((e=>e.filter((e=>"V"===e||"v"===e)).length));return s.filter(((e,t)=>2===Math.abs(o[t]-a[t])))};var gs={...Object.freeze({__proto__:null,foldDegree4:(e,t,r=0)=>{const s=(e=>{const t=e.map((e=>e.toUpperCase()));return t.filter((e=>"M"===e)).length>t.filter((e=>"V"===e)).length?t.indexOf("V"):t.indexOf("M")})(t);if(-1===s)return;const o=e[(s+1)%e.length],a=e[(s+2)%e.length],n=Math.max(-Math.PI,Math.min(Math.PI,r)),c=-Math.cos(o)*Math.cos(a)+Math.sin(o)*Math.sin(a)*Math.cos(Math.PI-n),i=Math.cos(Math.PI-n)-Math.sin(Math.PI-n)**2*Math.sin(o)*Math.sin(a)/(1-c),l=-Math.acos(i)+Math.PI;return s%2==0?[l,n,l,n].map(((e,t)=>s===t?-e:e)):[n,l,n,l].map(((e,t)=>s===t?-e:e))}}),...pr,...Object.freeze({__proto__:null,maekawaSolver:maekawaSolver}),...vr};const compileShader=(e,t,r)=>{const s=e.createShader(r);if(e.shaderSource(s,t),e.compileShader(s),!e.getShaderParameter(s,e.COMPILE_STATUS))throw new Error(e.getShaderInfoLog(s));return s},createProgram=(e,t,r)=>((e,t,r)=>{const s=e.createProgram();if(e.attachShader(s,t),e.attachShader(s,r),e.linkProgram(s),!e.getProgramParameter(s,e.LINK_STATUS))throw new Error(e.getProgramInfoLog(s));return e.deleteShader(t),e.deleteShader(r),s})(e,compileShader(e,t,e.VERTEX_SHADER),compileShader(e,r,e.FRAGMENT_SHADER));var ps=Object.freeze({__proto__:null,makeModelMatrix:e=>{if(!e)return Qr;const t=boundingBox(e);if(!t)return Qr;const r=Math.max(...t.span);if(0===r)return Qr;const s=[r,0,0,0,0,r,0,0,0,0,r,0,...resize(3,midpoint(t.min,t.max)),1];return invertMatrix4(s)||Qr},makeProjectionMatrix:(e,t="perspective",r=45)=>{if(!e)return Qr;const s=[e.clientWidth,e.clientHeight],o=Math.min(...s),a=[0,1].map((e=>(s[e]-o)/o/2)).map((e=>e+.5));return"orthographic"===t?makeOrthographicMatrix4(a[1],a[0],-a[1],-a[0],-100,100):makePerspectiveMatrix4(r*(Math.PI/180),s[0]/s[1],.1,20)},rebuildViewport:(e,t)=>{if(!e)return;const r=window.devicePixelRatio||1,s=[t.clientWidth,t.clientHeight].map((e=>e*r));t.width===s[0]&&t.height===s[1]||(t.width=s[0],t.height=s[1]),e.viewport(0,0,e.canvas.width,e.canvas.height)}});const uniformFunc=(e,t,r,s)=>{if("uniformMatrix4fv"===r)e[r](t,!1,s);else e[r](t,s)};var vs=Object.freeze({__proto__:null,deallocProgram:(e,t)=>{t.vertexArrays.forEach((t=>e.disableVertexAttribArray(t.location))),t.vertexArrays.forEach((t=>e.deleteBuffer(t.buffer))),t.elementArrays.forEach((t=>e.deleteBuffer(t.buffer))),e.deleteProgram(t.program)},drawProgram:(e,t,r,s={})=>{e.useProgram(r.program),r.flags.forEach((t=>e.enable(t)));const o=e.getProgramParameter(r.program,e.ACTIVE_UNIFORMS);for(let t=0;t<o;t+=1){const o=e.getActiveUniform(r.program,t).name,a=s[o];if(a){const t=e.getUniformLocation(r.program,o);uniformFunc(e,t,a.func,a.value)}}r.vertexArrays.forEach((t=>{e.bindBuffer(e.ARRAY_BUFFER,t.buffer),e.bufferData(e.ARRAY_BUFFER,t.data,e.STATIC_DRAW),e.vertexAttribPointer(t.location,t.length,t.type,!1,0,0),e.enableVertexAttribArray(t.location)})),r.elementArrays.forEach((r=>{e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,r.buffer),e.bufferData(e.ELEMENT_ARRAY_BUFFER,r.data,e.STATIC_DRAW),e.drawElements(r.mode,r.data.length,2===t?e.UNSIGNED_INT:e.UNSIGNED_SHORT,r.buffer)})),r.flags.forEach((t=>e.disable(t)))}});const _s={B:[.5,.5,.5],b:[.5,.5,.5],V:[.2,.4,.6],v:[.2,.4,.6],M:[.75,.25,.15],m:[.75,.25,.15],F:[.3,.3,.3],f:[.3,.3,.3],J:[.3,.2,0],j:[.3,.2,0],C:[.5,.8,.1],c:[.5,.8,.1],U:[.6,.25,.9],u:[.6,.25,.9]},us={B:[0,0,0],b:[0,0,0],V:[.2,.5,.8],v:[.2,.5,.8],M:[.75,.25,.15],m:[.75,.25,.15],F:[.75,.75,.75],f:[.75,.75,.75],J:[1,.75,.25],j:[1,.75,.25],C:[.5,.8,.1],c:[.5,.8,.1],U:[.6,.25,.9],u:[.6,.25,.9]},parseColorToWebGLRgb=e=>void 0!==e&&e.constructor===Array?e.slice(0,3):parseColorToRgb(e).slice(0,3).map((e=>e/255)),makeFacesVertexData=({vertices_coords:e,edges_assignment:t,faces_vertices:r,faces_edges:s,faces_normal:o},a={})=>{const n=e.map((e=>[...e].concat(Array(3-e.length).fill(0)))),c=makeVerticesNormal({vertices_coords:n,faces_vertices:r,faces_normal:o}),i=n.map(((e,t)=>t%3)).map((e=>[0===e?1:0,1===e?1:0,2===e?1:0])),l=s.map((e=>e.map((e=>t[e])).map((e=>"J"===e||"j"===e))));if(!a.showTrianglulation)for(let e=0;e<l.length;e+=1)l[e][0]&&(i[3*e+0][2]=i[3*e+1][2]=100),l[e][1]&&(i[3*e+1][0]=i[3*e+2][0]=100),l[e][2]&&(i[3*e+0][1]=i[3*e+2][1]=100);return{vertices_coords:e,vertices_normal:c,vertices_barycentric:i}},makeThickEdgesVertexData=(e,t)=>{if(!e||!e.vertices_coords||!e.edges_vertices)return[];const r={...t&&t.dark?_s:us,...t},s=e.vertices_coords.map((e=>[...e].concat(Array(3-e.length).fill(0)))),o=e.edges_vertices.flatMap((e=>e.map((e=>s[e])))).flatMap((e=>[e,e,e,e])),a=makeEdgesVector(e);return{vertices_coords:o,vertices_color:e.edges_assignment?e.edges_assignment.flatMap((e=>Array(8).fill(r[e]))):e.edges_vertices.flatMap((()=>Array(8).fill(r.U))),verticesEdgesVector:a.flatMap((e=>[e,e,e,e,e,e,e,e])),vertices_vector:e.edges_vertices.flatMap((()=>[[1,0],[0,1],[-1,0],[0,-1],[1,0],[0,1],[-1,0],[0,-1]]))}};var hs=Object.freeze({__proto__:null,makeFacesVertexData:makeFacesVertexData,makeThickEdgesVertexData:makeThickEdgesVertexData});const makeFoldedVertexArrays=(e,t,{vertices_coords:r,edges_vertices:s,edges_assignment:o,faces_vertices:a,faces_edges:n,faces_normal:c}={},i={})=>{if(!r||!a)return[];n||(n=makeFacesEdgesFromVertices({edges_vertices:s,faces_vertices:a}));const{vertices_coords:l,vertices_normal:d,vertices_barycentric:m}=makeFacesVertexData({vertices_coords:r,edges_assignment:o,faces_vertices:a,faces_edges:n,faces_normal:c},i);return[{location:e.getAttribLocation(t,"v_position"),buffer:e.createBuffer(),type:e.FLOAT,length:l.length?l[0].length:3,data:new Float32Array(l.flat())},{location:e.getAttribLocation(t,"v_normal"),buffer:e.createBuffer(),type:e.FLOAT,length:d.length?d[0].length:3,data:new Float32Array(d.flat())},{location:e.getAttribLocation(t,"v_barycentric"),buffer:e.createBuffer(),type:e.FLOAT,length:3,data:new Float32Array(m.flat())}].filter((e=>-1!==e.location))},makeFoldedElementArrays=(e,t=1,r={})=>r&&r.vertices_coords&&r.faces_vertices?[{mode:e.TRIANGLES,buffer:e.createBuffer(),data:2===t?new Uint32Array(r.faces_vertices.flat()):new Uint16Array(r.faces_vertices.flat())}]:[],makeThickEdgesVertexArrays=(e,t,r,s={})=>{if(!r||!r.vertices_coords||!r.edges_vertices)return[];const{vertices_coords:o,vertices_color:a,verticesEdgesVector:n,vertices_vector:c}=makeThickEdgesVertexData(r,s.assignment_color);return[{location:e.getAttribLocation(t,"v_position"),buffer:e.createBuffer(),type:e.FLOAT,length:o.length?o[0].length:3,data:new Float32Array(o.flat())},{location:e.getAttribLocation(t,"v_color"),buffer:e.createBuffer(),type:e.FLOAT,length:a.length?a[0].length:3,data:new Float32Array(a.flat())},{location:e.getAttribLocation(t,"edge_vector"),buffer:e.createBuffer(),type:e.FLOAT,length:n.length?n[0].length:3,data:new Float32Array(n.flat())},{location:e.getAttribLocation(t,"vertex_vector"),buffer:e.createBuffer(),type:e.FLOAT,length:c.length?c[0].length:3,data:new Float32Array(c.flat())}].filter((e=>-1!==e.location))},makeThickEdgesElementArrays=(e,t=1,r={})=>{if(!r||!r.edges_vertices)return[];const s=r.edges_vertices.map(((e,t)=>8*t)).flatMap((e=>[e+0,e+1,e+4,e+4,e+1,e+5,e+1,e+2,e+5,e+5,e+2,e+6,e+2,e+3,e+6,e+6,e+3,e+7,e+3,e+0,e+7,e+7,e+0,e+4]));return[{mode:e.TRIANGLES,buffer:e.createBuffer(),data:2===t?new Uint32Array(s):new Uint16Array(s)}]};var bs=Object.freeze({__proto__:null,makeFoldedElementArrays:makeFoldedElementArrays,makeFoldedVertexArrays:makeFoldedVertexArrays,makeThickEdgesElementArrays:makeThickEdgesElementArrays,makeThickEdgesVertexArrays:makeThickEdgesVertexArrays});const makeExplodedGraph=(e,t=5e-6)=>{const r={...e};if(!r.edges_assignment){const t=count.edges(e)||countImplied.edges(e);r.edges_assignment=Array(t).fill("U")}let s=[];r.faceOrders?s=nudgeFacesWithFaceOrders(r):r.faces_layer&&(s=nudgeFacesWithFacesLayer(r));const o=triangulate(r),a=explodeFaces(r);if(o.faces){invertMap(o.faces.map).forEach(((e,r)=>{const o=s[e];o&&a.faces_vertices[r].forEach((e=>{const r=scale$1(o.vector,o.layer*t);a.vertices_coords[e]=add(resize(3,a.vertices_coords[e]),r)}))}))}return a},makeUniforms$1=(e,{projectionMatrix:t,modelViewMatrix:r,frontColor:s,backColor:o,strokeWidth:a,opacity:n})=>({u_matrix:{func:"uniformMatrix4fv",value:multiplyMatrices4(t,r)},u_projection:{func:"uniformMatrix4fv",value:t},u_modelView:{func:"uniformMatrix4fv",value:r},u_frontColor:{func:"uniform3fv",value:parseColorToWebGLRgb(s)},u_backColor:{func:"uniform3fv",value:parseColorToWebGLRgb(o)},u_strokeWidth:{func:"uniform1f",value:a},u_opacity:{func:"uniform1f",value:n}}),foldedFormFaces=(e,t=1,r={},s={})=>{const o=makeExplodedGraph(r,s.layerNudge),a=1===t?createProgram(e,"#version 100\nattribute vec3 v_position;\nattribute vec3 v_normal;\nuniform mat4 u_projection;\nuniform mat4 u_modelView;\nuniform mat4 u_matrix;\nuniform vec3 u_frontColor;\nuniform vec3 u_backColor;\nvarying vec3 normal_color;\nvarying vec3 front_color;\nvarying vec3 back_color;\nvoid main () {\n\tgl_Position = u_matrix * vec4(v_position, 1);\n\tvec3 light = abs(normalize((vec4(v_normal, 1) * u_modelView).xyz));\n\tfloat brightness = 0.5 + light.x * 0.15 + light.z * 0.35;\n\tfront_color = u_frontColor * brightness;\n\tback_color = u_backColor * brightness;\n}\n","#version 100\nprecision mediump float;\nuniform float u_opacity;\nvarying vec3 front_color;\nvarying vec3 back_color;\nvoid main () {\n\tvec3 color = gl_FrontFacing ? front_color : back_color;\n\tgl_FragColor = vec4(color, u_opacity);\n}\n"):createProgram(e,"#version 300 es\nuniform mat4 u_modelView;\nuniform mat4 u_matrix;\nuniform vec3 u_frontColor;\nuniform vec3 u_backColor;\nin vec3 v_position;\nin vec3 v_normal;\nout vec3 front_color;\nout vec3 back_color;\nvoid main () {\n\tgl_Position = u_matrix * vec4(v_position, 1);\n\tvec3 light = abs(normalize((vec4(v_normal, 1) * u_modelView).xyz));\n\tfloat brightness = 0.5 + light.x * 0.15 + light.z * 0.35;\n\tfront_color = u_frontColor * brightness;\n\tback_color = u_backColor * brightness;\n}\n","#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\nuniform float u_opacity;\nin vec3 front_color;\nin vec3 back_color;\nout vec4 outColor;\nvoid main () {\n\tgl_FragDepth = gl_FragCoord.z;\n\tvec3 color = gl_FrontFacing ? front_color : back_color;\n\toutColor = vec4(color, u_opacity);\n}\n");return{program:a,vertexArrays:makeFoldedVertexArrays(e,a,o,s),elementArrays:makeFoldedElementArrays(e,t,o),flags:[e.DEPTH_TEST],makeUniforms:makeUniforms$1}},foldedFormEdges=(e,t=1,r={},s={})=>{const o=1===t?createProgram(e,"#version 100\nattribute vec3 v_position;\nattribute vec3 v_color;\nattribute vec3 edge_vector;\nattribute vec2 vertex_vector;\nuniform mat4 u_matrix;\nuniform mat4 u_projection;\nuniform mat4 u_modelView;\nuniform float u_strokeWidth;\nvarying vec3 blend_color;\nvoid main () {\n\tvec3 edge_norm = normalize(edge_vector);\n\t// axis most dissimilar to edge_vector\n\tvec3 absNorm = abs(edge_norm);\n\tvec3 xory = absNorm.x < absNorm.y ? vec3(1,0,0) : vec3(0,1,0);\n\tvec3 axis = absNorm.x > absNorm.z && absNorm.y > absNorm.z ? vec3(0,0,1) : xory;\n\t// two perpendiculars. with edge_vector these make basis vectors\n\tvec3 one = cross(axis, edge_norm);\n\tvec3 two = cross(one, edge_norm);\n\tvec3 displaceNormal = normalize(\n\t\tone * vertex_vector.x + two * vertex_vector.y\n\t);\n\tvec3 displace = displaceNormal * (u_strokeWidth * 0.5);\n\tgl_Position = u_matrix * vec4(v_position + displace, 1);\n\tblend_color = v_color;\n}\n","#version 100\nprecision mediump float;\nvarying vec3 blend_color;\nvoid main () {\n\tgl_FragColor = vec4(blend_color.rgb, 1);\n}\n"):createProgram(e,"#version 300 es\nuniform mat4 u_matrix;\nuniform mat4 u_projection;\nuniform mat4 u_modelView;\nuniform float u_strokeWidth;\nin vec3 v_position;\nin vec3 v_color;\nin vec3 edge_vector;\nin vec2 vertex_vector;\nout vec3 blend_color;\nvoid main () {\n\tvec3 edge_norm = normalize(edge_vector);\n\t// axis most dissimilar to edge_vector\n\tvec3 absNorm = abs(edge_norm);\n\tvec3 xory = absNorm.x < absNorm.y ? vec3(1,0,0) : vec3(0,1,0);\n\tvec3 axis = absNorm.x > absNorm.z && absNorm.y > absNorm.z ? vec3(0,0,1) : xory;\n\t// two perpendiculars. with edge_vector these make basis vectors\n\tvec3 one = cross(axis, edge_norm);\n\tvec3 two = cross(one, edge_norm);\n\tvec3 displaceNormal = normalize(\n\t\tone * vertex_vector.x + two * vertex_vector.y\n\t);\n\tvec3 displace = displaceNormal * (u_strokeWidth * 0.5);\n\tgl_Position = u_matrix * vec4(v_position + displace, 1);\n\tblend_color = v_color;\n}\n","#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\nin vec3 blend_color;\nout vec4 outColor;\n \nvoid main() {\n\toutColor = vec4(blend_color.rgb, 1);\n}\n");return{program:o,vertexArrays:makeThickEdgesVertexArrays(e,o,r,s),elementArrays:makeThickEdgesElementArrays(e,t,r),flags:[e.DEPTH_TEST],makeUniforms:makeUniforms$1}},foldedFormFacesOutlined=(e,t=1,r={},s={})=>{const o=makeExplodedGraph(r,s.layerNudge),a=1===t?createProgram(e,"#version 100\nattribute vec3 v_position;\nattribute vec3 v_normal;\nattribute vec3 v_barycentric;\nuniform mat4 u_projection;\nuniform mat4 u_modelView;\nuniform mat4 u_matrix;\nuniform vec3 u_frontColor;\nuniform vec3 u_backColor;\nvarying vec3 normal_color;\nvarying vec3 barycentric;\nvarying vec3 front_color;\nvarying vec3 back_color;\nvoid main () {\n\tgl_Position = u_matrix * vec4(v_position, 1);\n\tbarycentric = v_barycentric;\n\tvec3 light = abs(normalize((vec4(v_normal, 1) * u_modelView).xyz));\n\tfloat brightness = 0.5 + light.x * 0.15 + light.z * 0.35;\n\tfront_color = u_frontColor * brightness;\n\tback_color = u_backColor * brightness;\n}\n","#version 100\nprecision mediump float;\nuniform float u_opacity;\nvarying vec3 barycentric;\nvarying vec3 front_color;\nvarying vec3 back_color;\nvoid main () {\n\tvec3 color = gl_FrontFacing ? front_color : back_color;\n\tvec3 boundary = vec3(0.0, 0.0, 0.0)\n\t// gl_FragDepth = 0.5;\n\tgl_FragColor = any(lessThan(barycentric, vec3(0.02)))\n\t\t? vec4(boundary, u_opacity)\n\t\t: vec4(color, u_opacity);\n}\n"):createProgram(e,"#version 300 es\nuniform mat4 u_modelView;\nuniform mat4 u_matrix;\nuniform vec3 u_frontColor;\nuniform vec3 u_backColor;\nin vec3 v_position;\nin vec3 v_normal;\nin vec3 v_barycentric;\nin float v_rawEdge;\nout vec3 front_color;\nout vec3 back_color;\nout vec3 barycentric;\n// flat out int rawEdge;\nflat out int provokedVertex;\nvoid main () {\n\tgl_Position = u_matrix * vec4(v_position, 1);\n\tprovokedVertex = gl_VertexID;\n\tbarycentric = v_barycentric;\n\t// rawEdge = int(v_rawEdge);\n\tvec3 light = abs(normalize((vec4(v_normal, 1) * u_modelView).xyz));\n\tfloat brightness = 0.5 + light.x * 0.15 + light.z * 0.35;\n\tfront_color = u_frontColor * brightness;\n\tback_color = u_backColor * brightness;\n}\n","#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\nuniform float u_opacity;\nin vec3 front_color;\nin vec3 back_color;\nin vec3 barycentric;\nout vec4 outColor;\nfloat edgeFactor(vec3 barycenter) {\n\tvec3 d = fwidth(barycenter);\n\tvec3 a3 = smoothstep(vec3(0.0), d*3.5, barycenter);\n\treturn min(min(a3.x, a3.y), a3.z);\n}\nvoid main () {\n\tgl_FragDepth = gl_FragCoord.z;\n\tvec3 color = gl_FrontFacing ? front_color : back_color;\n\toutColor = vec4(mix(vec3(0.0), color, edgeFactor(barycentric)), u_opacity);\n}\n");return{program:a,vertexArrays:makeFoldedVertexArrays(e,a,o,s),elementArrays:makeFoldedElementArrays(e,t,o),flags:[e.DEPTH_TEST],makeUniforms:makeUniforms$1}};var ys=Object.freeze({__proto__:null,foldedFormEdges:foldedFormEdges,foldedFormFaces:foldedFormFaces,foldedFormFacesOutlined:foldedFormFacesOutlined});const make2D$1=e=>e.map((e=>[0,1].map((t=>e[t]||0)))),makeCPEdgesVertexData=(e,t)=>{if(!e||!e.vertices_coords||!e.edges_vertices)return[];const r={...t&&t.dark?_s:us,...t},s=make2D$1(e.edges_vertices.flatMap((t=>t.map((t=>e.vertices_coords[t])))).flatMap((e=>[e,e]))),o=make2D$1(makeEdgesVector(e));return{vertices_coords:s,vertices_color:e.edges_assignment?e.edges_assignment.flatMap((e=>[r[e],r[e],r[e],r[e]])):e.edges_vertices.flatMap((()=>[r.U,r.U,r.U,r.U])),verticesEdgesVector:o.flatMap((e=>[e,e,e,e])),vertices_vector:e.edges_vertices.flatMap((()=>[[1,0],[-1,0],[-1,0],[1,0]]))}};var Es=Object.freeze({__proto__:null,makeCPEdgesVertexData:makeCPEdgesVertexData});const makeCPEdgesVertexArrays=(e,t,r,s)=>{if(!r||!r.vertices_coords||!r.edges_vertices)return[];const{vertices_coords:o,vertices_color:a,verticesEdgesVector:n,vertices_vector:c}=makeCPEdgesVertexData(r,s);return[{location:e.getAttribLocation(t,"v_position"),buffer:e.createBuffer(),type:e.FLOAT,length:2,data:new Float32Array(o.flat())},{location:e.getAttribLocation(t,"v_color"),buffer:e.createBuffer(),type:e.FLOAT,length:a.length?a[0].length:2,data:new Float32Array(a.flat())},{location:e.getAttribLocation(t,"edge_vector"),buffer:e.createBuffer(),type:e.FLOAT,length:n.length?n[0].length:2,data:new Float32Array(n.flat())},{location:e.getAttribLocation(t,"vertex_vector"),buffer:e.createBuffer(),type:e.FLOAT,length:c.length?c[0].length:2,data:new Float32Array(c.flat())}].filter((e=>-1!==e.location))},makeCPEdgesElementArrays=(e,t=1,r={})=>{if(!r||!r.edges_vertices)return[];const s=r.edges_vertices.map(((e,t)=>4*t)).flatMap((e=>[e+0,e+1,e+2,e+2,e+3,e+0]));return[{mode:e.TRIANGLES,buffer:e.createBuffer(),data:2===t?new Uint32Array(s):new Uint16Array(s)}]},makeCPFacesVertexArrays=(e,t,r)=>{return r&&r.vertices_coords?[{location:e.getAttribLocation(t,"v_position"),buffer:e.createBuffer(),type:e.FLOAT,length:2,data:new Float32Array((s=r.vertices_coords,s.map((e=>[0,1].map((t=>e[t]||0))))).flat())}].filter((e=>-1!==e.location)):[];var s},makeCPFacesElementArrays=(e,t=1,r={})=>r&&r.vertices_coords&&r.faces_vertices?[{mode:e.TRIANGLES,buffer:e.createBuffer(),data:2===t?new Uint32Array(triangulateConvexFacesVertices(r).flat()):new Uint16Array(triangulateConvexFacesVertices(r).flat())}]:[];var As=Object.freeze({__proto__:null,makeCPEdgesElementArrays:makeCPEdgesElementArrays,makeCPEdgesVertexArrays:makeCPEdgesVertexArrays,makeCPFacesElementArrays:makeCPFacesElementArrays,makeCPFacesVertexArrays:makeCPFacesVertexArrays});const makeUniforms=(e,{projectionMatrix:t,modelViewMatrix:r,cpColor:s,strokeWidth:o})=>({u_matrix:{func:"uniformMatrix4fv",value:multiplyMatrices4(t,r)},u_projection:{func:"uniformMatrix4fv",value:t},u_modelView:{func:"uniformMatrix4fv",value:r},u_cpColor:{func:"uniform3fv",value:parseColorToWebGLRgb(s)},u_strokeWidth:{func:"uniform1f",value:o}}),xs="#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\nin vec3 blend_color;\nout vec4 outColor;\nvoid main() {\n\toutColor = vec4(blend_color.rgb, 1);\n}\n",Ms="#version 100\nprecision mediump float;\nvarying vec3 blend_color;\nvoid main () {\n\tgl_FragColor = vec4(blend_color.rgb, 1);\n}\n",cpFacesV1=(e,t={},r=void 0)=>{const s=createProgram(e,"#version 100\nuniform mat4 u_matrix;\nuniform vec3 u_cpColor;\nattribute vec2 v_position;\nvarying vec3 blend_color;\nvoid main () {\n\tgl_Position = u_matrix * vec4(v_position, 0, 1);\n\tblend_color = u_cpColor;\n}\n",Ms);return{program:s,vertexArrays:makeCPFacesVertexArrays(e,s,t),elementArrays:makeCPFacesElementArrays(e,1,t),flags:[],makeUniforms:makeUniforms}},cpEdgesV1=(e,t={},r=void 0)=>{const s=createProgram(e,"#version 100\nuniform mat4 u_matrix;\nuniform float u_strokeWidth;\nattribute vec2 v_position;\nattribute vec3 v_color;\nattribute vec2 edge_vector;\nattribute vec2 vertex_vector;\nvarying vec3 blend_color;\nvoid main () {\n\tfloat sign = vertex_vector[0];\n\tfloat halfWidth = u_strokeWidth * 0.5;\n\tvec2 side = normalize(vec2(edge_vector.y * sign, -edge_vector.x * sign)) * halfWidth;\n\tgl_Position = u_matrix * vec4(side + v_position, 0, 1);\n\tblend_color = v_color;\n}\n",Ms);return{program:s,vertexArrays:makeCPEdgesVertexArrays(e,s,t,r),elementArrays:makeCPEdgesElementArrays(e,1,t),flags:[],makeUniforms:makeUniforms}},cpFacesV2=(e,t={},r=void 0)=>{const s=createProgram(e,"#version 300 es\nuniform mat4 u_matrix;\nuniform vec3 u_cpColor;\nin vec2 v_position;\nout vec3 blend_color;\nvoid main () {\n\tgl_Position = u_matrix * vec4(v_position, 0, 1);\n\tblend_color = u_cpColor;\n}\n",xs);return{program:s,vertexArrays:makeCPFacesVertexArrays(e,s,t),elementArrays:makeCPFacesElementArrays(e,2,t),flags:[],makeUniforms:makeUniforms}},cpEdgesV2=(e,t={},r=void 0)=>{const s=createProgram(e,"#version 300 es\nuniform mat4 u_matrix;\nuniform float u_strokeWidth;\nin vec2 v_position;\nin vec3 v_color;\nin vec2 edge_vector;\nin vec2 vertex_vector;\nout vec3 blend_color;\nvoid main () {\n\tfloat sign = vertex_vector[0];\n\tfloat halfWidth = u_strokeWidth * 0.5;\n\tvec2 side = normalize(vec2(edge_vector.y * sign, -edge_vector.x * sign)) * halfWidth;\n\tgl_Position = u_matrix * vec4(side + v_position, 0, 1);\n\tblend_color = v_color;\n}\n",xs);return{program:s,vertexArrays:makeCPEdgesVertexArrays(e,s,t,r),elementArrays:makeCPEdgesElementArrays(e,2,t),flags:[],makeUniforms:makeUniforms}};var ks=Object.freeze({__proto__:null,cpEdgesV1:cpEdgesV1,cpEdgesV2:cpEdgesV2,cpFacesV1:cpFacesV1,cpFacesV2:cpFacesV2});var Os=Object.assign(Object.create(null),{createProgram:createProgram,initialize:(e,t)=>{const r=[null,"webgl","webgl2"],s=window.devicePixelRatio||1;if(e.width=e.clientWidth*s,e.height=e.clientHeight*s,t)return{gl:e.getContext(r[t]),version:t};const o=e.getContext(r[2]);if(o)return{gl:o,version:2};const a=e.getContext(r[1]);if(a)return{gl:a,version:1};throw new Error(c)},foldedForm:(e,t=1,r={},s={})=>{const o=[];return!1!==s.faces&&(!1===s.outlines?o.push(foldedFormFaces(e,t,r,s)):o.push(foldedFormFacesOutlined(e,t,r,s))),!0===s.edges&&o.push(foldedFormEdges(e,t,r,s)),o},creasePattern:(e,t=1,r={},s=void 0)=>1===t?[cpFacesV1(e,r,s),cpEdgesV1(e,r,s)]:[cpFacesV2(e,r,s),cpEdgesV2(e,r,s)]},ps,vs,bs,hs,ys,As,Es,ks);const makeEpsilon=({vertices_coords:e,edges_vertices:t})=>{const r=(({vertices_coords:e,edges_vertices:t})=>{const r=t.map((t=>t.map((t=>e[t])))).map((e=>distance(...e))).reduce(((e,t)=>Math.min(e,t)),1/0);return r===1/0?void 0:r})({vertices_coords:e,edges_vertices:t});if(r)return Math.max(1e-4*r,1e-10);const s=boundingBox({vertices_coords:e});return s&&s.span?Math.max(1e-6*Math.max(...s.span),1e-10):1e-6};var ws=Object.freeze({__proto__:null,faceOrdersToMatrix:e=>{const t=[];e.forEach((e=>{t[e[0]]=void 0,t[e[1]]=void 0}));const r=t.map((()=>[]));return e.forEach((([e,t,s])=>{r[e][t]=s,r[t][e]=-s})),r},facesLayerToEdgesAssignments:(e,t)=>{const r=[],s=makeFacesWinding(e);return(e.edges_faces?e.edges_faces:makeEdgesFaces(e)).forEach(((e,o)=>{if(1===e.length&&(r[o]="B"),2===e.length){const a=e.map((e=>s[e]));if(a[0]===a[1])return void(r[o]="F");const n=e.map((e=>t[e])),c=n[0]<n[1],i=a[0]?c:!c;r[o]=i?"V":"M"}})),r},flipFacesLayer:e=>invertMap(invertMap(e).reverse()),makeEpsilon:makeEpsilon});const js={taco_taco:e=>[[e[0],e[2]],[e[1],e[3]],[e[1],e[2]],[e[0],e[3]],[e[0],e[1]],[e[2],e[3]]],taco_tortilla:e=>[[e[0],e[2]],[e[0],e[1]],[e[1],e[2]]],tortilla_tortilla:e=>[[e[0],e[2]],[e[1],e[3]]],transitivity:e=>[[e[0],e[1]],[e[1],e[2]],[e[2],e[0]]]},pairArrayToSortedPairString=e=>e[0]<e[1]?`${e[0]} ${e[1]}`:`${e[1]} ${e[0]}`,Fs={taco_taco:e=>[pairArrayToSortedPairString([e[0],e[2]]),pairArrayToSortedPairString([e[1],e[3]]),pairArrayToSortedPairString([e[1],e[2]]),pairArrayToSortedPairString([e[0],e[3]]),pairArrayToSortedPairString([e[0],e[1]]),pairArrayToSortedPairString([e[2],e[3]])],taco_tortilla:e=>[pairArrayToSortedPairString([e[0],e[2]]),pairArrayToSortedPairString([e[0],e[1]]),pairArrayToSortedPairString([e[1],e[2]])],tortilla_tortilla:e=>[pairArrayToSortedPairString([e[0],e[2]]),pairArrayToSortedPairString([e[1],e[3]])],transitivity:e=>[pairArrayToSortedPairString([e[0],e[1]]),pairArrayToSortedPairString([e[1],e[2]]),pairArrayToSortedPairString([e[2],e[0]])]},Cs={0:0,1:1,2:-1},solverSolutionToFaceOrders=(e,t)=>{const r=Object.keys(e),s=r.map((e=>e.split(" ").map((e=>parseInt(e,10)))));return s.forEach(((s,o)=>{const a=Cs[e[r[o]]],n=t[s[1]]?a:-a;s.push(n)})),s};var Ss=Object.freeze({__proto__:null,constraintToFacePairs:js,constraintToFacePairsStrings:Fs,solverSolutionToFaceOrders:solverSolutionToFaceOrders});const makeConstraints=({taco_taco:e,taco_tortilla:t,tortilla_tortilla:r,transitivity:s})=>{const o={};return o.taco_taco=e.map((e=>[e[0][0],e[1][0],e[0][1],e[1][1]])),o.taco_tortilla=t.map((e=>[e.taco[0],e.tortilla,e.taco[1]])),o.tortilla_tortilla=r.map((e=>[e[0][0],e[0][1],e[1][0],e[1][1]])),o.transitivity=s.map((e=>[e[0],e[1],e[2]])),o},makeConstraintsLookup=e=>{const t={};return Object.keys(e).forEach((e=>{t[e]={}})),Object.keys(e).forEach((r=>{e[r].forEach(((e,s)=>Fs[r](e).forEach((e=>{void 0===t[r][e]&&(t[r][e]=[]),t[r][e].push(s)}))))})),t},classify_faces_pair=e=>1===e[0]&&-1===e[1]||-1===e[0]&&1===e[1]?"both":1===e[0]&&1===e[1]?"right":-1===e[0]&&-1===e[1]?"left":void 0,makeTacosAndTortillas=({vertices_coords:e,edges_vertices:t,edges_faces:r,faces_vertices:s,faces_center:o,edges_vector:a},n=v)=>{o||(o=makeFacesConvexCenter({vertices_coords:e,faces_vertices:s}));const c=(({vertices_coords:e,edges_vertices:t,edges_faces:r,faces_center:s})=>{const o=t.map((t=>e[t[0]])),a=t.map((t=>subtract2(e[t[1]],e[t[0]])));return r.map(((e,t)=>e.map((e=>cross2(subtract2(s[e],o[t]),a[t]))).map((e=>Math.sign(e)))))})({vertices_coords:e,edges_vertices:t,edges_faces:r,faces_center:o}),i=makeEdgesEdgesParallelOverlap({vertices_coords:e,edges_vertices:t,edges_vector:a},n),l=getEdgesFacesOverlap({vertices_coords:e,edges_vertices:t,edges_faces:r,faces_vertices:s},n),d=selfRelationalUniqueIndexPairs(i).filter((e=>e.map((e=>r[e].length>1)).reduce(((e,t)=>e&&t),!0))),m=d.map((e=>e.map((e=>r[e])))),g=(({vertices_coords:e,edges_vertices:t,faces_center:r},s,o)=>{const a=s.map((r=>t[r[0]].map((t=>e[t])))),n=a.map((e=>e[0])),c=a.map((e=>subtract2(e[1],e[0])));return o.map((e=>e.map((e=>e.map((e=>r[e])))))).map(((e,t)=>e.map((e=>e.map((e=>cross2(subtract2(e,n[t]),c[t]))).map((e=>Math.sign(e)))))))})({vertices_coords:e,edges_vertices:t,faces_center:o},d,m),p=g.map((e=>e.map(classify_faces_pair))),_=p.map(((e,t)=>{return(r=e)[0]===r[1]&&"both"!==r[0]?m[t]:void 0;var r})).filter((e=>void 0!==e)),u=p.map(((e,t)=>{return(r=e)[0]===r[1]&&"both"===r[0]?m[t]:void 0;var r})).map(((e,t)=>((e,t)=>{if(void 0!==e)return t[0][0]===t[1][0]?e:[e[0],[e[1][1],e[1][0]]]})(e,g[t]))).filter((e=>void 0!==e)),h=((e,t,r)=>{const s=t.map((e=>2===e.length&&e[0]!==e[1])).map(((e,t)=>e?t:void 0)).filter((e=>void 0!==e)),o=[];return s.forEach((e=>{o[e]=r[e]})),o.map(((t,r)=>t.map((t=>[e[r],[t,t]])))).reduce(((e,t)=>e.concat(t)),[])})(r,c,l),b=u.concat(h),y=p.map(((e,t)=>{return(r=e)[0]===r[1]||"both"!==r[0]&&"both"!==r[1]?void 0:((e,t,r)=>{const s="left"===t[0]||"left"===t[1]?-1:1,o="both"===t[0]?[...e[1]]:[...e[0]],a="both"===t[0]?0:1;return{taco:o,tortilla:r[a][0]===s?e[a][0]:e[a][1]}})(m[t],p[t],g[t]);var r})).filter((e=>void 0!==e)),E=l.map(((e,t)=>c[t].length>1&&c[t][0]===c[t][1]?e:[])).map(((e,t)=>({taco:r[t],tortillas:e}))).filter((e=>e.tortillas.length)).flatMap((e=>e.tortillas.map((t=>({taco:[...e.taco],tortilla:t})))));return{taco_taco:_,tortilla_tortilla:b,taco_tortilla:y.concat(E)}},makeTransitivity=({faces_polygon:e},t,r=v)=>{const s=t.map((()=>[]));t.forEach(((e,t)=>e.forEach((e=>{s[t][e]=!0,s[e][t]=!0}))));const o=[];t.forEach(((t,s)=>t.forEach((t=>{const a=clipPolygonPolygon(e[s],e[t],r);a&&(o[s]||(o[s]=[]),o[t]||(o[t]=[]),o[s][t]=a,o[t][s]=a)}))));const a=[];for(let t=0;t<o.length-1;t+=1)if(o[t])for(let n=t+1;n<o.length;n+=1)if(o[t][n])for(let c=n+1;c<o.length;c+=1){if(t===c||n===c)continue;if(!s[t][c]||!s[n][c])continue;clipPolygonPolygon(o[t][n],e[c],r)&&a.push([t,n,c].sort(((e,t)=>e-t)))}return a},filterTransitivity=(e,{taco_taco:t,taco_tortilla:r})=>{const s={};return t.map((e=>[e[0][0],e[0][1],e[1][0],e[1][1]].sort(((e,t)=>e-t)))).forEach((e=>[`${e[0]} ${e[1]} ${e[2]}`,`${e[0]} ${e[1]} ${e[3]}`,`${e[0]} ${e[2]} ${e[3]}`,`${e[1]} ${e[2]} ${e[3]}`].forEach((e=>{s[e]=!0})))),r.map((e=>[e.taco[0],e.taco[1],e.tortilla].sort(((e,t)=>e-t)).join(" "))).forEach((e=>{s[e]=!0})),e.filter((e=>void 0===s[e.join(" ")]))};var Ps=Object.freeze({__proto__:null,filterTransitivity:filterTransitivity,makeTransitivity:makeTransitivity});const setup$1=({vertices_coords:e,edges_vertices:t,edges_faces:r,faces_vertices:s,faces_edges:o,edges_vector:a},n=v)=>{const c=makeFacesWinding({vertices_coords:e,faces_vertices:s}),i=makeFacesPolygon({vertices_coords:e,faces_vertices:s},n);c.map(((e,t)=>e?void 0:t)).filter((e=>void 0!==e)).forEach((e=>i[e].reverse()));const l=getFacesFacesOverlap({vertices_coords:e,faces_vertices:s},n),{taco_taco:d,taco_tortilla:m,tortilla_tortilla:g}=makeTacosAndTortillas({vertices_coords:e,edges_vertices:t,edges_faces:r,faces_vertices:s,faces_edges:o,edges_vector:a},n),p=makeTransitivity({faces_polygon:i},l,n),_=filterTransitivity(p,{taco_taco:d,taco_tortilla:m}),u=selfRelationalUniqueIndexPairs(l).map((e=>e.join(" "))),h=makeConstraints({taco_taco:d,taco_tortilla:m,tortilla_tortilla:g,transitivity:_});return{constraints:h,lookup:makeConstraintsLookup(h),facePairs:u,faces_winding:c}};var Vs=Object.freeze({__proto__:null,setup:setup$1});const solveEdgeAdjacent=({edges_faces:e,edges_assignment:t},r,s)=>{const o={0:0,1:2,2:1},a={M:1,m:1,V:2,v:2},n={};r.forEach((e=>{n[e]=!0}));const c={};return e.forEach(((e,r)=>{const i=t[r],l=a[i];if(e.length<2||void 0===l)return;const d=s[e[0]]?l:o[l],m=`${e[0]} ${e[1]}`,g=`${e[1]} ${e[0]}`;m in n&&(c[m]=d),g in n&&(c[g]=o[d])})),c},make_lookup=e=>{const t=e[0].length,r=Array.from(Array(t+1)).map((()=>({})));Array.from(Array(2**t)).map(((e,t)=>t.toString(2))).map((e=>Array.from(e).map((e=>parseInt(e,10)+1)).join(""))).map((e=>`11111${e}`.slice(-t))).forEach((e=>{r[0][e]=!1})),e.forEach((e=>{r[0][e]=!0})),Array.from(Array(t)).map(((e,t)=>t+1)).map((e=>Array.from(Array(3**t)).map(((e,t)=>t.toString(3))).map((e=>`000000${e}`.slice(-t))).forEach((t=>((e,t,r)=>{const s=Array.from(r).map((e=>parseInt(e,10)));if(s.filter((e=>0===e)).length!==t)return;e[t][r]=!1;let o=!1;for(let r=0;r<s.length;r+=1){const a=[];if(0===s[r]){for(let o=1;o<=2;o+=1)s[r]=o,!1!==e[t-1][s.join("")]&&a.push([r,o]);s[r]=0,a.length>0&&!1===o&&(o=[]),1===a.length&&o.push(a[0])}}!1!==o&&0===o.length&&(o=!0),e[t][r]=o})(r,e,t)))));let s=[];Array.from(Array(t+1)).map(((e,r)=>t-r)).forEach((e=>{const t=[];Object.keys(r[e]).forEach((s=>{let o=r[e][s];o.constructor===Array&&(o=o[0]),t.push([s,o])})),s=s.concat(t)})),s.sort(((e,t)=>parseInt(e[0],10)-parseInt(t[0],10)));const o={};return s.forEach((e=>{o[e[0]]=Object.freeze(e[1])})),Object.freeze(o)},Ns={taco_taco:make_lookup(["111112","111121","111222","112111","121112","121222","122111","122212","211121","211222","212111","212221","221222","222111","222212","222221"]),taco_tortilla:make_lookup(["112","121","212","221"]),tortilla_tortilla:make_lookup(["11","22"]),transitivity:make_lookup(["112","121","122","211","212","221"])},zs=Object.freeze(Object.keys(Ns)),buildRuleAndLookup=(e,t,...r)=>{const s={0:0,1:2,2:1},o=js[e](t),a=o.map((e=>e[1]<e[0])),n=o.map(((e,t)=>a[t]?`${e[1]} ${e[0]}`:`${e[0]} ${e[1]}`)),c=n.map(((e,t)=>{for(let o=0;o<r.length;o+=1)if(r[o][e])return a[t]?s[r[o][e]]:r[o][e];return 0})).join("");if(!0===Ns[e][c]||!1===Ns[e][c])return Ns[e][c];const i=Ns[e][c];return[n[i[0]],a[i[0]]?s[i[1]]:i[1]]},getConstraintIndicesFromFacePairs=(e,t,r)=>{const s={};return zs.forEach((o=>{const a=r.flatMap((e=>t[o][e]));s[o]=uniqueElements(a).filter((t=>e[o][t]))})),s},propagate=(e,t,r,...s)=>{let o=r;const a={};do{const r=getConstraintIndicesFromFacePairs(e,t,o),n={};for(let t=0;t<zs.length;t+=1){const o=zs[t],c=r[o];for(let t=0;t<c.length;t+=1){const r=buildRuleAndLookup(o,e[o][c[t]],...s,a);if(!0!==r){if(!1===r)throw new Error(`invalid ${o} ${c[t]}:${e[o][c[t]]}`);if(a[r[0]]){if(a[r[0]]!==r[1])throw new Error(`conflict ${o} ${c[t]}:${e[o][c[t]]}`)}else{const[e,t]=r;n[e]=!0,a[r[0]]=t}}}}o=Object.keys(n)}while(o.length);return a},solveBranch=(e,t,r,...s)=>{if(!r.length)return[];const o=r[0],a=[],n=[];[1,2].forEach((c=>{let i;try{i=propagate(e,t,[o],...s,{[o]:c})}catch(e){return}i[o]=c,Object.keys(i).length===r.length?a.push(i):n.push(i)}));const c=n.map((o=>solveBranch(e,t,r.filter((e=>!(e in o))),...s,o)));return a.map((e=>[...s,e])).concat(...c)},solver2d=({constraints:e,lookup:t,facePairs:r,orders:s})=>{let o;try{o=propagate(e,t,Object.keys(s),s)}catch(e){throw new Error(g,{cause:e})}const a=r.filter((e=>!(e in s))).filter((e=>!(e in o)));let n;try{n=((e,t,r)=>{const s=Object.keys(t),o={};e.forEach((e=>{o[e]=!0}));let a=0;const n=[];for(;a<e.length;){if(!o[e[a]]){a+=1;continue}const c=[],i=[e[a]],l={[e[a]]:!0};do{const e=i.pop();delete o[e],c.push(e);const a={};s.forEach((s=>{const o=r[s][e];o&&o.map((e=>t[s][e])).map((e=>Fs[s](e).forEach((e=>{a[e]=!0}))))}));const n=Object.keys(a).filter((e=>o[e])).filter((e=>!l[e]));i.push(...n),n.forEach((e=>{l[e]=!0}))}while(i.length);a+=1,n.push(c)}return n})(a,e,t).map((r=>solveBranch(e,t,r,s,o)))}catch(e){throw new Error(g,{cause:e})}return{root:{...s,...o},branches:n.map((e=>e.map((e=>Object.assign({},...e)))))}},makePermutations=e=>{const t=e.reduce(((e,t)=>e*t),1),r=e.slice();for(let e=r.length-2;e>=0;e-=1)r[e]*=r[e+1];return r.push(1),r.shift(),Array.from(Array(t)).map(((t,s)=>e.map(((e,t)=>Math.floor(s/r[t])%e))))},Ts={count:function(){return this.branches.map((e=>e.length))},faceOrders:function(...e){return solverSolutionToFaceOrders(this.compile(...e),this.faces_winding)},facesLayer:function(...e){return invertMap(this.linearize(...e).reverse())},compile:function(...e){const t=Array(this.branches.length).fill(0).map(((t,r)=>null!=e[r]?e[r]:t)),r=this.branches?this.branches.map(((e,r)=>e[t[r]])):[];return Object.assign({},this.root,...r)},directedPairs:function(...e){const t=this.compile(...e);return Object.keys(t).map((e=>1===t[e]?e.split(" "):e.split(" ").reverse())).map((e=>e.map((e=>parseInt(e,10)))))},linearize:function(...e){return topologicalSort(this.directedPairs(...e))},allSolutions:function(){return makePermutations(this.count()).map((e=>this.compile(...e)))},allFacesLayers:function(){return makePermutations(this.count()).map((e=>this.facesLayer(...e)))}},layer=({vertices_coords:e,edges_vertices:t,edges_faces:r,edges_assignment:s,faces_vertices:o,faces_edges:a,edges_vector:n},c)=>{if(!e||!t||!o)return Object.assign(Object.create(Ts),{root:{},branches:[],faces_winding:[]});a||(a=makeFacesEdgesFromVertices({edges_vertices:t,faces_vertices:o})),r||(r=makeEdgesFacesUnsorted({edges_vertices:t,faces_edges:a})),void 0===c&&(c=makeEpsilon({vertices_coords:e,edges_vertices:t}));const{constraints:i,lookup:l,facePairs:d,faces_winding:m}=setup$1({vertices_coords:e,edges_vertices:t,edges_faces:r,faces_vertices:o,faces_edges:a,edges_vector:n},c),g=solveEdgeAdjacent({edges_faces:r,edges_assignment:s},d,m),{root:p,branches:v}=solver2d({constraints:i,lookup:l,facePairs:d,orders:g});return Object.assign(Object.create(Ts),{root:p,branches:v,faces_winding:m})},doRangesOverlap=(e,t,r=v)=>{const s=e[0]<e[1]?e:[e[1],e[0]],o=t[0]<t[1]?t:[t[1],t[0]];return Math.min(s[1],o[1])-Math.max(s[0],o[0])>r},reformatSolution=(e,t)=>(e.orders&&(e.orders=e.orders.flatMap((e=>solverSolutionToFaceOrders(e,t)))),e.leaves&&(e.leaves=e.leaves.map((e=>solverSolutionToFaceOrders(e,t)))),e.partitions&&e.partitions.forEach((e=>reformatSolution(e,t))),e.node&&e.node.forEach((e=>reformatSolution(e,t))),e);var $s=Object.freeze({__proto__:null,doEdgesOverlap:({vertices_coords:e,edges_vertices:t},r,s,o=v)=>{const a=r.map((r=>t[r].map((t=>e[t])))).map((e=>e.map((e=>dot(e,s)))));return doRangesOverlap(...a,o)},doRangesOverlap:doRangesOverlap,reformatSolution:reformatSolution});const getOverlappingParallelEdgePairs=({vertices_coords:e,edges_vertices:t,edges_faces:r,edges_foldAngle:s,faces_center:o},a,n,c,i=v)=>{const l=s.map(edgeFoldAngleIsFlat),d=(({vertices_coords:e,edges_vertices:t},r=v)=>{const{lines:s,edges_line:o}=getEdgesLine({vertices_coords:e,edges_vertices:t},r),a=o.map((e=>s[e].vector)),n=makeEdgesCoords({vertices_coords:e,edges_vertices:t}).map(((e,t)=>e.map((e=>dot(a[t],e)))));return invertMap(o).map((e=>e.constructor===Array?e:[e])).flatMap((e=>chooseTwoPairs(e).filter((e=>doRangesOverlap(...e.map((e=>n[e])))))))})({vertices_coords:e,edges_vertices:t},i).map((e=>e[0]<e[1]?e:e.slice().reverse())).filter((e=>!(l[e[0]]&&l[e[1]]))).filter((e=>e.map((e=>2===r[e].length)).reduce(((e,t)=>e&&t),!0))).filter((e=>e.map((e=>void 0!==a[e])).reduce(((e,t)=>e&&t),!0))).filter((e=>4!==Array.from(new Set(e.flatMap((e=>a[e])))).length)),m=d.map((e=>e.map((e=>a[e])))),g=m.map((e=>Array.from(new Set(e.flat())))),p=m.map(((e,t)=>{const r={};return e.flat().forEach((e=>{r[e]=[]})),e.forEach(((e,s)=>e.forEach((e=>r[e].push(d[t][s]))))),r})),_=d.map((e=>e.map((e=>r[e])))).map(((e,t)=>{const r={};return g[t].forEach((e=>{r[e]=[]})),e.flat().forEach((e=>r[n[e]].push(e))),r})),u=makeEdgesCoords({vertices_coords:e,edges_vertices:t}),h=g.map(((e,t)=>{const r=u[d[t][0]],s={};return e.forEach((e=>{s[e]=r.map((t=>multiplyMatrix4Vector3(c[e],t))).map((e=>[e[0],e[1]]))})),s})),b=_.map(((e,t)=>{const r={};return g[t].forEach((s=>{const a=h[t][s][0];r[s]=e[s].map((e=>cross2(subtract2(o[e],a),subtract2(h[t][s][1],a)))).map((e=>Math.sign(e)))})),r})),y=b.map(((e,t)=>{const r={};return g[t].forEach((t=>{r[t]=e[t].reduce(((r,s)=>r&&s===e[t][0]),!0)})),r})),E=d.map(((e,t)=>{const r={};return Object.keys(p[t]).forEach((e=>{r[e]={edges:p[t][e],faces:_[t][e],facesSides:b[t][e],facesSameSide:y[t][e]}})),{edges:e,sets:r}})),A=E.filter((e=>{const t=Object.values(e.sets).map((e=>2===e.faces.length)).reduce(((e,t)=>e&&t),!0),r=Object.values(e.sets).map((e=>e.facesSameSide)).reduce(((e,t)=>e&&t),!0);return t&&r})),x=E.filter((e=>{const t=3===Object.values(e.sets).length,r=Object.values(e.sets).map((e=>e.facesSameSide)).reduce(((e,t)=>e&&t),!0);return t&&r})),M=E.filter((e=>{const t=Object.values(e.sets).map((e=>2===e.faces.length)).reduce(((e,t)=>e&&t),!0),r=Object.values(e.sets).map((e=>e.facesSameSide)),s=r[0]!==r[1];return t&&s})),O=E.filter((e=>{const t=Object.values(e.sets).filter((e=>3===e.faces.length)).shift(),s=void 0!==t;if(!s)return!1;const o=t.facesSides.reduce(((e,t)=>e+t),0),a=1===Math.abs(o);if(!a)return!1;const n=t.faces.filter(((e,r)=>t.facesSides[r]===o)),c=t.edges.map((e=>r[e].map((e=>n.includes(e))).reduce(((e,t)=>e&&t),!0))).reduce(((e,t)=>e||t),!1);return s&&a&&!c}));return O.length&&console.log("This model contains the third case",O),{tortillaTortillaEdges:A,solvable1:x,solvable2:M,solvable3:[]}},solveEdgeFaceOverlapOrders=({vertices_coords:e,edges_vertices:t,edges_faces:r,edges_foldAngle:s},o,a,n,c,i,l,d,m=v)=>{const g=n.slice();g.forEach(((e,t)=>{e.length<2&&delete g[t]}));const p=r.map((e=>{const t={};return e.forEach((e=>{t[e]=!0})),t})),_=d.map((e=>e.filter((e=>void 0!==g[e])).map((e=>g[e]))));d.map(((e,t)=>t)).filter((e=>_[e].length<2)).forEach((e=>delete _[e]));const u=_.map(((e,t)=>e.map((e=>e.filter((e=>p[t][e])))))),h=_.map(((e,t)=>e.map((e=>e.filter((e=>!p[t][e])))))),b=_.map(((r,s)=>t[s].map((t=>e[t])))),y=h.map(((e,t)=>e.map((e=>e.map((e=>{const r=b[t].map((t=>multiplyMatrix4Vector3(a[c[e]],t))).map((e=>[e[0],e[1]]));return((e,t,r=v)=>!!t.map((t=>overlapConvexPolygonPoint(e,t,exclude,r))).reduce(((e,t)=>e||t),!1)||void 0!==clipLineConvexPolygon(e,{vector:subtract2(t[1],t[0]),origin:t[0]},exclude,excludeS,r))(i[e],r,m)?e:void 0})).filter((e=>void 0!==e)))))),E=_.flatMap(((e,t)=>y[t].flatMap(((e,r)=>{const s=1-r,o=u[t];return e.map((e=>({edge:t,faces:[o[r][0],o[s][0]],overlap:e,set:c[e]})))})))),A=E.map((e=>[e.faces[0],e.overlap])),x=A.map((e=>e[0]<e[1]));x.forEach(((e,t)=>{e||A[t].reverse()}));const M=E.map((e=>l[e.faces[0]])),O=E.map((e=>s[e.edge])).map(Math.sign).map((e=>1===e)),w=E.map(((e,t)=>M[t]^O[t])).map(((e,t)=>x[t]?e:1-e)).map((e=>e+1)),j={};return A.forEach(((e,t)=>{j[e.join(" ")]=w[t]})),j},solveFacePair3D=({edges_foldAngle:e,faces_winding:t},r,s)=>{const o=r.map((t=>t.map((t=>e[t])))),a=s.map((e=>e.map((e=>t[e])))),n=o.map(((e,t)=>e.map(((e,r)=>a[t][r]?e:-e)))).map((e=>e[0]>e[1])),c=s.map((e=>e[0]<e[1])),i=s.map(((e,t)=>n[t]^c[t])),l={},d=s.map(((e,t)=>c[t]?e:e.slice().reverse())).map((e=>e.join(" ")));return i.map((e=>e+1)).forEach(((e,t)=>{l[d[t]]=e})),l},solveEdgeEdgeOverlapOrders=({edges_foldAngle:e,faces_winding:t},r,s,o)=>{const a=(({edges_foldAngle:e,faces_winding:t},r)=>{const s=r.map((e=>Object.values(e.sets).sort(((e,t)=>t.faces.length-e.faces.length)).shift())),o=s.map((e=>e.edges)),a=s.map((e=>e.faces));return solveFacePair3D({edges_foldAngle:e,faces_winding:t},o,a)})({edges_foldAngle:e,faces_winding:t},r),n=(({edges_foldAngle:e,faces_winding:t},r)=>{const s=r.map((e=>Object.values(e.sets).filter((e=>e.facesSameSide)).shift())),o=s.map((e=>e.edges)),a=s.map((e=>e.faces));return solveFacePair3D({edges_foldAngle:e,faces_winding:t},o,a)})({edges_foldAngle:e,faces_winding:t},s);return{...a,...n,...{}}},graphGroupCopies=(e,t,r)=>{const s=e.vertices_coords.map((e=>resize(3,e))),o=t.map((t=>subgraphWithFaces(e,t)));r.forEach(((e,t)=>{o[t].vertices_coords=o[t].vertices_coords.map(((t,r)=>((e,t)=>{const r=multiplyMatrix4Vector3(e,t);return[r[0],r[1]]})(e,s[r])))}));const a=e.edges_foldAngle.map(edgeFoldAngleIsFlat).map(((e,t)=>e?void 0:t)).filter((e=>void 0!==e)),n=filterKeysWithPrefix(e,"edges");return o.forEach((e=>a.forEach((t=>n.forEach((r=>{delete e[r][t]})))))),o};var Bs=Object.freeze({__proto__:null,graphGroupCopies:graphGroupCopies});const setup3d=({vertices_coords:e,edges_vertices:t,edges_faces:r,edges_foldAngle:s,faces_edges:o,faces_winding:a,faces_center:n},c,i,l,d,m,g,p)=>{const v=g.map((e=>l[e[0]])),_=(invertMap(v).map((e=>e.constructor===Array?e:[e])).map((e=>e.map((e=>m[e])))),(({edges_vertices:e,faces_edges:t},r)=>{const s=e.map((()=>({})));return r.forEach(((e,r)=>t[r].forEach((t=>{s[t][e]=!0})))),s.map((e=>Object.keys(e).map((e=>parseInt(e,10))).sort(((e,t)=>e-t))))})({edges_vertices:t,faces_edges:o},l));_.map(((e,t)=>2!==e.length?t:void 0)).filter((e=>void 0!==e)).forEach((e=>delete _[e]));const{tortillaTortillaEdges:u,solvable1:h,solvable2:b,solvable3:y}=getOverlappingParallelEdgePairs({vertices_coords:e,edges_vertices:t,edges_faces:r,edges_foldAngle:s,faces_center:n},_,l,i,p),E=(({edges_faces:e},t,r,s)=>{const o=t.map((e=>e.edges)).map((t=>t.map((t=>e[t].slice()))));return o.forEach(((e,t)=>{r[e[0][0]]!==r[e[1][0]]&&o[t][1].reverse()})),o.map((e=>[e[0][0],e[0][1]])).map((e=>e.map((e=>s[e])))).map(((e,t)=>e[0]!==e[1]?t:void 0)).filter((e=>void 0!==e)).forEach((e=>{const t=o[e][0][1];o[e][0][1]=o[e][1][1],o[e][1][1]=t})),o})({edges_faces:r},u,l,a);return{tortillas3D:E,orders:{...solveEdgeFaceOverlapOrders({vertices_coords:e,edges_vertices:t,edges_faces:r,edges_foldAngle:s},0,i,c,l,d,a,_,p),...solveEdgeEdgeOverlapOrders({edges_foldAngle:s,faces_winding:a},h,b)}}},setup=({vertices_coords:e,edges_vertices:t,edges_faces:r,edges_assignment:s,edges_foldAngle:o,faces_vertices:a,faces_edges:n,faces_faces:c},i=v)=>{const{sets_faces:l,sets_transformXY:d,faces_set:m,faces_winding:g}=coplanarOverlappingFacesGroups({vertices_coords:e,faces_vertices:a,faces_faces:c},i),p=graphGroupCopies({vertices_coords:e,edges_vertices:t,edges_faces:r,edges_assignment:s,edges_foldAngle:o,faces_vertices:a,faces_edges:n,faces_faces:c},l,d),_=flatSort(...p.map((e=>makeFacesPolygon(e,i))));g.map(((e,t)=>e?void 0:t)).filter((e=>void 0!==e)).forEach((e=>_[e].reverse()));const u=flatSort(...p.map((e=>getFacesFacesOverlap(e,i)))),h=_.map((e=>average2(...e)));p.forEach((e=>{e.faces_center=e.faces_vertices.map(((e,t)=>h[t]))}));const b=p.map((e=>makeTacosAndTortillas(e,i))),y=b.flatMap((e=>e.taco_taco)),E=b.flatMap((e=>e.taco_tortilla)),A=b.flatMap((e=>e.tortilla_tortilla)),x=makeTransitivity({faces_polygon:_},u,i),M=filterTransitivity(x,{taco_taco:y,taco_tortilla:E}),O=selfRelationalUniqueIndexPairs(u),w=O.map((e=>e.join(" "))),{tortillas3D:j,orders:F}=setup3d({vertices_coords:e,edges_vertices:t,edges_faces:r,edges_foldAngle:o,faces_edges:n,faces_winding:g,faces_center:h},l,d,m,_,w,O,i);A.push(...j);const C=makeConstraints({taco_taco:y,taco_tortilla:E,tortilla_tortilla:A,transitivity:M}),S=makeConstraintsLookup(C);return p.map((e=>solveEdgeAdjacent(e,w,g))).forEach((e=>Object.assign(F,e))),{constraints:C,lookup:S,facePairs:w,faces_winding:g,orders:F}};var Ls=Object.freeze({__proto__:null,setup:setup});const between=(e,t,r)=>t<r?e.slice(t+1,r):e.slice(r+1,t),validateTacoTacoFacePairs=e=>{const t=nonUniqueElements(e),r={};let s=0;for(let e=0;e<t.length;e+=1)if(void 0===r[t[e]])s+=1,r[t[e]]=s;else if(void 0!==r[t[e]]){if(r[t[e]]!==s)return!1;s-=1,r[t[e]]=void 0}return!0},build_layers=(e,t)=>e.map((e=>t[e])).filter((e=>void 0!==e)),validateLayerSolver=(e,t,r,s,o)=>{const a=flattenArrays(t);if(!((e,t,r=!0,s=v)=>{const o=invertMap(t),a=e.map((e=>e?e[1]:void 0)),n=e.map((e=>e?Math.min(...e):void 0)).map((e=>e+s)),c=e.map((e=>e?Math.max(...e):void 0)).map((e=>e-s)),i=o.length+(r?0:-1);for(let e=0;e<i;e+=1){const r=(e+1)%o.length;if(o[e]===o[r])continue;const s=between(t,o[e],o[r]).flat(),i=s.map((t=>a[e]<n[t])).reduce(((e,t)=>e&&t),!0),l=s.map((t=>a[e]>c[t])).reduce(((e,t)=>e&&t),!0);if(!i&&!l)return!1}return!0})(e,t,s,o))return!1;for(let e=0;e<r.length;e+=1){const t=build_layers(a,r[e]);if(!validateTacoTacoFacePairs(t))return!1}return!0},Is={V:!0,v:!0,M:!0,m:!0},Us={V:1,v:1,M:-1,m:-1},assignmentsToFacesVertical=e=>{let t=0;return e.slice(1).concat([e[0]]).map((e=>{const r=(s=e,t%2==0?Us[s]||0:-(Us[s]||0));var s;return t+=void 0===Us[e]?0:1,r}))},foldStripWithAssignments=(e,t)=>{const r=(e=>{let t=0;const r=e.slice(1);return[!1].concat(r.map((e=>Is[e]?++t:t)).map((e=>e%2==1)))})(t).map(((t,r)=>e[r]*(t?-1:1))),s=e.map((()=>{}));s[0]=[0,r[0]];for(let o=1;o<e.length&&("B"!==t[o]&&"b"!==t[o]);o+=1){const t=s[(o-1+e.length)%e.length][1];s[o]=[t,t+r[o]]}return s},Rs={B:!0,b:!0},singleVertexSolver=(e,t,r=v)=>{const s=foldStripWithAssignments(e,t),o=assignmentsToFacesVertical(t),a=t.map((e=>!Rs[e])).reduce(((e,t)=>e&&t),!0);if(a){const e=s[0][0],t=s[s.length-1][1];if(Math.abs(e-t)>r)return[]}const n=((e,t,r)=>{const s=e.map((e=>e?(e[0]+e[1])/2:void 0)),o=[];return e.forEach(((a,n)=>{if(!a)return;if(!t&&n===e.length-1)return;const c=a[1],i=c-2*r,l=c+2*r,d=[n,(n+1)%e.length],m=d.map((e=>s[e])).map((e=>e>c)),g=1*(!m[0]&&!m[1])+2*(m[0]&&m[1]),p=o.filter((e=>e.min<c&&e.max>c)).shift(),v={faces:d,taco_type:g};p?p.pairs.push(v):o.push({min:i,max:l,pairs:[v]})})),o.map((e=>e.pairs)).filter((e=>e.length>1)).map((e=>({both:e.filter((e=>0===e.taco_type)).map((e=>e.faces)),left:e.filter((e=>1===e.taco_type)).map((e=>e.faces)),right:e.filter((e=>2===e.taco_type)).map((e=>e.faces))})))})(s,a,r).map((e=>[e.left,e.right].map(invertMap).filter((e=>e.length>1)))).reduce(((e,t)=>e.concat(t)),[]),recurse=(t=[0],c=0,i=0)=>{const l=c+1,d=o[c],m=c>=e.length-1,g=a&&m;if(!validateLayerSolver(s,t,n,g,r))return[];if(g){const e=invertMap(t),r=e[0],s=e[c];if(d>0&&s>r)return[];if(d<0&&s<r)return[]}if(m)return[t];if(0===d)return t[i]=[l].concat(t[i]),recurse(t,l,i);const p=1===d?Array.from(Array(t.length-i)).map(((e,t)=>i+t+1)):Array.from(Array(i+1)).map(((e,t)=>t)),v=p.map((()=>clone(t)));return v.forEach(((e,t)=>e.splice(p[t],0,l))),v.map(((e,t)=>recurse(e,l,p[t]))).reduce(((e,t)=>e.concat(t)),[])};return recurse().map(invertMap)};Object.assign(layer,{table:Ns,makeTacosAndTortillas:makeTacosAndTortillas,...Ps,...ws,...Ss,...Vs,layer3d:({vertices_coords:e,edges_vertices:t,edges_faces:r,edges_assignment:s,edges_foldAngle:o,faces_vertices:a,faces_edges:n,faces_faces:c},i)=>{if(!e||!t||!a)return Object.assign(Object.create(Ts),{root:{},branches:[],faces_winding:[]});n||(n=makeFacesEdgesFromVertices({edges_vertices:t,faces_vertices:a})),r||(r=makeEdgesFacesUnsorted({edges_vertices:t,faces_edges:n})),c||(c=makeFacesFaces({faces_vertices:a})),!o&&s&&(o=makeEdgesFoldAngle({edges_assignment:s})),s||(s=makeEdgesAssignmentSimple({edges_foldAngle:o})),void 0===i&&(i=makeEpsilon({vertices_coords:e,edges_vertices:t}));const{constraints:l,lookup:d,facePairs:m,faces_winding:g,orders:p}=setup({vertices_coords:e,edges_vertices:t,edges_faces:r,edges_assignment:s,edges_foldAngle:o,faces_vertices:a,faces_edges:n,faces_faces:c},i),{root:v,branches:_}=solver2d({constraints:l,lookup:d,facePairs:m,orders:p});return Object.assign(Object.create(Ts),{root:v,branches:_,faces_winding:g})},...Ls,...$s,...Bs,singleVertexSolver:singleVertexSolver,singleVertexAssignmentSolver:(e,t,r)=>{null==t&&(t=e.map((()=>"U")));const s=maekawaSolver(t),o=s.map((t=>singleVertexSolver(e,t,r)));return s.map(((e,t)=>t)).filter((e=>o[e].length>0)).map((e=>({assignment:s[e],layer:o[e]})))},foldStripWithAssignments:foldStripWithAssignments}),Object.assign(graph,ss);const qs={graph:graph,cp:cp,origami:origami,axiom:Cr,convert:Br,math:ds,singleVertex:gs,svg:SVG,webgl:Os,layer:layer};return It.ear=qs,Object.defineProperty(qs,"window",{enumerable:!1,set:e=>{var t;SVG.window=((t=e).document||(t.document=(e=>(new e.DOMParser).parseFromString("<!DOCTYPE html><title>.</title>","text/html"))(t)),p.window=t,p.window)}}),qs}));
