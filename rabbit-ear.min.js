/* Rabbit Ear 0.9.33 alpha 2023-02-02 (c) Kraft, MIT License */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e="undefined"!=typeof globalThis?globalThis:e||self).ear=t()}(this,(function(){"use strict";
/**
	 * Rabbit Ear (c) Kraft
	 */
// this is a really verbose way of coding this but so far this is the best
// way i can find to compress references in the minified .js file
const e="undefined",t="number",r="object",s="index",o="vertices",n="edges",a="faces",c="boundaries",i="vertices_coords",l="edges_vertices",d="faces_edges",m="edges_assignment",g="edges_foldAngle",p="faces_layer",v="boundary",u="front",h="back",_="foldedForm",b="black",y="white",E="none",x=typeof window!==e&&typeof window.document!==e;typeof process!==e&&null!=process.versions&&process.versions.node;const A=typeof self===r&&self.constructor&&"DedicatedWorkerGlobalScope"===self.constructor.name;
// // for debugging, uncomment to log system on boot
// const operating_systems = [
//   isBrowser ? "browser" : undefined,
//   isWebWorker ? "web-worker" : undefined,
//   isNode ? "node" : undefined,
// ].filter(a => a !== undefined).join(" ");
// console.log(`RabbitEar [${operating_systems}]`);
var k="graph could not planarize",O="manifold required",w="cycle not allowed",M="planar boundary detection error, bad graph",j="circular edges not allowed",F="replace() index < value. indices parameter modified",C="replace() generated undefined",P="foldAngles cannot be determined from flat-folded faces without an assignment",N="WebGl not Supported",S="only convex faces are supported",V="window not set; if using node/deno include package @xmldom/xmldom and set ear.window = xmldom",$="non-convex triangulation requires vertices_coords";
/**
	 * Rabbit Ear (c) Kraft
	 */const z={window:void 0};
// if we are in the browser, by default use the browser's "window".
x&&(z.window=window)
/**
	 * @description get the "window" object, which should have
	 * DOMParser, XMLSerializer, and document.
	 */;const RabbitEarWindow=()=>{if(void 0===z.window)throw new Error(V);return z.window};
/**
	 * Rabbit Ear (c) Kraft
	 */var T=Object.create(null);
/**
	 * @typedef AxiomParams
	 * @type {object}
	 * @description The input to one of the seven axiom calculations. Depending on which axiom,
	 * this will include up to two points and up to two lines, each inside their
	 * respectively named arrays, where the order matters.
	 * @property {RayLine[]} [lines] an array of lines
	 * @property {number[][]} [points] an array of points
	 * @example
	 * {
	 *   points: [[0.8, 0.5], [0.1, 0.15]],
	 *   lines: [{vector: [0,1], origin: [0.5, 0.5]}]
	 * }
	 */
/**
	 * @typedef FOLD
	 * @type {object}
	 * @description A Javascript object representation of a FOLD file which follows the FOLD
	 * specification in that it contains any number of the geometry arrays.
	 * @property {number[][]} [vertices_coords] xy or xyz coordinates of the vertices
	 * @property {number[][]} [vertices_vertices] for each vertex, all of its edge-adjacent vertices
	 * @property {number[][]} [edges_vertices] each edge connects two vertex indices
	 * @property {string[]} [edges_assignment] single-character fold assignment of each edge
	 * @property {number[]} [edges_foldAngle] in degrees, the fold angle of each edge
	 * @property {number[][]} [faces_vertices] each face defined by a sequence of vertex indices
	 * @property {number[][]} [faces_edges] each face defined by a sequence of edge indices
	 * @property {number[][]} [faces_faces] for each face, a list of faces which
	 * are edge-adjacent neighbors.
	 * @property {FOLD[]} [file_frames] array of embedded FOLD objects, good for representing
	 * a linear sequence like diagram steps for example.
	 * @example
	 * {
	 *   vertices_coords: [[0,0], [1,0], [1,1], [0,1]],
	 *   edges_vertices: [[0,1], [1,2], [2,3], [3,0], [0,2]],
	 *   edges_assignment: ["B", "B", "B", "B", "V"],
	 *   edges_foldAngle: [0, 0, 0, 0, 180],
	 *   faces_vertices: [[0,1,2], [0,2,3]],
	 * }
	 */
/* Math (c) Kraft, MIT License */
/**
	 * Math (c) Kraft
	 */const isIterable=e=>null!=e&&"function"==typeof e[Symbol.iterator]
/**
	 * @description flatten only until the point of comma separated entities. recursive
	 * @param {Array} args any array, intended to contain arrays of arrays.
	 * @returns always an array
	 * @linkcode
	 */,semiFlattenArrays=function(){switch(arguments.length){case void 0:case 0:return Array.from(arguments);
// only if its an array (is iterable) and NOT a string
case 1:return isIterable(arguments[0])&&"string"!=typeof arguments[0]?semiFlattenArrays(...arguments[0]):[arguments[0]];default:return Array.from(arguments).map((e=>isIterable(e)?[...semiFlattenArrays(e)]:e))}},flattenArrays=function(){switch(arguments.length){case void 0:case 0:return Array.from(arguments);
// only if its an array (is iterable) and NOT a string
case 1:return isIterable(arguments[0])&&"string"!=typeof arguments[0]?flattenArrays(...arguments[0]):[arguments[0]];default:return Array.from(arguments).map((e=>isIterable(e)?[...flattenArrays(e)]:e)).reduce(((e,t)=>e.concat(t)),[])}};var L=Object.freeze({__proto__:null,flattenArrays:flattenArrays,semiFlattenArrays:semiFlattenArrays});
/* Math (c) Kraft, MIT License */
/**
	 * Math (c) Kraft
	 */
/**
	 * @description Coerce the function arguments into a vector.
	 * This will object notation {x:, y:}, or array [number, number, ...]
	 * and work for n-dimensions.
	 * @returns {number[]} vector in array form, or empty array for bad inputs
	*/const getVector=function(){let e=flattenArrays(arguments);
// if the arguments's first element is an object with an "x" property
const t=e[0];return"object"!=typeof t||null===t||Number.isNaN(t.x)||(e=["x","y","z"].map((e=>t[e])).filter((e=>void 0!==e))),e.filter((e=>"number"==typeof e))},getArrayOfVectors=function(){return semiFlattenArrays(arguments).map((e=>getVector(e)))},vectorOriginForm=(e=[],t=[])=>({vector:e,origin:t})
// 	{ vector: vector || [], origin: origin || [] });
/**
	 * @description Coerce the function arguments into a line.
	 * @returns {object} a line in "vector" "origin" form.
	 */,getLine$1=function(){const e=semiFlattenArrays(arguments);return 0===e.length?vectorOriginForm([],[]):e[0].constructor===Object&&void 0!==e[0].vector?vectorOriginForm(e[0].vector||[],e[0].origin||[]):"number"==typeof e[0]?vectorOriginForm(getVector(e)):vectorOriginForm(...e.map((e=>getVector(e))))};
/**
	 * @description Coerce the function arguments into an array of vectors.
	 * @returns {number[][]} vectors in array form, or empty array.
	*/var B=Object.freeze({__proto__:null,getArrayOfVectors:getArrayOfVectors,getLine:getLine$1,getSegment:function(){const e=semiFlattenArrays(arguments);return 4===e.length?[[0,1],[2,3]].map((t=>t.map((t=>e[t])))):e.map((e=>getVector(e)))},getVector:getVector});
/* Math (c) Kraft, MIT License */
/**
	 * Math (c) Kraft
	 */
/**
	 * @description this epsilon is used throughout the library
	 * @linkcode Math ./src/algebra/constants.js 6
	 */const I=1e-6,R=180/Math.PI,U=Math.PI/180,D=2*Math.PI;
/**
	 * @description radians to degrees
	 * @linkcode Math ./src/algebra/constants.js 11
	 */var q=Object.freeze({__proto__:null,D2R:U,EPSILON:I,R2D:R,TWO_PI:D});
/* Math (c) Kraft, MIT License */
/**
	 * Math (c) Kraft
	 */
/**
	 * algebra operations on vectors (mostly).
	 *
	 * vectors are assumed to be Javascript Arrays objects /
	 * contain the Javascript Array prototype, as these methods depend
	 * on the use of "map", "reduce" and other Array functions.
	 *
	 * ({x: y:} vectors as Javascript Objects will not work)
	 *
	 * many of these operations can handle vectors of arbitrary dimension
	 * in which case there are two vectors as input, it will be noted that
	 * "dimensions match first parameter", you should verify that the second
	 * parameter is at least as long as the first (okay if it is longer)
	 *
	 * when a function name ends with a number (magnitude2) the input vector's
	 * dimension is assumed to be this number.
	 */
/**
	 * @description many methods here are operations on two arrays where
	 * the first array determines the number of loops. it's possible the
	 * array sizes mismatch, in which case, fill in any empty data with 0.
	 */const safeAdd=(e,t)=>e+(t||0)
/**
	 * @description compute the magnitude an n-dimensional vector
	 * @param {number[]} v one vector, n-dimensions
	 * @returns {number} one scalar
	 * @linkcode Math ./src/algebra/vectors.js 32
	 */,magnitude=e=>Math.sqrt(e.map((e=>e*e)).reduce(safeAdd,0))
/**
	 * @description compute the magnitude a 2D vector
	 * @param {number[]} v one 2D vector
	 * @returns {number} one scalar
	 * @linkcode Math ./src/algebra/vectors.js 41
	 */,magnitude2=e=>Math.sqrt(e[0]*e[0]+e[1]*e[1])
/**
	 * @description compute the magnitude a 3D vector
	 * @param {number[]} v one 3D vector
	 * @returns {number} one scalar
	 * @linkcode Math ./src/algebra/vectors.js 48
	 */,magnitude3=e=>Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2])
/**
	 * @description compute the square-magnitude an n-dimensional vector
	 * @param {number[]} v one vector, n-dimensions
	 * @returns {number} one scalar
	 * @linkcode Math ./src/algebra/vectors.js 55
	 */,magSquared=e=>e.map((e=>e*e)).reduce(safeAdd,0)
/**
	 * @description normalize the input vector and return a new vector as a copy
	 * @param {number[]} v one vector, n-dimensions
	 * @returns {number[]} one vector, dimension matching the input vector
	 * @linkcode Math ./src/algebra/vectors.js 64
	 */,normalize=e=>{const t=magnitude(e);return 0===t?e:e.map((e=>e/t))},normalize2=e=>{const t=magnitude2(e);return 0===t?e:[e[0]/t,e[1]/t]},normalize3=e=>{const t=magnitude3(e);return 0===t?e:[e[0]/t,e[1]/t,e[2]/t]},scale=(e,t)=>e.map((e=>e*t))
/**
	 * @description scale an input vector by one number, return a copy.
	 * @param {number[]} v one 2D vector
	 * @param {number} s one scalar
	 * @returns {number[]} one 2D vector
	 * @linkcode Math ./src/algebra/vectors.js 103
	 */,scale2=(e,t)=>[e[0]*t,e[1]*t]
/**
	 * @description scale an input vector by one number, return a copy.
	 * @param {number[]} v one 3D vector
	 * @param {number} s one scalar
	 * @returns {number[]} one 3D vector
	 * @linkcode
	 */,scale3=(e,t)=>[e[0]*t,e[1]*t,e[2]*t]
/**
	 * @description add two vectors and return the sum as another vector,
	 * do not modify the input vectors.
	 * @param {number[]} v one vector, n-dimensions
	 * @param {number[]} u one vector, n-dimensions
	 * @returns {number[]} one vector, dimension matching first parameter
	 * @linkcode Math ./src/algebra/vectors.js 112
	 */,add=(e,t)=>e.map(((e,r)=>e+(t[r]||0)))
/**
	 * @description add two vectors and return the sum as another vector,
	 * do not modify the input vectors.
	 * @param {number[]} v one 2D vector
	 * @param {number[]} u one 2D vector
	 * @returns {number[]} one 2D vector
	 * @linkcode Math ./src/algebra/vectors.js 121
	 */,add2=(e,t)=>[e[0]+t[0],e[1]+t[1]]
/**
	 * @description add two vectors and return the sum as another vector,
	 * do not modify the input vectors.
	 * @param {number[]} v one 3D vector
	 * @param {number[]} u one 3D vector
	 * @returns {number[]} one 3D vector
	 * @linkcode Math ./src/algebra/vectors.js 130
	 */,add3=(e,t)=>[e[0]+t[0],e[1]+t[1],e[2]+t[2]]
/**
	 * @description subtract the second vector from the first, return the result as a copy.
	 * @param {number[]} v one vector, n-dimensions
	 * @param {number[]} u one vector, n-dimensions
	 * @returns {number[]} one vector, dimension matching first parameter
	 * @linkcode Math ./src/algebra/vectors.js 138
	 */,subtract=(e,t)=>e.map(((e,r)=>e-(t[r]||0)))
/**
	 * @description subtract the second vector from the first, return the result as a copy.
	 * @param {number[]} v one 2D vector
	 * @param {number[]} u one 2D vector
	 * @returns {number[]} one 2D vector
	 * @linkcode Math ./src/algebra/vectors.js 146
	 */,subtract2=(e,t)=>[e[0]-t[0],e[1]-t[1]]
/**
	 * @description subtract the second vector from the first, return the result as a copy.
	 * @param {number[]} v one 3D vector
	 * @param {number[]} u one 3D vector
	 * @returns {number[]} one 3D vector
	 * @linkcode Math ./src/algebra/vectors.js 154
	 */,subtract3=(e,t)=>[e[0]-t[0],e[1]-t[1],e[2]-t[2]]
/**
	 * @description compute the dot product of two vectors.
	 * @param {number[]} v one vector, n-dimensions
	 * @param {number[]} u one vector, n-dimensions
	 * @returns {number} one scalar
	 * @linkcode Math ./src/algebra/vectors.js 162
	 */,dot=(e,t)=>e.map(((r,s)=>e[s]*t[s])).reduce(safeAdd,0)
/**
	 * @description compute the dot product of two 2D vectors.
	 * @param {number[]} v one 2D vector
	 * @param {number[]} u one 2D vector
	 * @returns {number} one scalar
	 * @linkcode Math ./src/algebra/vectors.js 172
	 */,dot2=(e,t)=>e[0]*t[0]+e[1]*t[1]
/**
	 * @description compute the dot product of two 3D vectors.
	 * @param {number[]} v one 3D vector
	 * @param {number[]} u one 3D vector
	 * @returns {number} one scalar
	 * @linkcode Math ./src/algebra/vectors.js 172
	 */,midpoint=(e,t)=>e.map(((e,r)=>(e+t[r])/2))
/**
	 * @description compute the midpoint of two 2D vectors.
	 * @param {number[]} v one 2D vector
	 * @param {number[]} u one 2D vector
	 * @returns {number} one 2D vector
	 * @linkcode Math ./src/algebra/vectors.js 188
	 */,midpoint2=(e,t)=>scale2(add2(e,t),.5)
/**
	 * @description compute the midpoint of two 2D vectors.
	 * @param {number[]} v one 2D vector
	 * @param {number[]} u one 2D vector
	 * @returns {number} one 2D vector
	 * @linkcode Math ./src/algebra/vectors.js 188
	 */,average=function(){if(0===arguments.length)return[];const e=arguments[0].length>0?arguments[0].length:0,t=Array(e).fill(0);return Array.from(arguments).forEach((e=>t.forEach(((r,s)=>{t[s]+=e[s]||0})))),t.map((e=>e/arguments.length))},lerp=(e,t,r)=>{const s=1-r;return e.map(((e,o)=>e*s+(t[o]||0)*r))},cross2=(e,t)=>e[0]*t[1]-e[1]*t[0]
/**
	 * @description the 3D cross product of two 3D vectors
	 * @param {number[]} v one 3D vector
	 * @param {number[]} u one 3D vector
	 * @returns {number[]} one 3D vector
	 * @linkcode Math ./src/algebra/vectors.js 232
	 */,cross3=(e,t)=>[e[1]*t[2]-e[2]*t[1],e[2]*t[0]-e[0]*t[2],e[0]*t[1]-e[1]*t[0]]
/**
	 * @description compute the distance between two vectors
	 * @param {number[]} v one vector, n-dimensions
	 * @param {number[]} u one vector, n-dimensions
	 * @returns {number} one scalar
	 * @linkcode Math ./src/algebra/vectors.js 244
	 */,distance=(e,t)=>Math.sqrt(e.map(((r,s)=>(e[s]-t[s])**2)).reduce(safeAdd,0))
/**
	 * @description compute the distance between two 2D vectors
	 * @param {number[]} v one 2D vector
	 * @param {number[]} u one 2D vector
	 * @returns {number} one scalar
	 * @linkcode Math ./src/algebra/vectors.js 254
	 */,distance2=(e,t)=>{const r=e[0]-t[0],s=e[1]-t[1];return Math.sqrt(r*r+s*s)},distance3=(e,t)=>{const r=e[0]-t[0],s=e[1]-t[1],o=e[2]-t[2];return Math.sqrt(r*r+s*s+o*o)},flip=e=>e.map((e=>-e))
/**
	 * @description return a copy of the input vector rotated 90 degrees counter-clockwise
	 * @param {number[]} v one 2D vector
	 * @returns {number[]} one 2D vector
	 * @linkcode Math ./src/algebra/vectors.js 285
	 */,rotate90=e=>[-e[1],e[0]]
/**
	 * @description return a copy of the input vector rotated 270 degrees counter-clockwise
	 * @param {number[]} v one 2D vector
	 * @returns {number[]} one 2D vector
	 * @linkcode Math ./src/algebra/vectors.js 292
	 */,rotate270=e=>[e[1],-e[0]]
/**
	 * @description check if a vector is degenerate, meaning its magnitude is below an epsilon limit.
	 * @param {number[]} v one vector, n-dimensions
	 * @param {number} [epsilon=1e-6] an optional epsilon with a default value of 1e-6
	 * @returns {boolean} is the magnitude of the vector smaller than the epsilon?
	 * @linkcode Math ./src/algebra/vectors.js 300
	 */,parallelNormalized=(e,t,r=I)=>1-Math.abs(dot(e,t))<r
/**
	 * @description check if two vectors are parallel to each other,
	 * within an epsilon. Parallel includes the case where the
	 * vectors are exactly 180 degrees flipped from one another.
	 * @param {number[]} v one vector, n-dimensions
	 * @param {number[]} u one vector, n-dimensions
	 * @param {number} [epsilon=1e-6] an optional epsilon with a default value of 1e-6
	 * @returns {boolean} are the two vectors parallel within an epsilon?
	 * @linkcode Math ./src/algebra/vectors.js 311
	 */,parallel=(e,t,r=I)=>parallelNormalized(normalize(e),normalize(t),r)
/**
	 * @description check if two 2D vectors are parallel to each other within an epsilon
	 * @param {number[]} v one 2D vector
	 * @param {number[]} u one 2D vector
	 * @param {number} [epsilon=1e-6] an optional epsilon with a default value of 1e-6
	 * @returns {boolean} are the two vectors parallel within an epsilon?
	 * @linkcode Math ./src/algebra/vectors.js 321
	 */,parallel2=(e,t,r=I)=>Math.abs(cross2(e,t))<r
/**
	 * @description Resize a vector to a particular length (duplicating it
	 * in memory in the process) by either lengthening or shortening it.
	 * In the case of lengthening, fill 0.
	 * @param {number} dimension the desired length
	 * @param {number[]} vector the vector to resize
	 * @returns {number[]} a copy of the vector resized to the desired length.
	 * @linkcode
	 */,resize=(e,t)=>t.length===e?t:Array(e).fill(0).map(((e,r)=>t[r]?t[r]:e))
/**
	 * @description Make the two vectors match in dimension by appending the
	 * smaller vector with 0s to match the dimension of the larger vector.
	 * @param {number[]} a a vector
	 * @param {number[]} b a vector
	 * @param {number[][]} an array containing two vectors, a copy of
	 * each of the input parameters.
	 * @linkcode
	 */,resizeUp=(e,t)=>[e,t].map((r=>resize(Math.max(e.length,t.length),r)));var G=Object.freeze({__proto__:null,add:add,add2:add2,add3:add3,average:average,cross2:cross2,cross3:cross3,degenerate:(e,t=I)=>e.map((e=>Math.abs(e))).reduce(safeAdd,0)<t
/**
	 * @description check if two already normalized vectors are parallel
	 * to each other, within an epsilon. Parallel includes the case where
	 * the vectors are exactly 180 degrees flipped from one another.
	 * @param {number[]} v one vector, n-dimensions
	 * @param {number[]} u one vector, n-dimensions
	 * @param {number} [epsilon=1e-6] an optional epsilon with a default value of 1e-6
	 * @returns {boolean} are the two vectors parallel within an epsilon?
	 * @linkcode Math ./src/algebra/vectors.js 311
	 */,distance:distance,distance2:distance2,distance3:distance3,dot:dot,dot2:dot2,dot3:(e,t)=>e[0]*t[0]+e[1]*t[1]+e[2]*t[2]
/**
	 * @description compute the midpoint of two vectors.
	 * @param {number[]} v one vector, n-dimensions
	 * @param {number[]} u one vector, n-dimensions
	 * @returns {number} one vector, dimension matching first parameter
	 * @linkcode Math ./src/algebra/vectors.js 180
	 */,flip:flip,lerp:lerp,magSquared:magSquared,magnitude:magnitude,magnitude2:magnitude2,magnitude3:magnitude3,midpoint:midpoint,midpoint2:midpoint2,midpoint3:(e,t)=>scale3(add3(e,t),.5)
/**
	 * @description the average of N number of vectors (not numbers),
	 * similar to midpoint but this can accept more than 2 inputs.
	 * @param {number[]} ...args any number of input vectors
	 * @returns {number[]} one vector, dimension matching first parameter
	 * @linkcode Math ./src/algebra/vectors.js 196
	 */,normalize:normalize,normalize2:normalize2,normalize3:normalize3,parallel:parallel,parallel2:parallel2,parallelNormalized:parallelNormalized,resize:resize,resizeUp:resizeUp,rotate270:rotate270,rotate90:rotate90,scale:scale,scale2:scale2,scale3:scale3,subtract:subtract,subtract2:subtract2,subtract3:subtract3});
/* Math (c) Kraft, MIT License */
/**
	 * Math (c) Kraft
	 */
/**
	 * the radius parameter measures from the center to the midpoint of the edge
	 * vertex-axis aligned
	 * todo: also possible to parameterize the radius as the center to the points
	 * todo: can be edge-aligned
	 */const angleArray=e=>Array.from(Array(Math.floor(e))).map(((t,r)=>D*(r/e))),anglesToVecs=(e,t)=>e.map((e=>[t*Math.cos(e),t*Math.sin(e)]))
// a = 2r tan(π/n)
/**
	 * @description Make a regular polygon from a circumradius,
	 * the first point is +X aligned.
	 * @param {number} sides the number of sides in the polygon
	 * @param {number} [circumradius=1] the polygon's circumradius
	 * @returns {number[][]} an array of points, each point as an arrays of numbers
	 * @linkcode Math ./src/geometry/polygons.js 34
	 */,makePolygonCircumradius=(e=3,t=1)=>anglesToVecs(angleArray(e),t)
/**
	 * @description Make a regular polygon from a circumradius,
	 * the middle of the first side is +X aligned.
	 * @param {number} sides the number of sides in the polygon
	 * @param {number} [circumradius=1] the polygon's circumradius
	 * @returns {number[][]} an array of points, each point as an arrays of numbers
	 * @linkcode Math ./src/geometry/polygons.js 45
	 */,makePolygonCircumradiusSide=(e=3,t=1)=>{const r=Math.PI/e,s=angleArray(e).map((e=>e+r));return anglesToVecs(s,t)},makePolygonNonCollinear=(e,t=I)=>{
// index map [i] to [i, i+1]
const r=e.map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>subtract(e[1],e[0]))).map(((e,t,r)=>[e,r[(t+r.length-1)%r.length]])).map((e=>!parallel(e[1],e[0],t)));
// the vertex to be removed. true=valid, false=collinear.
// ask if an edge is parallel to its predecessor, this way,
// the edge index will match to the collinear vertex.
return e.filter(((e,t)=>r[t]))},signedArea=e=>.5*e.map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>cross2(...e))).reduce(((e,t)=>e+t),0)
/**
	 * @description Calculates the centroid or the center of mass of the polygon.
	 * @param {number[][]} points an array of 2D points, which are arrays of numbers
	 * @returns {number[]} one 2D point as an array of numbers
	 * @example
	 * var centroid = polygon.centroid([ [1,2], [8,9], [8,0] ])
	 * @linkcode Math ./src/geometry/polygons.js 167
	 */,centroid=e=>{const t=1/(6*signedArea(e));return e.map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>scale2(add2(...e),cross2(...e)))).reduce(((e,t)=>add2(e,t)),[0,0]).map((e=>e*t))},boundingBox$1=(e,t=0)=>{if(!e||!e.length)return;const r=Array(e[0].length).fill(1/0),s=Array(e[0].length).fill(-1/0);e.forEach((e=>e.forEach(((e,o)=>{e<r[o]&&(r[o]=e-t),e>s[o]&&(s[o]=e+t)}))));const o=s.map(((e,t)=>e-r[t]));return{min:r,max:s,span:o}};var W=Object.freeze({__proto__:null,boundingBox:boundingBox$1,centroid:centroid,circumcircle:(e,t,r)=>{const s=t[0]-e[0],o=t[1]-e[1],n=r[0]-e[0],a=r[1]-e[1],c=s*(e[0]+t[0])+o*(e[1]+t[1]),i=n*(e[0]+r[0])+a*(e[1]+r[1]),l=2*(s*(r[1]-t[1])-o*(r[0]-t[0]));if(Math.abs(l)<I){const s=Math.min(e[0],t[0],r[0]),o=Math.min(e[1],t[1],r[1]),n=.5*(Math.max(e[0],t[0],r[0])-s),a=.5*(Math.max(e[1],t[1],r[1])-o);return{origin:[s+n,o+a],radius:Math.sqrt(n*n+a*a)}}const d=[(a*c-o*i)/l,(s*i-n*c)/l],m=d[0]-e[0],g=d[1]-e[1];return{origin:d,radius:Math.sqrt(m*m+g*g)}},makePolygonCircumradius:makePolygonCircumradius,makePolygonCircumradiusSide:makePolygonCircumradiusSide,makePolygonInradius:(e=3,t=1)=>makePolygonCircumradius(e,t/Math.cos(Math.PI/e))
/**
	 * @description Make a regular polygon from a inradius,
	 * the middle of the first side is +X aligned.
	 * @param {number} sides the number of sides in the polygon
	 * @param {number} [inradius=1] the polygon's inradius
	 * @returns {number[][]} an array of points, each point as an arrays of numbers
	 * @linkcode Math ./src/geometry/polygons.js 68
	 */,makePolygonInradiusSide:(e=3,t=1)=>makePolygonCircumradiusSide(e,t/Math.cos(Math.PI/e))
/**
	 * @description Make a regular polygon from a side length,
	 * the first point is +X aligned.
	 * @param {number} sides the number of sides in the polygon
	 * @param {number} [length=1] the polygon's side length
	 * @returns {number[][]} an array of points, each point as an arrays of numbers
	 * @linkcode Math ./src/geometry/polygons.js 78
	 */,makePolygonNonCollinear:makePolygonNonCollinear,makePolygonSideLength:(e=3,t=1)=>makePolygonCircumradius(e,t/2/Math.sin(Math.PI/e))
/**
	 * @description Make a regular polygon from a side length,
	 * the middle of the first side is +X aligned.
	 * @param {number} sides the number of sides in the polygon
	 * @param {number} [length=1] the polygon's side length
	 * @returns {number[][]} an array of points, each point as an arrays of numbers
	 * @linkcode Math ./src/geometry/polygons.js 88
	 */,makePolygonSideLengthSide:(e=3,t=1)=>makePolygonCircumradiusSide(e,t/2/Math.sin(Math.PI/e))
/**
	 * @description Remove any collinear vertices from a n-dimensional polygon.
	 * @param {number[][]} polygon a polygon as an array of ordered points in array form
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {number[][]} a copy of the polygon with collinear points removed
	 * @linkcode Math ./src/geometry/polygons.js 97
	 */,signedArea:signedArea});
/**
	 * Rabbit Ear (c) Kraft
	 */const vertex_degree=function(e,t){const r=this;Object.defineProperty(e,"degree",{get:()=>r.vertices_vertices&&r.vertices_vertices[t]?r.vertices_vertices[t].length:null})},edge_coords=function(e,t){const r=this;Object.defineProperty(e,"coords",{get:()=>{if(r.edges_vertices&&r.edges_vertices[t]&&r.vertices_coords)return r.edges_vertices[t].map((e=>r.vertices_coords[e]))}})},face_simple=function(e,t){const r=this;Object.defineProperty(e,"simple",{get:()=>{if(!r.faces_vertices||!r.faces_vertices[t])return null;for(let s=0;s<e.length-1;s+=1)for(let o=s+1;o<e.length;o+=1)if(r.faces_vertices[t][s]===r.faces_vertices[t][o])return!1;return!0}})},face_coords=function(e,t){const r=this;Object.defineProperty(e,"coords",{get:()=>{if(r.faces_vertices&&r.faces_vertices[t]&&r.vertices_coords)return r.faces_vertices[t].map((e=>r.vertices_coords[e]))}})};
// don't be confused about the naming
// it's probably more proper to use singular ("vertex" instead of "vertices")
// but the plural form is more common and this object will align with
// methods that tie to the plural key
var H={vertices:function(e,t){return vertex_degree.call(this,e,t),e},edges:function(e,t){return edge_coords.call(this,e,t),e},faces:function(e,t){return face_simple.call(this,e,t),face_coords.call(this,e,t),e}};
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * lists of keys and values involved in the FOLD file format spec
	 * https://github.com/edemaine/FOLD/
	 */
/**
	 * @description All FOLD keys described in the spec,
	 * sorted into descriptive categories.
	 */const J={file:["file_spec","file_creator","file_author","file_title","file_description","file_classes","file_frames"],frame:["frame_author","frame_title","frame_description","frame_attributes","frame_classes","frame_unit","frame_parent",// inside file_frames only
"frame_inherit"],graph:["vertices_coords","vertices_vertices","vertices_faces","edges_vertices","edges_faces","edges_assignment","edges_foldAngle","edges_length","faces_vertices","faces_edges",
// as of now, these are not described in the spec, but their behavior
// can be inferred, except faces_faces which could be edge-adjacent or
// face-adjacent. this library uses as EDGE-ADJACENT.
"vertices_edges","edges_edges","faces_faces"],orders:["edgeOrders","faceOrders"]};
/**
	 * values from the official spec, grouped by the key under which they appear.
	 */
/**
	 * @description All "file_classes" values according to the FOLD spec
	 */var Z=Object.freeze({__proto__:null,foldKeys:J,foldFileClasses:["singleModel","multiModel","animation","diagrams"],foldFrameClasses:["creasePattern","foldedForm","graph","linkage"],foldFrameAttributes:["2D","3D","abstract","manifold","nonManifold","orientable","nonOrientable","selfTouching","nonSelfTouching","selfIntersecting","nonSelfIntersecting"]});
/* Math (c) Kraft, MIT License */
/**
	 * Math (c) Kraft
	 */
/**
	 * common functions that get reused, especially inside of map/reduce etc...
	 */
/**
	 * @description Are two inputs equal within an epsilon of each other?
	 * @param {number} a any number input
	 * @param {number} b any number input
	 * @returns {boolean} true if the numbers are near each other
	 * @linkcode Math ./src/algebra/functions.js 79
	 */const epsilonEqual=(e,t,r=I)=>Math.abs(e-t)<r
/**
	 * @description Compare two numbers within an epsilon of each other,
	 * so that "1": a < b, "-1": a > b, and "0": a ~= b (epsilon equal).
	 * @param {number} a any number
	 * @param {number} b any number
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {number} -1, 0, +1
	 * @linkcode Math ./src/algebra/functions.js 89
	 */,epsilonCompare=(e,t,r=I)=>epsilonEqual(e,t,r)?0:Math.sign(t-e)
/**
	 * @description are two vectors equal to each other within an epsilon.
	 * This method uses a axis-aligned bounding box to check equality
	 * for speed. If the two vectors are of differing lengths, assume
	 * the remaining values are zero, compare until the end of the
	 * longest vector.
	 * @param {number[]} a an array of numbers
	 * @param {number[]} b an array of numbers
	 * @returns {boolean} true if the vectors are similar within an epsilon
	 * @linkcode Math ./src/algebra/functions.js 100
	 */,epsilonEqualVectors=(e,t,r=I)=>{for(let s=0;s<Math.max(e.length,t.length);s+=1)if(!epsilonEqual(e[s]||0,t[s]||0,r))return!1;return!0},include=(e,t=I)=>e>-t
/**
	 * @description the exclusive test used in intersection algorithms, returns
	 * true if the number is positive, excluding the epsilon between 0 and +epsilon.
	 * @returns {boolean} -Infinity...{false}...+epsilon...{true}...+Infinity
	 * @linkcode Math ./src/algebra/functions.js 119
	 */,exclude=(e,t=I)=>e>t
/**
	 * @description the function parameter for an inclusive line
	 * @linkcode Math ./src/algebra/functions.js 124
	 */,includeL=()=>!0
/**
	 * @description the function parameter for an exclusive line
	 * @linkcode Math ./src/algebra/functions.js 129
	 */,excludeL=()=>!0
/**
	 * @description the function parameter for an inclusive ray
	 * @linkcode Math ./src/algebra/functions.js 134
	 */,Y=include,X=exclude,includeS=(e,t=I)=>e>-t&&e<1+t
/**
	 * @description the function parameter for an exclusive segment
	 * @linkcode Math ./src/algebra/functions.js 149
	 */,excludeS=(e,t=I)=>e>t&&e<1-t
/**
	 * @description These clamp functions process lines/rays/segments intersections.
	 * The line method allows all values.
	 * @param {number} t the length along the vector
	 * @returns {number} the clamped input value (line does not clamp)
	 * @linkcode Math ./src/algebra/functions.js 157
	 */,clampLine=e=>e
/**
	 * @description These clamp functions process lines/rays/segments intersections.
	 * The ray method clamps values below -epsilon to be 0.
	 * @param {number} t the length along the vector
	 * @returns {number} the clamped input value
	 * @linkcode Math ./src/algebra/functions.js 165
	 */,clampSegment=e=>e<-I?0:e>1.000001?1:e;var K=Object.freeze({__proto__:null,clampLine:clampLine,clampRay:e=>e<-I?0:e
/**
	 * @description These clamp functions process lines/rays/segments intersections.
	 * The segment method clamps values below -epsilon to be 0 and above 1+epsilon to 1.
	 * @param {number} t the length along the vector
	 * @returns {number} the clamped input value
	 * @linkcode Math ./src/algebra/functions.js 173
	 */,clampSegment:clampSegment,epsilonCompare:epsilonCompare,epsilonEqual:epsilonEqual,epsilonEqualVectors:epsilonEqualVectors,exclude:exclude,excludeL:excludeL,excludeR:X,excludeS:excludeS,include:include,includeL:includeL,includeR:Y,includeS:includeS});
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * this contains two types of methods.
	 * 1. references to named string keys that are a part of the FOLD spec
	 *    (anytime FOLD is updated these will update too).
	 * 2. methods that take a FOLD object as a parameter, and perform some
	 *    searching and gathering of information contained inside.
	 */
/**
	 * @description English conversion of the names of graph components
	 * from plural to singular.
	 * @linkcode Origami ./src/fold/spec.js 16
	 */const Q={vertices:"vertex",edges:"edge",faces:"face"},ee=Array.from("BbMmVvFfJjUu"),te={b:"boundary",m:"mountain",v:"valley",f:"flat",j:"join",u:"unassigned"};
/**
	 * @description English conversion of the names of graph components
	 * from singular to plural.
	 * @linkcode Origami ./src/fold/spec.js 25
	 */Object.keys(te).forEach((e=>{te[e.toUpperCase()]=te[e]}));
/**
	 * @description get the foldAngle in degrees for every FOLD assignment spec
	 * character (like "M", or "b"). **this assumes the creases are flat folded.**
	 * @linkcode Origami ./src/fold/spec.js 54
	 */
const re={M:-180,m:-180,V:180,v:180,B:0,b:0,F:0,f:0,J:0,j:0,U:0,u:0},edgeAssignmentToFoldAngle=e=>re[e]||0
/**
	 * @description Convert a foldAngle to an edge assignment character.
	 * No boundary detection is performed so an edge which is otherwise
	 * a boundary will come back as "U".
	 * @todo should "U" be "F" instead?
	 * @param {number} angle fold angle in degrees
	 * @returns {string} an edge assignment letter: M V or U.
	 * @linkcode Origami ./src/fold/spec.js 85
	 */,edgeFoldAngleToAssignment=e=>e>I?"V":e<-I?"M":"U",edgeFoldAngleIsFlat=e=>epsilonEqual(0,e)||epsilonEqual(-180,e)||epsilonEqual(180,e)
/**
	 * @description Provide a FOLD graph and determine if all edges_foldAngle
	 * angles are flat, which includes -180, 0, 180, and the +/- epsilon
	 * around each number. If a graph contains no "edges_foldAngle",
	 * the angles are considered flat, and the method returns "true".
	 * @param {FOLD} graph a FOLD graph
	 * @returns {boolean} is the graph flat-foldable according to foldAngles.
	 * @linkcode Origami ./src/fold/spec.js 110
	 */,edgesFoldAngleAreAllFlat=({edges_foldAngle:e})=>{if(!e)return!0;for(let t=0;t<e.length;t+=1)if(!edgeFoldAngleIsFlat(e[t]))return!1;return!0},filterKeys=(e,t)=>Object.keys(e).filter((e=>t(e)))
/**
	 * @description Get all keys in an object which begin with a string and are
	 * immediately followed by "_". For example, provide "vertices" and this will
	 * match "vertices_coords", "vertices_faces", but not "faces_vertices"
	 * @param {object} obj an object
	 * @param {string} prefix a prefix to match against the keys
	 * @returns {string[]} array of matching keys
	 * @linkcode Origami ./src/fold/spec.js 151
	 */,filterKeysWithPrefix=(e,t)=>filterKeys(e,(e=>e.substring(0,t.length+1)===`${t}_`))
/**
	 * @description Get all keys in an object which end with a string and are
	 * immediately preceded by "_". For example, provide "vertices" and this will
	 * match "edges_vertices", "faces_vertices", but not "vertices_edges"
	 * @param {object} obj an object
	 * @param {string} suffix a suffix to match against the keys
	 * @returns {string[]} array of matching keys
	 * @linkcode Origami ./src/fold/spec.js 124
	 */,filterKeysWithSuffix=(e,t)=>filterKeys(e,(e=>e.substring(e.length-t.length-1,e.length)===`_${t}`))
/**
	 * @description This takes in a geometry_key (vectors, edges, faces), and flattens
	 * across all related arrays, creating one object with the keys for every index.
	 * @param {FOLD} graph a FOLD object
	 * @param {string} geometry_key a geometry item like "vertices"
	 * @returns {object[]} an array of objects with FOLD keys but the
	 * values are from this single element
	 * @linkcode Origami ./src/fold/spec.js 176
	 */,transposeGraphArrays=(e,t)=>{const r=filterKeysWithPrefix(e,t);if(0===r.length)return[];const s=Math.max(...r.map((t=>e[t].length))),o=Array.from(Array(s)).map((()=>({})));return r.forEach((t=>o.forEach(((r,s)=>{o[s][t]=e[t][s]})))),o},se=Object.freeze([].concat(J.file).concat(J.frame).concat(J.graph).concat(J.orders)),isFoldObject=(e={})=>0===Object.keys(e).length?0:se.filter((t=>e[t])).length/Object.keys(e).length
// export const getMetadata = (FOLD = {}) => {
// 	// build a list of all metadata keys (do not include file_frames)
// 	const metadataKeys = {}
// 	[...foldKeys.file, ...foldKeys.frame]
// 		.forEach(k => { metadataKeys[k] = true; });
// 	delete metadataKeys.file_frames;
// 	const copy = {};
// 	Object.keys(FOLD)
// 		.filter()
// };
/**
	 * @description Convert an assignment character to a foldAngle in degrees.
	 * This assumes that all assignments are flat folds.
	 * @param {string} assignment one edge assignment letter: M V B F U
	 * @returns {number} fold angle in degrees. M/V are assumed to be flat-folded.
	 * @linkcode Origami ./src/fold/spec.js 75
	 */var oe=Object.freeze({__proto__:null,singularize:Q,pluralize:{vertex:"vertices",edge:"edges",face:"faces"},edgesAssignmentValues:ee,edgesAssignmentNames:te,edgeAssignmentToFoldAngle:edgeAssignmentToFoldAngle,edgeFoldAngleToAssignment:edgeFoldAngleToAssignment,edgeFoldAngleIsFlat:edgeFoldAngleIsFlat,edgesFoldAngleAreAllFlat:edgesFoldAngleAreAllFlat,filterKeysWithPrefix:filterKeysWithPrefix,filterKeysWithSuffix:filterKeysWithSuffix,transposeGraphArrays:transposeGraphArrays,transposeGraphArrayAtIndex:(e,t,r)=>{const s=filterKeysWithPrefix(e,t);if(0===s.length)return;const o={};
// matching_keys
//   .map(k => ({ long: k, short: k.substring(geometry_key.length + 1) }))
//   .forEach((key) => { geometry[key.short] = graph[key.long][index]; });
return s.forEach((t=>{o[t]=e[t][r]})),o},isFoldObject:isFoldObject});
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * @description Find all clusters of vertices which lie within an epsilon of each other.
	 * Each cluster is an array of vertex indices. If no clusters exist, the method returns
	 * N-number of arrays, each with a single vertex entry. This is an implementation of a
	 * density-based spatial clustering of applications with noise (DBSCAN).
	 * @param {FOLD} graph a FOLD object
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {number[][]} array of arrays of vertex indices.
	 * @example
	 * no clusters: [ [0], [1], [2], [3], [4], ... ]
	 * clusters: [ [0, 5], [1], [3], [2, 4]]
	 * @linkcode Origami ./src/graph/verticesClusters.js 16
	 */const verticesClusters=({vertices_coords:e},t=I)=>{if(!e)return[];
// the return value, the clusters
const r=[],s=[],o=e.map(((e,t)=>({i:t,d:e[0]}))).sort(((e,t)=>e.d-t.d)).map((e=>e.i));
// add to this as we go. once length === vertices_coords.length, we are done.
let n=0,a=[0,0],c=[0,0];
/**
		 * @description Test if a vertex is inside the current cluster's bounding box
		 * @param {number} index an index in vertices_coords
		 */
const updateRange=r=>{const s=r[r.length-1];
// update rangeStart
// while (!isInsideCluster(cluster[rangeStart]) && rangeStart < cluster.length - 1) {
// 	rangeStart += 1;
// }
for(;e[s]-e[r[n]]>t;)n+=1;
// update bounding box
const o=r.slice(n,r.length).map((t=>e[t])),i=o.map((e=>e[1]));a=[Math.min(...i)-t,Math.max(...i)+t],c=[o[0][0]-t,o[o.length-1][0]+t]};
/**
		 * @description Each time we add a point to the current cluster,
		 * form a bounding box NOT by all points in the cluster, but all
		 * points that are within epsilon range along the X-axis of the most
		 * recently added point, as points are sorted left to right.
		 * "rangeStart" is the index of the cluster which is still within epsilon
		 * range of the most recently added point, every update to cluster will
		 * refresh the bounding box as rect range of indices (rangeStart...length).
		 */
// loop until all points have been added to "finished"
for(;s.length!==e.length;){
// start a new cluster, add the first vertex furthest to the left
const t=[],l=o.shift();t.push(l),s.push(l),
// rangeStart is an index in the array "cluster"
n=0,
// update new bounding box, walk x-start pointer forward
updateRange(t);
// walk is an index in the array "vertices"
let d=0;
// this boolean check tests whether or not the vertex is still inside
// the bounding box ONLY according to the X axis. it's possible a
// vertex is too far away in the Y (and rejected from the cluster), but
// the next few vertices to its right are still within the cluster.
// however, if we move too far away in the X direction from the cluster,
// we know this cluster is finished and we can start a new one.
for(;d<o.length&&e[o[d]][0]<c[1];)
// if the point is inside the bounding box of the cluster, add it.
if(i=o[d],e[i][0]>c[0]&&e[i][0]<c[1]&&e[i][1]>a[0]&&e[i][1]<a[1]){const e=o.splice(d,1).shift();t.push(e),s.push(e),
// update new bounding box, walk x-start pointer forward
updateRange(t)}else
// skip over this vertex. even though our vertices are sorted
// left to right, it's possible that this one is too far away in the
// Y axis, but the next few points will still be inside the cluster
d+=1;
// cluster is done, no more possible points can be added.
// start a new cluster next round, unless all vertices are finished.
r.push(t)}var i;return r;
// .map(arr => arr.sort((a, b) => a - b))
// .sort((a, b) => a[0] - b[0]);
},max_arrays_length=(...e)=>Math.max(0,...e.filter((e=>void 0!==e)).map((e=>e.length)))
/**
	 * @description Get the number of vertices, edges, or faces in the graph by
	 * simply checking the length of arrays starting with the key; in the case
	 * of differing array lengths (which shouldn't happen) return the largest number.
	 *
	 * This works even with custom component names in place of "vertices", "edges"...
	 *
	 * This will fail in the case of abstract graphs, for example where no vertices
	 * are defined in a vertex_ array, but still exist as mentions in faces_vertices.
	 * In that case, use the implied count method. "count_implied.js"
	 * @param {FOLD} graph a FOLD graph
	 * @param {string} key the prefix for a key, eg: "vertices"
	 * @returns {number} the number of the requested element type in the graph
	 * @linkcode Origami ./src/graph/count.js 25
	 */,count=(e,t)=>max_arrays_length(...filterKeysWithPrefix(e,t).map((t=>e[t])))
// standard graph components names
/**
	 * @description Get the number of vertices in a graph.
	 * @param {FOLD} graph a FOLD graph
	 * @returns {number} the number of vertices in the graph
	 */;
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * @param {any[]} arrays any number of arrays
	 * @returns {number} the length of the longest array
	 */count.vertices=({vertices_coords:e,vertices_faces:t,vertices_vertices:r})=>max_arrays_length(e,t,r)
/**
	 * @description Get the number of edges in a graph.
	 * @param {FOLD} graph a FOLD graph
	 * @returns {number} the number of edges in the graph
	 */,count.edges=({edges_vertices:e,edges_edges:t,edges_faces:r})=>max_arrays_length(e,t,r)
/**
	 * @description Get the number of faces in a graph.
	 * @param {FOLD} graph a FOLD graph
	 * @returns {number} the number of faces in the graph
	 */,count.faces=({faces_vertices:e,faces_edges:t,faces_faces:r})=>max_arrays_length(e,t,r)
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * @description Given a list of any type, remove all duplicates.
	 * @param {number[]} array an array of integers
	 * @returns {number[]} set of unique integers
	 * @example [1,2,3,2,1] will result in [1,2,3]
	 * @linkcode Origami ./src/general/arrays.js 10
	 */;const uniqueElements=e=>Array.from(new Set(e))
/**
	 * @description Given an array of any type, return the same array but filter
	 * out any items which only appear once. The comparison uses conversion-to-string,
	 * then matching to compare, so this works for primitives
	 * (bool, number, string), not objects or arrays.
	 * @param {any[]} array an array of any type.
	 * @returns {any[]} the same input array but filtered to
	 * remove elements which appear only once.
	 * @example [1,2,3,2,1] will result in [1,2,2,1]
	 * @linkcode Origami ./src/general/arrays.js 22
	 */,nonUniqueElements=e=>{const t={};return e.forEach((e=>{void 0===t[e]&&(t[e]=0),t[e]+=1})),e.filter((e=>t[e]>1))},uniqueSortedNumbers=e=>uniqueElements(e).sort(((e,t)=>e-t))
/**
	 * @description A circular array (data wraps around) requires 2 indices
	 * if you intend to split it into two arrays. The pair of indices can be
	 * provided in any order, they will be sorted, smaller index first.
	 * @param {any[]} array an array that is meant to be thought of as circular
	 * @param {number[]} indices two numbers, indices that divide the array into 2 parts
	 * @returns {any[][]} the same array split into two arrays
	 * @linkcode Origami ./src/general/arrays.js 49
	 */,splitCircularArray=(e,t)=>(t.sort(((e,t)=>e-t)),[e.slice(t[1]).concat(e.slice(0,t[0]+1)),e.slice(t[0],t[1]+1)]),booleanMatrixToIndexedArray=e=>e.map((e=>e.map(((e,t)=>!0===e?t:void 0)).filter((e=>void 0!==e))))
/**
	 * @description consult the upper right half triangle of the matrix,
	 * find all truthy values, gather the row/column index pairs,
	 * return them as pairs of indices in a single array.
	 * Triangle number, only visit half the indices. make unique pairs
	 * @param {any[][]} matrix a matrix containing any type
	 * @returns {number[][]} array of pairs of numbers, the pairs of indices
	 * which are truthy in the matrix.
	 * @linkcode Origami ./src/general/arrays.js 96
	 */
// todo: i wrote this to replace the bit below. this works with
// sparse arrays too. needs testing before it gets replaced.
// export const booleanMatrixToUniqueIndexPairs = matrix => {
// 	const pairs = [];
// 	matrix.forEach((row, i) => row.forEach((value, j) => {
// 		if (i >= j) { return; }
// 		if (value) { pairs.push([i, j]); }
// 	}));
// 	return pairs;
// };
,booleanMatrixToUniqueIndexPairs=e=>{const t=[];for(let r=0;r<e.length-1;r+=1)for(let s=r+1;s<e.length;s+=1)e[r][s]&&t.push([r,s]);return t};
/**
	 * @description given an array containing undefineds, gather all contiguous
	 * series of valid entries, and return the list of their indices in the form
	 * of [start_index, final_index].
	 * @param {any[]} array the array which is allowed to contain holes
	 * @returns {number[][]} array containing pairs of numbers
	 * @example
	 * circularArrayValidRanges([0, 1, undefined, 2, 3, 4, undefined, undefined, 5])
	 * // will return
	 * [ [8, 1], [3, 5] ]
	 * @linkcode Origami ./src/general/arrays.js 197
	 */
// export const circularArrayValidRanges = (array) => {
// 	// if the array contains no undefineds, return the default state.
// 	const not_undefineds = array.map(el => el !== undefined);
// 	if (not_undefineds.reduce((a, b) => a && b, true)) {
// 		return [[0, array.length - 1]];
// 	}
// 	// mark the location of the first-in-a-list of valid entries.
// 	const first_not_undefined = not_undefineds
// 		.map((el, i, arr) => el && !arr[(i - 1 + arr.length) % arr.length]);
// 	// this is the number of sets we have. will be >= 1
// 	const total = first_not_undefined.reduce((a, b) => a + (b ? 1 : 0), 0);
// 	// the location of the starting index of each contiguous set
// 	const starts = Array(total);
// 	// the length of contiguous each set.
// 	const counts = Array(total).fill(0);
// 	// we want the set that includes index 0 to be listed first,
// 	// if that doesn't exist, the next lowest index should be first.
// 	let index = not_undefineds[0] && not_undefineds[array.length - 1]
// 		? 0
// 		: (total - 1);
// 	not_undefineds.forEach((el, i) => {
// 		index = (index + (first_not_undefined[i] ? 1 : 0)) % counts.length;
// 		counts[index] += not_undefineds[i] ? 1 : 0;
// 		if (first_not_undefined[i]) { starts[index] = i; }
// 	});
// 	return starts.map((s, i) => [s, (s + counts[i] - 1) % array.length]);
// };
/**
	 * @description given an array containing undefineds, starting at index 0,
	 * walk backwards (circularly around) to find the first index that isn't
	 * undefined. similarly, from 0 increment to the final index that isn't
	 * undefined. no undefineds results in [0, length].
	 * @param {any[]} the array, which possibly contains holes
	 * @param {number} the length of the array. this is required because
	 * it's possible that the holes exist at the end of the array,
	 * causing it to misreport the (intended) length.
	 */
// const circularArrayValidRange = (array, array_length) => {
//   let start, end;
//   for (start = array_length - 1;
//     start >= 0 && array[start] !== undefined;
//     start--);
//   start = (start + 1) % array_length;
//   for (end = 0;
//     end < array_length && array[end] !== undefined;
//     end++);
//   return [start, end];
// };
// this is now "invertSimpleMap" in maps.js
// export const invert_array = (a) => {
// 	const b = [];
// 	a.forEach((n, i) => { b[n] = i; });
// 	return b;
// };
// export const invert_array = (a) => {
//  const b = [];
//  a.forEach((x, i) => {
//		if (typeof x === "number") { b[x] = i; }
//	});
//  return b;
// };
var ne=Object.freeze({__proto__:null,uniqueElements:uniqueElements,nonUniqueElements:nonUniqueElements,uniqueSortedNumbers:uniqueSortedNumbers,splitCircularArray:splitCircularArray,booleanMatrixToIndexedArray:booleanMatrixToIndexedArray,booleanMatrixToUniqueIndexPairs:booleanMatrixToUniqueIndexPairs,selfRelationalUniqueIndexPairs:e=>{const t=[],r=[];return e.forEach(((e,s)=>e.forEach((e=>{s<e&&r.push([s,e]),s!==e||t[s]||(t[s]=!0,r.push([s,e]))})))),r},clusterScalars:(e,t=I)=>{const r=e.map(((e,t)=>({v:e,i:t}))).sort(((e,t)=>e.v-t.v)).map((e=>e.i)),s=[[r[0]]];for(let o=1;o<r.length;o+=1){const n=r[o],a=s.length-1,c=s[a][s[a].length-1];Math.abs(e[c]-e[n])<t?s[a].push(n):s.push([n])}return s},chooseTwoPairs:e=>{const t=Array(e.length*(e.length-1)/2);let r=0;for(let s=0;s<e.length-1;s+=1)for(let o=s+1;o<e.length;o+=1,r+=1)t[r]=[e[s],e[o]];return t}});
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * @name remove
	 * @memberof graph
	 * @description Removes vertices, edges, or faces (or anything really)
	 * remove elements from inside arrays, shift up remaining components,
	 * and updates all relevant references across other arrays due to shifting.
	 * @param {FOLD} graph a FOLD object
	 * @param {string} key like "vertices", the prefix of the arrays
	 * @param {number[]} removeIndices an array of vertex indices, like [1,9,25]
	 * @returns {number[]} a map of changes to the graph
	 * @example remove(foldObject, "vertices", [2,6,11,15]);
	 * @example
	 * removing index 5 from a 10-long vertices list will shift all
	 * indices > 5 up by one, and then will look through all other arrays like
	 * edges_vertices, faces_vertices and update any reference to indices 6-9
	 * to match their new positions 5-8.
	 *
	 * this can handle removing multiple indices at once; and is faster than
	 * otherwise calling this multiple times with only one or a few removals.
	 * @example
	 * given removeIndices: [4, 6, 7];
	 * given a geometry array: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
	 * map becomes (_=undefined): [0, 1, 2, 3, _, 4, _, _, 5, 6];
	 * @linkcode Origami ./src/graph/remove.js 33
	 */const removeGeometryIndices=(e,t,r)=>{const s=count(e,t),o=uniqueSortedNumbers(r),n=[];for(let e=0,t=0,r=0;e<s;e+=1,t+=1){for(;e===o[r];)
// this prevents arrays with holes
n[e]=void 0,e+=1,r+=1;e<s&&(n[e]=t)}
// update every component that points to vertices_coords
// these arrays do not change their size, only their contents
return filterKeysWithSuffix(e,t).forEach((t=>e[t].forEach(((r,s)=>e[t][s].forEach(((r,o)=>{e[t][s][o]=n[r]})))))),
// update every array with a 1:1 relationship to vertices_ arrays
// these arrays do change their size, their contents are untouched
o.reverse(),filterKeysWithPrefix(e,t).forEach((t=>o.forEach((r=>e[t].splice(r,1))))),n},replaceGeometryIndices=(e,t,r)=>{const s=count(e,t);
// make sure replace indices are well-formed. values cannot be larger than keys.
// if this is the case, flip the index/value, assuming the two geometry items
// are interchangeable and it doesn't matter which one we remove, but warn
// the user that this took place.
let o=!1;Object.entries(r).filter((([e,t])=>e<t)).forEach((([e,t])=>{o=!0,delete r[e],r[t]=e})),o&&console.warn(F);const n=Object.keys(r).map((e=>parseInt(e,10))),a=uniqueSortedNumbers(n),c=[];for(let e=0,t=0,o=0;e<s;e+=1,t+=1){for(;e===a[o];){if(
// this prevents arrays with holes
c[e]=c[r[a[o]]],void 0===c[e])throw new Error(C);e+=1,o+=1}e<s&&(c[e]=t)}
// update every component that points to vertices_coords
// these arrays do not change their size, only their contents
return filterKeysWithSuffix(e,t).forEach((t=>e[t].forEach(((r,s)=>e[t][s].forEach(((r,o)=>{e[t][s][o]=c[r]})))))),
// update every array with a 1:1 relationship to vertices_ arrays
// these arrays do change their size, their contents are untouched
a.reverse(),filterKeysWithPrefix(e,t).forEach((t=>a.forEach((r=>e[t].splice(r,1))))),c},duplicateVertices=(e,t)=>verticesClusters(e,t).filter((e=>e.length>1))
/**
	 * @description Get the indices of all vertices which make no appearance in any edge.
	 * @param {FOLD} graph a FOLD graph
	 * @returns {number[]} the indices of the isolated vertices
	 * @linkcode Origami ./src/graph/verticesViolations.js 24
	 */,isolatedVertices=({vertices_coords:e,edges_vertices:t,faces_vertices:r})=>{if(!e)return[];let s=e.length;const o=Array(s).fill(!1);return t&&t.forEach((e=>{e.filter((e=>!o[e])).forEach((e=>{o[e]=!0,s-=1}))})),r&&r.forEach((e=>{e.filter((e=>!o[e])).forEach((e=>{o[e]=!0,s-=1}))})),o.map(((e,t)=>e?void 0:t)).filter((e=>void 0!==e))},removeIsolatedVertices=(e,t)=>(t||(t=isolatedVertices(e)),{map:removeGeometryIndices(e,o,t),remove:t}),removeDuplicateVertices=(e,t=I)=>{
// replaces array will be [index:value] index is the element to delete,
// value is the index this element will be replaced by.
const r=[],s=[],n=verticesClusters(e,t).filter((e=>e.length>1));
// "remove" is only needed for the return value summary.
// for each cluster of n, all indices from [1...n] will be replaced with [0]
return n.forEach((e=>{
// replace() must maintain index > value, ensure index[0] is the
// smallest of the set (most of the time it is)
Math.min(...e)!==e[0]&&e.sort(((e,t)=>e-t));for(let t=1;t<e.length;t+=1)r[e[t]]=e[0],s.push(e[t])})),
// for each cluster, average all vertices-to-merge to get their new point.
// set the vertex at the index[0] (the index to keep) to the new point.
n.map((t=>t.map((t=>e.vertices_coords[t])))).map((e=>average(...e))).forEach(((t,r)=>{e.vertices_coords[n[r][0]]=t})),{map:replaceGeometryIndices(e,o,r),remove:s}};
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * @name replace
	 * @memberof graph
	 * @description Replaces vertices, edges, or faces (or anything really)
	 * replace elements from inside arrays, shift up remaining components,
	 * and updates all relevant references across other arrays due to shifting.
	 * @param {FOLD} graph a FOLD object
	 * @param {string} key like "vertices", the prefix of the arrays
	 * @param {number[]} replaceIndices an array of vertex indices, like [1,9,25]
	 * @returns {number[]} a map of changes to the graph
	 * @example replace(foldObject, "vertices", [2,6,11,15]);
	 * @example
	 * for example: removing index 5 from a 10-long vertices list will shift all
	 * indices > 5 up by one, and then will look through all other arrays like
	 * edges_vertices, faces_vertices and update any reference to indices 6-9
	 * to match their new positions 5-8.
	 *
	 * this can handle removing multiple indices at once; and is faster than
	 * otherwise calling this multiple times with only one or a few removals.
	 * @linkcode Origami ./src/graph/replace.js 30
	 */
// replaceIndices: [4:3, 7:5, 8:3, 12:3, 14:9] where keys are indices to remove
var ae=Object.freeze({__proto__:null,duplicateVertices:duplicateVertices,edgeIsolatedVertices:({vertices_coords:e,edges_vertices:t})=>{if(!e||!t)return[];let r=e.length;const s=Array(r).fill(!1);return t.forEach((e=>{e.filter((e=>!s[e])).forEach((e=>{s[e]=!0,r-=1}))})),s.map(((e,t)=>e?void 0:t)).filter((e=>void 0!==e))},faceIsolatedVertices:({vertices_coords:e,faces_vertices:t})=>{if(!e||!t)return[];let r=e.length;const s=Array(r).fill(!1);return t.forEach((e=>{e.filter((e=>!s[e])).forEach((e=>{s[e]=!0,r-=1}))})),s.map(((e,t)=>e?void 0:t)).filter((e=>void 0!==e))},isolatedVertices:isolatedVertices,removeIsolatedVertices:removeIsolatedVertices,removeDuplicateVertices:removeDuplicateVertices});
/* Math (c) Kraft, MIT License */
/**
	 * Math (c) Kraft
	 */
/**
	 * @description Convert a 2D vector to an angle in radians.
	 * @param {number[]} v an input vector
	 * @returns {number} the angle in radians
	 * @linkcode Math ./src/algebra/functions.js 56
	 */const vectorToAngle=e=>Math.atan2(e[1],e[0])
/**
	 * @description Convert an angle in radians to a 2D vector.
	 * @param {number} a the angle in radians
	 * @returns {number[]} a 2D vector
	 * @linkcode Math ./src/algebra/functions.js 63
	 */,angleToVector=e=>[Math.cos(e),Math.sin(e)]
/**
	 * @description Given two points, create a vector-origin line representation
	 * of a line that passes through both points. This will work in n-dimensions.
	 * If there are more than two points, the rest will be ignored.
	 * @param {number[][]} points two points, each point being an array of numbers.
	 * @returns {RayLine} an object with "vector" and "origin".
	 */,pointsToLine=(...e)=>{const t=getArrayOfVectors(...e);return{vector:subtract(t[1],t[0]),origin:t[0]}},rayLineToUniqueLine=({vector:e,origin:t})=>{const r=magnitude(e),s=rotate90(e),o=dot(t,s)/r;return{normal:scale(s,1/r),distance:o}},uniqueLineToRayLine=({normal:e,distance:t})=>({vector:rotate270(e),origin:scale(e,t)});var ce=Object.freeze({__proto__:null,angleToVector:angleToVector,pointsToLine:pointsToLine,rayLineToUniqueLine:rayLineToUniqueLine,uniqueLineToRayLine:uniqueLineToRayLine,vectorToAngle:vectorToAngle});
/* Math (c) Kraft, MIT License */
/**
	 * Math (c) Kraft
	 */
/**
	 * measurements involving vectors and radians
	 */
/**
	 * @description check if the first parameter is counter-clockwise between A and B.
	 * floor and ceiling can be unbounded, this method takes care of 0-2pi wrap around.
	 * @param {number} angle angle in radians
	 * @param {number} floor angle in radians, lower bound
	 * @param {number} ceiling angle in radians, upper bound
	 * @returns {boolean} is the angle between floor and ceiling
	 * @linkcode Math ./src/geometry/radial.js 38
	 */const isCounterClockwiseBetween=(e,t,r)=>{for(;r<t;)r+=D;for(;e>t;)e-=D;for(;e<t;)e+=D;return e<r},clockwiseAngleRadians=(e,t)=>{
// this is on average 50 to 100 times faster than clockwiseAngle2
for(;e<0;)e+=D;for(;t<0;)t+=D;for(;e>D;)e-=D;for(;t>D;)t-=D;const r=e-t;return r>=0?r:D-(t-e)},counterClockwiseAngleRadians=(e,t)=>{
// this is on average 50 to 100 times faster than counterClockwiseAngle2
for(;e<0;)e+=D;for(;t<0;)t+=D;for(;e>D;)e-=D;for(;t>D;)t-=D;const r=t-e;return r>=0?r:D-(e-t)},clockwiseAngle2=(e,t)=>{const r=t[0]*e[0]+t[1]*e[1],s=t[0]*e[1]-t[1]*e[0];let o=Math.atan2(s,r);return o<0&&(o+=D),o},counterClockwiseAngle2=(e,t)=>{const r=e[0]*t[0]+e[1]*t[1],s=e[0]*t[1]-e[1]*t[0];let o=Math.atan2(s,r);return o<0&&(o+=D),o},clockwiseBisect2=(e,t)=>angleToVector(vectorToAngle(e)-clockwiseAngle2(e,t)/2)
/**
	 * @description calculate the angle bisection counter-clockwise from the first vector to the second.
	 * @param {number[]} a one 2D vector
	 * @param {number[]} b one 2D vector
	 * @returns {number[]} one 2D vector
	 * @linkcode Math ./src/geometry/radial.js 137
	 */,counterClockwiseBisect2=(e,t)=>angleToVector(vectorToAngle(e)+counterClockwiseAngle2(e,t)/2)
/**
	 * @description subsect into n-divisions the angle clockwise from one angle to the next
	 * @param {number} divisions number of angles minus 1
	 * @param {number} angleA one angle in radians
	 * @param {number} angleB one angle in radians
	 * @returns {number[]} array of angles in radians
	 * @linkcode Math ./src/geometry/radial.js 148
	 */,clockwiseSubsectRadians=(e,t,r)=>{const s=clockwiseAngleRadians(e,t)/r;return Array.from(Array(r-1)).map(((t,r)=>e+s*(r+1)))},counterClockwiseSubsectRadians=(e,t,r)=>{const s=counterClockwiseAngleRadians(e,t)/r;return Array.from(Array(r-1)).map(((t,r)=>e+s*(r+1)))},counterClockwiseSubsect2=(e,t,r)=>{const s=Math.atan2(e[1],e[0]),o=Math.atan2(t[1],t[0]);return counterClockwiseSubsectRadians(s,o,r).map(angleToVector)},counterClockwiseOrderRadians=function(){const e=Array.from(arguments).flat(),t=e.map(((e,t)=>t)).sort(((t,r)=>e[t]-e[r]));return t.slice(t.indexOf(0),t.length).concat(t.slice(0,t.indexOf(0)))},counterClockwiseOrder2=function(){return counterClockwiseOrderRadians(semiFlattenArrays(arguments).map(vectorToAngle))},counterClockwiseSectorsRadians=function(){const e=Array.from(arguments).flat();return counterClockwiseOrderRadians(e).map((t=>e[t])).map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>counterClockwiseAngleRadians(e[0],e[1])))},counterClockwiseSectors2=function(){return counterClockwiseSectorsRadians(semiFlattenArrays(arguments).map(vectorToAngle))},threePointTurnDirection=(e,t,r,s=I)=>{const o=normalize2(subtract2(t,e)),n=normalize2(subtract2(r,e)),a=cross2(o,n);return epsilonEqual(a,0,s)?epsilonEqual(distance2(e,t)+distance2(t,r),distance2(e,r))?0:void 0:Math.sign(a);
// collinear. now we have to ensure the order is 0, 1, 2, and point
// 1 lies between 0 and 2. otherwise we made a 180 degree turn (return undefined)
};
/**
	 * @description There are 2 interior angles between 2 vectors (as an angle in radians),
	 * A-to-B clockwise, and A-to-B counter-clockwise. Get the clockwise one from A to B.
	 * @param {number} a vector as an angle in radians
	 * @param {number} b vector as an angle in radians
	 * @returns {number} interior angle in radians
	 * @linkcode Math ./src/geometry/radial.js 52
	 */var ie=Object.freeze({__proto__:null,clockwiseAngle2:clockwiseAngle2,clockwiseAngleRadians:clockwiseAngleRadians,clockwiseBisect2:clockwiseBisect2,clockwiseSubsect2:(e,t,r)=>{const s=Math.atan2(e[1],e[0]),o=Math.atan2(t[1],t[0]);return clockwiseSubsectRadians(s,o,r).map(angleToVector)},clockwiseSubsectRadians:clockwiseSubsectRadians,counterClockwiseAngle2:counterClockwiseAngle2,counterClockwiseAngleRadians:counterClockwiseAngleRadians,counterClockwiseBisect2:counterClockwiseBisect2,counterClockwiseOrder2:counterClockwiseOrder2,counterClockwiseOrderRadians:counterClockwiseOrderRadians,counterClockwiseSectors2:counterClockwiseSectors2,counterClockwiseSectorsRadians:counterClockwiseSectorsRadians,counterClockwiseSubsect2:counterClockwiseSubsect2,counterClockwiseSubsectRadians:counterClockwiseSubsectRadians,isCounterClockwiseBetween:isCounterClockwiseBetween,threePointTurnDirection:threePointTurnDirection});
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * @description Search inside arrays inside arrays and return
	 * the largest number.
	 * @returns {number} largest number in array in arrays.
	 */const le={edges:"edgeOrders",faces:"faceOrders"},countImplied=(e,t)=>Math.max(
// return the maximum value between (1/2):
// 1. a found geometry in another geometry's array ("vertex" in "faces_vertices")
(e=>{let t=-1;// will become 0 if nothing is found
return e.filter((e=>void 0!==e)).forEach((e=>e.forEach((e=>e.forEach((e=>{e>t&&(t=e)})))))),t})(filterKeysWithSuffix(e,t).map((t=>e[t]))),
// 2. a found geometry in a faceOrders or edgeOrders type of array (special case)
e[le[t]]?(e=>{let t=-1;// will become 0 if nothing is found
return e.forEach((e=>{
// exception. index 2 is orientation, not index. check only 0, 1
e[0]>t&&(t=e[0]),e[1]>t&&(t=e[1])})),t})(e[le[t]]):-1)+1
// standard graph components names;
/**
	 * @description Search inside arrays inside arrays and return
	 * the largest number by only checking indices 0 and 1 in the
	 * inner arrays.
	 * @returns {number} largest number in indices 0 or 1 of array in arrays.
	 */countImplied.vertices=e=>countImplied(e,o),countImplied.edges=e=>countImplied(e,n),countImplied.faces=e=>countImplied(e,a)
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * @description discover a face by walking neighboring vertices until returning to the start.
	 * @param {FOLD} graph a FOLD graph
	 * @param {number} v0 starting vertex
	 * @param {number} v1 second vertex, this sets the direction of the walk
	 * @param {object} [walked_edges={}] memo object, to prevent walking down
	 * duplicate paths, or finding duplicate faces, this dictionary will
	 * store and check against vertex pairs "i j".
	 * @returns {object} the walked face, an object arrays of numbers
	 * under "vertices", "edges", and "angles"
	 * @linkcode Origami ./src/graph/walk.js 14
	 */;const counterClockwiseWalk=({vertices_vertices:e,vertices_sectors:t},r,s,o={})=>{
// each time we visit an edge (vertex pair as string, "4 9") add it here.
// this gives us a quick lookup to see if we've visited this edge before.
const n={},a={vertices:[r],edges:[],angles:[]};
// return the face: { vertices, edges, angles }
// walking the graph, we look at 3 vertices at a time. in sequence:
// prev_vertex, this_vertex, next_vertex
let c=r,i=s;for(;;){
// even though vertices_vertices are sorted counter-clockwise,
// to make a counter-clockwise wound face, when we visit a vertex's
// vertices_vertices array we have to select the [n-1] vertex, not [n+1],
// it's a little counter-intuitive.
const r=e[i],s=(r.indexOf(c)+r.length-1)%r.length,l=r[s],d=`${i} ${l}`;
// check if this edge was already walked 2 ways:
// 1. if we visited this edge while making this face, we are done.
if(n[d])return Object.assign(o,n),a.vertices.pop(),a;
// 2. if we visited this edge (with vertices in the same sequence),
// because of the counterclockwise winding, we are looking at a face
// that has already been built.
if(n[d]=!0,o[d])return;a.vertices.push(i),a.edges.push(d),t&&a.angles.push(t[i][s]),c=i,i=l}},planarVertexWalk=({vertices_vertices:e,vertices_sectors:t})=>{const r={vertices_vertices:e,vertices_sectors:t},s={};return e.map(((e,t)=>e.map((e=>counterClockwiseWalk(r,t,e,s))).filter((e=>void 0!==e)))).flat()},filterWalkedBoundaryFace=e=>e.filter((e=>e.angles.map((e=>Math.PI-e)).reduce(((e,t)=>e+t),0)>0));
/**
	 * @description Given a planar graph, discover all faces by counter-clockwise walking
	 * by starting at every edge.
	 * @param {FOLD} graph a FOLD graph
	 * @returns {object[]} an array of face objects, where each face has number arrays,
	 * "vertices", "edges", and "angles". vertices and edges are indices, angles are radians.
	 * @linkcode Origami ./src/graph/walk.js 67
	 */var fe=Object.freeze({__proto__:null,counterClockwiseWalk:counterClockwiseWalk,planarVertexWalk:planarVertexWalk,filterWalkedBoundaryFace:filterWalkedBoundaryFace});
/* Math (c) Kraft, MIT License */
/**
	 * Math (c) Kraft
	 */
/**
	 * @description Given a single object against which to compare,
	 * iterate through an array of the same type and run a custom
	 * comparison function which abides by this format:
	 * (a:any, b:any) => number. The element in the array which returns
	 * the smallest value, its index will be returned.
	 * @param {any} obj the single item to test against the set
	 * @param {any[]} array the set of items to test against
	 * @param {function} compare_func a function which takes two items (which match
	 * the type of the first parameter), execution of this function should return a scalar.
	 * @returns {number[]} the index from the set which minimizes the compare function
	 * @linkcode Math ./src/algebra/nearest.js 29
	 */const smallestComparisonSearch=(e,t,r)=>{const s=e.map(((e,s)=>({i:s,d:r(t,e)})));let o,n=1/0;for(let e=0;e<s.length;e+=1)s[e].d<n&&(o=e,n=s[e].d);return o},minimum2DPointIndex=(e,t=I)=>{
// export const minimumPointIndex = (points, epsilon = EPSILON) => {
if(!e.length)return;
// find the set of all points that share the smallest X value
// const smallSet = minimumXIndices(points, epsilonCompare, epsilon);
const r=((e,t=0,r=epsilonCompare,s=I)=>{
// find the set of all vectors that share the smallest X value within an epsilon
let o=[0];for(let n=1;n<e.length;n+=1)switch(r(e[n][t],e[o[0]][t],s)){case 0:o.push(n);break;case 1:o=[n]}return o})(e,0,epsilonCompare,t);
// from this set, find the point with the smallest Y value
let s=0;for(let t=1;t<r.length;t+=1)e[r[t]][1]<e[r[s]][1]&&(s=t);return r[s];
// idea to make this N-dimensional. requires back-mapping indices
// through all the subsets returned by smallestVectorSearch
// const dimensions = points[0].length;
// let set = points.map((_, i) => i);
// const levelMap = [];
// for (let d = 0; d < dimensions; d += 1) {
// 	const indices = levelMap[0].map((_, i) => i);
// 	levelMap.forEach(map => indices.forEach((s, i) => { indices[i] = map[s]; }));
// 	set = smallestVectorSearch(indices.map(i => points[i]), d, epsilonCompare, epsilon);
// 	levelMap.push(set);
// }
// console.log("levelMap", levelMap);
// oh no. the indices don't carry over each round
// we have to back map the indices from levelMap.
};
/**
	 * @description Find the indices from an array of vectors which all have
	 * the smallest value within an epsilon.
	 * @param {number[][]} vectors array of vectors
	 * @returns {number[]} array of indices which all have the lowest X value.
	 * @linkcode Math ./src/algebra/nearest.js 48
	 */var de=Object.freeze({__proto__:null,minimum2DPointIndex:minimum2DPointIndex,smallestComparisonSearch:smallestComparisonSearch});
/* Math (c) Kraft, MIT License */
/**
	 * Math (c) Kraft
	 */
/**
	 * @description Provide a comparison function and use it to sort an array
	 * of any type of object against a single item. The returned array will be
	 * the indices of the original array in sorted order.
	 * @param {any[]} array an array of elements to be sorted
	 * @param {any} item the item which to compare against all array elements
	 * @param {function} compareFn the comparison function to be run against
	 * every element in the array with the input item parameter, placing
	 * the array element first, the input item second: fn(arrayElem, paramItem)
	 * @returns {number[]} the indices of the original array, in sorted order
	 * @linkcode
	 */const sortAgainstItem=(e,t,r)=>e.map(((e,s)=>({i:s,n:r(e,t)}))).sort(((e,t)=>e.n-t.n)).map((e=>e.i))
/**
	 * @description Sort an array of n-dimensional points along an
	 * n-dimensional vector, get the indices in sorted order.
	 * @param {number[][]} points array of points (which are arrays of numbers)
	 * @param {number[]} vector one vector
	 * @returns {number[]} a list of sorted indices to the points array.
	 * @linkcode Math ./src/algebra/sort.js 18
	 */,sortPointsAlongVector=(e,t)=>sortAgainstItem(e,t,dot)
/**
	 * @description given an array of already-sorted values (so that
	 * comparisons only need to happen between neighboring items),
	 * cluster the numbers which are similar within an epsilon.
	 * Isolated values still get put in length-1 arrays. (all values returned)
	 * and the clusters contain the indices from the param array, not the values.
	 * @param {numbers[]} an array of sorted numbers
	 * @param {numbers} [epsilon=1e-6] an optional epsilon
	 * @returns {numbers[][]} an array of arrays, each inner array containin indices.
	 * each inner array represents clusters of values which lie within an epsilon.
	 * @linkcode Math ./src/algebra/sort.js 33
	 */,clusterIndicesOfSortedNumbers=(e,t=I)=>{const r=[[0]];let s=0;for(let o=1;o<e.length;o+=1)
// if this scalar fits inside the current cluster
epsilonEqual(e[o],e[o-1],t)?r[s].push(o):(s=r.length,r.push([o]));return r},radialSortPointIndices2=(e=[],t=I)=>{const r=minimum2DPointIndex(e,t),s=e.map((t=>subtract2(t,e[r]))).map((e=>normalize2(e))).map((e=>dot2([0,1],e))),o=s.map(((e,t)=>({a:e,i:t}))).sort(((e,t)=>e.a-t.a)).map((e=>e.i)).filter((e=>e!==r));return[[r]].concat(clusterIndicesOfSortedNumbers(o.map((e=>s[e])),t).map((e=>e.map((e=>o[e])))).map((t=>1===t.length?t:t.map((t=>({i:t,len:distance2(e[t],e[r])}))).sort(((e,t)=>e.len-t.len)).map((e=>e.i)))))};var me=Object.freeze({__proto__:null,clusterIndicesOfSortedNumbers:clusterIndicesOfSortedNumbers,radialSortPointIndices2:radialSortPointIndices2,sortAgainstItem:sortAgainstItem,sortPointsAlongVector:sortPointsAlongVector});
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * @description This is a subroutine for building vertices_vertices. This will
	 * take a set of vertices indices and a vertex index to be the center point, and
	 * sort the indices radially counter-clockwise.
	 * @param {FOLD} graph a FOLD object
	 * @param {number[]} vertices an array of vertex indices to be sorted
	 * @param {number} vertex the origin vertex, around which the vertices will be sorted
	 * @returns {number[]} indices of vertices, in sorted order
	 * @linkcode Origami ./src/graph/sort.js 13
	 */const sortVerticesCounterClockwise=({vertices_coords:e},t,r)=>t.map((t=>e[t])).map((t=>subtract(t,e[r]))).map((e=>Math.atan2(e[1],e[0])
// optional line, this makes the cycle loop start/end along the +X axis
)).map((e=>e>-I?e:e+2*Math.PI)).map(((e,t)=>({a:e,i:t}))).sort(((e,t)=>e.a-t.a)).map((e=>e.i)).map((e=>t[e]))
/**
	 * @description sort a subset of vertices from a graph along a vector.
	 * eg: given the vector [1,0], points according to their X value.
	 * @param {FOLD} graph a FOLD object
	 * @param {number[]} vertices the indices of vertices to be sorted
	 * @param {number[]} vector a vector along which to sort vertices
	 * @returns {number[]} indices of vertices, in sorted order
	 * @linkcode Origami ./src/graph/sort.js 34
	 */
// export const sortVerticesAlongVector = ({ vertices_coords }, vertices, vector) => (
// 	vertices
// 		.map(i => ({ i, d: dot(vertices_coords[i], vector) }))
// 		.sort((a, b) => a.d - b.d)
// 		.map(a => a.i)
// );
,sortVerticesAlongVector=({vertices_coords:e},t,r)=>sortPointsAlongVector(t.map((t=>e[t])),r).map((e=>t[e]));var ge=Object.freeze({__proto__:null,sortVerticesCounterClockwise:sortVerticesCounterClockwise,sortVerticesAlongVector:sortVerticesAlongVector});
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 *
	 */const makeFacesNormal=({vertices_coords:e,faces_vertices:t})=>t.map((t=>t.map((t=>e[t])))).map((e=>{
// cross product unit vectors from point 0 to point 1 and 2.
// as long as the face winding data is consistent, this gives consistent face normals
const t=resize(3,subtract(e[1],e[0])),r=resize(3,subtract(e[2],e[0]));return normalize3(cross3(t,r))}))
/**
	 *
	 */,makeVerticesNormal=({vertices_coords:e,faces_vertices:t,faces_normal:r})=>{r||(r=makeFacesNormal({vertices_coords:e,faces_vertices:t}));const s=e.map((()=>[0,0,0]));return t.forEach(((e,t)=>e.forEach((e=>{return o=s[e],n=r[t],o[0]+=n[0],o[1]+=n[1],void(o[2]+=n[2]);var o,n})))),s.map((e=>normalize3(e)))};var pe=Object.freeze({__proto__:null,makeFacesNormal:makeFacesNormal,makeVerticesNormal:makeVerticesNormal});
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * This is one big file (sorry) which contains methods to create all the
	 * geometry arrays in the FOLD spec, like "vertices_vertices", "faces_edges"..
	 *
	 * They are all named in camelCase (not snake), following the format:
	 * "make" + the FOLD array name + any clarifying comments such as
	 * "2D" or "from___" describing where the data is pulled from.
	 *
	 * all of the parameters required for each method follow a similar format:
	 * the first argument is a FOLD graph. and the graph remains unmodified.
	 * the method returns the data array.
	 *
	 * if you want to modify the input graph, assign the property after making it
	 *  var graph = {...};
	 *  graph.faces_faces = makeFacesFaces(graph);
	 */
/**
	 *
	 *    VERTICES
	 *
	 */
/**
	 * @description Make `vertices_edges` from `edges_vertices`, unsorted, which should
	 * be used sparingly. Prefer makeVerticesEdges().
	 * @param {FOLD} graph a FOLD object, containing edges_vertices
	 * @returns {number[][]} array of array of numbers, where each row corresponds to a
	 * vertex index and the values in the inner array are edge indices.
	 * @linkcode Origami ./src/graph/make.js 40
	 */const makeVerticesEdgesUnsorted=({edges_vertices:e})=>{const t=[];
// iterate over edges_vertices and swap the index for each of the contents
// each edge (index 0: [3, 4]) will be converted into (index 3: [0], index 4: [0])
// repeat. append to each array.
return e.forEach(((e,r)=>e.forEach((e=>{void 0===t[e]&&(t[e]=[]),t[e].push(r)})))),t},makeVerticesEdges=({edges_vertices:e,vertices_vertices:t})=>{const r=makeVerticesToEdgeBidirectional({edges_vertices:e});return t.map(((e,t)=>e.map((e=>r[`${t} ${e}`]))))},makeVerticesVertices2D=({vertices_coords:e,vertices_edges:t,edges_vertices:r})=>{t||(t=makeVerticesEdgesUnsorted({edges_vertices:r}));
// use adjacent edges to find adjacent vertices
const s=t.map(((e,t)=>e.map((e=>r[e].filter((e=>e!==t)))).reduce(((e,t)=>e.concat(t)),[])));return void 0===e?s:s.map(((t,r)=>sortVerticesCounterClockwise({vertices_coords:e},t,r)))},makeVerticesVerticesFromFaces=({vertices_coords:e,vertices_faces:t,faces_vertices:r})=>{t||(t=makeVerticesFacesUnsorted({vertices_coords:e,faces_vertices:r}));
// every iterate through every vertices_faces's faces_vertices
const s=t.map((e=>e.map((e=>r[e])))),o=s.map(((e,t)=>e.map((e=>e.indexOf(t)))));
// for every vertex, find its index in its faces_vertices array.
// using the data from above, walk around the vertex by starting with an
// edge, an edge represented as a pair of vertices, and alternate:
// 1. using the vertex-pair's adjacent face to get the other pair in
//    the same face, and,
// 2. swapping the vertices in the string ("141 7" becomes "7 141") to
//    find jump to another face, this being the adjacent face in the walk.
// care needs to be taken because this vertex may be adjacent to holes.
// a solution is possible if there are up to two holes, but a vertex
// with more than two holes is technically unsolvable.
return s.map(((e,t)=>e.map(((e,r)=>[(o[t][r]+e.length-1)%e.length,o[t][r],(o[t][r]+1)%e.length])))).map(((e,t)=>e.map(((e,r)=>e.map((e=>s[t][r][e])))))).map((e=>{
// facesVerts matches the order in this vertex's faces_vertices array.
// it contains vertex pair keys ([141, 7, 34] becomes ["141 7", "7 34"])
// which represent this face's adjacent vertices to our vertex
// coming to and from this vertex.
const t=e.map((e=>[[0,1],[1,2]].map((t=>t.map((t=>e[t])).join(" "))))),r={},s={};return t.forEach(((e,t)=>{r[e[0]]=t,s[e[1]]=t})),{facesVerts:t,to:s,from:r}})).map((e=>{
// locate any holes if they exist, holes are when the inverse of
// a "to" key does not exist in the "from" lookup, or visa versa.
const t=Object.keys(e.to),r=t.map((e=>e.split(" ").reverse().join(" "))),s=t.filter(((t,s)=>!(r[s]in e.from)));
// console.log("holeKeys", holeKeys);
if(s.length>2)return console.warn("vertices_vertices found an unsolvable vertex"),[];
// the start keys will be either each hole key, or just pick a key
// if no holes exist
const o=s.length?s:[t[0]],n=[],a={};
// vertex_vertices is each vertex's vertices_vertices
for(let t=0;t<o.length;t+=1){const r=o[t],s=[r];a[r]=!0;let c=!1;do{const t=s[s.length-1],r=e.to[t];
// this indicates the end of a walk which ended at a hole
if(!(r in e.facesVerts))break;let o;if(e.facesVerts[r][0]===t&&(o=e.facesVerts[r][1]),e.facesVerts[r][1]===t&&(o=e.facesVerts[r][0]),void 0===o)return"not found";const n=o.split(" ").reverse().join(" ");s.push(o),
// this indicates the end of a walk which completed a cycle
c=n in a,c||s.push(n),
// update the visited dictionary
a[o]=!0,a[n]=!0}while(!c);
// walk now contains keys like "4 0", "1 4", "4 1", "2 4", "4 2",
// mod 2 so that every edge is represented only once, which
// still works with odd numbers since we start at a hole, and get the
// one vertex which isn't our vertex. now we have our vertices_vertices
const i=s.filter(((e,t)=>t%2==0)).map((e=>e.split(" ")[1])).map((e=>parseInt(e,10)));n.push(...i)}return n}))},makeVerticesVertices=e=>e.vertices_coords&&e.vertices_coords.length?3===e.vertices_coords[0].length?makeVerticesVerticesFromFaces(e):makeVerticesVertices2D(e):[],makeVerticesVerticesUnsorted=({vertices_edges:e,edges_vertices:t})=>(e||(e=makeVerticesEdgesUnsorted({edges_vertices:t})),e.map(((e,r)=>e.flatMap((e=>t[e].filter((e=>e!==r))))))),makeVerticesFacesUnsorted=({vertices_coords:e,faces_vertices:t})=>{if(!t)return e.map((()=>[]));
// instead of initializing the array ahead of time (we would need to know
// the length of something like vertices_coords)
const r=void 0!==e?e.map((()=>[])):Array.from(Array(countImplied.vertices({faces_vertices:t}))).map((()=>[]));
// iterate over every face, then iterate over each of the face's vertices
return t.forEach(((e,t)=>{
// in the case that one face visits the same vertex multiple times,
// this hash acts as an intermediary, basically functioning like a set,
// and only allow one occurence of each vertex index.
const s=[];e.forEach((e=>{s[e]=t})),s.forEach(((e,t)=>r[t].push(e)))})),r},makeVerticesFaces=({vertices_coords:e,vertices_vertices:t,faces_vertices:r})=>{if(!r)return e.map((()=>[]));if(!t)return makeVerticesFacesUnsorted({vertices_coords:e,faces_vertices:r});const s=makeVerticesToFace({faces_vertices:r});return t.map(((e,t)=>e.map(((e,r,s)=>[s[(r+1)%s.length],t,e].join(" "))))).map((e=>e.map((e=>s[e]))));
// .filter(a => a !== undefined) // removed. read below.
},makeVerticesToEdgeBidirectional=({edges_vertices:e})=>{const t={};return e.map((e=>e.join(" "))).forEach(((e,r)=>{t[e]=r})),e.map((e=>`${e[1]} ${e[0]}`)).forEach(((e,r)=>{t[e]=r})),t},makeVerticesToEdge=({edges_vertices:e})=>{const t={};return e.map((e=>e.join(" "))).forEach(((e,r)=>{t[e]=r})),t},makeVerticesToFace=({faces_vertices:e})=>{const t={};return e.forEach(((e,r)=>e.map(((t,r)=>[0,1,2].map((t=>(r+t)%e.length)).map((t=>e[t])).join(" "))).forEach((e=>{t[e]=r})))),t},makeVerticesVerticesVector=({vertices_coords:e,vertices_vertices:t,edges_vertices:r,edges_vector:s})=>{s||(s=makeEdgesVector({vertices_coords:e,edges_vertices:r}));const o=makeVerticesToEdge({edges_vertices:r});return t.map(((e,r)=>t[r].map((e=>{const t=o[`${r} ${e}`],n=o[`${e} ${r}`];return void 0!==t?s[t]:void 0!==n?flip(s[n]):void 0}))))},makeVerticesSectors=({vertices_coords:e,vertices_vertices:t,edges_vertices:r,edges_vector:s})=>makeVerticesVerticesVector({vertices_coords:e,vertices_vertices:t,edges_vertices:r,edges_vector:s}).map((e=>1===e.length?[D]:counterClockwiseSectors2(e)))
/**
	 *
	 *    EDGES
	 *
	 */
/**
	 * @description Make `edges_edges` containing all vertex-adjacent edges.
	 * This will be radially sorted if you call makeVerticesEdges before calling this.
	 * @param {FOLD} graph a FOLD object, with entries edges_vertices, vertices_edges
	 * @returns {number[][]} each entry relates to an edge, each array contains indices
	 * of other edges.
	 * @linkcode Origami ./src/graph/make.js 425
	 */,makeEdgesFacesUnsorted=({edges_vertices:e,faces_edges:t})=>{
// instead of initializing the array ahead of time (we would need to know
// the length of something like edges_vertices)
const r=void 0!==e?e.map((()=>[])):Array.from(Array(countImplied.edges({faces_edges:t}))).map((()=>[]));
// todo: does not arrange counter-clockwise
return t.forEach(((e,t)=>{const s=[];
// in the case that one face visits the same edge multiple times,
// this hash acts as a set allowing one occurence of each edge index.
e.forEach((e=>{s[e]=t})),s.forEach(((e,t)=>r[t].push(e)))})),r},makeEdgesFaces=({vertices_coords:e,edges_vertices:t,edges_vector:r,faces_vertices:s,faces_edges:o,faces_center:n})=>{if(!t||!s&&!o)
// alert, we just made UNSORTED edges faces
return makeEdgesFacesUnsorted({faces_edges:o});s||(s=makeFacesVerticesFromEdges({edges_vertices:t,faces_edges:o})),o||(o=makeFacesEdgesFromVertices({edges_vertices:t,faces_vertices:s})),r||(r=makeEdgesVector({vertices_coords:e,edges_vertices:t}));const a=t.map((t=>e[t[0]]));n||(n=makeFacesConvexCenter({vertices_coords:e,faces_vertices:s}));const c=t.map((()=>[]));return o.forEach(((e,t)=>{const r=[];
// in the case that one face visits the same edge multiple times,
// this hash acts as a set allowing one occurence of each edge index.
e.forEach((e=>{r[e]=t})),r.forEach(((e,t)=>c[t].push(e)))})),
// sort edges_faces in 2D based on which side of the edge's vector
// each face lies, sorting the face on the left first. see FOLD spec.
c.forEach(((e,t)=>{const s=e.map((e=>n[e])).map((e=>subtract2(e,a[t]))).map((e=>cross2(e,r[t])));e.sort(((e,t)=>s[e]-s[t]))})),c},ve={M:-180,m:-180,V:180,v:180},makeEdgesAssignmentSimple=({edges_foldAngle:e})=>e.map((e=>0===e?"F":e<0?"M":"V"))
/**
	 * @description Convert edges fold angle into assignment for every edge. This method
	 * will assign "M" "V" "F" and "B" for edges with only one incident face.
	 * @param {FOLD} graph a FOLD object, with edges_foldAngle
	 * @returns {string[]} array of fold assignments
	 * @linkcode Origami ./src/graph/make.js 520
	 */,makeEdgesAssignment=({edges_vertices:e,edges_foldAngle:t,edges_faces:r,faces_vertices:s,faces_edges:o})=>(r||(o||(o=makeFacesEdgesFromVertices({edges_vertices:e,faces_vertices:s})),r=makeEdgesFacesUnsorted({edges_vertices:e,faces_edges:o})),t.map(((e,t)=>r[t].length<2?"B":0===e?"F":e<0?"M":"V"))),makeEdgesFoldAngle=({edges_assignment:e})=>e.map((e=>ve[e]||0))
// angle between two 3D vectors
// α = arccos[(xa * xb + ya * yb + za * zb) / (√(xa2 + ya2 + za2) * √(xb2 + yb2 + zb2))]
// angle between two 2D vectors
// α = arccos[(xa * xb + ya * yb) / (√(xa2 + ya2) * √(xb2 + yb2))]
/**
	 * @description Inspecting adjacent faces, and referencing their normals, infer
	 * the foldAngle for every edge. This will result in a negative number for
	 * mountain creases, and positive for valley. This works well for 3D models,
	 * but will fail for flat-folded models, in which case, edges_assignment
	 * will be consulted to differentiate between 180 degree M or V folds.
	 * @param {FOLD} graph a FOLD graph
	 * @returns {number[]} for every edge, an angle in degrees.
	 * @linkcode Origami ./src/graph/make.js 558
	 */,makeEdgesFoldAngleFromFaces=({vertices_coords:e,edges_vertices:t,edges_faces:r,edges_assignment:s,faces_vertices:o,faces_edges:n,faces_normal:a,faces_center:c})=>(r||(n||(n=makeFacesEdgesFromVertices({edges_vertices:t,faces_vertices:o})),r=makeEdgesFacesUnsorted({edges_vertices:t,faces_edges:n})),a||(a=makeFacesNormal({vertices_coords:e,faces_vertices:o})),c||(c=makeFacesConvexCenter({vertices_coords:e,faces_vertices:o})),r.map(((e,t)=>{if(e.length>2)throw new Error(O);if(e.length<2)return 0;const r=a[e[0]],o=a[e[1]],n=normalize(subtract(c[e[1]],c[e[0]]));
// for mountain creases (faces facing away from each other), set the sign to negative.
let i=Math.sign(dot(r,n));
// if the sign is zero, the faces are coplanar, it's impossible to tell if
// this was because of a mountain or a valley fold.
if(0===i){if(!s||!s[t])throw new Error(P);"F"!==s[t]&&"F"!==s[t]||(i=0),"M"!==s[t]&&"m"!==s[t]||(i=-1),"V"!==s[t]&&"v"!==s[t]||(i=1)}return Math.acos(dot(r,o))*(180/Math.PI)*i}))),makeEdgesCoords=({vertices_coords:e,edges_vertices:t})=>t.map((t=>t.map((t=>e[t]))))
/**
	 * @description Turn every edge into a vector, basing the direction on the order of
	 * the pair of vertices in each edges_vertices entry.
	 * @param {FOLD} graph a FOLD graph, with vertices_coords, edges_vertices
	 * @returns {number[][]} each entry relates to an edge, each array contains a 2D vector
	 * @linkcode Origami ./src/graph/make.js 625
	 */,makeEdgesVector=({vertices_coords:e,edges_vertices:t})=>makeEdgesCoords({vertices_coords:e,edges_vertices:t}).map((e=>subtract(e[1],e[0])))
/**
	 * @description For every edge, find the length between the edges pair of vertices.
	 * @param {FOLD} graph a FOLD graph, with vertices_coords, edges_vertices
	 * @returns {number[]} the distance between each edge's pair of vertices
	 * @linkcode Origami ./src/graph/make.js 634
	 */,makeEdgesLength=({vertices_coords:e,edges_vertices:t})=>makeEdgesVector({vertices_coords:e,edges_vertices:t}).map((e=>magnitude(e)))
/**
	 * @description Make an array of axis-aligned bounding boxes, one for each edge,
	 * that encloses the edge, and will work in n-dimensions. Intended for
	 * fast line-sweep algorithms.
	 * @param {FOLD} graph a FOLD graph with vertices and edges.
	 * @returns {object[]} an array of boxes, length matching the number of edges
	 * @linkcode Origami ./src/graph/make.js 645
	 */,makeEdgesBoundingBox=({vertices_coords:e,edges_vertices:t,edges_coords:r},s=0)=>(r||(r=makeEdgesCoords({vertices_coords:e,edges_vertices:t})),r.map((e=>boundingBox$1(e,s)))),makePlanarFaces=({vertices_coords:e,vertices_vertices:t,vertices_edges:r,vertices_sectors:s,edges_vertices:o,edges_vector:n})=>{t||(t=makeVerticesVertices({vertices_coords:e,edges_vertices:o,vertices_edges:r})),s||(s=makeVerticesSectors({vertices_coords:e,vertices_vertices:t,edges_vertices:o,edges_vector:n}));const a=makeVerticesToEdgeBidirectional({edges_vertices:o});
// removes the one face that outlines the piece with opposite winding.
// planarVertexWalk stores edges as vertex pair strings, "4 9",
// convert these into edge indices
return filterWalkedBoundaryFace(planarVertexWalk({vertices_vertices:t,vertices_sectors:s})).map((e=>({...e,edges:e.edges.map((e=>a[e]))})))},makeFacesVerticesFromEdges=({edges_vertices:e,faces_edges:t})=>t.map((t=>t.map((t=>e[t])).map(((e,t,r)=>{const s=r[(t+1)%r.length];return e[0]===s[0]||e[0]===s[1]?e[1]:e[0]}))))
/**
	 * @description Make `faces_edges` from `faces_vertices`.
	 * @param {FOLD} graph a FOLD graph, with
	 * edges_vertices and faces_vertices
	 * @returns {number[][]} a `faces_edges` array
	 * @linkcode Origami ./src/graph/make.js 727
	 */,makeFacesEdgesFromVertices=({edges_vertices:e,faces_vertices:t})=>{const r=makeVerticesToEdgeBidirectional({edges_vertices:e});return t.map((e=>e.map(((e,t,r)=>[e,r[(t+1)%r.length]].join(" "))))).map((e=>e.map((e=>r[e]))))},makeFacesFaces=({faces_vertices:e})=>{const t=e.map((()=>[])),r={};return e.forEach(((e,t)=>e.forEach(((s,o,n)=>{let a=n[(o+1)%e.length];a<s&&([s,a]=[a,s]);const c=`${s} ${a}`;void 0===r[c]&&(r[c]={}),r[c][t]=!0})))),Object.values(r).map((e=>Object.keys(e))).filter((e=>e.length>1)).forEach((e=>{t[e[0]].push(parseInt(e[1],10)),t[e[1]].push(parseInt(e[0],10))})),t},makeFacesPolygon=({vertices_coords:e,faces_vertices:t},r)=>t.map((t=>t.map((t=>e[t])))).map((e=>makePolygonNonCollinear(e,r)))
/**
	 * @description map vertices_coords onto each face's set of vertices,
	 * turning each face into an array of points. "Quick" meaning collinear vertices are
	 * not removed, which in some cases, this will be the preferred method.
	 * @param {FOLD} graph a FOLD graph, with vertices_coords, faces_vertices
	 * @returns {number[][][]} array of array of points, where each point is an array of numbers
	 * @linkcode Origami ./src/graph/make.js 807
	 */,makeFacesConvexCenter=({vertices_coords:e,faces_vertices:t})=>t.map((t=>t.map((t=>e[t])).reduce(((e,t)=>add(e,t)),Array(e[0].length).fill(0)).map((e=>e/t.length))));
/**
	 * @description Make `vertices_edges` sorted, so that the edges are sorted
	 * radially around the vertex, corresponding with the order in `vertices_vertices`.
	 * @param {FOLD} graph a FOLD object, containing edges_vertices, vertices_vertices
	 * @returns {number[][]} array of array of numbers, where each row corresponds to a
	 * vertex index and the values in the inner array are edge indices.
	 * @linkcode Origami ./src/graph/make.js 62
	 */var ue=Object.freeze({__proto__:null,makeVerticesEdgesUnsorted:makeVerticesEdgesUnsorted,makeVerticesEdges:makeVerticesEdges,makeVerticesVertices2D:makeVerticesVertices2D,makeVerticesVerticesFromFaces:makeVerticesVerticesFromFaces,makeVerticesVertices:makeVerticesVertices,makeVerticesVerticesUnsorted:makeVerticesVerticesUnsorted,makeVerticesFacesUnsorted:makeVerticesFacesUnsorted,makeVerticesFaces:makeVerticesFaces,makeVerticesToEdgeBidirectional:makeVerticesToEdgeBidirectional,makeVerticesToEdge:makeVerticesToEdge,makeVerticesToFace:makeVerticesToFace,makeVerticesVerticesVector:makeVerticesVerticesVector,makeVerticesSectors:makeVerticesSectors,makeEdgesEdges:({edges_vertices:e,vertices_edges:t})=>e.map(((e,r)=>{const s=t[e[0]].filter((e=>e!==r)),o=t[e[1]].filter((e=>e!==r));return s.concat(o)}))
/**
	 * @description Make `edges_faces` where each edge is paired with its incident faces.
	 * This is unsorted, prefer makeEdgesFaces()
	 * @param {FOLD} graph a FOLD object, with entries edges_vertices, faces_edges
	 * @returns {number[][]} each entry relates to an edge, each array contains indices
	 * of adjacent faces.
	 * @linkcode Origami ./src/graph/make.js 439
	 */,makeEdgesFacesUnsorted:makeEdgesFacesUnsorted,makeEdgesFaces:makeEdgesFaces,makeEdgesAssignmentSimple:makeEdgesAssignmentSimple,makeEdgesAssignment:makeEdgesAssignment,makeEdgesFoldAngle:makeEdgesFoldAngle,makeEdgesFoldAngleFromFaces:makeEdgesFoldAngleFromFaces,makeEdgesCoords:makeEdgesCoords,makeEdgesVector:makeEdgesVector,makeEdgesLength:makeEdgesLength,makeEdgesBoundingBox:makeEdgesBoundingBox,makePlanarFaces:makePlanarFaces,makeFacesVerticesFromEdges:makeFacesVerticesFromEdges,makeFacesEdgesFromVertices:makeFacesEdgesFromVertices,makeFacesFaces:makeFacesFaces,makeFacesPolygon:makeFacesPolygon,makeFacesPolygonQuick:({vertices_coords:e,faces_vertices:t})=>t.map((t=>t.map((t=>e[t]))))
/**
	 * @description For every face, get the face's centroid.
	 * @param {FOLD} graph a FOLD graph, with vertices_coords, faces_vertices
	 * @returns {number[][]} array of points, where each point is an array of numbers
	 * @linkcode Origami ./src/graph/make.js 815
	 */,makeFacesCenter2D:({vertices_coords:e,faces_vertices:t})=>t.map((t=>t.map((t=>e[t])))).map((e=>centroid(e)))
/**
	 * @description This uses point average, not centroid, faces must
	 * be convex, and again it's not precise, but in many use cases
	 * this is often more than sufficient.
	 * @param {FOLD} graph a FOLD graph, with vertices_coords, faces_vertices
	 * @returns {number[][]} array of points, where each point is an array of numbers
	 * @linkcode Origami ./src/graph/make.js 826
	 */,makeFacesConvexCenter:makeFacesConvexCenter});
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * @description Get the indices of all circular edges. Circular edges are
	 * edges where both of its edges_vertices is the same vertex.
	 * @param {FOLD} graph a FOLD graph
	 * @returns {number[]} array of indices of circular edges. empty if none.
	 * @linkcode Origami ./src/graph/edgesViolations.js 21
	 */const circularEdges=({edges_vertices:e})=>{if(!e)return[];const t=[];for(let r=0;r<e.length;r+=1)e[r][0]===e[r][1]&&t.push(r);return t},duplicateEdges=({edges_vertices:e})=>{if(!e)return[];const t=[],r={};for(let s=0;s<e.length;s+=1){
// we need to store both, but only need to test one
const o=`${e[s][0]} ${e[s][1]}`,n=`${e[s][1]} ${e[s][0]}`;void 0!==r[o]?// instead of (map[a] || map[b])
t[s]=r[o]:(
// only update the map. if an edge exists as two vertices, it will only
// be set once, this prevents chains of duplicate relationships where
// A points to B points to C points to D...
r[o]=s,r[n]=s)}return t},removeCircularEdges=(e,t)=>(t||(t=circularEdges(e)),t.length&&
// remove every instance of a circular edge in every _edge array.
// assumption is we can simply remove them because a face that includes
// a circular edge is still the same face when you just remove the edge
((e,t,r)=>{const s={};r.forEach((e=>{s[e]=!0})),filterKeysWithSuffix(e,t).forEach((t=>e[t].forEach(((r,o)=>{// faces_edges[0], faces_edges[1], ...
// reverse iterate through array, remove elements with splice
for(let n=r.length-1;n>=0;n-=1)!0===s[r[n]]&&e[t][o].splice(n,1)}))))})(e,n,t),{map:removeGeometryIndices(e,n,t),remove:t}),removeDuplicateEdges=(e,t)=>{
// index: edge to remove, value: the edge which should replace it.
t||(t=duplicateEdges(e));const r=Object.keys(t).map((e=>parseInt(e,10))),s=replaceGeometryIndices(e,n,t);
// if edges were removed, we need to rebuild vertices_edges and then
// vertices_vertices since that was built from vertices_edges, and then
// vertices_faces since that was built from vertices_vertices.
return r.length&&(e.vertices_edges||e.vertices_vertices||e.vertices_faces)&&(e.vertices_edges=makeVerticesEdgesUnsorted(e),e.vertices_vertices=makeVerticesVertices(e),e.vertices_edges=makeVerticesEdges(e),e.vertices_faces=makeVerticesFaces(e)),{map:s,remove:r}};
/**
	 * @description Get the indices of all duplicate edges by marking the
	 * second/third/... as duplicate (not the first of the duplicates).
	 * The result is given as an array with holes, where:
	 * - the indices are the indices of the duplicate edges.
	 * - the values are the indices of the first occurence of the duplicate.
	 * Under this system, many edges can be duplicates of the same edge.
	 * Order is not important. [5,9] and [9,5] are still duplicate.
	 * @param {FOLD} graph a FOLD object
	 * @returns {number[]} an array where the redundant edges are the indices,
	 * and the values are the indices of the first occurence of the duplicate.
	 * @example
	 * {number[]} array, [4:3, 7:5, 8:3, 12:3, 14:9] where indices
	 * (3, 4, 8, 12) are all duplicates. (5,7), (9,14) are also duplicates.
	 * @linkcode Origami ./src/graph/edgesViolations.js 47
	 */var he=Object.freeze({__proto__:null,circularEdges:circularEdges,duplicateEdges:duplicateEdges,removeCircularEdges:removeCircularEdges,removeDuplicateEdges:removeDuplicateEdges});
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * @description Provide two or more simple nextmaps in the order they were made
	 * and this will merge them into one nextmap which reflects all changes to the graph.
	 * @param {...number[]} ...maps a sequence of simple nextmaps
	 * @returns {number[]} one nextmap reflecting the sum of changes
	 * @linkcode Origami ./src/graph/maps.js 10
	 */const mergeSimpleNextmaps=(...e)=>{if(0===e.length)return[];const t=e[0].map(((e,t)=>t));return e.forEach((e=>t.forEach(((r,s)=>{t[s]=e[r]})))),t},mergeNextmaps=(...e)=>{if(0===e.length)return[];const t=e[0].map(((e,t)=>[t]));return e.forEach((e=>{t.forEach(((r,s)=>r.forEach(((r,o)=>{t[s][o]=e[r]})))),t.forEach(((e,r)=>{t[r]=e.reduce(((e,t)=>e.concat(t)),[]).filter((e=>void 0!==e))}))})),t},mergeBackmaps=(...e)=>{if(0===e.length)return[];let r=e[0].reduce(((e,t)=>e.concat(t)),[]).map(((e,t)=>[t]));return e.forEach((e=>{const s=[];e.forEach(((e,o)=>{s[o]=typeof e===t?r[e]:e.map((e=>r[e])).reduce(((e,t)=>e.concat(t)),[])})),r=s})),r},invertMap=e=>{const r=[],setIndexValue=(e,s)=>{
// before we set the inverted map [i] spot, check if something is already there
void 0!==r[e]?
// if that thing is a number, turn it into an array
typeof r[e]===t?r[e]=[r[e],s]:
// already an array, add to it
r[e].push(s):r[e]=s};
// set inv[index] = value, but before we do, make sure that an array
// will be formed if there are multiple values at that index
// iterate through the argument array and flip the index/value
// in the new array so that the index is the value and visa versa.
return e.forEach(((e,r)=>{null!=e&&(typeof e===t&&setIndexValue(e,r),e.constructor===Array&&e.forEach((e=>setIndexValue(e,r))))})),r},invertSimpleMap=e=>{const t=[];return e.forEach(((e,r)=>{t[e]=r})),t};
/**
	 * @description Provide two or more nextmaps in the order they were made
	 * and this will merge them into one nextmap which reflects all changes to the graph.
	 * @param {...number[][]} ...maps a sequence of nextmaps
	 * @returns {number[][]} one nextmap reflecting the sum of changes
	 * @linkcode Origami ./src/graph/maps.js 23
	 */var _e=Object.freeze({__proto__:null,mergeSimpleNextmaps:mergeSimpleNextmaps,mergeNextmaps:mergeNextmaps,mergeSimpleBackmaps:(...e)=>{if(0===e.length)return[];let t=e[0].map(((e,t)=>t));return e.forEach((e=>{const r=e.map((e=>t[e]));t=r})),t},mergeBackmaps:mergeBackmaps,invertMap:invertMap,invertSimpleMap:invertSimpleMap});
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * @description clean will remove bad graph data. this includes:
	 * - duplicate (Euclidean distance) and isolated vertices
	 * - circular and duplicate edges.
	 * @param {FOLD} graph a FOLD object
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {object} summary of changes, a nextmap and the indices removed.
	 * @linkcode Origami ./src/graph/clean.js 24
	 */const clean=(e,t)=>{
// duplicate vertices has to be done first as it's possible that
// this will create circular/duplicate edges.
const r=removeDuplicateVertices(e,t),s=removeCircularEdges(e),o=removeDuplicateEdges(e),n=removeIsolatedVertices(e),a=invertSimpleMap(r.map),c=n.remove.map((e=>a[e])),i=invertSimpleMap(s.map),l=o.remove.map((e=>i[e]));return{vertices:{map:mergeSimpleNextmaps(r.map,n.map),remove:r.remove.concat(c)},edges:{map:mergeSimpleNextmaps(s.map,o.map),remove:s.remove.concat(l)}}},validate=(e,t)=>{const r=duplicateEdges(e),s=circularEdges(e),o=isolatedVertices(e),n=duplicateVertices(e,t),a=(e=>{const t=count.vertices(e),r=count.edges(e),s=count.faces(e);return{vertices:t>=countImplied.vertices(e),edges:r>=countImplied.edges(e),faces:s>=countImplied.faces(e)}})(e);return{summary:0===r.length&&0===s.length&&0===o.length&&a.vertices&&a.edges&&a.faces?"valid":"problematic",vertices:{isolated:o,duplicate:n,references:a.vertices},edges:{circular:s,duplicate:r,references:a.edges},faces:{references:a.faces}}},populate=(e,t)=>"object"!=typeof e?e:e.edges_vertices?(e.vertices_edges=makeVerticesEdgesUnsorted(e),e.vertices_vertices=makeVerticesVertices(e),e.vertices_edges=makeVerticesEdges(e),
// todo consider adding vertices_sectors, these are used for
// planar graphs (crease patterns) for walking faces
// todo, what is the reason to have edges_vector?
// if (graph.vertices_coords) {
//   graph.edges_vector = makeEdgesVector(graph);
// }
// make sure "edges_foldAngle" and "edges_assignment" are done.
(e=>{const t=e.edges_vertices.length;
// we know that edges_vertices exists
// complete the shorter array to match the longer one
if(e.edges_assignment||(e.edges_assignment=[]),e.edges_foldAngle||(e.edges_foldAngle=[]),e.edges_assignment.length>e.edges_foldAngle.length)for(let t=e.edges_foldAngle.length;t<e.edges_assignment.length;t+=1)e.edges_foldAngle[t]=edgeAssignmentToFoldAngle(e.edges_assignment[t]);if(e.edges_foldAngle.length>e.edges_assignment.length)for(let t=e.edges_assignment.length;t<e.edges_foldAngle.length;t+=1)e.edges_assignment[t]=edgeFoldAngleToAssignment(e.edges_foldAngle[t]);
// two arrays should be at the same length now. even if they are not complete
for(let r=e.edges_assignment.length;r<t;r+=1)e.edges_assignment[r]="U",e.edges_foldAngle[r]=0})(e),
// make sure "faces_vertices" and "faces_edges" are built.
((e,t)=>{
// build planar faces (no Z) if the user asks for it or if faces do not exist.
// todo: this is making a big assumption that the faces are even planar
// to begin with.
if(
// if faces_vertices does not exist, we need to build it.
// todo: if faces_edges exists but not vertices (unusual but possible),
// then build faces_vertices from faces_edges and call it done.
void 0!==t||e.faces_vertices||e.faces_edges||(t=!0),t&&e.vertices_coords){const t=makePlanarFaces(e);
// graph.faces_sectors = faces.map(face => face.angles);
return e.faces_vertices=t.map((e=>e.vertices)),void(e.faces_edges=t.map((e=>e.edges)))}
// if both faces exist, and no request to be rebuilt, exit.
e.faces_vertices&&e.faces_edges||(
// between the two: faces_vertices and faces_edges,
// if only one exists, build the other.
e.faces_vertices&&!e.faces_edges?e.faces_edges=makeFacesEdgesFromVertices(e):e.faces_edges&&!e.faces_vertices?e.faces_vertices=makeFacesVerticesFromEdges(e):(
// neither array exists, set placeholder empty arrays.
e.faces_vertices=[],e.faces_edges=[]))})(e,t),
// depending on the presence of vertices_vertices, this will
// run the simple algorithm (no radial sorting) or the proper one.
e.vertices_faces=makeVerticesFaces(e),e.edges_faces=makeEdgesFacesUnsorted(e),e.faces_faces=makeFacesFaces(e),e):e,collinearBetween=(e,t,r,s=!1,o=I)=>{if([e,r].map((e=>epsilonEqualVectors(t,e))).reduce(((e,t)=>e||t),!1))return s;const n=[[e,t],[t,r]].map((e=>subtract(e[1],e[0]))).map((e=>normalize(e)));return epsilonEqual(1,dot(...n),o)},pleat=(e,t,r,s=I)=>{const o=dot(e.vector,t.vector),n=cross2(e.vector,t.vector),a=cross2(subtract2(t.origin,e.origin),t.vector)/n,c=[e.vector,t.vector].map((e=>normalize(e))),i=(n>-s?[[e.vector,t.vector],[flip(t.vector),e.vector]]:[[t.vector,e.vector],[flip(e.vector),t.vector]]).map((e=>counterClockwiseSubsect2(e[0],e[1],r))),l=Math.abs(cross2(...c))<s,d=l?void 0:add2(e.origin,scale2(e.vector,a)),m=Array.from(Array(r-1)),g=l?m.map(((s,o)=>lerp(e.origin,t.origin,(o+1)/r))):m.map((()=>d)),p=i.map((e=>e.map(((e,t)=>({vector:e,origin:[...g[t]]})))));return l&&(p[o>-s?1:0]=[]),p},bisectLines2=(e,t,r=I)=>{const s=pleat(e,t,2,r).map((e=>e[0]));return s.forEach(((e,t)=>{void 0===e&&delete s[t]})),s};
/**
	 * Rabbit Ear (c) Kraft
	 */
// import getVerticesEdgesOverlap from "./vertices_edges_overlap";
/**
	 * @description iterate over all graph cross-references between vertices,
	 * edges, and faces, and, instead of checking if each index exists,
	 * (which would be nice), do the faster operation of simply checking
	 * if the largest reference is out of bounds of the component array length.
	 * @returns {boolean} true if all references are valid within bounds.
	 */var be=Object.freeze({__proto__:null,bisectLines2:bisectLines2,collinearBetween:collinearBetween,lerpLines:(e,t,r)=>({vector:lerp(e.vector,t.vector,r),origin:lerp(e.origin,t.origin,r)}),pleat:pleat});
/* Math (c) Kraft, MIT License */
/**
	 * Math (c) Kraft
	 */
/**
	 * @description check if a point lies collinear along a line, and specify if the
	 * line is a line/ray/segment and test whether the point lies within endpoint(s).
	 * @param {number[]} vector the vector component of the line
	 * @param {number[]} origin the origin component of the line
	 * @param {number[]} point one 2D point
	 * @parma {function} [lineDomain=excludeL] specify line/ray/segment and inclusive/exclusive
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {boolean} is the point collinear to the line, and in the case of ray/segment,
	 * does the point lie within the bounds of the ray/segment?
	 * @linkcode Math ./src/intersection/overlap-line-point.js 22
	 */const overlapLinePoint=({vector:e,origin:t},r,s=excludeL,o=I)=>{const n=subtract2(r,t),a=magSquared(e),c=Math.sqrt(a);
// the line is degenerate
if(c<o)return!1;const i=cross2(n,e.map((e=>e/c))),l=dot2(n,e)/a;return Math.abs(i)<o&&s(l,o/c)},overlapLineLine=(e,t,r=excludeL,s=excludeL,o=I)=>{const n=cross2(e.vector,t.vector),a=-n,c=subtract2(t.origin,e.origin),i=[-c[0],-c[1]];if(Math.abs(n)<o){// parallel
if(Math.abs(cross2(c,e.vector))>o)return!1;
// project each line's two endpoints onto the vector of the other line.
const n=i,a=add2(n,e.vector),l=c,d=add2(l,t.vector),m=dot2(e.vector,e.vector),g=dot2(e.vector,e.vector),p=dot2(n,t.vector)/g,v=dot2(a,t.vector)/g,u=dot2(l,e.vector)/m,h=dot2(d,e.vector)/m;
// use the supplied function parameters to allow line/ray/segment
// clamping and check if either point from either line is inside
// the other line's vector, and if the function (l/r/s) allows it
return r(u,o)||r(h,o)||s(p,o)||s(v,o)}const l=cross2(c,t.vector)/n,d=cross2(i,e.vector)/a;return r(l,o/magnitude2(e.vector))&&s(d,o/magnitude2(t.vector))},overlapConvexPolygonPoint=(e,t,r=exclude,s=I)=>e.map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>cross2(normalize2(subtract2(e[1],e[0])),subtract2(t,e[0])))).map((e=>r(e,s))).map(((e,t,r)=>e===r[0])).reduce(((e,t)=>e&&t),!0)
/**
	 * @description find out if two convex polygons are overlapping by searching
	 * for a dividing axis, which should be one side from one of the polygons.
	 * @param {number[][]} polygon in array of array form
	 * @param {number[][]} polygon in array of array form
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @linkcode Math ./src/intersection/overlap-polygons.js 13
	 */,overlapConvexPolygons=(e,t,r=I)=>{for(let s=0;s<2;s+=1){
// for non-overlapping convex polygons, it's possible that only only
// one edge on one polygon holds the property of being a dividing axis.
// we must run the algorithm on both polygons
const o=0===s?e:t,n=0===s?t:e;for(let e=0;e<o.length;e+=1){
// each edge of polygonA will become a line
const t=o[e],s=rotate90(subtract2(o[(e+1)%o.length],o[e])),a=n.map((e=>subtract2(e,t))).map((e=>dot2(s,e))),c=o[(e+2)%o.length],i=dot2(s,subtract2(c,t))>0;
// if true, we found a dividing axis
if(a.map((e=>i?e<r:e>-r)).reduce(((e,t)=>e&&t),!0))return!1}}return!0},overlapBoundingBoxes=(e,t,r=I)=>{const s=Math.min(e.min.length,t.min.length);for(let o=0;o<s;o+=1)
// if one minimum is above the other's maximum, or visa versa
if(e.min[o]>t.max[o]+r||e.max[o]<t.min[o]-r)return!1;return!0};
/**
	 * @description Test if two lines overlap each other, generalized
	 * and works for lines, rays, and segments.
	 * @param {RayLine} lineA a line as an object with "vector" and "origin"
	 * @param {RayLine} lineB a line as an object with "vector" and "origin"
	 * @param {function} aFn first line's boolean test normalized value lies collinear
	 * @param {function} bFn second line's boolean test normalized value lies collinear
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @linkcode Math ./src/intersection/overlap-line-line.js 21
	*/var ye=Object.freeze({__proto__:null,overlapBoundingBoxes:overlapBoundingBoxes,overlapCirclePoint:({radius:e,origin:t},r,s=exclude,o=I)=>s(e-distance2(t,r),o)
/**
	 * @description tests if a point is inside a convex polygon. Polygon is
	 * expected to be counter-clockwise winding.
	 * @param {number[]} point in array form
	 * @param {number[][]} polygon in array of array form
	 * @param {function} fn is the boundary of the polygon inclusive or exclusive
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {boolean} is the point inside the polygon?
	 * @linkcode Math ./src/intersection/overlap-polygon-point.js 23
	 */,overlapConvexPolygonPoint:overlapConvexPolygonPoint,overlapConvexPolygons:overlapConvexPolygons,overlapLineLine:overlapLineLine,overlapLinePoint:overlapLinePoint});
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * @description This returns a matrix relating every edge to every vertex,
	 * answering the question "does the vertex sit inside the edge's bounding box?"
	 * It doesn't solve if a vertex lies on an edge, only that it *might* lie along an edge.
	 * @param {FOLD} graph a FOLD object
	 * @param {number} [epsilon=1e-6] an optional epsilon to be added as padding to the bounding boxes
	 * @returns {boolean[][]} array matching edges_ length where each value is
	 * an array matching vertices_ length, containing true/false.
	 * @linkcode Origami ./src/graph/span.js 14
	 */const getEdgesVerticesOverlappingSpan=(e,t=I)=>makeEdgesBoundingBox(e,t).map((t=>e.vertices_coords.map((e=>e[0]>t.min[0]&&e[1]>t.min[1]&&e[0]<t.max[0]&&e[1]<t.max[1]))))
/**
	 * @description Calculate every edge's rectangular bounding box and compare every box to
	 * every box to determine if boxes overlap. This doesn't claim edges overlap, only that
	 * their bounding boxes do, and that two edges *might* overlap.
	 * @param {FOLD} graph a FOLD object
	 * @param {number} [epsilon=1e-6] an optional epsilon to be added as padding to the bounding boxes
	 * @returns {boolean[][]} NxN 2D array filled with true/false answering
	 * "do edges's bounding boxes overlap?"
	 * Both triangles of the matrix are filled and the main diagonal contains true.
	 * ```text
	 *     0  1  2  3
	 * 0 [ t,  ,  ,  ]
	 * 1 [  , t,  ,  ]
	 * 2 [  ,  , t,  ]
	 * 3 [  ,  ,  , t]
	 * ```
	 * @linkcode Origami ./src/graph/span.js 41
	 */,getEdgesEdgesOverlapingSpans=({vertices_coords:e,edges_vertices:t,edges_coords:r},s=I)=>{const o=makeEdgesBoundingBox({vertices_coords:e,edges_vertices:t,edges_coords:r},s),n=t.map((()=>[]));
// span_overlaps will be false if no overlap possible, true if overlap is possible.
for(let e=0;e<t.length-1;e+=1)for(let r=e+1;r<t.length;r+=1){
// if first max is less than second min, or second max is less than first min,
// for both X and Y
const t=(o[e].max[0]<o[r].min[0]||o[r].max[0]<o[e].min[0])&&(o[e].max[1]<o[r].min[1]||o[r].max[1]<o[e].min[1]);
// true if the spans are not touching. flip for overlap
n[e][r]=!t,n[r][e]=!t}for(let e=0;e<t.length;e+=1)n[e][e]=!0;return n};var Ee=Object.freeze({__proto__:null,getEdgesVerticesOverlappingSpan:getEdgesVerticesOverlappingSpan,getEdgesEdgesOverlapingSpans:getEdgesEdgesOverlapingSpans});
/**
	 * Rabbit Ear (c) Kraft
	 */const getOppositeVertices=({edges_vertices:e},t,r)=>(r.forEach((r=>{if(e[r][0]===t&&e[r][1]===t)throw new Error(j)})),r.map((r=>e[r][0]===t?e[r][1]:e[r][0]))),isVertexCollinear=({vertices_coords:e,vertices_edges:t,edges_vertices:r},s,o=I)=>{if(!e||!r)return!1;t||(t=makeVerticesEdgesUnsorted({edges_vertices:r}));const n=t[s];if(void 0===n||2!==n.length)return!1;
// don't just check if they are parallel, use the direction of the vertex
// to make sure the center vertex is inbetween, instead of the odd
// case where the two edges are on top of one another with
// a leaf-like vertex.
const a=getOppositeVertices({edges_vertices:r},s,n),c=[a[0],s,a[1]].map((t=>e[t]));return collinearBetween(...c,!1,o)},getVerticesEdgesOverlap=({vertices_coords:e,edges_vertices:t,edges_coords:r},s=I)=>{r||(r=t.map((t=>t.map((t=>e[t])))));const o=getEdgesVerticesOverlappingSpan({vertices_coords:e,edges_vertices:t,edges_coords:r},s);
// todo, consider pushing values into a results array instead of modifying,
// then filtering the existing one
for(let t=0;t<r.length;t+=1)for(let n=0;n<e.length;n+=1)o[t][n]&&(o[t][n]=overlapLinePoint({vector:subtract(r[t][1],r[t][0]),origin:r[t][0]},e[n],excludeS,s));return o.map((e=>e.map(((e,t)=>e?t:void 0)).filter((e=>void 0!==e))))};
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * @description determine if a vertex exists between two and only two edges, and
	 * those edges are both parallel and on opposite ends of the vertex. In a lot of
	 * cases, this vertex can be removed and the graph would function the same.
	 * @param {FOLD} graph a FOLD object
	 * @param {number} vertex an index of a vertex in the graph
	 * @returns {boolean} true if the vertex is collinear and can be removed.
	 * @linkcode Origami ./src/graph/verticesCollinear.js 15
	 */var xe=Object.freeze({__proto__:null,isVertexCollinear:isVertexCollinear,getVerticesEdgesOverlap:getVerticesEdgesOverlap});
/* Math (c) Kraft, MIT License */
/**
	 * Math (c) Kraft
	 */
/**
	 * @description Find the intersection of two lines. Lines can be
	 * lines/rays/segments, and can be inclusve or exclusive in terms
	 * of their endpoints and the epsilon value.
	 * @param {RayLine} lineA line object with "vector" and "origin"
	 * @param {RayLine} lineB line object with "vector" and "origin"
	 * @param {function} [aDomain=includeL] first line's boolean test
	 * normalized value lies collinear
	 * @param {function} [bDomain=includeL] second line's boolean test
	 * normalized value lies collinear
	 * @param {number} [epsilon=1e-6] optional epsilon
	 * @returns {number[]|undefined} one 2D point or undefined
	 * @linkcode Math ./src/intersection/intersect-line-line.js 26
	*/const intersectLineLine=(e,t,r=includeL,s=includeL,o=I)=>{
// a normalized determinant gives consistent values across all epsilon ranges
const n=cross2(normalize2(e.vector),normalize2(t.vector));
// lines are parallel
if(Math.abs(n)<o)return;const a=cross2(e.vector,t.vector),c=-a,i=[t.origin[0]-e.origin[0],t.origin[1]-e.origin[1]],l=[-i[0],-i[1]],d=cross2(i,t.vector)/a,m=cross2(l,e.vector)/c;return r(d,o/magnitude2(e.vector))&&s(m,o/magnitude2(t.vector))?add2(e.origin,scale2(e.vector,d)):void 0},intersectCircleLine=(e,t,r=include,s=includeL,o=I)=>{const n=t.vector[0]**2+t.vector[1]**2,a=Math.sqrt(n),c=0===a?t.vector:t.vector.map((e=>e/a)),i=rotate90(c),l=subtract2(t.origin,e.origin),d=cross2(l,c);if(Math.abs(d)>e.radius+o)return;const m=Math.sqrt(e.radius**2-d**2),f=(t,r)=>e.origin[r]-i[r]*d+c[r]*t,g=Math.abs(e.radius-Math.abs(d))<o?[m].map((e=>[e,e].map(f)// tangent to circle
)):[-m,m].map((e=>[e,e].map(f))),p=g.map((e=>e.map(((e,r)=>e-t.origin[r])))).map((e=>e[0]*t.vector[0]+t.vector[1]*e[1])).map((e=>e/n));return g.filter(((e,t)=>s(p[t],o)))},rotateVector2=(e,t,r)=>{const s=t[0]-e[0],o=t[1]-e[1],n=s*Math.cos(r)+o*Math.sin(r),a=o*Math.cos(r)-s*Math.sin(r);return[e[0]+n,e[1]+a]},getUniquePair=e=>{for(let t=1;t<e.length;t+=1)if(!epsilonEqualVectors(e[0],e[t]))return[e[0],e[t]]},intersectConvexPolygonLineInclusive=(e,{vector:t,origin:r},s=includeS,o=includeL,n=I)=>{const a=e.map(((e,t,r)=>[e,r[(t+1)%r.length]]// into segment pairs
)).map((e=>intersectLineLine({vector:subtract2(e[1],e[0]),origin:e[0]},{vector:t,origin:r},s,o,n))).filter((e=>void 0!==e));switch(a.length){case 0:return;case 1:return[a];default:
// for two intersection points or more, in the case of vertex-
// collinear intersections the same point from 2 polygon sides
// can be returned. we need to filter for unique points.
// if no 2 unique points found:
// there was only one unique intersection point after all.
return getUniquePair(a)||[a[0]]}},intersectConvexPolygonLine=(e,{vector:t,origin:r},s=includeS,o=excludeL,n=I)=>{const a=intersectConvexPolygonLineInclusive(e,{vector:t,origin:r},s,o,n);
// const sects = convex_poly_line_intersect(intersect_func, poly, line1, line2, epsilon);
let c;// the opposite func, as far as inclusive/exclusive
switch(o){
// case excludeL: altFunc = includeL; break;
case X:c=Y;break;case excludeS:c=includeS;break;default:return a}
// here on, we are only dealing with exclusive tests, parsing issues with
// vertex-on intersections that still intersect or don't intersect the polygon.
// repeat the computation but include intersections with the polygon's vertices.
const i=intersectConvexPolygonLineInclusive(e,{vector:t,origin:r},includeS,c,n);
// const includes = convex_poly_line_intersect(altFunc, poly, line1, line2, epsilon);
// if there are still no intersections, the line doesn't intersect.
if(void 0===i)return;
// if there are intersections, see if the line crosses the entire polygon
// (gives us 2 unique points)
const l=getUniquePair(i);
// first, deal with the case that there are no unique 2 points.
if(void 0===l)switch(o){
// if there is one intersection, check if a ray's origin is inside.
// 1. if the origin is inside, consider the intersection valid
// 2. if the origin is outside, same as the line case above. no intersection.
case X:
// is the ray origin inside?
return overlapConvexPolygonPoint(e,r,exclude,n)?i:void 0;
// if there is one intersection, check if either of a segment's points are
// inside the polygon, same as the ray above. if neither are, consider
// the intersection invalid for the exclusive case.
case excludeS:return overlapConvexPolygonPoint(e,add2(r,t),exclude,n)||overlapConvexPolygonPoint(e,r,exclude,n)?i:void 0;
// if there is one intersection, an infinite line is intersecting the
// polygon from the outside touching at just one vertex. this should be
// considered undefined for the exclusive case.
default:return}
// now that we've covered all the other cases, we know that the line intersects
// the polygon at two unique points. this should return true for all cases
// except one: when the line is collinear to an edge of the polygon.
// to test this, get the midpoint of the two intersects and do an exclusive
// check if the midpoint is inside the polygon. if it is, the line is crossing
// the polygon and the intersection is valid.
return overlapConvexPolygonPoint(e,midpoint2(...l),exclude,n)?l:a};
/**
	 * @description Calculate the intersection of a circle and a line;
	 * the line can be a line, ray, or segment.
	 * @param {number} circleRadius the circle's radius
	 * @param {number[]} circleOrigin the center of the circle
	 * @param {number[]} lineVector the vector component of the line
	 * @param {number[]} lineOrigin the origin component of the line
	 * @param {function} [lineFunc=includeL] set the line/ray/segment
	 * and inclusive/exclusive
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @linkcode Math ./src/intersection/intersect-circle-line.js 20
	 */var Ae=Object.freeze({__proto__:null,intersectCircleCircle:(e,t,r=include,s=include,o=I)=>{
// sort by largest-smallest radius
const n=e.radius<t.radius?e.radius:t.radius,a=e.radius<t.radius?t.radius:e.radius,c=e.radius<t.radius?e.origin:t.origin,i=e.radius<t.radius?t.origin:e.origin,l=[c[0]-i[0],c[1]-i[1]],d=Math.sqrt(l[0]**2+l[1]**2);
// infinite solutions // don't need this because the below case covers it
// if (d < epsilon && Math.abs(R - r) < epsilon) { return undefined; }
// no intersection (same center, different size)
if(d<o)return;const m=l.map(((e,t)=>e/d*a+i[t]));
// kissing circles
if(Math.abs(a+n-d)<o||Math.abs(a-(n+d))<o)return[m];
// circles are contained
if(d+n<a||a+n<d)return;const g=(p=(n*n-d*d-a*a)/(-2*d*a))>=1?0:p<=-1?Math.PI:Math.acos(p);var p;return[rotateVector2(i,m,+g),rotateVector2(i,m,-g)]},intersectCircleLine:intersectCircleLine,intersectConvexPolygonLine:intersectConvexPolygonLine,intersectLineLine:intersectLineLine});
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * @description Find all edges in a graph which lie parallel along a line (infinite line).
	 * @param {FOLD} graph a FOLD object
	 * @param {number[]} vector a line defined by a vector crossing a point
	 * @param {number[]} point a line defined by a vector crossing a point
	 * @returns {boolean[]} length matching number of edges, true if parallel and overlapping
	 * @linkcode Origami ./src/graph/intersect.js 18
	 */const makeEdgesLineParallelOverlap=({vertices_coords:e,edges_vertices:t},r,s,o=I)=>{const n=normalize2(r),a=t.map((t=>e[t[0]])),c=t.map((t=>t.map((t=>e[t])))).map((e=>subtract2(e[1],e[0]))).map((e=>parallel2(e,r,o)));
// second, filter out edges which do not lie on top of the line
for(let e=0;e<t.length;e+=1){if(!c[e])continue;if(epsilonEqualVectors(a[e],s)){c[e]=!0;continue}const t=normalize2(subtract2(a[e],s)),r=Math.abs(dot2(t,n));c[e]=Math.abs(1-r)<o}return c},makeEdgesSegmentIntersection=({vertices_coords:e,edges_vertices:t,edges_coords:r},s,o,n=I)=>{r||(r=makeEdgesCoords({vertices_coords:e,edges_vertices:t}));const a=boundingBox$1([s,o],n),c=subtract2(o,s);
// convert each edge into a bounding box, do bounding-box intersection
// with the segment, filter these results, then run actual intersection
// algorithm on this subset.
return makeEdgesBoundingBox({vertices_coords:e,edges_vertices:t,edges_coords:r},n).map((e=>overlapBoundingBoxes(a,e))).map(((e,t)=>e?intersectLineLine({vector:c,origin:s},{vector:subtract2(r[t][1],r[t][0]),origin:r[t][0]},includeS,includeS,n):void 0))},makeEdgesEdgesIntersection=function({vertices_coords:e,edges_vertices:t,edges_vector:r,edges_origin:s},o=I){r||(r=makeEdgesVector({vertices_coords:e,edges_vertices:t})),s||(s=t.map((t=>e[t[0]])));const n=r.map((()=>[])),a=getEdgesEdgesOverlapingSpans({vertices_coords:e,edges_vertices:t},o);for(let e=0;e<r.length-1;e+=1)for(let t=e+1;t<r.length;t+=1){if(!0!==a[e][t])continue;const c=intersectLineLine({vector:r[e],origin:s[e]},{vector:r[t],origin:s[t]},excludeS,excludeS,o);void 0!==c&&(n[e][t]=c,n[t][e]=c)}return n},intersectConvexFaceLine=({vertices_coords:e,edges_vertices:t,faces_vertices:r,faces_edges:s},o,{vector:n,origin:a},c=I)=>{
// give us back the indices in the faces_vertices[face] array
// we can count on these being sorted (important later)
const i=r[o].map((t=>e[t])).map((e=>overlapLinePoint({vector:n,origin:a},e,(()=>!0),c))).map(((e,t)=>e?t:void 0)).filter((e=>void 0!==e)),l=i.map((e=>r[o][e]));
// o-----o---o  we have to test against cases like this, where more than two
// |         |  vertices lie along one line.
// o---------o
// if vertices are neighbors
// because convex polygon, if collinear vertices lie along an edge,
// it must be an outside edge. this case returns no intersection.
if(i.concat(i.map((e=>e+r[o].length))).map(((e,t,r)=>r[t+1]-e==1)).reduce(((e,t)=>e||t),!1))return;if(l.length>1)return{vertices:l,edges:[]};
// run the line-segment intersection on every side of the face polygon
const d=s[o].map((r=>t[r].map((t=>e[t])))).map((e=>intersectLineLine({vector:n,origin:a},{vector:subtract(e[1],e[0]),origin:e[0]},includeL,excludeS,c))).map(((e,t)=>({coords:e,edge:s[o][t]})
// remove edges with no intersection
)).filter((e=>void 0!==e.coords
// remove edges which share a vertex with a previously found vertex.
// these edges are because the intersection is near a vertex but also
// intersects the edge very close to the end.
)).filter((e=>!l.map((r=>t[e.edge].includes(r))).reduce(((e,t)=>e||t),!1)));
// only return the case with 2 intersections. for example, only 1 vertex
// intersection implies outside the polygon, collinear with one vertex.
return d.length+l.length===2?{vertices:l,edges:d}:void 0};
/**
	 * @description Find all edges in a graph which lie parallel along a segment, the
	 * endpoints of the segments and the edges are inclusive.
	 * @param {object} a FOLD graph
	 * @param {number[]} point1, the first point of the segment
	 * @param {number[]} point2, the second point of the segment
	 * @returns {number[]} array length matching number of edges containing a point
	 * if there is an intersection, and undefined if no intersection.
	 * @linkcode Origami ./src/graph/intersect.js 52
	 */var ke=Object.freeze({__proto__:null,makeEdgesLineParallelOverlap:makeEdgesLineParallelOverlap,makeEdgesSegmentIntersection:makeEdgesSegmentIntersection,makeEdgesEdgesIntersection:makeEdgesEdgesIntersection,intersectConvexFaceLine:intersectConvexFaceLine});
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * Fragment converts a graph into a planar graph. it flattens all the
	 * coordinates onto the 2D plane.
	 *
	 * it modifies edges and vertices. splitting overlapping edges
	 * at their intersections, merging vertices that lie too near to one another.
	 * # of edges may increase. # of vertices may decrease. (is that for sure?)
	 *
	 * This function requires an epsilon (1e-6), for example a busy
	 * edge crossing should be able to resolve to one point
	 *
	 * 1. merge vertices that are within the epsilon.
	 *
	 * 2. gather all intersections, for every line.
	 *    for example, the first line in the list gets compared to other lines
	 *    resulting in a list of intersection points,
	 *
	 * 3. replace the edge with a new, rebuilt, sequence of edges, with
	 *    new vertices.
	 */const fragment_graph=(e,t=I)=>{const r=e.edges_vertices.map((t=>t.map((t=>e.vertices_coords[t])))),s=r.map((e=>subtract(e[1],e[0]))),o=r.map((e=>e[0])),n=makeEdgesEdgesIntersection({vertices_coords:e.vertices_coords,edges_vertices:e.edges_vertices,edges_vector:s,edges_origin:o},1e-6),a=getVerticesEdgesOverlap({vertices_coords:e.vertices_coords,edges_vertices:e.edges_vertices,edges_coords:r},t);
// when we rebuild an edge we need the intersection points sorted
// so we can walk down it and rebuild one by one. sort along vector
// exit early
if(0===n.flat().filter((e=>void 0!==e)).length&&0===a.flat().filter((e=>void 0!==e)).length)return;
// remember, edges_intersections contains intersections [x,y] points
// each one appears twice (both edges that intersect) and is the same
// object, shallow pointer.

// iterate over this list and move each vertex into new_vertices_coords.
// in their place put the index of this new vertex in the new array.
// when we get to the second appearance of the same point, it will have
// been replaced with the index, so we can skip it. (check length of
// item, 2=point, 1=index)
const c=e.vertices_coords.length;
// add new vertices (intersection points) to the graph
n.forEach((t=>t.filter((e=>void 0!==e)).filter((e=>2===e.length)).forEach((t=>{const r=e.vertices_coords.length;e.vertices_coords.push([...t]),t.splice(0,2),t.push(r)})))),
// replace arrays with indices
n.forEach(((e,t)=>{e.forEach(((e,r)=>{e&&(n[t][r]=e[0])}))}));const i=n.map((e=>e.filter((e=>void 0!==e))));
// add lists of vertices into each element in edges_vertices
// edges verts now contains an illegal arrangement of more than 2 verts
// to be resolved below
e.edges_vertices.forEach(((e,t)=>e.push(...i[t],...a[t]))),
// .push(...edges_intersections_flat[i]));
e.edges_vertices.forEach(((t,r)=>{e.edges_vertices[r]=sortVerticesAlongVector({vertices_coords:e.vertices_coords},t,s[r])}));
// edge_map is length edges_vertices in the new, fragmented graph.
// the value at each index is the edge that this edge was formed from.
const l=e.edges_vertices.map(((e,t)=>Array(e.length-1).fill(t))).flat();
// copy over edge metadata if it exists
// make foldAngles and assignments match if foldAngle is longer
if(e.edges_vertices=e.edges_vertices.map((e=>Array.from(Array(e.length-1)).map(((t,r,s)=>[e[r],e[r+1]]))// todo, is this supposed to be % arr.length
)).flat(),e.edges_assignment&&e.edges_foldAngle&&e.edges_foldAngle.length>e.edges_assignment.length)for(let t=e.edges_assignment.length;t<e.edges_foldAngle.length;t+=1)e.edges_assignment[t]=edgeFoldAngleToAssignment(e.edges_foldAngle[t]);
// copy over assignments and fold angle and base fold angle off assigments if it's shorter
return e.edges_assignment&&(e.edges_assignment=l.map((t=>e.edges_assignment[t]||"U"))),e.edges_foldAngle&&(e.edges_foldAngle=l.map((t=>e.edges_foldAngle[t])).map(((t,r)=>void 0===t?edgeAssignmentToFoldAngle(e.edges_assignment[r]):t))),{vertices:{new:Array.from(Array(e.vertices_coords.length-c)).map(((e,t)=>c+t))},edges:{backmap:l}}},Oe=[i,l,m,g],fragment=(e,t=I)=>{
// project all vertices onto the XY plane
e.vertices_coords=e.vertices_coords.map((e=>e.slice(0,2))),[o,n,a].map((t=>filterKeysWithPrefix(e,t))).flat().filter((e=>!Oe.includes(e))).forEach((t=>delete e[t]));const r={vertices:{},edges:{}};let s;
// most of the time this will loop twice, but exit early during the second
// iteration due to all checks being passed. rarely, but still possible,
// the merging of two vertices will bring one of the vertices over another
// vertex junction, creating more edge-edge overlaps which requires another
// iteration through this loop. at most, this has only ever been
// observed to require one or two more loops, about 3 loops in total.
for(s=0;s<20;s+=1){const s=removeDuplicateVertices(e,t/2),o=removeDuplicateEdges(e),n=removeCircularEdges(e),a=fragment_graph(e,t);if(void 0===a){r.vertices.map=void 0===r.vertices.map?s.map:mergeNextmaps(r.vertices.map,s.map),r.edges.map=void 0===r.edges.map?mergeNextmaps(o.map,n.map):mergeNextmaps(r.edges.map,o.map,n.map);break}const c=invertMap(a.edges.backmap),i=mergeNextmaps(o.map,n.map,c);r.vertices.map=void 0===r.vertices.map?s.map:mergeNextmaps(r.vertices.map,s.map),r.edges.map=void 0===r.edges.map?i:mergeNextmaps(r.edges.map,i)}if(20===s)throw new Error(k);return r},boundingBox=({vertices_coords:e},t)=>boundingBox$1(e,t)
/**
	 * @description For every vertex return a true if the vertex lies along a boundary
	 * edge, as defined by edges_assignment. If edges_assignment is not present,
	 * or does not contain boundary edges, this will return an empty array.
	 * @param {FOLD} graph a FOLD graph
	 * @returns {number[]} unsorted list of vertex indices which lie along the boundary.
	 * @linkcode Origami ./src/graph/boundary.js 32
	 */,boundaryVertices=({edges_vertices:e,edges_assignment:t})=>uniqueElements(e.filter(((e,r)=>"B"===t[r]||"b"===t[r])).flat())
// export const boundaryVertices = ({ edges_vertices, edges_assignment }) => {
// 	// assign vertices to a hash table to make sure they are unique.
// 	const vertices = {};
// 	edges_vertices.forEach((v, i) => {
// 		const boundary = edges_assignment[i] === "B" || edges_assignment[i] === "b";
// 		if (!boundary) { return; }
// 		vertices[v[0]] = true;
// 		vertices[v[1]] = true;
// 	});
// 	return Object.keys(vertices).map(str => parseInt(str));
// };
,boundary=({vertices_edges:e,edges_vertices:t,edges_assignment:r})=>{if(void 0===r)return{vertices:[],edges:[]};e||(e=makeVerticesEdgesUnsorted({edges_vertices:t}));const s=r.map((e=>"B"===e||"b"===e)),o=[],n=[];let a=-1;for(let e=0;e<s.length;e+=1)if(s[e]){a=e;break}if(-1===a)return{vertices:[],edges:[]};s[a]=!1,o.push(a),n.push(t[a][0]);let c=t[a][1];for(;n[0]!==c;){if(n.push(c),a=e[c].filter((e=>s[e])).shift(),void 0===a)return{vertices:[],edges:[]};t[a][0]===c?[,c]=t[a]:[c]=t[a],s[a]=!1,o.push(a)}return{vertices:n,edges:o}},planarBoundary=({vertices_coords:e,vertices_edges:t,vertices_vertices:r,edges_vertices:s},o=!0)=>{r||(r=makeVerticesVertices({vertices_coords:e,vertices_edges:t,edges_vertices:s}));const n=makeVerticesToEdgeBidirectional({edges_vertices:s}),a=[],c=[],i={vertices:c,edges:a};let l=-1/0,d=-1;if(e.forEach(((e,t)=>{e[0]>l&&(l=e[0],d=t)})),-1===d)return i;c.push(d);const m=e[d],g=r[d],p=g.map((t=>e[t])).map((e=>[e[0]-m[0],e[1]-m[1]])).map((e=>Math.atan2(e[1],e[0]))).map((e=>e<0?e+2*Math.PI:e)).map(((e,t)=>({a:e,i:t}))).sort(((e,t)=>e.a-t.a)).shift().i,v=g[p],u=n[d<v?`${d} ${v}`:`${v} ${d}`];
// vertex_walk.push(second_vertex_i);
a.push(u);
// now we begin the loop
// walking the graph, we look at 3 vertices at a time. in sequence:
// prev_vertex, this_vertex, next_vertex
let h=d,_=v;
// because this is an infinite loop, and it relies on vertices_vertices
// being well formed (if it was user-made, we cannot guarantee),
// this loop protection will mod 1000 loops and check the duration.
const b=performance.now();
// 10 seconds. more than enough to verify something went wrong
let y=0;for(;;){const e=r[_],t=e.indexOf(h),s=e[(t+1)%e.length],l=n[_<s?`${_} ${s}`:`${s} ${_}`];
// exit loop condition
if(l===a[0])return i;
// if loop protection is turned on, check elapsed time every 1000 loops
// so that we reduce number of calls to the performance API.
if(c.push(_),a.push(l),h=_,_=s,y+=1,o&&y%1e3==0&&performance.now()-b>1e4)throw new Error(M)}};var we=Object.freeze({__proto__:null,boundingBox:boundingBox,boundaryVertices:boundaryVertices,boundary:boundary,planarBoundary:planarBoundary});
/* Math (c) Kraft, MIT License */
/**
	 * Math (c) Kraft
	 */
/**
	 * 2x3 matrix methods for two dimensional transformations.
	 * the third column is a 2D translation vector
	 */
/**
	 * @description the identity matrix for 2x2 matrices
	 * @linkcode Math ./src/algebra/matrix2.js 10
	 */const Me=[1,0,0,1],je=Me.concat(0,0),multiplyMatrix2Vector2=(e,t)=>[e[0]*t[0]+e[2]*t[1]+e[4],e[1]*t[0]+e[3]*t[1]+e[5]]
/**
	 * @param {number[]} matrix, in array form
	 * @param {number[]} vector of the line
	 * @param {number[]} origin of the line
	 * @returns transformed line in point-vector form
	 * @linkcode Math ./src/algebra/matrix2.js 31
	 */,multiplyMatrix2Line2=(e,t,r)=>({vector:[e[0]*t[0]+e[2]*t[1],e[1]*t[0]+e[3]*t[1]],origin:[e[0]*r[0]+e[2]*r[1]+e[4],e[1]*r[0]+e[3]*r[1]+e[5]]})
/**
	 * @param {number[]} matrix1, left/right order matches what you'd see on a page.
	 * @param {number[]} matrix2, left/right order matches what you'd see on a page.
	 * @returns {number[]} matrix
	 * @linkcode Math ./src/algebra/matrix2.js 46
	 */,multiplyMatrices2=(e,t)=>[e[0]*t[0]+e[2]*t[1],e[1]*t[0]+e[3]*t[1],e[0]*t[2]+e[2]*t[3],e[1]*t[2]+e[3]*t[3],e[0]*t[4]+e[2]*t[5]+e[4],e[1]*t[4]+e[3]*t[5]+e[5]]
/**
	 * @description calculate the determinant of a 2x3 or 2x2 matrix.
	 * in the case of 2x3, the translation component is ignored.
	 * @param {number[]} matrix one matrix in array form
	 * @returns {number} the determinant of the matrix
	 * @linkcode Math ./src/algebra/matrix2.js 61
	 */,determinant2=e=>e[0]*e[3]-e[1]*e[2]
/**
	 * @description invert a 2x3 matrix
	 * @param {number[]} matrix one matrix in array form
	 * @returns {number[]|undefined} the inverted matrix, or undefined if not possible
	 * @linkcode Math ./src/algebra/matrix2.js 68
	 */,invertMatrix2=e=>{const t=determinant2(e);if(!(Math.abs(t)<1e-6||Number.isNaN(t))&&Number.isFinite(e[4])&&Number.isFinite(e[5]))return[e[3]/t,-e[1]/t,-e[2]/t,e[0]/t,(e[2]*e[5]-e[3]*e[4])/t,(e[1]*e[4]-e[0]*e[5])/t]},makeMatrix2Reflect=(e,t=[0,0])=>{
// the line of reflection passes through origin, runs along vector
const r=Math.atan2(e[1],e[0]),s=Math.cos(r),o=Math.sin(r),n=Math.cos(-r),a=Math.sin(-r),c=s*n+o*a,i=s*-a+o*n,l=o*n+-s*a,d=o*-a+-s*n;return[c,i,l,d,t[0]+c*-t[0]+-t[1]*l,t[1]+i*-t[0]+-t[1]*d]};
/**
	 * @description the identity matrix for 2x3 matrices (zero translation)
	 * @linkcode Math ./src/algebra/matrix2.js 15
	 */var Fe=Object.freeze({__proto__:null,determinant2:determinant2,identity2x2:Me,identity2x3:je,invertMatrix2:invertMatrix2,makeMatrix2Reflect:makeMatrix2Reflect,makeMatrix2Rotate:(e,t=[0,0])=>{const r=Math.cos(e),s=Math.sin(e);return[r,s,-s,r,t[0],t[1]]},makeMatrix2Scale:(e=[1,1],t=[0,0])=>[e[0],0,0,e[1],e[0]*-t[0]+t[0],e[1]*-t[1]+t[1]]
/**
	 * @param angle of rotation, origin of transformation
	 * @returns {number[]} matrix
	 * @linkcode Math ./src/algebra/matrix2.js 109
	 */,makeMatrix2Translate:(e=0,t=0)=>Me.concat(e,t)
/**
	 * @param ratio of scale, optional origin homothetic center (0,0 default)
	 * @returns {number[]} matrix
	 * @linkcode Math ./src/algebra/matrix2.js 96
	 */,multiplyMatrices2:multiplyMatrices2,multiplyMatrix2Line2:multiplyMatrix2Line2,multiplyMatrix2Vector2:multiplyMatrix2Vector2});
/* Math (c) Kraft, MIT License */
/**
	 * Math (c) Kraft
	 */
/**
	 * @description the identity matrix for 3x3 matrices
	 * @linkcode Math ./src/algebra/matrix3.js 13
	 */const Ce=Object.freeze([1,0,0,0,1,0,0,0,1]),Pe=Object.freeze(Ce.concat(0,0,0)),multiplyMatrix3Vector3=(e,t)=>[e[0]*t[0]+e[3]*t[1]+e[6]*t[2]+e[9],e[1]*t[0]+e[4]*t[1]+e[7]*t[2]+e[10],e[2]*t[0]+e[5]*t[1]+e[8]*t[2]+e[11]]
/**
	 * @description multiply one 3D line by a 3x4 matrix
	 * @param {number[]} matrix one matrix in array form
	 * @param {number[]} vector the vector of the line
	 * @param {number[]} origin the origin of the line
	 * @returns {object} transformed line in point-vector form
	 * @linkcode Math ./src/algebra/matrix3.js 48
	 */,multiplyMatrices3=(e,t)=>[e[0]*t[0]+e[3]*t[1]+e[6]*t[2],e[1]*t[0]+e[4]*t[1]+e[7]*t[2],e[2]*t[0]+e[5]*t[1]+e[8]*t[2],e[0]*t[3]+e[3]*t[4]+e[6]*t[5],e[1]*t[3]+e[4]*t[4]+e[7]*t[5],e[2]*t[3]+e[5]*t[4]+e[8]*t[5],e[0]*t[6]+e[3]*t[7]+e[6]*t[8],e[1]*t[6]+e[4]*t[7]+e[7]*t[8],e[2]*t[6]+e[5]*t[7]+e[8]*t[8],e[0]*t[9]+e[3]*t[10]+e[6]*t[11]+e[9],e[1]*t[9]+e[4]*t[10]+e[7]*t[11]+e[10],e[2]*t[9]+e[5]*t[10]+e[8]*t[11]+e[11]]
/**
	 * @description calculate the determinant of a 3x4 or 3x3 matrix.
	 * in the case of 3x4, the translation component is ignored.
	 * @param {number[]} matrix one matrix in array form
	 * @returns {number} the determinant of the matrix
	 * @linkcode Math ./src/algebra/matrix3.js 88
	 */,determinant3=e=>e[0]*e[4]*e[8]-e[0]*e[7]*e[5]-e[3]*e[1]*e[8]+e[3]*e[7]*e[2]+e[6]*e[1]*e[5]-e[6]*e[4]*e[2]
/**
	 * @description invert a 3x4 matrix
	 * @param {number[]} matrix one matrix in array form
	 * @returns {number[]|undefined} the inverted matrix, or undefined if not possible
	 * @linkcode Math ./src/algebra/matrix3.js 102
	 */,makeMatrix3Translate=(e=0,t=0,r=0)=>Ce.concat(e,t,r)
// i0 and i1 direct which columns and rows are filled
// sgn manages right hand rule
,singleAxisRotate=(e,t,r,s,o)=>{const n=Ce.concat([0,1,2].map((e=>t[e]||0))),a=Math.cos(e),c=Math.sin(e);return n[3*r+r]=a,n[3*r+s]=(o?1:-1)*c,n[3*s+r]=(o?-1:1)*c,n[3*s+s]=a,n},makeMatrix3RotateZ=(e,t=[0,0,0])=>singleAxisRotate(e,t,0,1,!0)
/**
	 * @description make a 3x4 matrix representing a rotation in 3D
	 * around a given vector and around a given center of rotation.
	 * @param {number} angle the angle of rotation in radians
	 * @param {number[]} [vector=[0,0,1]] the axis of rotation
	 * @param {number[]} [origin=[0,0,0]] the center of rotation
	 * @returns {number[]} one 3x4 matrix
	 * @linkcode Math ./src/algebra/matrix3.js 190
	 */,makeMatrix3Rotate=(e,t=[0,0,1],r=[0,0,0])=>{const s=[0,1,2].map((e=>r[e]||0)),[o,n,a]=resize(3,normalize(t)),c=Math.cos(e),i=Math.sin(e),l=1-c,d=Ce.concat(-s[0],-s[1],-s[2]),m=Ce.concat(s[0],s[1],s[2]);return multiplyMatrices3(m,multiplyMatrices3([l*o*o+c,l*n*o+a*i,l*a*o-n*i,l*o*n-a*i,l*n*n+c,l*a*n+o*i,l*o*a+n*i,l*n*a-o*i,l*a*a+c,0,0,0],d))},makeMatrix3Scale=(e=[1,1,1],t=[0,0,0])=>[e[0],0,0,0,e[1],0,0,0,e[2],e[0]*-t[0]+t[0],e[1]*-t[1]+t[1],e[2]*-t[2]+t[2]]
/**
	 * @description make a 3x4 representing a reflection across a line in the XY plane
	 * This is a 2D operation, assumes everything is in the XY plane.
	 * @param {number[]} vector one 2D vector specifying the reflection axis
	 * @param {number[]} [origin=[0,0]] 2D origin specifying a point of reflection
	 * @returns {number[]} one 3x4 matrix
	 * @linkcode Math ./src/algebra/matrix3.js 252
	 */;
/**
	 * @description the identity matrix for 3x4 matrices (zero translation)
	 * @linkcode Math ./src/algebra/matrix3.js 18
	 */var Ne=Object.freeze({__proto__:null,determinant3:determinant3,identity3x3:Ce,identity3x4:Pe,invertMatrix3:e=>{const t=determinant3(e);if(Math.abs(t)<1e-6||Number.isNaN(t)||!Number.isFinite(e[9])||!Number.isFinite(e[10])||!Number.isFinite(e[11]))return;const r=[e[4]*e[8]-e[7]*e[5],-e[1]*e[8]+e[7]*e[2],e[1]*e[5]-e[4]*e[2],-e[3]*e[8]+e[6]*e[5],e[0]*e[8]-e[6]*e[2],-e[0]*e[5]+e[3]*e[2],e[3]*e[7]-e[6]*e[4],-e[0]*e[7]+e[6]*e[1],e[0]*e[4]-e[3]*e[1],-e[3]*e[7]*e[11]+e[3]*e[8]*e[10]+e[6]*e[4]*e[11]-e[6]*e[5]*e[10]-e[9]*e[4]*e[8]+e[9]*e[5]*e[7],e[0]*e[7]*e[11]-e[0]*e[8]*e[10]-e[6]*e[1]*e[11]+e[6]*e[2]*e[10]+e[9]*e[1]*e[8]-e[9]*e[2]*e[7],-e[0]*e[4]*e[11]+e[0]*e[5]*e[10]+e[3]*e[1]*e[11]-e[3]*e[2]*e[10]-e[9]*e[1]*e[5]+e[9]*e[2]*e[4]],s=1/t;return r.map((e=>e*s))},isIdentity3x4:e=>Pe.map(((t,r)=>Math.abs(t-e[r])<I)).reduce(((e,t)=>e&&t),!0)
/**
	 * @description multiply one 3D vector by a 3x4 matrix
	 * @param {number[]} matrix one matrix in array form
	 * @param {number[]} vector in array form
	 * @returns {number[]} the transformed vector
	 * @linkcode Math ./src/algebra/matrix3.js 35
	 */,makeMatrix3ReflectZ:(e,t=[0,0])=>{const r=makeMatrix2Reflect(e,t);return[r[0],r[1],0,r[2],r[3],0,0,0,1,r[4],r[5],0]},makeMatrix3Rotate:makeMatrix3Rotate,makeMatrix3RotateX:(e,t=[0,0,0])=>singleAxisRotate(e,t,1,2,!0)
/**
	 * @description make a 3x4 matrix representing a rotation in 3D around the y-axis
	 * (allowing you to specify the center of rotation if needed).
	 * @param {number} angle the angle of rotation in radians
	 * @param {number[]} [origin=[0,0,0]] the center of rotation
	 * @returns {number[]} one 3x4 matrix
	 * @linkcode Math ./src/algebra/matrix3.js 169
	 */,makeMatrix3RotateY:(e,t=[0,0,0])=>singleAxisRotate(e,t,0,2,!1)
/**
	 * @description make a 3x4 matrix representing a rotation in 3D around the z-axis
	 * (allowing you to specify the center of rotation if needed).
	 * @param {number} angle the angle of rotation in radians
	 * @param {number[]} [origin=[0,0,0]] the center of rotation
	 * @returns {number[]} one 3x4 matrix
	 * @linkcode Math ./src/algebra/matrix3.js 179
	 */,makeMatrix3RotateZ:makeMatrix3RotateZ,makeMatrix3Scale:makeMatrix3Scale,makeMatrix3Translate:makeMatrix3Translate,multiplyMatrices3:multiplyMatrices3,multiplyMatrix3Line3:(e,t,r)=>({vector:[e[0]*t[0]+e[3]*t[1]+e[6]*t[2],e[1]*t[0]+e[4]*t[1]+e[7]*t[2],e[2]*t[0]+e[5]*t[1]+e[8]*t[2]],origin:[e[0]*r[0]+e[3]*r[1]+e[6]*r[2]+e[9],e[1]*r[0]+e[4]*r[1]+e[7]*r[2]+e[10],e[2]*r[0]+e[5]*r[1]+e[8]*r[2]+e[11]]})
/**
	 * @description multiply two 3x4 matrices together
	 * @param {number[]} matrix the first matrix
	 * @param {number[]} matrix the second matrix
	 * @returns {number[]} one matrix, the product of the two
	 * @linkcode Math ./src/algebra/matrix3.js 67
	 */,multiplyMatrix3Vector3:multiplyMatrix3Vector3});
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * @name transform
	 * @memberof graph
	 * @description apply an affine transform to a graph; this includes
	 * modifying the position of any key ending with "_coords" and multiplying
	 * any matrix in keys that end with "_matrix".
	 * @param {FOLD} graph a FOLD graph
	 * @param {number[]} matrix a 3x4 matrix as a 12 number array
	 * @returns {FOLD} the same input graph, modified
	 * @linkcode Origami ./src/graph/affine.js 15
	 */const apply_matrix_to_graph=function(e,t){
// apply to anything with a coordinate value
return filterKeysWithSuffix(e,"coords").forEach((r=>{e[r]=e[r].map((e=>resize(3,e))).map((e=>multiplyMatrix3Vector3(t,e)))})),
// update all matrix types
// todo, are these being multiplied in the right order?
filterKeysWithSuffix(e,"matrix").forEach((r=>{e[r]=e[r].map((e=>multiplyMatrices3(e,t)))})),e};
/**
	 * @name scale
	 * @memberof graph
	 * @description apply a uniform affine scale to a graph.
	 * @param {FOLD} graph a FOLD graph
	 * @param {number} scale the scale amount
	 * @param {number[]} optional. an array or series of numbers, the center of scale.
	 * @returns {FOLD} the same input graph, modified.
	 * @linkcode Origami ./src/graph/affine.js 40
	 */
// makeMatrix3Rotate
// makeMatrix3RotateX
// makeMatrix3RotateY
// makeMatrix3ReflectZ
var Se={scale:(e,...t)=>{const r=1===t.length?[t[0],t[0],t[0]]:[1,1,1].map(((e,r)=>void 0===t[r]?e:t[r])),s=makeMatrix3Scale(r);return apply_matrix_to_graph(e,s)},translate:(e,...t)=>{const r=getVector(...t),s=resize(3,r),o=makeMatrix3Translate(...s);return apply_matrix_to_graph(e,o)},rotateZ:(e,t,...r)=>{const s=getVector(...r),o=resize(3,s),n=makeMatrix3RotateZ(t,...o);return apply_matrix_to_graph(e,n)},transform:apply_matrix_to_graph};
/**
	 * Rabbit Ear (c) Kraft
	 */
// const getFaceFaceSharedVertices = (graph, face0, face1) => graph
//   .faces_vertices[face0]
//   .filter(v => graph.faces_vertices[face1].indexOf(v) !== -1)
/**
	 * @description given two faces, get the vertices which are shared between the two faces.
	 * @param {number[]} face_a_vertices the faces_vertices entry for face A
	 * @param {number[]} face_b_vertices the faces_vertices entry for face B
	 * @returns {number[]} indices of vertices that are shared between faces maintaining
	 * the vertices in the same order as the winding order of face A.
	 * @linkcode Origami ./src/graph/faceSpanningTree.js 16
	 */
// todo: this was throwing errors in the case of weird nonconvex faces with
// single edges poking in. the "already_added" was added to fix this.
// tbd if this fix covers all cases of weird polygons in a planar graph.
const getFaceFaceSharedVertices=(e,t)=>{
// build a quick lookup table: T/F is a vertex in face B
const r={};t.forEach((e=>{r[e]=!0}));
// make a copy of face A containing T/F, if the vertex is shared in face B
const s=e.map((e=>!!r[e])),o=[],n=s.indexOf(!1),a={};
// filter and keep only the shared vertices.
for(let t=n+1;t<s.length;t+=1)s[t]&&!a[e[t]]&&(o.push(e[t]),a[e[t]]=!0);for(let t=0;t<n;t+=1)s[t]&&!a[e[t]]&&(o.push(e[t]),a[e[t]]=!0);return o},makeFaceSpanningTree=({faces_vertices:e,faces_faces:t},r=0)=>{if(t||(t=makeFacesFaces({faces_vertices:e})),0===t.length)return[];const s=[[{face:r}]],o={};o[r]=!0;do{
// iterate the previous level's faces and gather their adjacent faces
const r=s[s.length-1].map((e=>t[e.face].map((t=>({face:t,parent:e.face}))))).reduce(((e,t)=>e.concat(t)),[]),n={};
// at this point its likely many faces are duplicated either because:
// 1. they were already visited in previous levels
// 2. the same face was adjacent to a few different faces from this step
r.forEach(((e,t)=>{o[e.face]&&(n[t]=!0),o[e.face]=!0}));
// unqiue set of next level faces
const a=r.filter(((e,t)=>!n[t]));
// set next_level's edge_vertices
// we cannot depend on faces being convex and only sharing 2 vertices in common.
// if there are more than 2 edges, let's hope they are collinear.
// either way, grab the first 2 vertices if there are more.
a.map((t=>getFaceFaceSharedVertices(e[t.face],e[t.parent]))).forEach(((e,t)=>{const r=e.slice(0,2);
// const edgeKey = edge_vertices.join(" ");
a[t].edge_vertices=r}
// next_level[i].edge = edge_map[edgeKey];
)),
// append this next_level to the master tree
s[s.length]=a}while(s[s.length-1].length>0);return s.length>0&&0===s[s.length-1].length&&s.pop(),s};
// each element will have
// except for the first level. the root level has no reference to the
// parent face, or the edge_vertices shared between them
// root_face will become the root node
/**
	 * @description Make a minimum spanning tree of a graph that edge-adjacent faces.
	 * @param {FOLD} graph a FOLD graph
	 * @param {number} [root_face=0] the face index to be the root node
	 * @returns {object[][]} a tree arranged as an array containin arrays of nodes. each inner
	 * array contains all nodes at that depth (0, 1, 2...) each node contains:
	 * "face" {number} "parent" {number} "edge_vertices" {number[]}
	 * @linkcode Origami ./src/graph/faceSpanningTree.js 59
	 */var Ve=Object.freeze({__proto__:null,getFaceFaceSharedVertices:getFaceFaceSharedVertices,makeFaceSpanningTree:makeFaceSpanningTree});
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * @description Given a FOLD object and a set of 2x3 matrices, one per face,
	 * "fold" the vertices by finding one matrix per vertex and multiplying them.
	 * @param {object} FOLD graph with vertices_coords, faces_vertices, and
	 * if vertices_faces does not exist it will be built.
	 * @param {number[][]} an array of 2x3 matrices. one per face.
	 * @returns {number[][]} a new set of vertices_coords, transformed.
	 * @linkcode Origami ./src/graph/facesMatrix.js 21
	 */const multiplyVerticesFacesMatrix2=({vertices_coords:e,vertices_faces:t,faces_vertices:r},s)=>{t||(t=makeVerticesFaces({faces_vertices:r}));const o=t.map((e=>e.filter((e=>null!=e)).shift())).map((e=>void 0===e?je:s[e]));return e.map(((e,t)=>multiplyMatrix2Vector2(o[t],e)))},$e={U:!0,u:!0},makeFacesMatrix=({vertices_coords:e,edges_vertices:t,edges_foldAngle:r,edges_assignment:s,faces_vertices:o,faces_faces:n},a=0)=>{!s&&r&&(s=makeEdgesAssignmentSimple({edges_foldAngle:r})),r||(r=s?makeEdgesFoldAngle({edges_assignment:s}):Array(t.length).fill(0));const c=makeVerticesToEdgeBidirectional({edges_vertices:t}),i=o.map((()=>Pe));return makeFaceSpanningTree({faces_vertices:o,faces_faces:n},a).slice(1).forEach((t=>t.forEach((t=>{const o=t.edge_vertices.map((t=>e[t])),n=t.edge_vertices.join(" "),a=c[n],l=$e[s[a]]?Math.PI:r[a]*Math.PI/180,d=makeMatrix3Rotate(l,// rotation angle
subtract(...resizeUp(o[1],o[0])),// line-vector
o[0]);i[t.face]=multiplyMatrices3(i[t.parent],d)}
// to build the inverse matrix, switch these two parameters
// .multiplyMatrices3(local_matrix, faces_matrix[entry.parent]);
)))),i},ze={M:!0,m:!0,V:!0,v:!0,U:!0,u:!0,F:!1,f:!1,B:!1,b:!1},makeEdgesIsFolded=({edges_vertices:e,edges_foldAngle:t,edges_assignment:r})=>void 0===r?void 0===t?e.map((()=>!0)):t.map((e=>e<-I||e>I)):r.map((e=>ze[e])),makeFacesMatrix2=({vertices_coords:e,edges_vertices:t,edges_foldAngle:r,edges_assignment:s,faces_vertices:o,faces_faces:n},a=0)=>{r||(r=s?makeEdgesFoldAngle({edges_assignment:s}):Array(t.length).fill(0));const c=makeEdgesIsFolded({edges_vertices:t,edges_foldAngle:r,edges_assignment:s}),i=makeVerticesToEdgeBidirectional({edges_vertices:t}),l=o.map((()=>je));return makeFaceSpanningTree({faces_vertices:o,faces_faces:n},a).slice(1).forEach((t=>t.forEach((t=>{const r=t.edge_vertices.map((t=>e[t])),s=t.edge_vertices.join(" "),o=i[s],n=subtract2(r[1],r[0]),a=r[0],d=c[o]?makeMatrix2Reflect(n,a):je;l[t.face]=multiplyMatrices2(l[t.parent],d)}
// to build the inverse matrix, switch these two parameters
// .multiplyMatrices2(local_matrix, faces_matrix[entry.parent]);
)))),l};var Te=Object.freeze({__proto__:null,multiplyVerticesFacesMatrix2:multiplyVerticesFacesMatrix2,makeFacesMatrix:makeFacesMatrix,makeEdgesIsFolded:makeEdgesIsFolded,makeFacesMatrix2:makeFacesMatrix2});
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * @description Fold a graph along its edges and return the position
	 * of the folded vertices. This method works in both 2D and 3D
	 * unassigned edges are treated as flat fold (mountain/valley 180deg)
	 * as a way of (assuming the user is giving a flat folded origami), help
	 * solve things about an origami that is currently being figured out.
	 * @param {FOLD} graph a FOLD graph
	 * @param {number} [root_face=0] the index of the face that will remain in place
	 * @returns {number[][]} a new set of `vertices_coords` with the new positions.
	 * @linkcode Origami ./src/graph/verticesCoordsFolded.js 23
	 */const makeVerticesCoordsFolded=({vertices_coords:e,vertices_faces:t,edges_vertices:r,edges_foldAngle:s,edges_assignment:o,faces_vertices:n,faces_faces:a,faces_matrix:c},i)=>{c=makeFacesMatrix({vertices_coords:e,edges_vertices:r,edges_foldAngle:s,edges_assignment:o,faces_vertices:n,faces_faces:a},i),t||(t=makeVerticesFaces({faces_vertices:n}));
// assign one matrix to every vertex from faces, identity matrix if none exist
const l=t.map((e=>e.filter((e=>null!=e// must filter "undefined" and "null"
)).shift()// get any face from the list
)).map((e=>void 0===e?Pe:c[e]));return e.map((e=>resize(3,e))).map(((e,t)=>multiplyMatrix3Vector3(l[t],e)))},makeVerticesCoordsFlatFolded=({vertices_coords:e,edges_vertices:t,edges_foldAngle:r,edges_assignment:s,faces_vertices:o,faces_faces:n},a=0)=>{const c=makeEdgesIsFolded({edges_vertices:t,edges_foldAngle:r,edges_assignment:s}),i=[];o[a].forEach((t=>{i[t]=[...e[t]]}));const l=[];l[a]=!1;const d=makeVerticesToEdgeBidirectional({edges_vertices:t});return makeFaceSpanningTree({faces_vertices:o,faces_faces:n},a).slice(1).forEach((r=>r.forEach((r=>{
// coordinates and vectors of the reflecting edge
const s=r.edge_vertices.join(" "),n=d[s],a=t[n].map((e=>i[e]));if(void 0===a[0]||void 0===a[1])return;const m=t[n].map((t=>e[t])),g=m[0],p=normalize2(subtract2(m[1],m[0])),v=rotate90(p);
// the basis axis origin, x-basis axis (vector) and y-basis (normal)
// if we are crossing a flipping edge (m/v), set this face to be
// flipped opposite of the parent face. otherwise keep it the same.
l[r.face]=c[n]?!l[r.parent]:l[r.parent];const u=normalize2(subtract2(a[1],a[0])),h=a[0],_=l[r.face]?rotate270(u):rotate90(u);
// remaining_faces_vertices
o[r.face].filter((e=>void 0===i[e])).forEach((t=>{const r=subtract2(e[t],g),s=dot(r,v),o=dot(r,p),n=scale2(u,o),a=scale2(_,s),c=add2(add2(h,n),a);i[t]=c}))})))),i};
/**
	 * @description Fold a graph along its edges and return the position of the folded
	 * vertices. this method works for 2D only (no z value).
	 * if a edges_assignment is "U", assumed to be folded ("V" or "M").
	 * Finally, if no edge foldAngle or assignments exist, this method will
	 * assume all edges are flat-folded (except boundary) and will fold everything.
	 * @param {FOLD} graph a FOLD graph
	 * @param {number} [root_face=0] the index of the face that will remain in place
	 * @returns {number[][]} a new set of `vertices_coords` with the new positions.
	 * @linkcode Origami ./src/graph/verticesCoordsFolded.js 56
	 */var Le=Object.freeze({__proto__:null,makeVerticesCoordsFolded:makeVerticesCoordsFolded,makeVerticesCoordsFlatFolded:makeVerticesCoordsFlatFolded});
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * @description deep copy an object, like JSON.parse(JSON.stringify())
	 *
	 * this clone function is decent, except for:
	 *  - it doesn't detect recursive cycles
	 *  - weird behavior around Proxys
	 * @author https://jsperf.com/deep-copy-vs-json-stringify-json-parse/5
	 * @param {object} o
	 * @returns {object} a deep copy of the input
	 * @linkcode Origami ./src/general/clone.js 14
	 */const clone=function(e){let t,s;if(typeof e!==r)return e;if(!e)return e;if("[object Array]"===Object.prototype.toString.apply(e)){for(t=[],s=0;s<e.length;s+=1)t[s]=clone(e[s]);return t}for(s in t={},e)e.hasOwnProperty(s)&&(
// this is where a self-similar reference causes an infinite loop
t[s]=clone(e[s]));return t},makeFacesWindingFromMatrix2=e=>e.map((e=>e[0]*e[3]-e[1]*e[2])).map((e=>e>=0))
/**
	 * @description For every face, return a boolean if the face's vertices are
	 * in counter-clockwise winding. For origami models, this translates to
	 * true meaning the face is upright, false meaning the face is flipped over.
	 * @param {FOLD} graph a FOLD graph
	 * @returns {boolean[]} boolean for every face, true if face is counter-clockwise.
	 * @attribution cool trick from https://stackoverflow.com/questions/1165647/how-to-determine-if-a-list-of-polygon-points-are-in-clockwise-order
	 * @linkcode Origami ./src/graph/facesWinding.js 33
	 */,makeFacesWinding=({vertices_coords:e,faces_vertices:t})=>t.map((t=>t.map((t=>e[t])).map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>(e[1][0]-e[0][0])*(e[1][1]+e[0][1]))).reduce(((e,t)=>e+t),0))).map((e=>e<0));
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * @description For every face, return a boolean indicating if the face has
	 * been flipped over or not (false=flipped), by using the faces_matrix and
	 * checking the determinant.
	 * @param {number[][]} faces_matrix for every face, a 3x4 transform matrix
	 * @returns {boolean[]} true if a face is counter-clockwise.
	 * @linkcode Origami ./src/graph/facesWinding.js 10
	 */var Be=Object.freeze({__proto__:null,makeFacesWindingFromMatrix:e=>e.map((e=>e[0]*e[4]-e[1]*e[3])).map((e=>e>=0))
/**
	 * @description For every face, return a boolean indicating if the face has
	 * been flipped over or not (false=flipped), by using a faces_matrix containing
	 * 2D matrices.
	 * @param {number[][]} faces_matrix for every face, a 2x3 transform matrix
	 * @returns {boolean[]} true if a face is counter-clockwise.
	 * @linkcode Origami ./src/graph/facesWinding.js 21
	 */,makeFacesWindingFromMatrix2:makeFacesWindingFromMatrix2,makeFacesWinding:makeFacesWinding});
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * @description Create a modified graph which separates all faces from each other.
	 * This will add new vertices and new edges. Most adjacency arrays will be
	 * deleted as a lot of it becomes trivial. However, edges_assignment and foldAngle
	 * will remain and be correctly updated to match the new edge indices.
	 * @param {FOLD} graph a FOLD graph, will be modified in place
	 * @returns {object} a summary of changes to the vertices and edges
	 * @linkcode Origami ./src/graph/explodeFaces.js 18
	 */const explode=e=>{
// make sure we have faces_vertices (required) and faces_edges (can be built)
if(!e.faces_vertices)return{};const t=e.faces_edges?e.faces_edges:makeFacesEdgesFromVertices(e),r=e.faces_vertices.flatMap((e=>e)),s=t.flatMap((e=>e));
// every new element's location in the old elements_ arrays.
// build new data
let o=0,n=0,a=0;return e.faces_vertices=e.faces_vertices.map((e=>e.map((()=>o++)))),e.faces_edges=e.faces_edges.map((e=>e.map((()=>n++)))),
// use faces_edges (or vertices) to build a loop, where new edges are made to
// connect new vertices, but when a face is done connect back to its first vertex.
e.edges_vertices=e.faces_edges.flatMap((e=>e.map(((e,t,r)=>{const s=t===r.length-1?[a,a+1-r.length]:[a,a+1];return a+=1,s})))),e.vertices_coords&&(e.vertices_coords=clone(r.map((t=>e.vertices_coords[t])))),e.edges_assignment&&(e.edges_assignment=clone(s.map((t=>e.edges_assignment[t])))),e.edges_foldAngle&&(e.edges_foldAngle=clone(s.map((t=>e.edges_foldAngle[t])))),e.vertices_vertices&&delete e.vertices_vertices,e.vertices_edges&&delete e.vertices_edges,e.vertices_faces&&delete e.vertices_faces,e.edges_edges&&delete e.edges_edges,e.edges_faces&&delete e.edges_faces,e.faces_faces&&delete e.faces_faces,{vertices:{map:r},edges:{map:s}}},explodeFaces=e=>{const t=e.faces_vertices.flatMap((t=>t.map((t=>e.vertices_coords[t]))));let r=0;const s=e.faces_vertices.map((e=>e.map((()=>r++))));
// duplicate vertices are simply duplicate references, changing
// one will still change the others. we need to deep copy the array
return{vertices_coords:JSON.parse(JSON.stringify(t)),faces_vertices:s}},explodeShrinkFaces=({vertices_coords:e,faces_vertices:t},r=.333)=>{const s=explodeFaces({vertices_coords:e,faces_vertices:t}),o=makeFacesWinding(s),n=s.faces_vertices.map((e=>e.map((e=>s.vertices_coords[e])))).map((e=>e.map(((e,t,r)=>subtract2(e,r[(t+1)%r.length]))))),a=makeFacesConvexCenter({vertices_coords:e,faces_vertices:t}),c=t.map((t=>t.map((t=>e[t])))).map(((e,t)=>e.map((e=>distance2(e,a[t]))))),i=n.map(((e,t)=>e.map(((e,t,r)=>[e,flip(r[(t-1+r.length)%r.length])])).map((e=>o[t]?counterClockwiseBisect2(...e):clockwiseBisect2(...e))))).map(((e,t)=>e.map(((e,r)=>scale(e,c[t][r])))));return s.faces_vertices.forEach(((e,t)=>e.forEach(((e,o)=>{s.vertices_coords[e]=add2(s.vertices_coords[e],scale2(i[t][o],-r))})))),s};
/**
	 * @description Create a modified graph which contains vertices_coords and faces_vertices
	 * but that for every face, vertices_coords has been duplicated so that faces
	 * do not share vertices.
	 * @param {FOLD} graph a FOLD graph
	 * @returns {FOLD} a new FOLD graph with exploded faces
	 * @linkcode Origami ./src/graph/explodeFaces.js 71
	 */var Ie=Object.freeze({__proto__:null,explode:explode,explodeFaces:explodeFaces,explodeShrinkFaces:explodeShrinkFaces});
/* Math (c) Kraft, MIT License */
/**
	 * Math (c) Kraft
	 */
/**
	 * @description find the one point in an array of 2D points closest to a 2D point.
	 * @param {number[][]} array_of_points an array of 2D points to test against
	 * @param {number[]} point the 2D point to test nearness to
	 * @returns {number[]} one point from the array of points
	 * @linkcode Math ./src/algebra/nearest.js 86
	 */const nearestPointOnLine=({vector:e,origin:t},r,s=clampLine,o=I)=>{t=resize(e.length,t),r=resize(e.length,r);const n=magSquared(e),a=subtract(r,t),c=s(dot(e,a)/n,o);return add(t,scale(e,c))};
/**
	 * @description find the one point in an array of points closest to a point.
	 * @param {number[][]} array_of_points an array of points to test against
	 * @param {number[]} point the point to test nearness to
	 * @returns {number[]} one point from the array of points
	 * @linkcode Math ./src/algebra/nearest.js 98
	 */var Re=Object.freeze({__proto__:null,nearestPoint:(e,t)=>{
// todo speed up with partitioning
const r=smallestComparisonSearch(e,t,distance);return void 0===r?void 0:e[r]},nearestPoint2:(e,t)=>{
// todo speed up with partitioning
const r=smallestComparisonSearch(e,t,distance2);return void 0===r?void 0:e[r]},nearestPointOnCircle:({radius:e,origin:t},r)=>add(t,scale(normalize(subtract(r,t)),e)),nearestPointOnLine:nearestPointOnLine,nearestPointOnPolygon:(e,t)=>e.map(((e,t,r)=>subtract(r[(t+1)%r.length],e))).map(((t,r)=>({vector:t,origin:e[r]}))).map((e=>nearestPointOnLine(e,t,clampSegment))).map(((e,r)=>({point:e,edge:r,distance:distance(e,t)}))).sort(((e,t)=>e.distance-t.distance)).shift()
/**
	 * @description find the nearest point on the boundary of a circle to another point
	 * that is closest to the provided point.
	 * @param {object} circle object with "radius" (number) and "origin" (number[])
	 * @param {number[]} origin the origin of the circle as an array of numbers.
	 * @param {number[]} point the point to test nearness to
	 * @returns {number[]} a point
	 * @linkcode Math ./src/algebra/nearest.js 151
	 */});
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * @description Iterate through all vertices in a graph and find the one nearest to a
	 * provided point. This is the only of the "nearest" graph operations that works in 3D.
	 * @param {FOLD} graph a FOLD graph
	 * @param {number[]} point the point to find the nearest vertex
	 * @returns {number} the index of the nearest vertex
	 * @todo improve with space partitioning
	 * @linkcode Origami ./src/graph/nearest.js 17
	 */const nearestVertex=({vertices_coords:e},t)=>{if(!e)return;
// resize our point to be the same dimension as the first vertex
const r=resize(e[0].length,t),s=e.map(((e,t)=>({d:distance(r,e),i:t}))).sort(((e,t)=>e.d-t.d)).shift();
// sort by distance, hold onto the original index in vertices_coords
// return index, not vertex
return s?s.i:void 0},nearestEdge=({vertices_coords:e,edges_vertices:t},r)=>{if(!e||!t)return;const s=t.map((t=>t.map((t=>e[t])))).map((e=>nearestPointOnLine({vector:subtract(e[1],e[0]),origin:e[0]},r,clampSegment)));return smallestComparisonSearch(s,r,distance)},faceContainingPoint=({vertices_coords:e,faces_vertices:t},r)=>{if(!e||!t)return;const s=t.map(((t,r)=>({face:t.map((t=>e[t])),i:r}))).filter((e=>overlapConvexPolygonPoint(e.face,r))).shift();return void 0===s?void 0:s.i},nearestFace=(e,t)=>{const r=faceContainingPoint(e,t);if(void 0!==r)return r;if(e.edges_faces){const r=nearestEdge(e,t),s=e.edges_faces[r];if(1===s.length)return s[0];if(s.length>1){const r=makeFacesConvexCenter({vertices_coords:e.vertices_coords,faces_vertices:s.map((t=>e.faces_vertices[t]))}).map((e=>distance(e,t)));let o=0;for(let e=0;e<r.length;e+=1)r[e]<r[o]&&(o=e);return s[o]}}};
/**
	 * @description Iterate through all edges in a graph and find the one nearest to a provided point.
	 * @param {FOLD} graph a FOLD graph
	 * @param {number[]} point the point to find the nearest edge
	 * @returns {number|undefined} the index of the nearest edge, or undefined
	 * if there are no vertices_coords or edges_vertices
	 * @linkcode Origami ./src/graph/nearest.js 37
	 */
/**
	 * @todo this needs testing: does the cache cause a memory leak after many repeated calls?
	 */
// export const nearest = (graph, ...args) => {
// 	const nearestMethods = {
// 		vertices: nearestVertex,
// 		edges: nearestEdge,
// 		faces: nearestFace,
// 	};
// 	const point = getVector(...args);
// 	const nears = Object.create(null);
// 	const cache = {};
// 	["vertices", "edges", "faces"].forEach(key => {
// 		Object.defineProperty(nears, singularize[key], {
// 			enumerable: true,
// 			get: () => {
// 				if (cache[key] !== undefined) { return cache[key]; }
// 				cache[key] = nearestMethods[key](graph, point);
// 				return cache[key];
// 			},
// 		});
// 		filterKeysWithPrefix(graph, key)
// 			.forEach(fold_key => Object.defineProperty(nears, fold_key, {
// 				enumerable: true,
// 				get: () => graph[fold_key][nears[singularize[key]]],
// 			}));
// 	});
// 	return nears;
// };
var Ue=Object.freeze({__proto__:null,nearestVertex:nearestVertex,nearestEdge:nearestEdge,faceContainingPoint:faceContainingPoint,nearestFace:nearestFace,nearest:(e,...t)=>{const r={vertices:nearestVertex,edges:nearestEdge,faces:nearestFace},s=getVector(...t),o=Object.create(null);return["vertices","edges","faces"].forEach((t=>{Object.defineProperty(o,Q[t],{enumerable:!0,get:()=>r[t](e,s)}),filterKeysWithPrefix(e,t).forEach((r=>Object.defineProperty(o,r,{enumerable:!0,get:()=>e[r][o[Q[t]]]})))})),o}});
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * @description add vertices to a graph by adding their vertices_coords only. This
	 * will also compare against every existing vertex, only adding non-duplicate
	 * vertices, as determined by an epsilon.
	 * @param {FOLD} graph a FOLD graph, modified in place.
	 * @param {number[][]} vertices_coords array of points to be added to the graph
	 * @param {number} [epsilon=1e-6] optional epsilon to merge similar vertices
	 * @returns {number[]} index of vertex in new vertices_coords array.
	 * the size of this array matches array size of source vertices.
	 * duplicate (non-added) vertices returns their pre-existing counterpart's index.
	 * @linkcode Origami ./src/graph/add/addVertices.js 15
	 */const addVertices=(e,t,r=I)=>{e.vertices_coords||(e.vertices_coords=[]),
// the user messed up the input and only provided one vertex
// it's easy to fix for them
"number"==typeof t[0]&&(t=[t]);
// make an array that matches the new vertices_coords where each entry is either
// - undefined, if the vertex is unique
// - number, index of duplicate vertex in source graph, if duplicate exists
const s=t.map((t=>e.vertices_coords.map((e=>distance(e,t)<r)).map(((e,t)=>e?t:void 0)).filter((e=>void 0!==e)).shift()));
// to be used in the return data array
let o=e.vertices_coords.length;
// add the unique vertices to the destination graph
const n=t.filter(((e,t)=>void 0===s[t]));
// return the indices of the added vertices in the destination graph
return e.vertices_coords.push(...n),s.map((e=>void 0===e?o++:e))},splitEdge=(e,t,r,s=I)=>{
// make sure old_edge is a valid index
if(e.edges_vertices.length<t)return{};const o=e.edges_vertices[t];r||(r=midpoint(...o));
// test similarity with the incident vertices, if similar, return.
const a=o.map((t=>e.vertices_coords[t])).map((e=>distance(e,r)<s));if(a[0])return{vertex:o[0],edges:{}};if(a[1])return{vertex:o[1],edges:{}};
// the new vertex will sit at the end of the array
const c=e.vertices_coords.length;e.vertices_coords[c]=r;
// indices of new edges
const i=[0,1].map((t=>t+e.edges_vertices.length));
// create 2 new edges, add them to the graph
((e,t,r)=>{const s=e.edges_vertices[t],o=[{edges_vertices:[s[0],r]},{edges_vertices:[r,s[1]]}];
// these are outside the spec values that are easy enough to calculate.
// only update them if they exist!
if(o.forEach((r=>[m,g].filter((r=>e[r]&&void 0!==e[r][t])).forEach((s=>{r[s]=e[s][t]})))),e.vertices_coords&&(e.edges_length||e.edges_vector)){const t=o.map((t=>t.edges_vertices.map((t=>e.vertices_coords[t]))));e.edges_vector&&o.forEach(((e,r)=>{e.edges_vector=subtract(t[r][1],t[r][0])})),e.edges_length&&o.forEach(((e,r)=>{e.edges_length=distance(...t[r])}))}return o})(e,t,c).forEach(((t,r)=>Object.keys(t).forEach((s=>{e[s][i[r]]=t[s]})))),
// done with: vertices_coords, edges_vertices, edges_assignment, edges_foldAngle
(({vertices_vertices:e},t,r)=>{e&&(
// create a new entry for this new vertex
// only 2 vertices, no need to worry about winding order.
e[t]=[...r],
// for each incident vertex in the vertices_vertices, replace the other incident
// vertex's entry with this new vertex, the new vertex takes its place.
r.forEach(((r,s,o)=>{const n=o[(s+1)%o.length],a=e[r].indexOf(n);e[r][a]=t})))})(e,c,o),(({vertices_coords:e,vertices_vertices:t,vertices_sectors:r},s)=>{r&&(r[s]=1===t[s].length?[D]:counterClockwiseSectors2(t[s].map((t=>subtract2(e[t],e[s])))))})(e,c),// after vertices_vertices
(({vertices_edges:e},t,r,s,o)=>{e&&(
// update 1 vertex, our new vertex
e[r]=[...o],
// update the two vertices, our new vertex replaces the alternate
// vertex in each of their arrays.  0-------x-------0
s.map((r=>e[r].indexOf(t))).forEach(((t,r)=>{e[s[r]][t]=o[r]})))})(e,t,c,o,i);
// done with: vertices_edges, vertices_vertices, and
// vertices_sectors if it exists.
const l=(({vertices_faces:e,edges_vertices:t,edges_faces:r,faces_edges:s,faces_vertices:o},n)=>{
// easiest case, if edges_faces already exists.
if(r&&r[n])return r[n];
// if that doesn't exist, uncover the data by looking at our incident
// vertices' faces, compare every index against every index, looking
// for 2 indices that are present in both arrays. there should be 2.
const a=t[n];if(void 0!==e){const t=[];for(let r=0;r<e[a[0]].length;r+=1)for(let s=0;s<e[a[1]].length;s+=1)if(e[a[0]][r]===e[a[1]][s]){
// todo: now allowing undefined to be in vertices_faces,
// but, do we want to exclude them from the result?
if(void 0===e[a[0]][r])continue;t.push(e[a[0]][r])}return t}if(s){const e=[];for(let t=0;t<s.length;t+=1)for(let r=0;r<s[t].length;r+=1)s[t][r]===n&&e.push(t);return e}o&&console.warn("todo: findAdjacentFacesToEdge")})(e,t);l&&((({vertices_faces:e},t,r)=>{e&&(e[t]=[...r])})(e,c,l),(({edges_faces:e},t,r)=>{e&&t.forEach((t=>{e[t]=[...r]}))})(e,i,l),(({faces_vertices:e},t,r,s)=>{
// exit if we don't even have faces_vertices
e&&s.map((t=>e[t])).forEach((e=>e.map(((e,t,s)=>{const o=(t+1)%s.length;return e===r[0]&&s[o]===r[1]||e===r[1]&&s[o]===r[0]?o:void 0})).filter((e=>void 0!==e)).sort(((e,t)=>t-e)).forEach((r=>e.splice(r,0,t)))))})(e,c,o,l),(({edges_vertices:e,faces_vertices:t,faces_edges:r},s)=>{const o=makeVerticesToEdgeBidirectional({edges_vertices:e});s.map((e=>t[e].map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>o[e.join(" ")])))).forEach(((e,t)=>{r[s[t]]=e}))})(e,l));
// done with: vertices_faces, edges_faces, faces_vertices, faces_edges
// and we don't need to bother with faces_faces and faceOrders.
// todo: edgeOrders. the only spec key remaining.
// remove old data
const d=removeGeometryIndices(e,n,[t]);
// shift our new edge indices since these relate to the graph before remove().
return i.forEach(((e,t)=>{i[t]=d[i[t]]})),
// we had to run "remove" with the new edges added. to return the change info,
// we need to adjust the map to exclude these edges.
d.splice(-2),
// replace the "undefined" in the map with the two new edge indices.
d[t]=i,{vertex:c,edges:{map:d,new:i,remove:t}}},rebuild_edge=(e,t,r)=>{
// now that 2 vertices are in place, add a new edge between them.
const s=e.edges_vertices.length,o=(({vertices_coords:e},t,r)=>{
// coords reversed for "vector", so index [0] comes last in subtract
const s=t.map((t=>e[t])).reverse();return{edges_vertices:[...t],edges_foldAngle:0,edges_assignment:"U",edges_length:distance(...s),edges_vector:subtract(...s),edges_faces:[r,r]}})(e,r,t);
// construct data for our new edge (vertices, assignent, foldAngle...)
// and the entry for edges_faces will be [x, x] where x is the index of
// the old face, twice, and will be replaced later in this function.
// ignoring any keys that aren't a part of our graph, add the new edge
return Object.keys(o).filter((t=>void 0!==e[t])).forEach((t=>{e[t][s]=o[t]})),s},build_faces=(e,t,r)=>{
// new face indices at the end of the list
const s=[0,1].map((t=>e.faces_vertices.length+t));
// construct new face data for faces_vertices, faces_edges
// add them to the graph
return(({edges_vertices:e,faces_vertices:t,faces_edges:r},s,o)=>{
// the indices of the two vertices inside the face_vertices array.
// this is where we will split the face into two.
const n=o.map((e=>t[s].indexOf(e))),a=splitCircularArray(t[s],n).map((e=>({faces_vertices:e})));if(r){
// table to build faces_edges
const t=makeVerticesToEdgeBidirectional({edges_vertices:e});a.map((e=>e.faces_vertices.map(((e,t,r)=>`${e} ${r[(t+1)%r.length]}`)).map((e=>t[e])))).forEach(((e,t)=>{a[t].faces_edges=e}))}return a})(e,t,r).forEach(((t,r)=>Object.keys(t).forEach((o=>{e[o][s[r]]=t[o]})))),s},splitFace=(e,t,r,s,o)=>{
// survey face for any intersections which cross directly over a vertex
const n=intersectConvexFaceLine(e,t,{vector:r,origin:s},o);
// if no intersection exists, return undefined.
if(void 0===n)return;
// this result will be appended to (vertices, edges) and returned by this method.
const c=((e,{vertices:t,edges:r})=>{
// intersection will contain 2 items, either in "vertices" or "edges",
// however we will split edges and store their new vertex in "vertices"
// so in the end, "vertices" will contain 2 items.
let s;
// split the edge (modifying the graph), and store the changes so that during
// the next loop the second edge to split will be updated to the new index
const o=r.map((t=>{const r=splitEdge(e,s?s[t.edge]:t.edge,t.coords);return s=s?mergeNextmaps(s,r.edges.map):r.edges.map,r}));
// if two edges were split, the second one contains a "remove" key that was
// based on the mid-operation graph, update this value to match the graph
// before any changes occurred.
let n;
// todo: if we extend this to include non-convex polygons, this is the
// only part of the code we need to test. cumulative backmap merge.
// this was written without any testing, as convex polygons never have
// more than 2 intersections
return t.push(...o.map((e=>e.vertex))),o.forEach((e=>{e.edges.remove=n?n[e.edges.remove]:e.edges.remove;const t=invertSimpleMap(e.edges.map);n=n?mergeBackmaps(n,t):t})),{vertices:t,edges:{map:s,remove:o.map((e=>e.edges.remove))}}})(e,n);
// this modifies the graph by only adding an edge between existing vertices
c.edges.new=rebuild_edge(e,t,c.vertices),
// update all changes to vertices and edges (anything other than faces).
(({vertices_coords:e,vertices_vertices:t,edges_vertices:r},s)=>{const o=r[s][0],n=r[s][1];t[o]=sortVerticesCounterClockwise({vertices_coords:e},t[o].concat(n),o),t[n]=sortVerticesCounterClockwise({vertices_coords:e},t[n].concat(o),n)})(e,c.edges.new),(({edges_vertices:e,vertices_edges:t,vertices_vertices:r},s)=>{
// the expensive way, rebuild all arrays
// graph.vertices_edges = makeVerticesEdges(graph);
if(!t||!r)return;const o=e[s];
// for each of the two vertices, check its vertices_vertices for the
// index of the opposite vertex. this is the edge. return its position
// in the vertices_vertices to be used to insert into vertices_edges.
o.map((e=>r[e])).map(((e,t)=>e.indexOf(o[(t+1)%o.length]))).forEach(((e,r)=>t[o[r]].splice(e,0,s)))})(e,c.edges.new);
// done: vertices_coords, vertices_edges, vertices_vertices, edges_vertices
// at this point the graph is once again technically valid, except
// the face data is a little weird as one face is ignoring the newly-added
// edge that cuts through it.
const i=build_faces(e,t,c.vertices);
// update all arrays having to do with face data
((e,t,r)=>{
// for each of the vertices (only the vertices involved in this split),
// use the new faces_vertices data (built in the previous method) to get
// a list of the new faces to be added to this vertex's vertices_faces.
const s={};r.forEach((t=>e.faces_vertices[t].forEach((e=>{s[e]||(s[e]=[]),s[e].push(t)})))),
// these vertices need updating
e.faces_vertices[t].forEach((r=>{const o=e.vertices_faces[r].indexOf(t),n=s[r];if(-1===o||!n)throw new Error(S);e.vertices_faces[r].splice(o,1,...n)}))})(e,t,i),((e,t,r,s)=>{
// for each of the edges (only the edges involved in this split),
// use the new faces_edges data (built in the previous method) to get
// a list of the new faces to be added to this edge's edges_faces.
// most will be length of 1, except the edge which split the face will be 2.
const o={};s.forEach((t=>e.faces_edges[t].forEach((e=>{o[e]||(o[e]=[]),o[e].push(t)})))),[...e.faces_edges[t],r].forEach((r=>{
// these are the faces which should be inserted into this edge's
// edges_faces array, we just need to find the old index to replace.
const s=o[r],n=[];
// basically rewriting .indexOf(), but supporting multiple results.
// these will be the indices containing a reference to the old face.
for(let s=0;s<e.edges_faces[r].length;s+=1)e.edges_faces[r][s]===t&&n.push(s);if(0===n.length||!s)throw new Error(S);
// "indices" will most often be length 1, except for the one edge which
// was added which splits the face in half. the previous methods which
// did this gave that edge two references both to the same face, knowing
// that here we will replace both references to the pair of the new
// faces which the edge now divides.
// remove the old indices.
n.reverse().forEach((t=>e.edges_faces[r].splice(t,1)));
// in both cases when "indices" is length 1 or 2, get just one index
// at which to insert the new reference(s).
const a=n[n.length-1];e.edges_faces[r].splice(a,0,...s)}))})(e,t,c.edges.new,i),(({faces_vertices:e,faces_faces:t},r,s)=>{
// this is presuming that new_faces have their updated faces_vertices by now
const o=t[r],n=s.map((t=>e[t])),a=o.map((t=>{const r=e[t],o=[0,0];for(let e=0;e<n.length;e+=1){let t=0;for(let s=0;s<r.length;s+=1)-1!==n[e].indexOf(r[s])&&(t+=1);o[e]=t}return o[0]>=2?s[0]:o[1]>=2?s[1]:void 0}));
// prepare the new faces' face_faces empty arrays, filled with one
// face, the opposite of the pair of the new faces.
s.forEach(((e,r,o)=>{t[e]=[o[(r+1)%s.length]]})),
// 2 things, fill the new face's arrays and update each of the
// incident faces to point to the correct of the two new faces.
o.forEach(((e,s)=>{for(let o=0;o<t[e].length;o+=1)t[e][o]===r&&(t[e][o]=a[s],t[a[s]].push(e))}))})(e,t,i);
// remove old data
const l=removeGeometryIndices(e,a,[t]);
// the graph is now complete, however our return object needs updating.
// shift our new face indices since these relate to the graph before remove().
return i.forEach(((e,t)=>{i[t]=l[i[t]]})),
// we had to run "remove" with the new faces added. to return the change info,
// we need to adjust the map to exclude these faces.
l.splice(-2),
// replace the "undefined" in the map with the two new edge indices.
l[t]=i,c.faces={map:l,new:i,remove:t},c},De={};
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * @description Given an edge, uncover the adjacent faces.
	 * @param {FOLD} graph a FOLD graph
	 * @param {number} edge index of the edge in the graph
	 * {number[]} indices of the two vertices making up the edge
	 * @returns {number[]} array of 0, 1, or 2 numbers, the edge's adjacent faces
	 * @linkcode Origami ./src/graph/find.js 10
	 */De.prototype=Object.create(Object.prototype),De.prototype.constructor=De;
/**
	 * methods where "graph" is the first parameter, followed by ...arguments
	 * func(graph, ...args)
	 */
const qe={
// count,
clean:clean,validate:validate,populate:populate,fragment:fragment,
// subgraph,
// assign,
// convert snake_case to camelCase
addVertices:addVertices,splitEdge:splitEdge,faceSpanningTree:makeFaceSpanningTree,explodeFaces:explodeFaces,explodeShrinkFaces:explodeShrinkFaces,...Se};Object.keys(qe).forEach((e=>{De.prototype[e]=function(){return qe[e](this,...arguments)}})),
/**
	 * methods below here need some kind of pre-processing of their arguments
	 */
De.prototype.splitFace=function(e,...t){const r=getLine$1(...t);return splitFace(this,e,r.vector,r.origin)},
/**
	 * @returns {this} a deep copy of this object
	 */
De.prototype.copy=function(){
// return Object.assign(Object.create(Graph.prototype), clone(this));
// return Object.assign(Object.create(this.__proto__), clone(this));
return Object.assign(Object.create(Object.getPrototypeOf(this)),clone(this));
// todo: switch this for:
// Object.getPrototypeOf(this);
},
/**
	 * @param {object} is a FOLD object.
	 * @param {options}
	 *   "append" import will first, clear FOLD keys. "append":true prevents this clearing
	 */
// Graph.prototype.load = function (object, options = {}) {
//   if (typeof object !== S._object) { return; }
//   if (options.append !== true) {
//     keys.forEach(key => delete this[key]);
//   }
//   // allow overwriting of file_spec and file_creator if included in import
//   Object.assign(this, { file_spec, file_creator }, clone(object));
// };
/**
	 * this clears all components from the graph, leaving metadata and other
	 * keys untouched.
	 */
De.prototype.clear=function(){return J.graph.forEach((e=>delete this[e])),J.orders.forEach((e=>delete this[e])),
// the code above just avoided deleting all "file_" keys,
// however, file_frames needs to be removed as it contains geometry.
delete this.file_frames,this},
/**
	 * @description get the axis-aligned bounding rectangle that encloses
	 * all the vertices of the graph. not only the boundary vertices.
	 */
De.prototype.boundingBox=function(){return boundingBox$1(this.vertices_coords)},
/**
	 * @description alter the vertices by moving the corner of the graph
	 * to the origin and shrink or expand the vertices until they
	 * aspect fit inside the unit square.
	 */
De.prototype.unitize=function(){if(!this.vertices_coords)return this;const e=boundingBox$1(this.vertices_coords),t=Math.max(...e.span),r=0===t?1:1/t,s=e.min;return this.vertices_coords=this.vertices_coords.map((e=>subtract(e,s))).map((e=>e.map((e=>e*r)))),this},
/**
	 * @description return a copy of this graph with the vertices folded.
	 * This method works for both 2D and 3D origami.
	 * The angle of the fold is searched for in this order:
	 * - faces_matrix2 if it exists
	 * - edges_foldAngle if it exists
	 * - edges_assignment if it exists
	 * Careful, repeated calls to this method will repeatedly fold the vertices
	 * resulting in a behavior that is surely unintended.
	 */
De.prototype.folded=function(){const e=this.faces_matrix2?multiplyVerticesFacesMatrix2(this,this.faces_matrix2):makeVerticesCoordsFolded(this,...arguments);
// const faces_layer = this["faces_re:layer"]
//   ? this["faces_re:layer"]
//   : makeFacesLayer(this, arguments[0], 0.001);
return Object.assign(
// todo: switch this for:
Object.create(Object.getPrototypeOf(this)),
// Object.create(this.__proto__),
Object.assign(clone(this),{vertices_coords:e,
// "faces_re:layer": faces_layer,
frame_classes:[_]}));
// delete any arrays that becomes incorrect due to folding
// delete copy.edges_vector;
// return copy;
},
/**
	 * @description return a copy of this graph with the vertices folded.
	 * This method will work for 2D only.
	 * The angle of the fold is searched for in this order:
	 * - faces_matrix2 if it exists
	 * - edges_assignment or edges_foldAngle if it exists
	 * If neither exists, this method will assume that ALL edges are flat-folded.
	 */
De.prototype.flatFolded=function(){const e=this.faces_matrix2?multiplyVerticesFacesMatrix2(this,this.faces_matrix2):makeVerticesCoordsFlatFolded(this,...arguments);return Object.assign(
// todo: switch this for:
// Object.getPrototypeOf(this);
Object.create(Object.getPrototypeOf(this)),
// Object.create(this.__proto__),
Object.assign(clone(this),{vertices_coords:e,frame_classes:[_]}))};
/**
	 * graph components
	 */
// bind "vertices", "edges", or "faces" to "this"
// then we can pass in this function directly to map()
const shortenKeys=function(e){const t=Object.create(null);return Object.keys(e).forEach((r=>{t[r.substring(this.length+1)]=e[r]})),t},getComponent=function(e){return transposeGraphArrays(this,e).map(shortenKeys.bind(e)).map(H[e].bind(this))};
// bind the FOLD graph to "this"
[o,n,a].forEach((e=>Object.defineProperty(De.prototype,e,{enumerable:!0,get:function(){return getComponent.call(this,e)}}))),
// todo: get boundaries, plural
// get boundary. only if the edges_assignment
Object.defineProperty(De.prototype,v,{enumerable:!0,get:function(){const e=boundary(this),t=e.vertices.map((e=>this.vertices_coords[e]));
// const poly = math.polygon(b.vertices.map(v => this.vertices_coords[v]));
return Object.keys(e).forEach((r=>{t[r]=e[r]})),Object.assign(t,e)}});
/**
	 * graph components based on Euclidean distance
	 */
const Ge={vertices:nearestVertex,edges:nearestEdge,faces:nearestFace};
/**
	 * @description given a point, this will return the nearest vertex, edge,
	 * and face, as well as the nearest entry inside all of the "vertices_",
	 * "edges_", and "faces_" arrays.
	 */De.prototype.nearest=function(){const e=getVector(arguments),t=Object.create(null),r={};return[o,n,a].forEach((s=>{Object.defineProperty(t,Q[s],{enumerable:!0,get:()=>(void 0!==r[s]||(r[s]=Ge[s](this,e)),r[s])}),filterKeysWithPrefix(this,s).forEach((e=>Object.defineProperty(t,e,{enumerable:!0,get:()=>this[e][t[Q[s]]]})))})),t};var We=De.prototype;
/* Math (c) Kraft, MIT License */
/**
	 * Math (c) Kraft
	 */const linePointFromParameter=(e,t,r)=>add2(t,scale2(e,r))
// get all intersections with polgyon faces using the polyLineFunc:
// - includeS or excludeS
// sort them so we can grab the two most opposite intersections
,getIntersectParameters=(e,t,r,s,o)=>e.map(((e,t,r)=>[subtract2(r[(t+1)%r.length],e),e])).map((e=>((e,t,r,s,o=includeS,n=I)=>{
// a normalized determinant gives consistent values across all epsilon ranges
const a=cross2(normalize2(e),normalize2(r));
// lines are parallel
if(Math.abs(a)<n)return;const c=cross2(e,r),i=-c,l=subtract2(s,t),d=flip(l),m=cross2(l,r)/c;return o(cross2(d,e)/i,n/magnitude2(r))?m:void 0})(t,r,e[0],e[1],s,o))).filter((e=>void 0!==e)).sort(((e,t)=>e-t))
// we have already done the test that numbers is a valid array
// and the length is >= 2
,clipLineConvexPolygon=(e,{vector:t,origin:r},s=include,o=includeL,n=I)=>{const a=getIntersectParameters(e,t,r,includeS,n);if(a.length<2)return;const c=((e,t,r)=>{let s=0,o=e.length-1;for(;s<o&&!t(e[s+1]-e[s],r);)s+=1;for(;o>s&&!t(e[o]-e[o-1],r);)o-=1;if(!(s>=o))return[e[s],e[o]]})(a,s,2*n/magnitude2(t));
// ends is now an array, length 2, of the min and max parameter on the line
// this also verifies the two intersections are not the same point
if(void 0===c)return;
// ends_clip is the intersection between 2 domains, the result
// and the valid inclusive/exclusive function
// todo: this line hardcodes the parameterization that segments and rays are cropping
// their lowest point at 0 and highest (if segment) at 1
const i=c.map((e=>o(e)?e:e<.5?0:1));
// if endpoints are the same, exit
if(Math.abs(i[0]-i[1])<2*n/magnitude2(t))return;
// test if the solution is collinear to an edge by getting the segment midpoint
// then test inclusive or exclusive depending on user parameter
const l=linePointFromParameter(t,r,(i[0]+i[1])/2);return overlapConvexPolygonPoint(e,l,s,n)?i.map((e=>linePointFromParameter(t,r,e))):void 0},clipPolygonPolygon=(e,t,r=I)=>{const inside=(e,t,s)=>(s[0]-t[0])*(e[1]-t[1])>(s[1]-t[1])*(e[0]-t[0])+r,intersection=(e,t,r,s)=>{const o=subtract2(e,t),n=subtract2(s,r),a=cross2(e,t),c=cross2(s,r),i=1/cross2(o,n);
// return [
// 	(n1 * dp[0] - n2 * dc[0]) * n3,
// 	(n1 * dp[1] - n2 * dc[1]) * n3,
// ];
return scale2(subtract2(scale2(n,a),scale2(o,c)),i)};let s=e,o=t[t.length-1];for(let e=0;e<t.length;e+=1){const r=t[e],n=s;s=[];let a=n[n.length-1];for(let e=0;e<n.length;e+=1){const t=n[e];inside(t,o,r)?(inside(a,o,r)||s.push(intersection(o,r,t,a)),s.push(t)):inside(a,o,r)&&s.push(intersection(o,r,t,a)),a=t}o=r}return 0===s.length?void 0:s};var He=Object.freeze({__proto__:null,clipLineConvexPolygon:clipLineConvexPolygon,clipPolygonPolygon:clipPolygonPolygon});
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * @description Clip a line inside the boundaries of a graph, resulting in
	 * one segment or undefined. The line can be a line, ray, or segment.
	 * @param {FOLD} graph a FOLD graph
	 * @param {RayLine|number[][]} line a line or a segment
	 * @returns {number[][]|undefined} a segment, a pair of two points,
	 * or undefined if no intersection
	 * @linkcode Origami ./src/graph/clip.js 13
	 */const clip=function(e,t){const r=boundary(e).vertices.map((t=>e.vertices_coords[t])),s=t.vector?t.vector:subtract2(t[1],t[0]),o=t.origin?t.origin:t[0],n=t.domain?t.domain:includeL;return clipLineConvexPolygon(r,{vector:s,origin:o},include,n)},addEdges=(e,t)=>{e.edges_vertices||(e.edges_vertices=[]),
// the user messed up the input and only provided one edge
// it's easy to fix for them
"number"==typeof t[0]&&(t=[t]);const r=t.map(((t,r)=>e.edges_vertices.length+r));e.edges_vertices.push(...t);const s=removeDuplicateEdges(e).map;return r.map((e=>s[e]))},addPlanarSegment=(e,t,r,s=I)=>{
// vertices_sectors not a part of the spec, might not be included.
// this is needed for when we walk faces. we need to be able to
// identify the one face that winds around the outside enclosing Infinity.
e.vertices_sectors||(e.vertices_sectors=makeVerticesSectors(e));
// flatten input points to the Z=0 plane
const o=[t,r].map((e=>[e[0],e[1]])),n=subtract2(o[1],o[0]),a=makeEdgesSegmentIntersection(e,o[0],o[1],s),c=a.map(((e,t)=>void 0===e?void 0:t)).filter((e=>void 0!==e)).sort(((e,t)=>e-t)),i={};c.forEach((t=>e.edges_faces[t].forEach((e=>{i[e]=!0}))));const l=Object.keys(i).map((e=>parseInt(e,10))).sort(((e,t)=>e-t)),d=c.reverse().map((t=>splitEdge(e,t,a[t],s))).map((e=>e.vertex)),m=addVertices(e,o,s),g={};
// split all intersected edges into two edges, in reverse order
// so that the "remove()" call only ever removes the last from the
// set of edges. each splitEdge call also rebuilds all graph data,
// vertices, faces, adjacent of each, etc..
d.forEach((e=>{g[e]=!0})),m.forEach((e=>{g[e]=!0}));const p=Object.keys(g).map((e=>parseInt(e,10))),v=sortVerticesAlongVector(e,p,n),u=makeVerticesToEdgeBidirectional(e),h=((e,t,r)=>{
// without looking at the graph, connect all the segment vertices
// fenceposted to create a list of N-1 edges.
const s=Array.from(Array(t.length-1)).map(((e,r)=>[t[r],t[r+1]])),o=s.map((e=>e.join(" "))).map((e=>void 0===r[e])),n=s.filter(((e,t)=>o[t])),a=Array.from(Array(n.length)).map(((t,r)=>e.edges_vertices.length+r));
// check the list of segments against the edge_map and mark
// each segment which already exists as "false".
// add new edges to the graph, these edges compose the new segment.
// add edges_vertices.
a.forEach(((t,r)=>{e.edges_vertices[t]=n[r]})),
// only update these arrays if they exist.
e.edges_assignment&&a.forEach((t=>{e.edges_assignment[t]="U"})),e.edges_foldAngle&&a.forEach((t=>{e.edges_foldAngle[t]=0}));
// build vertices_vertices
// for each vertex (n), get the previous (n-1) and the next (n+1)
// by default, the endpoints will not have neighbor vertices on either side,
// and most importantly, use the "seg_not_exist_yet" from earlier to
// check if an edge already existed, and prevent joining vertices across
// these already existing edges.
for(let r=0;r<t.length;r+=1){const s=t[r],n=[o[r-1]?t[r-1]:void 0,o[r]?t[r+1]:void 0].filter((e=>void 0!==e)),a=(e.vertices_vertices[s]?e.vertices_vertices[s]:[]).concat(n);e.vertices_vertices[s]=sortVerticesCounterClockwise(e,a,t[r])}
// build vertices_edges from vertices_vertices
const c=makeVerticesToEdgeBidirectional(e);for(let r=0;r<t.length;r+=1){const s=t[r];e.vertices_edges[s]=e.vertices_vertices[s].map((e=>c[`${s} ${e}`]))}
// build vertices_sectors from vertices_vertices
return t.map((t=>1===e.vertices_vertices[t].length?[D]:counterClockwiseSectors2(e.vertices_vertices[t].map((r=>subtract2(e.vertices_coords[r],e.vertices_coords[t])))))).forEach(((r,s)=>{e.vertices_sectors[t[s]]=r})),a})(e,v,u);
// these vertices are sorted in the direction of the segment
// update the edge_map with the new segment edges. this is needed for
// after we walk faces, the faces_edges data comes in the form of
// vertex pairs, and we need to be able to look up these new edges.
h.forEach((t=>{const r=e.edges_vertices[t];u[`${r[0]} ${r[1]}`]=t,u[`${r[1]} ${r[0]}`]=t}));
// in preparation to rebuild faces, we need a set of edges (as a
// pair of vertices) to begin a counter-clockwise walk. it's
// insufficient to simply start the walks from all of the new segment's
// edges, as it would fail this case: the segment splits a face and
// ends collinear, so that no part of the segment exists INSIDE the face
// and the face will never be walked.
// __________
// [        ]   segment
// [  face  O-------------
// [        ]
// ----------
// therefore, we will use all of the vertices_vertices from the
// segment's vertices. this seems to cover all cases.
// additionally, we don't have to worry about repeating faces, the
// method has a protection against that ("walked_edges").
const _=v.map((t=>e.vertices_vertices[t].map((e=>[[e,t],[t,e]])))).reduce(((e,t)=>e.concat(t)),[]).reduce(((e,t)=>e.concat(t)),[]),b={},y=_.map((t=>counterClockwiseWalk(e,t[0],t[1],b))).filter((e=>void 0!==e)),E=filterWalkedBoundaryFace(y);
// graph.vertices_sectors = makeVerticesSectors(graph);
// memo to prevent duplicate faces. this one object should be
// applied globally to all calls to the method.
// const walked_faces = all_walked_faces;
// this method could be called before or after the walk. but
// for simplicity we're calling it before adding the new faces.
removeGeometryIndices(e,"faces",l);
// todo: this assumes faces_vertices exists.
const x=E.map(((t,r)=>e.faces_vertices.length+r));
// add each array, only if they exist.
// console.log("intersected_edges", intersected_edges);
// console.log("intersected_faces", intersected_faces);
// console.log("splitEdge_results", splitEdge_results);
// console.log("splitEdge_map", splitEdge_map);
// console.log("splitEdge_vertices", splitEdge_vertices);
// console.log("vertices_vertices", splitEdge_vertices
//   .map(v => graph.vertices_vertices[v]));
// console.log("endpoint_vertices", endpoint_vertices);
// console.log("new_vertices", new_vertices);
// console.log("segment_vertices", segment_vertices);
// console.log("segment_vertex_pairs", segment_vertex_pairs);
// console.log("walked_faces", walked_faces);
// console.log("new_check", new_check);
return e.faces_vertices&&x.forEach(((t,r)=>{e.faces_vertices[t]=E[r].vertices})),
// edges are in vertex pairs. these need to be converted to edges
e.faces_edges&&x.forEach(((t,r)=>{e.faces_edges[t]=E[r].edges.map((e=>u[e]))})),
// tbh, this array is not typically used.
e.faces_angles&&x.forEach(((t,r)=>{e.faces_angles[t]=E[r].faces_angles})),
// update all the arrays which reference face arrays, this includes
// vertices_faces, edges_faces, faces_faces (all that end with _faces)
e.vertices_faces&&(e.vertices_faces=makeVerticesFaces(e)),e.edges_faces&&(e.edges_faces=makeEdgesFacesUnsorted(e)),e.faces_faces&&(e.faces_faces=makeFacesFaces(e)),
// todo, get rid of this after testing.
e.vertices_coords.length===e.vertices_vertices.length&&e.vertices_coords.length===e.vertices_edges.length&&e.vertices_coords.length===e.vertices_faces.length||console.warn("vertices mismatch",JSON.parse(JSON.stringify(e))),e.edges_vertices.length===e.edges_faces.length&&e.edges_vertices.length===e.edges_assignment.length||console.warn("edges mismatch",JSON.parse(JSON.stringify(e))),e.faces_vertices.length===e.faces_edges.length&&e.faces_vertices.length===e.faces_faces.length||console.warn("faces mismatch",JSON.parse(JSON.stringify(e))),h},removePlanarEdge=(e,t)=>{
// the edge's vertices, sorted large to small.
// if they are isolated, we want to remove them.
const r=[...e.edges_vertices[t]].sort(((e,t)=>t-e)),s=[...e.edges_faces[t]];
// console.log("removing edge", edge, "with", faces.length, "adjacent faces",
// faces, "and", vertices.length, "adjacent vertices", vertices);
(({vertices_vertices:e},t)=>{const r=[t[1],t[0]];t.map(((t,s)=>e[t].indexOf(r[s]))).forEach(((r,s)=>e[t[s]].splice(r,1)))})(e,r),(({vertices_edges:e},t,r)=>{r.map(((r,s)=>e[r].indexOf(t))).forEach(((t,s)=>e[r[s]].splice(t,1)))})(e,t,r);
// is the vertex isolated? if so, mark it for removal
// either 0, 1, or 2 vertices are able to be removed.
// wait until the end to remove these.
const o=r.map((t=>0===e.vertices_vertices[t].length)),n=r.filter(((e,t)=>o[t]));
// only if the edge has two adjacent faces, and those faces are unique,
// construct a new face by joining the two faces together at the edge.
if(2===s.length&&s[0]!==s[1]){
// the index of the new face, the three faces (new and 2 old) are
// going to temporarily coexist in the graph, before the 2 are removed.
const o=e.faces_vertices.length,n=((e,t,r,s)=>{
// const other = [faces[1], faces[0]];
// the index of the edge in the face's faces_edges array.
const o=t.map((t=>e.faces_edges[t].indexOf(r))),n=[];
// the index of the FIRST vertex in the face's faces_vertices array.
// this means that the two vertex indices are at i, and i+1.
t.forEach(((t,r)=>e.faces_vertices[t].forEach(((e,t,o)=>{const a=o[(t+1)%o.length];(e===s[0]&&a===s[1]||e===s[1]&&a===s[0])&&(n[r]=t)})))),void 0!==n[0]&&void 0!==n[1]||console.warn("removePlanarEdge error joining faces");
// get the length of each face, before and after changes
const a=t.map((t=>e.faces_edges[t].length)),c=t.map((t=>e.faces_vertices[t].length)),i=a.map((e=>e-1)),l=c.map((e=>e-1)),d=o.map(((e,t)=>(e+1)%a[t])),m=n.map(((e,t)=>(e+1)%c[t])),g=t.map(((t,r)=>Array.from(Array(i[r])).map(((e,t)=>(d[r]+t)%a[r])).map((r=>e.faces_edges[t][r])))),p=t.map(((t,r)=>Array.from(Array(l[r])).map(((e,t)=>(m[r]+t)%c[r])).map((r=>e.faces_vertices[t][r])))),v=t.map((t=>e.faces_faces[t])).reduce(((e,t)=>e.concat(t)),[]).filter((e=>e!==t[0]&&e!==t[1]));return{vertices:p[0].concat(p[1]),edges:g[0].concat(g[1]),faces:v}})(e,s,t,r);
// generate the new face's faces_vertices, faces_edges, faces_faces
e.faces_vertices.push(n.vertices),e.faces_edges.push(n.edges),e.faces_faces.push(n.faces),
// todo, check if other faces_ arrays exist. they are out of sync.
// update all graphs which point to faces:
// vertices_faces, edges_faces, faces_faces
e.vertices_faces.forEach(((t,r)=>{
// in the case of one vertex touching both faces, remove both
// occurences of the old faces, but only add 1 occurence of the new.
let n=!1;t.forEach(((a,c)=>{if(a===s[0]||a===s[1]){e.vertices_faces[r][c]=o;const s=n?[r,1]:[r,1,o];t.splice(...s),n=!0}}))})),e.edges_faces.forEach(((t,r)=>t.forEach(((t,n)=>{t!==s[0]&&t!==s[1]||(e.edges_faces[r][n]=o)})))),e.faces_faces.forEach(((t,r)=>t.forEach(((t,n)=>{t!==s[0]&&t!==s[1]||(e.faces_faces[r][n]=o)})))),e.faces_vertices.forEach((t=>t.forEach((t=>{void 0===t&&console.log("FOUND ONE before remove",e.faces_vertices)})))),
// again, only if the edge separated two unique faces, then
// remove the old faces
removeGeometryIndices(e,"faces",s)}
// this edge is a part of a face where the edge pokes in, winds back
// out, definitely not convex.
// from the faces_vertices, remove any isolated vertices.
// from the faces_edges, remove the edge.
// then this creates a situation where two of the same vertex might be
// repeated. filter out so that the vertices are unique only.
if(2===s.length&&s[0]===s[1]&&n.length){const r=s[0];// the non-convex face which needs correcting.
e.faces_vertices[r]=e.faces_vertices[r].filter((e=>!n.includes(e))).filter(((e,t,r)=>e!==r[(t+1)%r.length])),e.faces_edges[r]=e.faces_edges[r].filter((e=>e!==t))}
// remove edge, shrink edges_vertices, edges_faces, ... by 1
// this also replaces any edge occurence in _edge arrays including:
// vertices_edges, faces_edges.
removeGeometryIndices(e,"edges",[t]),removeGeometryIndices(e,"vertices",n)},removePlanarVertex=(e,t)=>{const r=e.vertices_edges[t],s=uniqueSortedNumbers(e.vertices_faces[t].filter((e=>null!=e)));if(2!==r.length||s.length>2)return void console.warn("cannot remove non 2-degree vertex yet (e,f)",r,s);const o=getOppositeVertices(e,t,r),n=o.slice().reverse();
// sort edges so the smallest index is first
// edges[0] is the keep edge. edges[1] will be the removed edge.
r.sort(((e,t)=>e-t)),
// vertices_edges
// replace the index of the removed edge with the keep edge.
// one of them will already be linked to the keep edge. skip it.
o.forEach((t=>{const s=e.vertices_edges[t].indexOf(r[1]);-1!==s&&(e.vertices_edges[t][s]=r[0])})),
// vertices_vertices
// find the index of the removed vertex,
// replace it with the opposite vertex.
o.forEach(((r,s)=>{const o=e.vertices_vertices[r].indexOf(t);-1!==o?e.vertices_vertices[r][o]=n[s]:console.warn("removePlanarVertex unknown vertex issue")})),
// edges_vertices
e.edges_vertices[r[0]]=[...o],
// faces_vertices
s.forEach((r=>{const s=e.faces_vertices[r].indexOf(t);-1!==s?e.faces_vertices[r].splice(s,1):console.warn("removePlanarVertex unknown face_vertex issue")})),
// faces_edges
s.forEach((t=>{const s=e.faces_edges[t].indexOf(r[1]);-1!==s?e.faces_edges[t].splice(s,1):console.warn("removePlanarVertex unknown face_edge issue")})),
// no changes to: vertices_faces, edges_faces, faces_faces,
// edges_assignment/foldAngle
removeGeometryIndices(e,"vertices",[t]),removeGeometryIndices(e,"edges",[r[1]])},alternatingSum=e=>[0,1].map((t=>e.filter(((e,r)=>r%2===t)).reduce(((e,t)=>e+t),0)))
/**
	 * @description alternatingSum, filter odd and even into two categories, then
	 *  then set them to be the deviation from the average of the sum.
	 * @param {number[]} sectors one list of numbers
	 * @returns {number[]} one array of two numbers. if both alternating sets sum
	 *  to the same, the result will be [0, 0]. if the first set is 2 more than the
	 *  second, the result will be [1, -1]. (not [2, 0] or something with a 2 in it)
	 * @linkcode Origami ./src/singleVertex/kawasakiMath.js 23
	 */,kawasakiSolutionsRadians=e=>e.map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>counterClockwiseAngleRadians(...e)
// for every sector, make an array of all the OTHER sectors
)).map(((e,t,r)=>r.slice(t+1,r.length).concat(r.slice(0,t))
// for every sector, use the sector score from the OTHERS two to split it
)).map((e=>alternatingSum(e).map((e=>Math.PI-e))
// add the deviation to the edge to get the absolute position
)).map(((t,r)=>e[r]+t[0]
// sometimes this results in a solution OUTSIDE the sector. ignore these
)).map(((t,r)=>isCounterClockwiseBetween(t,e[r],e[(r+1)%e.length])?t:void 0))
// or should we remove the indices so the array reports [ empty x2, ...]
/**
	 * @description given a set of edges around a single vertex (expressed as an array
	 * of vectors), find all possible single-ray additions which
	 * when added to the set, the set satisfies Kawasaki's theorem.
	 * @usage this is hard coded to work for flat-plane, where sectors sum to 360deg
	 * @param {number[][]} vectors array of vectors, the edges around a single vertex. pre-sorted.
	 * @returns {number[][]} for every sector either one vector
	 * or undefined if that sector contains no solution.
	 * @linkcode Origami ./src/singleVertex/kawasakiMath.js 71
	 */,kawasakiSolutionsVectors=e=>{const t=e.map((e=>Math.atan2(e[1],e[0])));return kawasakiSolutionsRadians(t).map((e=>void 0===e?void 0:[Math.cos(e),Math.sin(e)]))};
/**
	 * Rabbit Ear (c) Kraft
	 */var Je=Object.freeze({__proto__:null,alternatingSum:alternatingSum,alternatingSumDifference:e=>{const t=e.reduce(((e,t)=>e+t),0)/2;return alternatingSum(e).map((e=>e-t))},kawasakiSolutionsRadians:kawasakiSolutionsRadians,kawasakiSolutionsVectors:kawasakiSolutionsVectors});
/**
	 * Rabbit Ear (c) Kraft
	 */const Ze={B:!0,b:!0,F:!0,f:!0,U:!0,u:!0},vertices_flat=({vertices_edges:e,edges_assignment:t})=>e.map((e=>e.map((e=>Ze[t[e]])).reduce(((e,t)=>e&&t),!0))).map(((e,t)=>e?t:void 0)).filter((e=>void 0!==e)),Ye={M:!0,m:!0,V:!0,v:!0},Xe={M:-1,m:-1,V:1,v:1},validateMaekawa=({edges_vertices:e,vertices_edges:t,edges_assignment:r})=>{t||(t=makeVerticesEdgesUnsorted({edges_vertices:e}));const s=t.map((e=>e.map((e=>Xe[r[e]])).filter((e=>void 0!==e)).reduce(((e,t)=>e+t),0))).map((e=>2===e||-2===e));
// overwrite any false values to true for all boundary vertices
return boundaryVertices({edges_vertices:e,edges_assignment:r}).forEach((e=>{s[e]=!0})),vertices_flat({vertices_edges:t,edges_assignment:r}).forEach((e=>{s[e]=!0})),s.map(((e,t)=>e?void 0:t)).filter((e=>void 0!==e))},validateKawasaki=({vertices_coords:e,vertices_vertices:t,vertices_edges:r,edges_vertices:s,edges_assignment:o,edges_vector:n},a=I)=>{t||(t=makeVerticesVertices({vertices_coords:e,vertices_edges:r,edges_vertices:s}));const c=makeVerticesVerticesVector({vertices_coords:e,vertices_vertices:t,edges_vertices:s,edges_vector:n}).map(((e,t)=>e.filter(((e,s)=>Ye[o[r[t][s]]])))).map((e=>e.length>1?counterClockwiseSectors2(e):[0,0])).map((e=>alternatingSum(e))).map((e=>Math.abs(e[0]-e[1])<a));
// overwrite any false values to true for all boundary vertices
return boundaryVertices({edges_vertices:s,edges_assignment:o}).forEach((e=>{c[e]=!0})),vertices_flat({vertices_edges:r,edges_assignment:o}).forEach((e=>{c[e]=!0})),c.map(((e,t)=>e?void 0:t)).filter((e=>void 0!==e))};
/**
	 * @description get all vertices indices which are adjacent to edges
	 * with no mountain/valleys, only containing either flat, unassigned,
	 * or boundary.
	 */var Ke=Object.freeze({__proto__:null,validateMaekawa:validateMaekawa,validateKawasaki:validateKawasaki});
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * Crease Pattern - a flat-array, index-based graph with faces, edges, and vertices
	 * that exist in 2D space, edges resolved so there are no edge crossings.
	 * The naming scheme for keys follows the FOLD format.
	 */const Qe={};Qe.prototype=Object.create(We),Qe.prototype.constructor=Qe;
/**
	 * how many segments will curves be converted into.
	 * todo: user should be able to change this
	 */
const et=96,make_edges_array=function(e){return e.mountain=(t=-180)=>(e.forEach((e=>{this.edges_assignment[e]="M",this.edges_foldAngle[e]=t})),e),e.valley=(t=180)=>(e.forEach((e=>{this.edges_assignment[e]="V",this.edges_foldAngle[e]=t})),e),e.flat=()=>(e.forEach((e=>{this.edges_assignment[e]="F",this.edges_foldAngle[e]=0})),e),e},clipLineTypeToCP=(e,t)=>{const r=clip(e,t);if(!r)return;const s=addPlanarSegment(e,r[0],r[1]);
// if (!edges) { return undefined; }
return make_edges_array.call(e,s)};Qe.prototype.line=function(...e){const t=getLine$1(...e);if(t)return t.domain=includeL,clipLineTypeToCP(this,t)},Qe.prototype.ray=function(...e){const t=getLine$1(...e);if(t)return t.domain=Y,clipLineTypeToCP(this,t)},Qe.prototype.segment=function(...e){const t=getArrayOfVectors(...e);if(t)return t.domain=includeS,clipLineTypeToCP(this,t)},["circle","ellipse","rect","polygon"].forEach((e=>{Qe.prototype[e]=function(){const t=math[e](...arguments);if(!t)return;const r=t.segments(et).map((e=>math.segment(e))).map((e=>clip(this,e))).filter((e=>void 0!==e));if(!r)return;const s=[],o=[];r.forEach((e=>{const t=addVertices(this,e);s.push(...t),o.push(...addEdges(this,t))}));const{map:n}=fragment(this).edges;return populate(this),make_edges_array.call(this,o.map((e=>n[e])).reduce(((e,t)=>e.concat(t)),[]))}})),
// ["circle", "ellipse", "rect", "polygon"].forEach((fName) => {
//   CreasePattern.prototype[fName] = function () {
//     const primitive = math[fName](...arguments);
//     if (!primitive) { return; }
//     const segments = primitive.segments(arcResolution)
//       .map(segment => math.segment(segment))
//       .map(segment => clip(this, segment))
//       .filter(a => a !== undefined);
//     if (!segments) { return; }
//     const vertices = [];
//     // const edges = [];
//     const edges = segments.map(segment => {
//       return addPlanarSegment(this, segment[0], segment[1]);
//     });
//     console.log("verts, edges", vertices, edges);
//     // return make_edges_array.call(this, edges
//     //   .reduce((a, b) => a.concat(b), []));
//   };
// });
Qe.prototype.removeEdge=function(e){const t=this.edges_vertices[e];return removePlanarEdge(this,e),t.map((e=>isVertexCollinear(this,e))).map(((e,r)=>e?t[r]:void 0)).filter((e=>void 0!==e)).sort(((e,t)=>t-e)).forEach((e=>removePlanarVertex(this,e))),!0},Qe.prototype.validate=function(e){const t=validate(this,e);return t.vertices.kawasaki=validateKawasaki(this,e),t.vertices.maekawa=validateMaekawa(this),this.edges_foldAngle&&(t.edges.not_flat=this.edges_foldAngle.map(((e,t)=>edgeFoldAngleIsFlat(e)?void 0:t)).filter((e=>void 0!==e))),"valid"===t.summary&&(t.vertices.kawasaki.length||t.vertices.maekawa.length?t.summary="invalid":t.edges.not_flat.length&&(t.summary="not flat")),t};var tt=Qe.prototype;
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * @description this builds a new faces_layer array. it first separates the
	 * folding faces from the non-folding using faces_folding, an array of [t,f].
	 * it flips the folding faces over, appends them to the non-folding ordering,
	 * and (re-indexes/normalizes) all the z-index values to be the minimum
	 * whole number set starting with 0.
	 * @param {number[]} each index is a face, each value is the z-layer order.
	 * @param {boolean[]} each index is a face, T/F will the face be folded over?
	 * @returns {number[]} each index is a face, each value is the z-layer order.
	 */const make_face_side=(e,t,r,s)=>{const o=subtract2(r,t),n=cross2(e,o);return s?n>0:n<0},make_face_center=(e,t)=>e.faces_vertices[t]?e.faces_vertices[t].map((t=>e.vertices_coords[t])).reduce(((e,t)=>[e[0]+t[0],e[1]+t[1]]),[0,0]).map((r=>r/e.faces_vertices[t].length)):[0,0],rt={F:!0,f:!0,U:!0,u:!0},st={M:"V",m:"V",V:"M",v:"M"},face_snapshot=(e,t)=>({center:e.faces_center[t],matrix:e.faces_matrix2[t],winding:e.faces_winding[t],crease:e.faces_crease[t],side:e.faces_side[t],layer:e.faces_layer[t]})
/**
	 * @description make a crease that passes through the entire origami and modify the
	 * faces order to simulate one side of the faces flipped over and set on top.
	 * @param {object} graph a FOLD graph in crease pattern form, will be modified in place
	 * @param {number[]} vector a 2D vector describing the line as an array of numbers
	 * @param {number[]} origin a 2D origin describing the line as an array of numbers
	 * @param {string} assignment (M/V/F) a FOLD spec encoding of the direction of the fold
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {object} a summary of changes to faces/edges.
	 * @algorithm Because we want to return the new modified origami in crease pattern form,
	 * as we iterate through the faces, splitting faces which cross the crease
	 * line, we have to be modifying the crease pattern, as opposed to modifying
	 * a folded form then unfolding the vertices, which would be less precise.
	 * So, we will create copies of the crease line, one per face, transformed
	 * into place by its face's matrix, which superimposes many copies of the
	 * crease line onto the crease pattern, each in place
	 * @linkcode Origami ./src/graph/flatFold/index.js 86
	 */,flatFold=(e,t,r,s="V",o=I)=>{const n=st[a=s]||a;
// make sure the input graph contains the necessary data.
// this takes care of all standard FOLD-spec arrays.
// todo: this could be optimized by trusting that the existing arrays
// are accurate, checking if they exist and skipping them if so.
var a;
/**
	 * @description shallow copy these entries for one face in the graph.
	 * this is intended to capture the values, in the case of the face
	 * being removed from the graph (not deep deleted, just unreferenced).
	 */populate(e),
// additionally, we need to ensure faces layer exists.
// todo: if it doesn't exist, should we use the solver?
e.faces_layer||(e.faces_layer=Array(e.faces_vertices.length).fill(0)),
// these will be properties on the graph. as we iterate through faces,
// splitting (removing 1 face, adding 2) inside "splitFace", the remove
// method will automatically shift indices for arrays starting with "faces_".
// we will remove these arrays at the end of this method.
e.faces_center=e.faces_vertices.map(((t,r)=>make_face_center(e,r))),
// faces_matrix is built from the crease pattern, but reflects
// the faces in their folded state.
e.faces_matrix2||(e.faces_matrix2=makeFacesMatrix2(e,0)),e.faces_winding=makeFacesWindingFromMatrix2(e.faces_matrix2),e.faces_crease=e.faces_matrix2.map(invertMatrix2).map((e=>multiplyMatrix2Line2(e,t,r))),e.faces_side=e.faces_vertices.map(((t,r)=>make_face_side(e.faces_crease[r].vector,e.faces_crease[r].origin,e.faces_center[r],e.faces_winding[r])));
// before we start splitting faces, we have to handle the case where
// a flat crease already exists along the fold crease, already splitting
// two faces (assignment "F" or "U" only), the splitFace method
// will not catch these. we need to find these edges before we modify
// the graph, find the face they are attached to and whether the face
// is flipped, and set the edge to the proper "V" or "M" (and foldAngle).
const c=multiplyVerticesFacesMatrix2(e,e.faces_matrix2),i=makeEdgesLineParallelOverlap({vertices_coords:c,edges_vertices:e.edges_vertices},t,r,o).map(((e,t)=>e?t:void 0)).filter((e=>void 0!==e)).filter((t=>rt[e.edges_assignment[t]]));
// get all (folded) edges which lie parallel and overlap the crease line
// get the first valid adjacent face for each edge, get that face's winding,
// which determines the crease assignment, and assign it to the edge
i.map((t=>e.edges_faces[t].find((e=>null!=e)))).map((t=>e.faces_winding[t])).map((e=>e?s:n)).forEach(((t,r)=>{e.edges_assignment[i[r]]=t,e.edges_foldAngle[i[r]]=edgeAssignmentToFoldAngle(t)}));
// before we start splitting, capture the state of face 0. we will use
// it when rebuilding the graph's matrices after all splitting is finished.
const l=face_snapshot(e,0),d=e.faces_vertices.map(((e,t)=>t)).reverse().map((t=>{
// this is the face about to be removed. if the face is successfully
// split the face will be removed but we still need to reference
// values from it to complete the 2 new faces which replace it.
const r=face_snapshot(e,t),a=splitFace(e,t,r.crease.vector,r.crease.origin,o);
// split the polygon (if possible), get back a summary of changes.
// console.log("split convex polygon change", change);
if(void 0===a)return;
// const face_winding = folded.faces_winding[i];
// console.log("face change", face, change);
// update the assignment of the newly added edge separating the 2 new faces
e.edges_assignment[a.edges.new]=r.winding?s:n,e.edges_foldAngle[a.edges.new]=edgeAssignmentToFoldAngle(e.edges_assignment[a.edges.new]);return a.faces.map[a.faces.remove].forEach((t=>{
// no need right now to build faces_winding, faces_matrix, ...
e.faces_center[t]=make_face_center(e,t),e.faces_side[t]=make_face_side(r.crease.vector,r.crease.origin,e.faces_center[t],r.winding),e.faces_layer[t]=r.layer})),a})).filter((e=>void 0!==e)),m=mergeNextmaps(...d.map((e=>e.faces.map))),g=mergeNextmaps(...d.map((e=>e.edges.map)).filter((e=>void 0!==e))),p=d.map((e=>e.faces.remove)).reverse();
// now, iterate through faces (reverse order), rebuilding the custom
// arrays for the newly added faces when a face is split.
// const vert_dict = {};
// split_changes.forEach(el => el.vertices.forEach(v => { vert_dict[v] = true; }));
// const new_vertices = Object.keys(vert_dict).map(s => parseInt(s));
// build a new face layer ordering
e.faces_layer=((e,t)=>{const r=[],s=e.map(((e,t)=>t)),o=s.filter((e=>t[e])),n=s.filter((e=>!t[e]));
// filter face indices into two arrays, those folding and not folding
// sort all the non-folding indices by their current layer, bottom to top,
// give each face index a new layering index.
// compress whatever current layer numbers down into [0...n]
return n.sort(((t,r)=>e[t]-e[r])).forEach(((e,t)=>{r[e]=t})),
// sort the folding faces in reverse order (flip them), compress their
// layers down into [0...n] and and set each face to this layer index
o.sort(((t,r)=>e[r]-e[t]// reverse order here
)).forEach(((e,t)=>{r[e]=n.length+t})),r})(e.faces_layer,e.faces_side);
// build new face matrices for the folded state. use face 0 as reference
// we need its original matrix, and if face 0 was split we need to know
// which of its two new faces doesn't move as the new faces matrix
// calculation requires we provide the one face that doesn't move.
const v=m&&m[0]&&2===m[0].length,u=v?m[0].filter((t=>e.faces_side[t])).shift():0;
// only if face 0 lies on the not-flipped side (sidedness is false),
// and it wasn't creased-through, can we use its original matrix.
// if face 0 lies on the flip side (sidedness is true), or it was split,
// face 0 needs to be multiplied by its crease's reflection matrix, but
// only for valley or mountain folds, "flat" folds need to copy the matrix
let h=l.matrix;
// only if the assignment is valley or mountain, do this. otherwise skip
// summary of changes to the graph
return s!==n&&(h=v||e.faces_side[0]?multiplyMatrices2(l.matrix,makeMatrix2Reflect(l.crease.vector,l.crease.origin)):l.matrix),
// build our new faces_matrices using face 0 as the starting point,
// setting face 0 as the identity matrix, then multiply every
// face's matrix by face 0's actual starting matrix
e.faces_matrix2=makeFacesMatrix2(e,u).map((e=>multiplyMatrices2(h,e))),
// these are no longer needed. some of them haven't even been fully rebuilt.
delete e.faces_center,delete e.faces_winding,delete e.faces_crease,delete e.faces_side,{faces:{map:m,remove:p},edges:{map:g}}},ot={};
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * @description this determines which side of a line (using cross product)
	 * a face lies in a folded form, except, the face is the face in
	 * the crease pattern and the line (vector origin) is transformed
	 * by the face matrix. because of this, we use face_winding to know
	 * if this face was flipped over, reversing the result.
	 * @note by flipping the < and > in the return, this one change
	 * will modify the entire method to toggle which side of the line
	 * are the faces which will be folded over.
	 */ot.prototype=Object.create(We),ot.prototype.constructor=ot,ot.prototype.flatFold=function(){const e=getLine$1(arguments);return flatFold(this,e.vector,e.origin),this};var nt=ot.prototype;
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * @description Check a FOLD object's frame_classes for the presence of "foldedForm".
	 * @param {FOLD} graph a FOLD object
	 * @returns {boolean} true if the graph is folded.
	 * @linkcode Origami ./src/graph/query.js 8
	 */const isFoldedForm=e=>e.frame_classes&&e.frame_classes.includes("foldedForm")||e.file_classes&&e.file_classes.includes("foldedForm");var at=Object.freeze({__proto__:null,isFoldedForm:isFoldedForm});
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * @description Given a self-relational array like faces_faces or
	 * vertices_vertices, and a list of indices with which to keep,
	 * copy the array so that only those elements found in "indices"
	 * are copied over, including the data in the inner most arrays.
	 * This will produce an array with holes.
	 * @param {number[][]} array_array a self-relational index array,
	 * such as "faces_faces".
	 * @param {number[]} indices a list of indices to keep.
	 * @returns {number[][]} a copy of the array_array but excluding
	 * all indices which were not included in the "indices" parameter set.
	 */const subgraph=(e,t={})=>{
// allow user to only specify one or two; fill in the empty arrays.
t.vertices||(t.vertices=[]),t.edges||(t.edges=[]),t.faces||(t.faces=[]);const r=["faces","edges","vertices"],s={};
// create a lookup which will be used when a component is a suffix
// and we need to filter out elements which don't appear in other arrays
r.forEach((e=>{s[e]={}})),r.forEach((e=>t[e].forEach((t=>{s[e][t]=!0}))));
// get all prefix arrays ("edges_") and suffix arrays ("_edges")
// for all geometry component type.
const o={};r.forEach((t=>{filterKeysWithPrefix(e,t).forEach((e=>{o[e]={}})),filterKeysWithSuffix(e,t).forEach((e=>{o[e]={}}))})),r.forEach((t=>{filterKeysWithPrefix(e,t).forEach((e=>{o[e].prefix=t})),filterKeysWithSuffix(e,t).forEach((e=>{o[e].suffix=t}))}));
// shallow copy of the graph. excluding all geometry arrays.
// this allows all metadata, including that which is unknown to
// the spec to be carried over.
const n={...e};
// delete all graph data. only carry over metadata
return J.graph.forEach((e=>delete n[e])),delete n.file_frames,
// use prefixes and suffixes to make sure we initialize all
// geometry array types. this even supports out of spec arrays,
// like: faces_matrix, colors_edges...
Object.keys(o).forEach((e=>{n[e]=[]})),Object.keys(o).forEach((r=>{const{prefix:a,suffix:c}=o[r];
// if prefix exists, filter outer array elements (creating holes)
// if suffix exists, filter inner elements using the quick lookup
a&&c?t[a].forEach((t=>{n[r][t]=e[r][t].filter((e=>s[c][e]))})):a?t[a].forEach((t=>{n[r][t]=e[r][t]})):n[r]=c?e[r].map((e=>e.filter((e=>s[c][e])))):e[r]})),n};
/**
	 * @description Create a subgraph from a graph, with shallow pointers
	 * to arrays by providing a list of vertices, edges, and faces which
	 * will be carried over.
	 * The subgraph component arrays will contain holes, meaning the
	 * indices are preserved, making it useful for performing operations
	 * on a subgraph, then carrying that information back to the original.
	 * @param {FOLD} graph a FOLD graph
	 * @param {object} indices an object containing:
	 * { vertices: [], edges: [], faces: [] }
	 * all of which contains a list of indices to keep in the copied graph.
	 * the values can be integers or integer-strings, doesn't matter.
	 * @returns {FOLD} a shallow copy of the graph parameter provided.
	 */var ct=Object.freeze({__proto__:null,selfRelationalArraySubset:(e,t)=>{
// quick lookup, is an index to be included?
const r={};t.forEach((e=>{r[e]=!0}));
// only include those faces which are in the group, both at
// the top level and inside the inside reference arrays.
const s=[];return t.forEach((t=>{s[t]=e[t].filter((e=>r[e]))})),s},subgraph:subgraph,subgraphWithFaces:(e,t)=>{
// vertices will be take from one place:
// - faces_vertices, every vertex involved in the subset of faces
// there is no way to take it from edges_vertices, as edges_vertices
// itself needs to be determined by this "vertices" array.
let r=[];e.faces_vertices&&(r=uniqueSortedNumbers(t.flatMap((t=>e.faces_vertices[t]))));
// edges will be taken from one of two places, either:
// - faces edges, the edges involved in the subset of faces
// - edges_vertices where BOTH vertices involved are in "vertices".
// otherwise, no edges will be carried over.
let s=[];if(e.faces_edges)s=uniqueSortedNumbers(t.flatMap((t=>e.faces_edges[t])));else if(e.edges_vertices){const t={};r.forEach((e=>{t[e]=!0})),s=e.edges_vertices.map(((e,r)=>t[e[0]]&&t[e[1]]?r:void 0)).filter((e=>void 0!==e))}return subgraph(e,{faces:t,edges:s,vertices:r})}});
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * @description Return an ExF matrix (number of: E=edges, F=faces), relating every edge
	 * to every face. Value will contain true if the edge and face overlap each other, excluding
	 * the space around the edge's endpoints, and the edges of the face.
	 * @param {FOLD} graph a FOLD object
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {boolean[][]} matrix relating edges to faces, answering, do they overlap?
	 * @linkcode Origami ./src/graph/overlap.js 199
	 */const makeEdgesFacesOverlap=({vertices_coords:e,edges_vertices:t,edges_vector:r,edges_faces:s,faces_vertices:o},n)=>{r||(r=makeEdgesVector({vertices_coords:e,edges_vertices:t}));const a=makeFacesWinding({vertices_coords:e,faces_vertices:o}),c=t.map((t=>e[t[0]])),i=t.map((t=>t.map((t=>e[t])))),l=o.map((t=>t.map((t=>e[t]))));
// use graph vertices_coords for edges vertices
a.forEach(((e,t)=>{e||l[t].reverse()}));
// the result object
const d=t.map((()=>o.map((()=>{}))));
// edges which define a face are already known to not-overlap
s.forEach(((e,t)=>e.forEach((e=>{d[t][e]=!1}))));
// quick bounding box test to eliminate non-overlapping axis-aligned areas
// todo improve n^2
const m=makeEdgesBoundingBox({edges_coords:i}),g=l.map((e=>boundingBox$1(e)));
// faster code. todo: switch this out for the block just above here
// but refactor so that we use forEach instead of for()
// const finished_edges = {};
// for (let e = 0; e < matrix.length; e += 1) {
// 	if (finished_edges[e]) { continue; }
// 	for (let f = 0; f < matrix[e].length; f += 1) {
// 		if (matrix[e][f] !== undefined) { continue; }
// 		const point_in_poly = edges_coords[e]
// 			.map(point => overlapConvexPolygonPoint(
// 				faces_coords[f],
// 				point,
// 				exclude,
// 				epsilon,
// 			)).reduce((a, b) => a || b, false);
// 		if (point_in_poly) { matrix[e][f] = true; continue; }
// 		const edge_intersect = intersectConvexPolygonLine(
// 			faces_coords[f],
// 			{ vector: edges_vector[e], origin: edges_origin[e] },
// 			excludeS,
// 			excludeS,
// 			epsilon,
// 		);
// 		if (edge_intersect) { matrix[e][f] = true; continue; }
// 		matrix[e][f] = false;
// 	}
// 	edges_similar[e].forEach(adjacent_edge => {
// 		matrix[adjacent_edge] = matrix[e].slice();
// 		finished_edges[adjacent_edge] = true;
// 	});
// }
// old code
// matrix.forEach((row, e) => row.forEach((val, f) => {
// 	if (val === false) { return; }
// 	// both segment endpoints, true if either one of them is inside the face.
// 	const point_in_poly = edges_coords[e]
// 		.map(point => overlapConvexPolygonPoint(
// 			faces_coords[f],
// 			point,
// 			exclude,
// 			epsilon,
// 		)).reduce((a, b) => a || b, false);
// 	if (point_in_poly) { matrix[e][f] = true; return; }
// 	const edge_intersect = intersectConvexPolygonLine(
// 		faces_coords[f],
// 		{ vector: edges_vector[e], origin: edges_origin[e] },
// 		excludeS,
// 		excludeS,
// 		epsilon,
// 	);
// 	if (edge_intersect) { matrix[e][f] = true; return; }
// 	matrix[e][f] = false;
// }));
return m.forEach(((e,t)=>g.forEach(((r,s)=>{!1!==d[t][s]&&(overlapBoundingBoxes(r,e)||(d[t][s]=!1))})))),i.forEach(((e,t)=>l.forEach(((e,s)=>{if(void 0!==d[t][s])return;if(i[t].map((e=>overlapConvexPolygonPoint(l[s],e,exclude,n))).reduce(((e,t)=>e||t),!1))return void(d[t][s]=!0);intersectConvexPolygonLine(l[s],{vector:r[t],origin:c[t]},excludeS,excludeS,n)?d[t][s]=!0:d[t][s]=!1})))),d},getFacesFaces2DOverlap=({vertices_coords:e,faces_vertices:t},r=I)=>{const s=Array.from(Array(t.length)).map((()=>Array.from(Array(t.length)))),o=t.map((t=>t.map((t=>e[t])))),n=o.map((e=>boundingBox$1(e)));for(let e=0;e<n.length-1;e+=1)for(let t=e+1;t<n.length;t+=1)overlapBoundingBoxes(n[e],n[t])||(s[e][t]=!1,s[t][e]=!1);const a=o.map((e=>makePolygonNonCollinear(e,r)));for(let e=0;e<t.length-1;e+=1)for(let o=e+1;o<t.length;o+=1){if(!1===s[e][o])continue;const t=overlapConvexPolygons(a[e],a[o],r);s[e][o]=t,s[o][e]=t}return s};
// const makeFacesFacesOverlap = ({ vertices_coords, faces_vertices }, epsilon = EPSILON) => {
//   const matrix = Array.from(Array(faces_vertices.length))
//     .map(() => Array.from(Array(faces_vertices.length)));
//   const faces_polygon = makeFacesPolygon({ vertices_coords, faces_vertices }, epsilon);
//   for (let i = 0; i < faces_vertices.length - 1; i++) {
//     for (let j = i + 1; j < faces_vertices.length; j++) {
//       const intersection = intersect_polygon_polygon(
//         faces_polygon[i],
//         faces_polygon[j],
//         // exclude,
//         epsilon);
//       console.log("testing", faces_polygon[i], faces_polygon[j], intersection, epsilon);
//       const overlap = intersection.length !== 0;
//       matrix[i][j] = overlap;
//       matrix[j][i] = overlap;
//     }
//   }
//   return matrix;
// };
/**
	 * @description Compare every face to every face to answer: do the two faces overlap?
	 * Return the result in the form of a matrix, an array of arrays of booleans,
	 * where both halves of the matrix are filled, matrix[i][j] === matrix[j][i].
	 * @param {FOLD} graph a FOLD object
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {boolean[][]} face-face matrix answering: do they overlap?
	 * @linkcode Origami ./src/graph/overlap.js 347
	 */var it=Object.freeze({__proto__:null,makeEdgesFacesOverlap:makeEdgesFacesOverlap,getFacesFaces2DOverlap:getFacesFaces2DOverlap});
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * @description Convert an array of indices into an array of array of
	 * indices where each inner array forms a triangle fan: [0, 1, 2, 3, 4]
	 * becomes [[0, 1, 2], [1, 2, 3], [1, 3, 4]].
	 * @param {number[]} indices an array of indices
	 * @returns {number[][]} an array of arrays where the inner arrays are
	 * all of length 3.
	 */const triangulateConvexFacesVertices=({faces_vertices:e})=>e.flatMap((e=>{return e.length<4?[e]:(t=e,Array.from(Array(t.length-2)).map(((e,r)=>[t[0],t[r+1],t[r+2]])));var t;
/**
	 * @description Triangulate a faces_vertices with the capability to handle
	 * only convex faces. This will increase the number of faces.
	 * @param {FOLD} graph a FOLD object.
	 * @returns {number[][]} faces_vertices where all faces have only 3 vertices
	 */}))
/**
	 * @description convert an array of any values into an array of arrays
	 * where each of the inner arrays contains 3 elements.
	 * This assumes the length % 3 is 0, if not, the couple remainders
	 * will be chopped off.
	 * @param {any[]} array an array containing any type
	 * @returns {any[][]} array of arrays where each inner array is length 3.
	 */,triangulateNonConvexFacesVertices=({vertices_coords:e,faces_vertices:t},r)=>{if(!e||!e.length)throw new Error($);const s=e[0].length;return t.map((t=>t.flatMap((t=>e[t])))).map((e=>r(e,null,s)
// earcut returns vertices [0...n] local to this one polygon
// convert these indices back to the face's faces_vertices.
)).map(((e,r)=>e.map((e=>t[r][e])))).flatMap((e=>{return 3===(t=e).length?[t]:Array.from(Array(Math.floor(t.length/3))).map(((e,r)=>[3*r+0,3*r+1,3*r+2].map((e=>t[e]))));var t;
/**
	 * @description Triangulate a faces_vertices with the capability to handle
	 * both convex and nonconvex. This will increase the number of faces.
	 * You will need to link a reference to the package "Earcut" by Mapbox.
	 * Earcut is a small and capable library with zero dependencies.
	 * https://www.npmjs.com/package/earcut
	 * @param {FOLD} graph a FOLD object.
	 * @returns {number[][]} faces_vertices where all faces have only 3 vertices
	 */}))},triangulate=(e,t)=>{if(!e.faces_vertices)return{};const r=e.edges_vertices?e.edges_vertices.length:0,s=(({faces_vertices:e})=>{let t=0;return e.map((e=>Math.max(3,e.length))).map((e=>Array.from(Array(e-2)).map((()=>t++))))})(e);e.faces_vertices=t?triangulateNonConvexFacesVertices(e,t):triangulateConvexFacesVertices(e),
// if the graph did not contain edges_vertices after this method, it will
(e=>{e.edges_vertices||(e.edges_vertices=[]);const t=makeVerticesToEdgeBidirectional(e);let r=e.edges_vertices.length;
// as we traverse the new faces_edges, if we encounter a new edge, add
// it here in the form of a new edges_vertices
const s=[];e.faces_edges=e.faces_vertices.map((e=>e.map(((e,o,n)=>{const a=[e,n[(o+1)%n.length]],c=a.join(" ");return c in t?t[c]:(s.push(a),t[c]=r,t[a.reverse().join(" ")]=r,r++)}))));const o=s.length;e.edges_vertices.push(...s),e.edges_assignment&&e.edges_assignment.push(...Array(o).fill("J")),e.edges_foldAngle&&e.edges_foldAngle.push(...Array(o).fill(0)),e.vertices_vertices&&delete e.vertices_vertices,e.vertices_edges&&delete e.vertices_edges,e.vertices_faces&&delete e.vertices_faces,e.edges_faces&&delete e.edges_faces,e.faces_faces&&delete e.faces_faces,e.faceOrders&&delete e.faceOrders})(e);return{faces:{map:s},edges:{new:Array.from(Array(e.edges_vertices.length-r)).map(((e,t)=>r+t))}}};var lt=Object.freeze({__proto__:null,triangulateConvexFacesVertices:triangulateConvexFacesVertices,triangulateNonConvexFacesVertices:triangulateNonConvexFacesVertices,triangulate:triangulate});
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * @description given a self-relational array of arrays, for example,
	 * vertices_vertices, edges_edges, faces_faces, where the values in the
	 * inner arrays relate to the indices of the outer array, create
	 * collection groups where each item is included in a group if it
	 * points to another member in that group.
	 * @param {number[][]} array_array an array of arrays of numbers
	 * @returns {number[][]} groups of the indices where each index appears only once
	 * @linkcode Origami ./src/graph/connectedComponents.js 12
	 */const connectedComponents=e=>{const t=[],recurse=(r,s)=>
// do not increment groups if this
void 0!==t[r]?0:(t[r]=s,e[r].forEach((e=>recurse(e,s))),1);for(let t=0,r=0;t<e.length;t+=1)t in e&&(r+=recurse(t,r));return t},makeEdgesEdgesParallel=({vertices_coords:e,edges_vertices:t,edges_vector:r},s=I)=>{r||(r=makeEdgesVector({vertices_coords:e,edges_vertices:t}));const o=r.map((e=>normalize(e)));return o.map(((e,t)=>o.map(((e,r)=>t===r?void 0:1-Math.abs(dot(o[t],o[r]))<s)).map(((e,t)=>e?t:void 0)).filter((e=>void 0!==e))))},overwriteEdgesOverlaps=(e,t,r,s,o)=>{const n=e.map((()=>[]));return e.forEach(((e,a)=>e.forEach((e=>{a>=e||overlapLineLine({vector:t[a],origin:r[a]},{vector:t[e],origin:r[e]},s,s,o)&&(n[a].push(e),n[e].push(a))})))),n},makeEdgesEdgesParallelOverlap=({vertices_coords:e,edges_vertices:t,edges_vector:r},s)=>{r||(r=makeEdgesVector({vertices_coords:e,edges_vertices:t}));const o=t.map((t=>e[t[0]])),n=makeEdgesEdgesParallel({vertices_coords:e,edges_vertices:t,edges_vector:r},s);
// start with edges-edges parallel matrix
// only if lines are parallel, then run the more expensive overlap method
return overwriteEdgesOverlaps(n,r,o,excludeS,s)};
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * @description Similar edges are defined by their coordinates, it doesn't matter
	 * the order, so long as the two endpoints match
	 */
/**
	 * we want to include this case, where one edge may not overlap another
	 * but it still gets included because both are overlapped by a common edge.
	 *
	 *  |----a-----|    |-------c------|
	 *          |-----b----|
	 *
	 * "a" and "c" are included together because b causes them to be so.
	 */
/**
	 * @description folds the graph then groups edges into categories if edges
	 * overlap and are parallel. groups are only formed for groups of 2 or more.
	 * any edges which is isolated in the folded form will be ignored.
	 */
/*
	const make_groups_edges = (graph, epsilon) => {
		// gather together all edges which lie on top of one another in the
		// folded state. take each edge's two adjacent faces,
		const overlap_matrix = makeEdgesEdgesParallelOverlap(graph, epsilon)
		const overlapping_edges = booleanMatrixToIndexedArray(overlap_matrix);
		// each index will be an edge, each value is a group, starting with 0,
		// incrementing upwards. for all unique edges, array will be [0, 1, 2, 3...]
		// if edges 0 and 3 share a group, array will be [0, 1, 2, 0, 3...]
		const edges_group = connectedComponentsArray(overlapping_edges);
		// gather groups, but remove groups with only one edge, and from the
		// remaining sets, remove any edges which lie on the boundary.
		// finally, remove sets with only one edge (after removing).
		return invertMap(edges_group)
			.filter(el => typeof el === "object")
			.map(edges => edges
				.filter(edge => graph.edges_faces[edge].length === 2))
			.filter(edges => edges.length > 1);
	};
	*/
var ft=Object.freeze({__proto__:null,makeEdgesEdgesSimilar:({vertices_coords:e,edges_vertices:t,edges_coords:r},s=I)=>{
// ///////////////////////////////////////
// idk why this isn't working. it's leaving out some indices. something with
// the group building - indices.slice(), something there.
r||(r=makeEdgesCoords({vertices_coords:e,edges_vertices:t}));const o=makeEdgesBoundingBox({vertices_coords:e,edges_vertices:t,edges_coords:r}),n=Array.from(Array(r.length)).map((()=>[])),a=o.length?o[0].min.length:0;
// todo improve. n^2
for(let e=0;e<r.length-1;e+=1)for(let t=e+1;t<r.length;t+=1){let r=!0;for(let n=0;n<a;n+=1)epsilonEqual(o[e].min[n],o[t].min[n],s)&&epsilonEqual(o[e].max[n],o[t].max[n],s)||(r=!1);n[e][t]=r,n[t][e]=r}for(let e=0;e<r.length-1;e+=1)for(let t=e+1;t<r.length;t+=1){if(!n[e][t])continue;const o=epsilonEqualVectors(r[e][0],r[t][0],s)&&epsilonEqualVectors(r[e][1],r[t][1],s),a=epsilonEqualVectors(r[e][0],r[t][1],s)&&epsilonEqualVectors(r[e][1],r[t][0],s),c=o||a;n[e][t]=c,n[t][e]=c}return booleanMatrixToIndexedArray(n)},makeEdgesEdgesParallel:makeEdgesEdgesParallel,makeEdgesEdges2DParallel:({vertices_coords:e,edges_vertices:t,edges_vector:r},s=I)=>{r||(r=makeEdgesVector({vertices_coords:e,edges_vertices:t}));const o=r.map((e=>Math.atan2(e[1],e[0]))).map(((e,t)=>({a:e,i:t}))).sort(((e,t)=>e.a-t.a));o.forEach(((e,t)=>{}));const n=o.slice(-1).concat(o.slice(0,-1)).filter((e=>e));console.log("shifted",n)}
// todo
// const normalized = edges_vector.map(vec => math.normalize(vec));
// return normalized
// 	.map((vec1, i) => normalized
// 		.map((vec2, j) => (i === j
// 			? undefined
// 			: (1 - Math.abs(math.dot(normalized[i], normalized[j])) < epsilon)))
// 		.map((parallel, j) => (parallel ? j : undefined))
// 		.filter(a => a !== undefined));
,makeEdgesEdgesCrossing:({vertices_coords:e,edges_vertices:t,edges_vector:r},s)=>{r||(r=makeEdgesVector({vertices_coords:e,edges_vertices:t}));
// use graph vertices_coords for edges vertices
const o=t.map((t=>e[t[0]])),n=(({vertices_coords:e,edges_vertices:t,edges_vector:r},s=I)=>{r||(r=makeEdgesVector({vertices_coords:e,edges_vertices:t}));const o=r.map((e=>normalize(e)));return o.map(((e,t)=>o.map(((e,r)=>t===r?void 0:1-Math.abs(dot(o[t],o[r]))<s)).map(((e,t)=>e?void 0:t)).filter((e=>void 0!==e))))})({vertices_coords:e,edges_vertices:t,edges_vector:r},s);
// convert parallel into NOT parallel.
// if edges are parallel (not this value), skip.
return overwriteEdgesOverlaps(n,r,o,excludeS,s)},makeEdgesEdgesParallelOverlap:makeEdgesEdgesParallelOverlap});
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * @description todo
	 * @param {FOLD} graph a FOLD graph
	 * @param {number} frame which frame number to expose as the sole contents
	 * @returns {FOLD} the requested frame separated out from the rest of
	 * the graph, inheriting any necessary data if needed.
	 */
/**
	 * Rabbit Ear (c) Kraft
	 */
var dt=Object.assign(Object.create(null),{count:count,countImplied:countImplied,validate:validate,clean:clean,populate:populate,remove:removeGeometryIndices,replace:replaceGeometryIndices,removePlanarVertex:removePlanarVertex,removePlanarEdge:removePlanarEdge,addVertices:addVertices,addEdges:addEdges,splitEdge:splitEdge,splitFace:splitFace,flatFold:flatFold,addPlanarSegment:addPlanarSegment,
// assign,
clip:clip,fragment:fragment,verticesClusters:verticesClusters,connectedComponents:connectedComponents,clone:clone,flattenFrame:(e,t=1)=>{if(!e.file_frames||e.file_frames.length<t)return e;const r=["frame_parent","frame_inherit"],s={visited_frames:[]},o={};filterKeysWithPrefix(e,"file").filter((e=>"file_frames"!==e)).forEach((t=>{o[t]=e[t]}));const recurse=(e,t,r)=>{if(-1!==s.visited_frames.indexOf(t))throw new Error(w);return s.visited_frames.push(t),r=[t].concat(r),0===t?r:e.file_frames[t-1].frame_inherit&&null!=e.file_frames[t-1].frame_parent?recurse(e,e.file_frames[t-1].frame_parent,r):r};return recurse(e,t,[]).map((t=>{if(0===t){
// for frame 0 (the key frame) don't copy over file_frames array
const t=e.file_frames;e.file_frames=null;const s=clone(e);return e.file_frames=t,delete s.file_frames,r.forEach((e=>delete s[e])),s}const s=clone(e.file_frames[t-1]);return r.forEach((e=>delete s[e])),s})).reduce(((e,t)=>Object.assign(e,t)),o)}},Z,oe,ue,we,fe,Ue,ge,Ee,_e,at,
// setsMethods,
ct,ke,it,lt,pe,Se,ae,he,xe,
// facesLayer,
ft,Le,Ve,Te,Be,Ie,ne);
/**
	 * Rabbit Ear (c) Kraft
	 */
// values to FOLD file keys maintained by this software
const mt=1.1,gt="Rabbit Ear",pt={},make_rect_vertices_coords=(e,t)=>[[0,0],[e,0],[e,t],[0,t]]
/**
	 * @description given an already initialized vertices_coords array,
	 * create a fully-populated graph that sets these vertices to be
	 * the closed boundary of a polygon.
	 */,make_closed_polygon=e=>populate({vertices_coords:e,edges_vertices:e.map(((e,t,r)=>[t,(t+1)%r.length])),edges_assignment:Array(e.length).fill("B")})
// const polygon_names = [
// 	undefined,
// 	undefined,
// 	undefined,
// 	"triangle",
// 	undefined,
// 	"pentagon",
// 	"hexagon",
// 	"heptagon",
// 	"octagon",
// 	"nonagon",
// 	"decagon",
// 	"hendecagon",
// 	"dodecagon"
// ];
/**
	 * create an array/object with only the keys and polygon names used below.
	 */
// polygon_names
// 	.map((str, i) => str === undefined ? i : undefined)
// 	.filter(a => a !== undefined)
// 	.forEach(i => delete polygon_names[i]);
/**
	 * fill the "Create" object with constructors under polygon-named keys.
	 */
/**
	 * @description make vertices_coords for a regular polygon,
	 * centered at the origin and with side lengths of 1,
	 * except for square, centered at [0.5, 0.5]
	 * @param {number} number of sides of the desired regular polygon
	 * @returns {number[][]} 2D vertices_coords, vertices of the polygon
	 */
// polygon_names.forEach((name, i) => {
// 	Create[name] = () => make_closed_polygon(math
// 		.makePolygonSideLength(i));
// });
/**
	 * special cases
	 *
	 * square and rectangle are axis-aligned with one vertex at (0, 0)
	 * circle asks for # of sides, and also sets radius to be 1,
	 *  instead of side-length to be 1.
	 */
/**
	 * @description Create a new FOLD object which contains one square face,
	 * including vertices and boundary edges.
	 * @param {number} [scale=1] the length of the sides.
	 * @returns {FOLD} a FOLD object
	 */;pt.square=(e=1)=>make_closed_polygon(make_rect_vertices_coords(e,e))
/**
	 * @description Create a new FOLD object which contains one rectangular face,
	 * including vertices and boundary edges.
	 * @param {number} [width=1] the width of the rectangle
	 * @param {number} [height=1] the height of the rectangle
	 * @returns {FOLD} a FOLD object
	 */,pt.rectangle=(e=1,t=1)=>make_closed_polygon(make_rect_vertices_coords(e,t))
/**
	 * @description Create a new FOLD object with a regular-polygon shaped boundary.
	 * @param {number} [sides=3] the number of sides to the polygon
	 * @param {number} [radius=1] the circumradius
	 * @returns {FOLD} a FOLD object
	 */,pt.polygon=(e=3,t=1)=>make_closed_polygon(makePolygonCircumradius(e,t))
// Create.circle = (sides = 90) =>
// 	make_closed_polygon(math.makePolygon(sides));
// origami bases. todo: more
/**
	 * @description Create a kite base FOLD object, in crease pattern form.
	 * @returns {FOLD} a FOLD object
	 */,pt.kite=()=>populate({vertices_coords:[[0,0],[1,0],[1,Math.sqrt(2)-1],[1,1],[Math.sqrt(2)-1,1],[0,1]],edges_vertices:[[0,1],[1,2],[2,3],[3,4],[4,5],[5,0],[0,2],[0,4],[0,3]],edges_assignment:Array.from("BBBBBBVVF")})
/**
	 * Rabbit Ear (c) Kraft
	 */
// if we ever need to call any of these constructors from somewhere
// else inside the library (creating a circular dependency)
// move this line into a file "Constructors.js", and remove the
// export at the bottom. have all files point to "Constructors.js"
// instead, and all circular dependencies will be avoided.;
const vt=Object.create(null),ut={graph:We,cp:tt,origami:nt},ht={graph:()=>{},cp:pt.square,origami:pt.square},_t={graph:()=>({file_spec:mt,file_creator:gt}),cp:()=>({file_spec:mt,file_creator:gt,frame_classes:["creasePattern"]}),origami:()=>({file_spec:mt,file_creator:gt,frame_classes:["foldedForm"]})};
/**
	 * Calling the initializer also runs populate(), which does
	 * take some computation time but it's very quick.
	 */
Object.keys(ut).forEach((e=>{vt[e]=function(){const t=Array.from(arguments).filter((e=>isFoldObject(e)
// deep copy input graph
)).map((e=>JSON.parse(JSON.stringify(e))));return populate(Object.assign(Object.create(ut[e]),t.length?{}:ht[e](),...t,_t[e]()))},
// const graph = function () { return create("graph", arguments); };
// const cp = function () { return create("cp", arguments); };
// const origami = function () { return create("origami", arguments); };
// tried to improve it. broke it.
// ObjectConstructors[name] = function () {
//   const certain = Array.from(arguments)
//     .map(arg => ({ arg, certainty: isFoldObject(arg) }))
//     .sort((a, b) => a.certainty - b.certainty);
//   const fold = certain.length && certain[0].certainty > 0.1
//     ? JSON.parse(JSON.stringify(certain.shift().arg))
//     : default_graph[name]();
//   console.log("FOLD", fold);
//   // const otherArguments = certain
//   //   .map(el => el.arg);
//   // const argFold = Array.from(arguments)
//   //   .map(arg => ({ arg, certainty: isFoldObject(arg) }))
//   //   .sort((a, b) => a.certainty - b.certainty)
//   //   .shift();
//   // const start = argFold
//   //   ? clone(argFold)
//   //   : default_graph[name]()
//   //   .map(obj => JSON.parse(JSON.stringify(obj)));
//   return Object.assign(
//     Object.create(ConstructorPrototypes[name]),
//     // (argFolds.length ? {} : default_graph[name]()),
//     fold,
//     // ...otherArguments,
//     { file_spec, file_creator }
//   );
// };
vt[e].prototype=ut[e],vt[e].prototype.constructor=vt[e],
// wrap static constructors with "this" initializer
// all the polygon names
Object.keys(pt).forEach((t=>{vt[e][t]=function(){return vt[e](pt[t](...arguments))}}))})),Object.assign(vt.graph,dt);
/* Math (c) Kraft, MIT License */
/**
	 * Math (c) Kraft
	 */
/**
	 * @description Count the number of places deep past the decimal point.
	 * @param {number} num any number
	 * @returns {number} an integer, the number of decimal digits.
	 * @linkcode
	 */
const countPlaces=function(e){const t=`${e}`.match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);return t?Math.max(0,(t[1]?t[1].length:0)-(t[2]?+t[2]:0)):0};
/**
	 * @description clean floating point numbers, where 15.0000000000000002 becomes 15,
	 * this method involves encoding and parsing so it is relatively expensive.
	 * @param {number} num the floating point number to clean
	 * @param {number} [places=15] the whole number of decimal places to
	 * keep, beyond this point can be considered to be noise.
	 * @returns {number} the cleaned floating point number
	 */
/* Math (c) Kraft, MIT License */
/**
	 * Math (c) Kraft
	 */
/**
	 * @description Infer the type of an object.
	 * @param {any} any object
	 * @returns {string} the type name
	 * @linkcode Math ./src/types/typeof.js 17
	 */
const typeOf=e=>"object"!=typeof e?typeof e:void 0!==e.radius?"circle":void 0!==e.width?"rect":"number"==typeof e[0]?"vector":void 0!==e.vector&&void 0!==e.origin?"line":void 0!==e[0]&&e[0].length&&"number"==typeof e[0][0]?2===e.length?"segment":"polygon":"object",bt={...q,...K,...B,...ce,...L,...Object.freeze({__proto__:null,cleanNumber:function(e,t=15){if("number"!=typeof e)return e;const r=parseFloat(e.toFixed(t));return countPlaces(r)===Math.min(t,countPlaces(e))?e:r}}),...de,...me,typeof:typeOf},yt=Object.freeze([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),multiplyMatrices4=(e,t)=>[e[0]*t[0]+e[4]*t[1]+e[8]*t[2]+e[12]*t[3],e[1]*t[0]+e[5]*t[1]+e[9]*t[2]+e[13]*t[3],e[2]*t[0]+e[6]*t[1]+e[10]*t[2]+e[14]*t[3],e[3]*t[0]+e[7]*t[1]+e[11]*t[2]+e[15]*t[3],e[0]*t[4]+e[4]*t[5]+e[8]*t[6]+e[12]*t[7],e[1]*t[4]+e[5]*t[5]+e[9]*t[6]+e[13]*t[7],e[2]*t[4]+e[6]*t[5]+e[10]*t[6]+e[14]*t[7],e[3]*t[4]+e[7]*t[5]+e[11]*t[6]+e[15]*t[7],e[0]*t[8]+e[4]*t[9]+e[8]*t[10]+e[12]*t[11],e[1]*t[8]+e[5]*t[9]+e[9]*t[10]+e[13]*t[11],e[2]*t[8]+e[6]*t[9]+e[10]*t[10]+e[14]*t[11],e[3]*t[8]+e[7]*t[9]+e[11]*t[10]+e[15]*t[11],e[0]*t[12]+e[4]*t[13]+e[8]*t[14]+e[12]*t[15],e[1]*t[12]+e[5]*t[13]+e[9]*t[14]+e[13]*t[15],e[2]*t[12]+e[6]*t[13]+e[10]*t[14]+e[14]*t[15],e[3]*t[12]+e[7]*t[13]+e[11]*t[14]+e[15]*t[15]]
/**
	 * @description calculate the determinant of a 4x4 or 3x3 matrix.
	 * in the case of 4x4, the translation component is ignored.
	 * @param {number[]} matrix one matrix in array form
	 * @returns {number} the determinant of the matrix
	 * @linkcode Math ./src/algebra/matrix4.js 92
	 */,determinant4=e=>{const t=e[10]*e[15]-e[11]*e[14],r=e[9]*e[15]-e[11]*e[13],s=e[9]*e[14]-e[10]*e[13],o=e[8]*e[15]-e[11]*e[12],n=e[8]*e[14]-e[10]*e[12],a=e[8]*e[13]-e[9]*e[12];return e[0]*(e[5]*t-e[6]*r+e[7]*s)-e[1]*(e[4]*t-e[6]*o+e[7]*n)+e[2]*(e[4]*r-e[5]*o+e[7]*a)-e[3]*(e[4]*s-e[5]*n+e[6]*a)},invertMatrix4=e=>{const t=determinant4(e);if(Math.abs(t)<1e-6||Number.isNaN(t)||!Number.isFinite(e[12])||!Number.isFinite(e[13])||!Number.isFinite(e[14]))return;const r=e[10]*e[15]-e[11]*e[14],s=e[9]*e[15]-e[11]*e[13],o=e[9]*e[14]-e[10]*e[13],n=e[8]*e[15]-e[11]*e[12],a=e[8]*e[14]-e[10]*e[12],c=e[8]*e[13]-e[9]*e[12],i=e[6]*e[15]-e[7]*e[14],l=e[5]*e[15]-e[7]*e[13],d=e[5]*e[14]-e[6]*e[13],m=e[6]*e[11]-e[7]*e[10],g=e[5]*e[11]-e[7]*e[9],p=e[5]*e[10]-e[6]*e[9],v=e[4]*e[15]-e[7]*e[12],u=e[4]*e[14]-e[6]*e[12],h=e[4]*e[11]-e[7]*e[8],_=e[4]*e[10]-e[6]*e[8],b=e[4]*e[13]-e[5]*e[12],y=e[4]*e[9]-e[5]*e[8],E=[+(e[5]*r-e[6]*s+e[7]*o),-(e[1]*r-e[2]*s+e[3]*o),+(e[1]*i-e[2]*l+e[3]*d),-(e[1]*m-e[2]*g+e[3]*p),-(e[4]*r-e[6]*n+e[7]*a),+(e[0]*r-e[2]*n+e[3]*a),-(e[0]*i-e[2]*v+e[3]*u),+(e[0]*m-e[2]*h+e[3]*_),+(e[4]*s-e[5]*n+e[7]*c),-(e[0]*s-e[1]*n+e[3]*c),+(e[0]*l-e[1]*v+e[3]*b),-(e[0]*g-e[1]*h+e[3]*y),-(e[4]*o-e[5]*a+e[6]*c),+(e[0]*o-e[1]*a+e[2]*c),-(e[0]*d-e[1]*u+e[2]*b),+(e[0]*p-e[1]*_+e[2]*y)],x=1/t;return E.map((e=>e*x))},Et=Object.freeze([1,0,0,0,0,1,0,0,0,0,1,0]),makeMatrix4Translate=(e=0,t=0,r=0)=>[...Et,e,t,r,1]
// i0 and i1 direct which columns and rows are filled
// sgn manages right hand rule
,singleAxisRotate4=(e,t,r,s,o)=>{const n=makeMatrix4Translate(...t),a=Math.cos(e),c=Math.sin(e);return n[4*r+r]=a,n[4*r+s]=(o?1:-1)*c,n[4*s+r]=(o?-1:1)*c,n[4*s+s]=a,n},makePerspectiveMatrix4=(e,t,r,s)=>{const o=Math.tan(.5*Math.PI-.5*e),n=1/(r-s);return[o/t,0,0,0,0,o,0,0,0,0,(r+s)*n,-1,0,0,r*s*n*2,0]},makeOrthographicMatrix4=(e,t,r,s,o,n)=>[2/(t-s),0,0,0,0,2/(e-r),0,0,0,0,2/(o-n),0,(s+t)/(s-t),(r+e)/(r-e),(o+n)/(o-n),1]
/**
	 * @param {number[]} position the location of the camera in 3D space
	 * @param {number[]} target the point in space the camera is looking towards
	 * @param {number[]} up the vector pointing up out the top of the camera.
	 */;
/* Math (c) Kraft, MIT License */
/**
	 * Math (c) Kraft
	 */var xt=Object.freeze({__proto__:null,determinant4:determinant4,identity4x4:yt,invertMatrix4:invertMatrix4,isIdentity4x4:e=>yt.map(((t,r)=>Math.abs(t-e[r])<I)).reduce(((e,t)=>e&&t),!0)
/**
	 * @description multiply one 3D vector by a 4x4 matrix
	 * @param {number[]} matrix one matrix in array form
	 * @param {number[]} vector in array form
	 * @returns {number[]} the transformed vector
	 * @linkcode Math ./src/algebra/matrix4.js 35
	 */,makeLookAtMatrix4:(e,t,r)=>{const s=normalize3(subtract3(e,t)),o=normalize3(cross3(r,s)),n=normalize3(cross3(s,o));return[o[0],o[1],o[2],0,n[0],n[1],n[2],0,s[0],s[1],s[2],0,e[0],e[1],e[2],1]},makeMatrix4ReflectZ:(e,t=[0,0])=>{const r=makeMatrix2Reflect(e,t);return[r[0],r[1],0,0,r[2],r[3],0,0,0,0,1,0,r[4],r[5],0,1]},makeMatrix4Rotate:(e,t=[0,0,1],r=[0,0,0])=>{const s=[0,1,2].map((e=>r[e]||0)),[o,n,a]=resize(3,normalize(t)),c=Math.cos(e),i=Math.sin(e),l=1-c,d=makeMatrix4Translate(-s[0],-s[1],-s[2]),m=makeMatrix4Translate(s[0],s[1],s[2]);return multiplyMatrices4(m,multiplyMatrices4([l*o*o+c,l*n*o+a*i,l*a*o-n*i,0,l*o*n-a*i,l*n*n+c,l*a*n+o*i,0,l*o*a+n*i,l*n*a-o*i,l*a*a+c,0,0,0,0,1],d))},makeMatrix4RotateX:(e,t=[0,0,0])=>singleAxisRotate4(e,t,1,2,!0)
/**
	 * @description make a 4x4 matrix representing a rotation in 3D around the y-axis
	 * (allowing you to specify the center of rotation if needed).
	 * @param {number} angle the angle of rotation in radians
	 * @param {number[]} [origin=[0,0,0]] the center of rotation
	 * @returns {number[]} one 4x4 matrix
	 * @linkcode Math ./src/algebra/matrix4.js 198
	 */,makeMatrix4RotateY:(e,t=[0,0,0])=>singleAxisRotate4(e,t,0,2,!1)
/**
	 * @description make a 4x4 matrix representing a rotation in 3D around the z-axis
	 * (allowing you to specify the center of rotation if needed).
	 * @param {number} angle the angle of rotation in radians
	 * @param {number[]} [origin=[0,0,0]] the center of rotation
	 * @returns {number[]} one 4x4 matrix
	 * @linkcode Math ./src/algebra/matrix4.js 208
	 */,makeMatrix4RotateZ:(e,t=[0,0,0])=>singleAxisRotate4(e,t,0,1,!0)
/**
	 * @description make a 4x4 matrix representing a rotation in 3D
	 * around a given vector and around a given center of rotation.
	 * @param {number} angle the angle of rotation in radians
	 * @param {number[]} [vector=[0,0,1]] the axis of rotation
	 * @param {number[]} [origin=[0,0,0]] the center of rotation
	 * @returns {number[]} one 4x4 matrix
	 * @linkcode Math ./src/algebra/matrix4.js 219
	 */,makeMatrix4Scale:(e=[1,1,1],t=[0,0,0])=>[e[0],0,0,0,0,e[1],0,0,0,0,e[2],0,e[0]*-t[0]+t[0],e[1]*-t[1]+t[1],e[2]*-t[2]+t[2],1]
/**
	 * @description make a 4x4 representing a reflection across a line in the XY plane
	 * This is a 2D operation, assumes everything is in the XY plane.
	 * @param {number[]} vector one 2D vector specifying the reflection axis
	 * @param {number[]} [origin=[0,0]] 2D origin specifying a point of reflection
	 * @returns {number[]} one 4x4 matrix
	 * @linkcode Math ./src/algebra/matrix4.js 257
	 */,makeMatrix4Translate:makeMatrix4Translate,makeOrthographicMatrix4:makeOrthographicMatrix4,makePerspectiveMatrix4:makePerspectiveMatrix4,multiplyMatrices4:multiplyMatrices4,multiplyMatrix4Line3:(e,t,r)=>({vector:[e[0]*t[0]+e[4]*t[1]+e[8]*t[2],e[1]*t[0]+e[5]*t[1]+e[9]*t[2],e[2]*t[0]+e[6]*t[1]+e[10]*t[2]],origin:[e[0]*r[0]+e[4]*r[1]+e[8]*r[2]+e[12],e[1]*r[0]+e[5]*r[1]+e[9]*r[2]+e[13],e[2]*r[0]+e[6]*r[1]+e[10]*r[2]+e[14]]})
/**
	 * @description multiply two 4x4 matrices together
	 * @param {number[]} matrix the first matrix
	 * @param {number[]} matrix the second matrix
	 * @returns {number[]} one matrix, the product of the two
	 * @linkcode Math ./src/algebra/matrix4.js 67
	 */,multiplyMatrix4Vector3:(e,t)=>[e[0]*t[0]+e[4]*t[1]+e[8]*t[2]+e[12],e[1]*t[0]+e[5]*t[1]+e[9]*t[2]+e[13],e[2]*t[0]+e[6]*t[1]+e[10]*t[2]+e[14]]
/**
	 * @description multiply one 3D line by a 4x4 matrix
	 * @param {number[]} matrix one matrix in array form
	 * @param {number[]} vector the vector of the line
	 * @param {number[]} origin the origin of the line
	 * @returns {object} transformed line in point-vector form
	 * @linkcode Math ./src/algebra/matrix4.js 48
	 */});
/* Math (c) Kraft, MIT License */
/**
	 * Math (c) Kraft
	 */
/**
	 * @description Create a quaternion which represents a rotation from
	 * one 3D vector to another. Quaternion encoded as 0:x, 1:y, 2:z, 3:w.
	 * @param {number[]} u a 3D vector
	 * @param {number[]} v a 3D vector
	 * @returns {number[]} a quaternion representing a rotation
	 */
/* Math (c) Kraft, MIT License */
/**
	 * Math (c) Kraft
	 */
const At={...G,...Fe,...Ne,...xt,...Object.freeze({__proto__:null,matrix4FromQuaternion:e=>multiplyMatrices4([e[3],e[2],-e[1],e[0],-e[2],e[3],e[0],e[1],e[1],-e[0],e[3],e[2],-e[0],-e[1],-e[2],e[3]],[e[3],e[2],-e[1],-e[0],-e[2],e[3],e[0],-e[1],e[1],-e[0],e[3],-e[2],e[0],e[1],e[2],e[3]]),quaternionFromTwoVectors:(e,t)=>{const r=cross3(e,t),s=[r[0],r[1],r[2],dot(e,t)];return s[3]+=magnitude(s),normalize(s)}})},convexHull=(e=[],t=!1,r=I)=>{if(e.length<2)return[];
// if includeCollinear is true, we need to walk collinear points,
// problem is we don't know if we should be going towards or away from
// the origin point, so to work around that, make a mirror of all collinear
// vertices so that it walks both directions, ie: 1,6,5,13,5,6,1.
// half of them will be ignored due to being rejected from the
// threePointTurnDirection call, and the correct half will be saved.
const s=radialSortPointIndices2(e,r).map((e=>1===e.length?e:(e=>e.concat(e.slice(0,-1).reverse()))
/**
	 * @description Convex hull from a set of 2D points, choose whether
	 * to include or exclude points which lie collinear inside one of
	 * the boundary lines. modified Graham scan algorithm.
	 * @param {number[][]} points array of points, each point an array of numbers
	 * @param {boolean} [includeCollinear=false] true will include
	 * points collinear along the boundary
	 * @param {number} [epsilon=1e-6] undefined behavior when larger than 0.01
	 * @returns {number[]} not the points, but the indices
	 * of points in your "points" array
	 * @linkcode Math ./src/geometry/convex-hull.js 19
	 */(e))).flat();s.push(s[0]);const o=[s[0]];let n=1;
// threePointTurnDirection returns -1,0,1, with 0 as the collinear case.
// setup our operation for each case, depending on includeCollinear
const a={"-1":()=>o.pop(),1:e=>{o.push(e),n+=1},undefined:()=>{n+=1}};for(a[0]=t?a[1]:a[-1];n<s.length;){if(o.length<2){o.push(s[n]),n+=1;continue}const t=o[o.length-2],c=o[o.length-1],i=s[n];a[threePointTurnDirection(...[t,c,i].map((t=>e[t])),r)](i)}return o.pop(),o};
/* Math (c) Kraft, MIT License */
/**
	 * Math (c) Kraft
	 */
/**
	 * @description mirror an array and join it at the end, except
	 * do not duplicate the final element, it should only appear once.
	 */
/* Math (c) Kraft, MIT License */
/**
	 * Math (c) Kraft
	 */
/**
	 * @description this recursive algorithm works outwards-to-inwards, each repeat
	 * decreases the size of the polygon by one point/side. (removes 2, adds 1)
	 * and repeating the algorithm on the smaller polygon.
	 *
	 * @param {number[][]} array of point objects (arrays of numbers, [x, y]). the
	 *   counter-clockwise sorted points of the polygon. as we recurse this list shrinks
	 *   by removing the points that are "finished".
	 *
	 * @returns {object[]} array of line segments as objects with keys:
	 *   "points": array of 2 points in array form [ [x, y], [x, y] ]
	 *   "type": "skeleton" or "kawasaki", the latter being the projected perpendicular
	 *   dropped edges down to the sides of the polygon.
	 */
const recurseSkeleton=(e,t,r)=>{
// every point has an interior angle bisector vector, this ray is
// tested for intersections with its neighbors on both sides.
// "intersects" is fencepost mapped (i) to "points" (i, i+1)
// because one point/ray intersects with both points on either side,
// so in reverse, every point (i) relates to intersection (i-1, i)
const s=e.map(((e,t)=>({vector:r[t],origin:e}))).map(((e,t,r)=>intersectLineLine(e,r[(t+1)%r.length],X,X))),o=t.map(((e,t)=>nearestPointOnLine(e,s[t],(e=>e))));
// project each intersection point down perpendicular to the edge of the polygon
// const projections = lines.map((line, i) => line.nearestPoint(intersects[i]));
// when we reach only 3 points remaining, we are at the end. we can return early
// and skip unnecessary calculations, all 3 projection lengths will be the same.
if(3===e.length)return e.map((e=>({type:"skeleton",points:[e,s[0]]}))).concat([{type:"perpendicular",points:[o[0],s[0]]}]);
// measure the lengths of the projected lines, these will be used to identify
// the smallest length, or the point we want to operate on this round.
const n=s.map(((e,t)=>distance(e,o[t])));let a=0;n.forEach(((e,t)=>{e<n[a]&&(a=t)}));
// we have the shortest length, we now have the solution for this round
// (all that remains is to prepare the arguments for the next recursive call)
const c=[{type:"skeleton",points:[e[a],s[a]]},{type:"skeleton",points:[e[(a+1)%e.length],s[a]]},
// perpendicular projection
// we could expand this algorithm here to include all three instead of just one.
// two more of the entries in "intersects" will have the same length as shortest
{type:"perpendicular",points:[o[a],s[a]]}],i=clockwiseBisect2(flip(t[(a+t.length-1)%t.length].vector),t[(a+1)%t.length].vector),l=a===e.length-1;
// our new smaller polygon, missing two points now, but gaining one more (the intersection)
// this is to calculate the new angle bisector at this new point.
// we are now operating on the inside of the polygon, the lines that will be built from
// this bisection will become interior skeleton lines.
// first, flip the first vector so that both of the vectors originate at the
// center point, and extend towards the neighbors.
return e.splice(a,2,s[a]),t.splice(a,1),r.splice(a,2,i),l&&(
// in the case the index was at the end of the array,
// we tried to remove two elements but only removed one because
// it was the last element. remove the first element too.
e.splice(0,1),r.splice(0,1),
// also, the fencepost mapping of the lines array is off by one,
// move the first element to the end of the array.
t.push(t.shift())),c.concat(recurseSkeleton(e,t,r))},kt={...Object.freeze({__proto__:null,convexHull:convexHull}),...be,...Re,...W,...ie,straightSkeleton:e=>{
// first time running this function, create the 2nd and 3rd parameters
// convert the edges of the polygons into lines
const t=e.map(((e,t,r)=>[e,r[(t+1)%r.length]]
// .map(side => math.line.fromPoints(...side));
)).map((e=>({vector:subtract(e[1],e[0]),origin:e[0]}))),r=e.map(((e,t,r)=>[(t-1+r.length)%r.length,t,(t+1)%r.length].map((e=>r[e]))
// make 2 vectors, from current point to previous/next neighbors
)).map((e=>[subtract(e[0],e[1]),subtract(e[2],e[1])]
// it is a little counter-intuitive but the interior angle between three
// consecutive points in a counter-clockwise wound polygon is measured
// in the clockwise direction
)).map((e=>clockwiseBisect2(...e)));
// get the interior angle bisectors for every corner of the polygon
// index map match to "points"
// points is modified in place. create a copy
// const points_clone = JSON.parse(JSON.stringify(points));
// console.log("ss points", points_clone, points);
return recurseSkeleton([...e],t,r)}};
/**
	 * @description create a straight skeleton inside of a convex polygon
	 * @param {number[][]} points counter-clockwise polygon as an array of points
	 * (which are arrays of numbers)
	 * @returns {object[]} list of objects containing "points" {number[][]}: two points
	 * defining a line segment, and "type" {string}: either "skeleton" or "perpendicular"
	 *
	 * make sure:
	 *  - your polygon is convex (todo: make this algorithm work with non-convex)
	 *  - your polygon points are sorted counter-clockwise
	 * @linkcode Math ./src/geometry/straight-skeleton.js 123
	 */var Ot=Object.freeze({__proto__:null,enclosingBoundingBoxes:(e,t,r=I)=>{const s=Math.min(e.min.length,t.min.length);for(let o=0;o<s;o+=1)
// if one minimum is above the other's maximum, or visa versa
if(t.min[o]<e.min[o]-r||t.max[o]>e.max[o]+r)return!1;return!0},enclosingPolygonPolygon:(e,t,r=include)=>{
// these points should be *not inside* (false)
const s=e.map((e=>overlapConvexPolygonPoint(t,e,r))).reduce(((e,t)=>e||t),!1),o=t.map((e=>overlapConvexPolygonPoint(t,e,r))).reduce(((e,t)=>e&&t),!0);
// these points should be *inside* (true)
return!s&&o}});
/* Math (c) Kraft, MIT License */
/**
	 * Math (c) Kraft
	 */
/**
	 * @description Split a convex polygon by a line and rebuild each
	 * half into two convex polygons.
	 * @param {number[][]} polygon an array of points, each point is an array of numbers
	 * @param {RayLine} line a line object with "vector" and "origin"
	 * @param {number[]} origin the origin component of the line
	 * @returns {number[][][]} an array of one or two polygons, each polygon is an array of points,
	 * each point is an array of numbers.
	 * @linkcode Math ./src/geometry/split-polygon.js 19
	 */var wt=Object.freeze({__proto__:null,splitConvexPolygon:(e,t)=>{
// todo: should this return undefined if no intersection?
//       or the original poly?
//    point: intersection [x,y] point or null if no intersection
// at_index: where in the polygon this occurs
const r=e.map(((e,r)=>({point:overlapLinePoint(t,e,includeL)?e:null,at_index:r}))).filter((e=>null!=e.point)),s=e.map(((e,t,r)=>({vector:subtract(e,r[(t+1)%r.length]),origin:r[(t+1)%r.length]}))).map(((e,r)=>({point:intersectLineLine(t,e,excludeL,excludeS),at_index:r}))).filter((e=>null!=e.point));
// three cases: intersection at 2 edges, 2 points, 1 edge and 1 point
if(2===s.length){const t=s.slice().sort(((e,t)=>e.at_index-t.at_index)),r=e.slice(t[1].at_index+1).concat(e.slice(0,t[0].at_index+1));r.push(t[0].point),r.push(t[1].point);const o=e.slice(t[0].at_index+1,t[1].at_index+1);return o.push(t[1].point),o.push(t[0].point),[r,o]}if(1===s.length&&1===r.length){r[0].type="v",s[0].type="e";const t=r.concat(s).sort(((e,t)=>e.at_index-t.at_index)),o=e.slice(t[1].at_index+1).concat(e.slice(0,t[0].at_index+1));"e"===t[0].type&&o.push(t[0].point),o.push(t[1].point);// todo: if there's a bug, it's here. switch this
const n=e.slice(t[0].at_index+1,t[1].at_index+1);// todo: if there's a bug, it's here. switch this
return"e"===t[1].type&&n.push(t[1].point),n.push(t[0].point),[o,n]}if(2===r.length){const t=r.slice().sort(((e,t)=>e.at_index-t.at_index));return[e.slice(t[1].at_index).concat(e.slice(0,t[0].at_index+1)),e.slice(t[0].at_index,t[1].at_index+1)]}return[e.slice()]}});
/* Math (c) Kraft, MIT License */
/**
	 * Math (c) Kraft
	 */const Mt={polygon:includeS,circle:include,line:includeL,ray:Y,segment:includeS},jt={...Ot,...ye,...Ae,...He,...wt,intersect:(e,t,r=I)=>{
// method names are: (a) capitalized, and
// (b) "Polygon" appears as "ConvexPolygon"
const nameType=e=>"polygon"===e?"ConvexPolygon":(e=>e.charAt(0).toUpperCase()+e.slice(1))(e)
// get the type of each parameter
,s=[e,t].map(typeOf),o=[s,s.slice().reverse()].map((e=>e.map(nameType).join(""))).map((e=>Ae[`intersect${e}`])),n=[e.domain,t.domain].map(((e,t)=>e||Mt[s[t]])),a=[[e,t,...n],[t,e,...n.slice().reverse()]],c=o.map(((e,t)=>({fn:e,params:a[t]}))).filter((e=>e.fn)).shift();return c?c.fn(...c.params,r):void 0}},Ft={...bt,...At,...kt,...jt},cubrt=e=>e<0?-Math.pow(-e,1/3):Math.pow(e,1/3)
// Robert Lang's cubic solver from Reference Finder
// https://langorigami.com/article/referencefinder/
,normalAxiom6=(e,t,r,s)=>{
// at least pointA must not be on lineA
// for some reason this epsilon is much higher than 1e-6
if(Math.abs(1-dot2(e.normal,r)/e.distance)<.02)return[];
// line vec is the first line's vector, along the line, not the normal
const o=rotate90(e.normal),n=subtract2(add2(r,scale2(e.normal,e.distance)),scale2(s,2)),a=subtract2(scale2(e.normal,e.distance),r),c=dot2(s,t.normal)-t.distance,i=2*dot2(a,o),l=dot2(a,a),d=dot2(add2(n,a),o),m=dot2(n,a),g=dot2(o,t.normal),p=dot2(a,t.normal),v=g,u=c+d*g+p,h=c*i+m*g+d*p,_=c*l+m*p;
// construct the solution from the root, the solution being the parameter
// point reflected across the fold line, lying on the parameter line
let b=0;return Math.abs(h)>I&&(b=1),Math.abs(u)>I&&(b=2),Math.abs(v)>I&&(b=3),((e,t,r,s,o)=>{switch(e){case 1:return[-o/s];case 2:{
// quadratic
const e=Math.pow(s,2)-4*r*o;
// no solution
if(e<-I)return[];
// one solution
const t=-s/(2*r);if(e<I)return[t];
// two solutions
const n=Math.sqrt(e)/(2*r);return[t+n,t-n]}case 3:{
// cubic
// Cardano's formula. convert to depressed cubic
const e=r/t,n=s/t,a=o/t,c=(3*n-Math.pow(e,2))/9,i=(9*e*n-27*a-2*Math.pow(e,3))/54,l=Math.pow(c,3)+Math.pow(i,2),d=-e/3;
// one solution
if(l>0){const e=Math.sqrt(l);return[d+cubrt(i+e)+cubrt(i-e)]}
// two solutions
if(Math.abs(l)<I){const e=Math.pow(i,1/3);
// const S = cubrt(R);
// instead of checking if S is NaN, check if R was negative
// if (isNaN(S)) { break; }
return i<0?[]:[d+2*e,d-e]}
// three solutions
const m=Math.sqrt(-l),g=Math.atan2(m,i)/3,p=Math.pow(Math.pow(i,2)-l,1/6),v=p*Math.cos(g),u=p*Math.sin(g);return[d+2*v,d-v-Math.sqrt(3)*u,d-v+Math.sqrt(3)*u]}default:return[]}})(b,v,u,h,_).map((t=>add2(scale2(e.normal,e.distance),scale2(o,t)))).map((e=>({p:e,normal:normalize2(subtract2(e,r))}))).map((e=>({normal:e.normal,distance:dot2(e.normal,midpoint2(e.p,r))})))};var Ct=Object.freeze({__proto__:null,normalAxiom1:(e,t)=>{const r=normalize2(rotate90(subtract2(t,e)));return{normal:r,distance:dot2(add2(e,t),r)/2}},normalAxiom2:(e,t)=>{const r=normalize2(subtract2(t,e));return{normal:r,distance:dot2(add2(e,t),r)/2}},normalAxiom3:(e,t)=>{
// if no intersect, lines are parallel, only one solution exists
const r=((e,t)=>{const r=cross2(e.normal,t.normal);if(Math.abs(r)<I)return;return[(e.distance*t.normal[1]-t.distance*e.normal[1])/r,(t.distance*e.normal[0]-e.distance*t.normal[0])/r]})(e,t);return void 0===r?[{normal:e.normal,distance:(e.distance+t.distance*dot2(e.normal,t.normal))/2}]:[add2,subtract2].map((r=>normalize2(r(e.normal,t.normal)))).map((e=>({normal:e,distance:dot2(r,e)})))},normalAxiom4:(e,t)=>{const r=rotate90(e.normal);return{normal:r,distance:dot2(t,r)}},normalAxiom5:(e,t,r)=>{const s=dot2(t,e.normal),o=e.distance-s,n=distance2(t,r);if(o>n)return[];const a=Math.sqrt(n*n-o*o),c=scale2(e.normal,o),i=add2(t,c),l=scale2(rotate90(e.normal),a);return(a<I?[i]:[add2(i,l),subtract2(i,l)]).map((e=>normalize2(subtract2(r,e)))).map((e=>({normal:e,distance:dot2(t,e)})))},normalAxiom6:normalAxiom6,normalAxiom7:(e,t,r)=>{const s=rotate90(e.normal),o=dot2(s,t.normal);
// if norm_norm is close to 0, the two input lines are parallel, no solution
if(Math.abs(o)<I)return;const n=dot2(r,s),a=dot2(r,t.normal);return{normal:s,distance:(t.distance+2*n*o-a)/(2*o)}}});
/**
	 * Rabbit Ear (c) Kraft
	 */
/*           _                       _              _
							(_)                     (_)            (_)
		 ___  _ __ _  __ _  __ _ _ __ ___  _    __ ___  ___  ___  _ __ ___  ___
		/ _ \| '__| |/ _` |/ _` | '_ ` _ \| |  / _` \ \/ / |/ _ \| '_ ` _ \/ __|
	 | (_) | |  | | (_| | (_| | | | | | | | | (_| |>  <| | (_) | | | | | \__ \
		\___/|_|  |_|\__, |\__,_|_| |_| |_|_|  \__,_/_/\_\_|\___/|_| |_| |_|___/
									__/ |
								 |___/
	/**
	 * these origami axioms assume 2D geometry in the 2D plane,
	 * where points are parameterized as vectors (Javascript arrays of numbers)
	 * and lines are in vector-origin form (Javascript objects with "origin" and "vector")
	 *   (themselves are Javascript Arrays, same as "points")
	 * where the direction of the vector is along the line, and
	 * is not necessarily normalized.
	 */
/**
	 * @description origami axiom 1: form a line that passes between the given points
	 * @param {number[]} point1 one 2D point
	 * @param {number[]} point2 one 2D point
	 * @returns {RayLine} the line in {vector, origin} form
	 * @linkcode Origami ./src/axioms/axiomsVecOrigin.js 28
	 */var Pt=Object.freeze({__proto__:null,axiom1:(e,t)=>({vector:normalize2(subtract2(...resizeUp(t,e))),origin:e})
/**
	 * @description origami axiom 2: form a perpendicular bisector between the given points
	 * @param {number[]} point1 one 2D point
	 * @param {number[]} point2 one 2D point
	 * @returns {RayLine} the line in {vector, origin} form
	 * @linkcode Origami ./src/axioms/axiomsVecOrigin.js 39
	 */,axiom2:(e,t)=>({vector:normalize2(rotate90(subtract2(...resizeUp(t,e)))),origin:midpoint2(e,t)})
// todo: make sure these all get a resizeUp or whatever is necessary
/**
	 * @description origami axiom 3: form two lines that make the two angular bisectors between
	 * two input lines, and in the case of parallel inputs only one solution will be given
	 * @param {RayLine} line1 one 2D line in {vector, origin} form
	 * @param {RayLine} line2 one 2D line in {vector, origin} form
	 * @returns {RayLine[]} an array of lines in {vector, origin} form
	 * @linkcode Origami ./src/axioms/axiomsVecOrigin.js 54
	 */,axiom3:(e,t)=>bisectLines2(e,t)
/**
	 * @description origami axiom 4: form a line perpendicular to a given line that
	 * passes through a point.
	 * @param {RayLine} line one 2D line in {vector, origin} form
	 * @param {number[]} point one 2D point
	 * @returns {RayLine} the line in {vector, origin} form
	 * @linkcode Origami ./src/axioms/axiomsVecOrigin.js 64
	 */,axiom4:(e,t)=>({vector:rotate90(normalize2(e.vector)),origin:t})
/**
	 * @description origami axiom 5: form up to two lines that pass through a point that also
	 * brings another point onto a given line
	 * @param {RayLine} line one 2D line in {vector, origin} form
	 * @param {number[]} point one 2D point, the point that the line(s) pass through
	 * @param {number[]} point one 2D point, the point that is being brought onto the line
	 * @returns {RayLine[]} an array of lines in {vector, origin} form
	 * @linkcode Origami ./src/axioms/axiomsVecOrigin.js 77
	 */,axiom5:(e,t,r)=>(intersectCircleLine({radius:distance2(t,r),origin:t},e)||[]).map((e=>({vector:normalize2(rotate90(subtract2(...resizeUp(e,r)))),origin:midpoint2(r,e)})))
/**
	 * @description origami axiom 6: form up to three lines that are made by bringing
	 * a point to a line and a second point to a second line.
	 * @param {RayLine} line1 one 2D line in {vector, origin} form
	 * @param {RayLine} line2 one 2D line in {vector, origin} form
	 * @param {number[]} point1 the point to bring to the first line
	 * @param {number[]} point2 the point to bring to the second line
	 * @returns {RayLine[]} an array of lines in {vector, origin} form
	 * @linkcode Origami ./src/axioms/axiomsVecOrigin.js 100
	 */,axiom6:(e,t,r,s)=>normalAxiom6(rayLineToUniqueLine(e),rayLineToUniqueLine(t),r,s).map(uniqueLineToRayLine)
// .map(Constructors.line);
/**
	 * @description origami axiom 7: form a line by bringing a point onto a given line
	 * while being perpendicular to another given line.
	 * @param {RayLine} line1 one 2D line in {vector, origin} form,
	 * the line the point will be brought onto.
	 * @param {RayLine} line2 one 2D line in {vector, origin} form,
	 * the line which the perpendicular will be based off.
	 * @param {number[]} point the point to bring onto the line
	 * @returns {RayLine | undefined} the line in {vector, origin} form
	 * or undefined if the given lines are parallel
	 * @linkcode Origami ./src/axioms/axiomsVecOrigin.js 119
	 */,axiom7:(e,t,r)=>{const s=intersectLineLine(e,{vector:t.vector,origin:r},includeL,includeL);return void 0===s?void 0:{
// todo: switch this out, but test it as you do
vector:normalize2(rotate90(subtract2(...resizeUp(s,r)))),
// vector: normalize2(rotate90(line2.vector)),
origin:midpoint2(r,s)}}});
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * @description The core axiom methods return arrays for *some* of the axioms.
	 * Standardize the output so that all of them are inside arrays.
	 * @param {number} the axiom number
	 * @param {Line|Line[]} the solutions from having run the axiom method
	 * @returns {Line[]} the solution lines, now consistently inside an array.
	 */const arrayify=(e,t)=>{switch(e){case 3:case"3":case 5:case"5":case 6:case"6":return t;
// 7 is the only axiom which can return a single undefined (not in an array)
case 7:case"7":return void 0===t?[]:[t];default:return[t]}},reflectPoint=(e,t)=>{const r=makeMatrix2Reflect(e.vector,e.origin);return multiplyMatrix2Vector2(r,t)},validateAxiom1=(e,t)=>e.points.map((e=>overlapConvexPolygonPoint(t,e,include))).reduce(((e,t)=>e&&t),!0)
/**
	 * @description To validate axiom 2 check if the input points are inside the
	 * boundary polygon, if so, the solution is valid.
	 * @param {AxiomParams} params the axiom parameters, lines and points in one object
	 * @param {number[][]} boundary an array of points, each point is an array of numbers
	 * @returns {boolean} true if the solution is valid
	 * @linkcode Origami ./src/axioms/validate.js 28
	 */,Nt=validateAxiom1,validateAxiom3=(e,t,r)=>{const s=e.lines.map((e=>clipLineConvexPolygon(t,e,include,includeL)));
// if line parameters lie outside polygon, no solution possible
if(void 0===s[0]||void 0===s[1])return[!1,!1];
// test A:
// make sure the results themselves lie in the polygon
// exclusive! an exterior line collinear to polygon's point is excluded
// const results_clip = results
//   .map(line => line === undefined ? undefined : math
//     .intersectConvexPolygonLine(
//       boundary,
//       line,
//       includeS,
//       excludeL));
const o=r.map((e=>void 0===e?void 0:clipLineConvexPolygon(t,e,include,includeL))),n=[0,1].map((e=>void 0!==o[e])),a=r.map((e=>void 0===e?void 0:[reflectPoint(e,s[0][0]),reflectPoint(e,s[0][1])])).map((e=>void 0!==e&&(overlapLinePoint({vector:subtract(s[1][1],s[1][0]),origin:s[1][0]},e[0],includeS)||overlapLinePoint({vector:subtract(s[1][1],s[1][0]),origin:s[1][0]},e[1],includeS)||overlapLinePoint({vector:subtract(e[1],e[0]),origin:e[0]},s[1][0],includeS)||overlapLinePoint({vector:subtract(e[1],e[0]),origin:e[0]},s[1][1],includeS))));
// valid if A and B
return[0,1].map((e=>!0===a[e]&&!0===n[e]))},validateAxiom4=(e,t)=>{const r=intersectLineLine(e.lines[0],{vector:rotate90(e.lines[0].vector),origin:e.points[0]},includeL,includeL);return[e.points[0],r].filter((e=>void 0!==e)).map((e=>overlapConvexPolygonPoint(t,e,include))).reduce(((e,t)=>e&&t),!0)},validateAxiom5=(e,t,r)=>{if(0===r.length)return[];const s=e.points.map((e=>overlapConvexPolygonPoint(t,e,include))).reduce(((e,t)=>e&&t),!0);return r.map((t=>reflectPoint(t,e.points[1]))).map((e=>overlapConvexPolygonPoint(t,e,include))).map((e=>e&&s))},validateAxiom6=function(e,t,r){if(0===r.length)return[];if(!e.points.map((e=>overlapConvexPolygonPoint(t,e,include))).reduce(((e,t)=>e&&t),!0))return r.map((()=>!1));const s=r.map((t=>reflectPoint(t,e.points[0]))).map((e=>overlapConvexPolygonPoint(t,e,include))),o=r.map((t=>reflectPoint(t,e.points[1]))).map((e=>overlapConvexPolygonPoint(t,e,include)));return r.map(((e,t)=>s[t]&&o[t]))},validateAxiom7=(e,t,r)=>{
// check if the point parameter is inside the polygon
const s=overlapConvexPolygonPoint(t,e.points[0],include);
// check if the reflected point on the fold line is inside the polygon
if(void 0===r)return[!1];const o=reflectPoint(r,e.points[0]),n=overlapConvexPolygonPoint(t,o,include),a=void 0!==intersectConvexPolygonLine(t,e.lines[1],includeS,includeL),c=intersectLineLine(e.lines[1],r,includeL,includeL),i=!!c&&overlapConvexPolygonPoint(t,c,include);return s&&n&&a&&i},validateAxiom=(e,t,r,s)=>arrayify(e,[null,validateAxiom1,Nt,validateAxiom3,validateAxiom4,validateAxiom5,validateAxiom6,validateAxiom7][e](t,r,((e,t)=>{switch(e){case 3:case"3":case 5:case"5":case 6:case"6":return t;default:return t?t[0]:void 0}})(e,s)));
/**
	 * @description convert an array of solutions into the original state,
	 * which means for axiom 3, 5, 6 it remains an array,
	 * and for 1, 2, 4, 7 the first (only) element is returned.
	 */var St=Object.freeze({__proto__:null,validateAxiom1:validateAxiom1,validateAxiom2:Nt,validateAxiom3:validateAxiom3,validateAxiom4:validateAxiom4,validateAxiom5:validateAxiom5,validateAxiom6:validateAxiom6,validateAxiom7:validateAxiom7,validateAxiom:validateAxiom});
/**
	 * Rabbit Ear (c) Kraft
	 */const spreadParams=e=>[...e.lines?e.lines:[],...e.points?e.points:[]],axiomInBoundary=(e,t={},r)=>{const s=arrayify(e,Pt[`axiom${e}`](...spreadParams(t)));
// ).map(l => math.line(l));
return r&&arrayify(e,St[`validateAxiom${e}`](t,r,s)).forEach(((e,t)=>e?t:void 0)).filter((e=>void 0!==e)).forEach((e=>delete s[e])),s};
/**
	 * @description All axiom method arguments are ordered such that all lines are
	 * listed first, followed by all points. convert the axiom params object
	 * (with "points", "lines" keys) into a single flat array
	 */var Vt=Object.freeze({__proto__:null,axiomInBoundary:axiomInBoundary,normalAxiomInBoundary:(e,t={},r)=>{const s=arrayify(e,Ct[`normalAxiom${e}`](...spreadParams(t))).map((e=>uniqueLineToRayLine(e)));return r&&arrayify(e,St[`validateAxiom${e}`]((e=>({points:e.points,lines:e.lines.map(uniqueLineToRayLine)}))(t),r,s)).forEach(((e,t)=>e?t:void 0)).filter((e=>void 0!==e)).forEach((e=>delete s[e])),s}});
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * @description Perform one of the seven origami axioms. Supply an optional boundary
	 * so that only the results possible inside the boundary will be returned.
	 * @param {number} number the axiom number, 1-7. **note, 0 is not an option**
	 * @param {AxiomParams} params the origami axiom parameters, lines and points,
	 * where the lines are either {RayLine} or {UniqueLine}.
	 * @param {number[][]} [boundary] the optional boundary,
	 * including this will exclude results that lie outside.
	 * @returns {RayLine[]} an array of solutions as lines, or an empty array if no solutions.
	 * @linkcode Origami ./src/axioms/index.js 26
	 */const axiom=(e,t={},r)=>axiomInBoundary(e,t,r);Object.keys(Pt).forEach((e=>{axiom[e]=Pt[e]})),Object.keys(Ct).forEach((e=>{axiom[e]=Ct[e]})),Object.keys(Vt).forEach((e=>{axiom[e]=Vt[e]})),axiom.validateAxiom1=validateAxiom1,axiom.validateAxiom2=Nt,axiom.validateAxiom3=validateAxiom3,axiom.validateAxiom4=validateAxiom4,axiom.validateAxiom5=validateAxiom5,axiom.validateAxiom6=validateAxiom6,axiom.validateAxiom7=validateAxiom7,axiom.validate=validateAxiom;// different name
/**
	 * Rabbit Ear (c) Kraft
	 */
const line_line_for_arrows=(e,t)=>intersectLineLine(e,t,includeL,includeL),diagram_reflect_point=(e,t)=>{const r=makeMatrix2Reflect(e.vector,e.origin);return multiplyMatrix2Vector2(r,t)},boundary_for_arrows$1=({vertices_coords:e})=>convexHull(e).map((t=>e[t])),widest_perp=(e,t,r)=>{const s=boundary_for_arrows$1(e);if(void 0===r){const e=clipLineConvexPolygon(s,t,exclude,includeL);r=midpoint(...e)}const o=rotate270(t.vector),n=clipLineConvexPolygon(s,{vector:o,origin:r},exclude,includeL).map((e=>distance(r,e))).sort(((e,t)=>e-t)).shift(),a=scale(normalize(o),n);return[add(r,flip(a)),add(r,a)]},between_2_segments=(e,t,r)=>{const s=t.map((e=>midpoint(e[0],e[1]))),o=pointsToLine(...s),n=intersect(r,o),a={vector:r.vector.rotate90(),origin:n};return segment(e.lines.map((e=>intersect(e,a))))},$t=[null,(e,t)=>axiom(1,e).map((e=>[widest_perp(t,e)])),e=>[[...e.points]],(e,t)=>{const r=boundary_for_arrows$1(t),s=e.lines.map((e=>clipLineConvexPolygon(r,e,exclude,includeL))),o=s.map((e=>subtract(e[1],e[0]))),n=intersectLineLine({vector:o[0],origin:s[0][0]},{vector:o[1],origin:s[1][0]},excludeS,excludeS);return n?axiom(3,e).map((t=>((e,t,r,s)=>{const o=e.lines.map((e=>e.vector)),n=o.map(flip),a=o.concat(n).map((e=>ray(e,t))),c=a.filter((e=>dot(e.vector,r.vector)>0&&cross2(e.vector,r.vector)>0)).shift(),i=a.filter((e=>dot(e.vector,r.vector)>0&&cross2(e.vector,r.vector)<0)).shift(),l=a.filter((e=>dot(e.vector,r.vector)<0&&cross2(e.vector,r.vector)>0)).shift(),d=a.filter((e=>dot(e.vector,r.vector)<0&&cross2(e.vector,r.vector)<0)).shift(),m=[c,i,l,d].map((e=>intersectConvexPolygonLine(s,e,excludeS,X).shift().shift())),g=m.map((e=>distance(e,t)));return[[g[0]<g[1]?m[0]:m[1],g[0]<g[1]?add(i.origin,i.vector.normalize().scale(g[0])):add(c.origin,c.vector.normalize().scale(g[1]))],[g[2]<g[3]?m[2]:m[3],g[2]<g[3]?add(d.origin,d.vector.normalize().scale(g[2])):add(l.origin,l.vector.normalize().scale(g[3]))]]})(e,n,t,r))):[between_2_segments(e,s,axiom(3,e).filter((e=>void 0!==e)).shift())]},(e,t)=>axiom(4,e).map((r=>[widest_perp(t,r,line_line_for_arrows(r,e.lines[0]))])),e=>axiom(5,e).map((t=>[e.points[1],diagram_reflect_point(t,e.points[1])])),e=>axiom(6,e).map((t=>e.points.map((e=>[e,diagram_reflect_point(t,e)])))),(e,t)=>axiom(7,e).map((r=>[[e.points[0],diagram_reflect_point(r,e.points[0])],widest_perp(t,r,line_line_for_arrows(r,e.lines[1]))]))];delete $t[0];const axiomArrows=(e,t={},...r)=>{const s=t.points?t.points.map((e=>getVector(e))):void 0,o=t.lines?t.lines.map((e=>getLine$1(e))):void 0;return $t[e]({points:s,lines:o},...r)};Object.keys($t).forEach((e=>{axiomArrows[e]=(...t)=>axiomArrows(e,...t)}));
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * @description A collection of methods for drawing origami diagrams.
	 */
var zt=Object.assign(Object.create(null),
// arrows, {
{axiom_arrows:axiomArrows,simple_arrow:(e,t)=>{const r=(({vertices_coords:e})=>convexHull(e).map((t=>e[t])))(e),s=boundingBox$1(r),o=((e,t,r)=>{if(void 0===r){const s=clipLineConvexPolygon(e,t,exclude,includeL);if(void 0===s)return;r=midpoint(...s)}const s=rotate90(t.vector),o=clipLineConvexPolygon(e,{vector:s,origin:r},exclude,includeL).map((e=>distance(r,e))).sort(((e,t)=>e-t)).shift(),n=scale(normalize(s),o);return[add(r,flip(n)),add(r,n)]})(r,t);if(void 0===o)return;const n=subtract(o[1],o[0]),a=magnitude(n),c=dot(n,[1,0]),i=s.span[0]<s.span[1]?s.span[0]:s.span[1];return o.head={width:.1*i,height:.15*i},o.bend=c>0?.3:-.3,o.padding=.05*a,o}});
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * @description Flip a model over by reversing the order of the faces
	 * in a faces_layer encoding.
	 * @param {number[]} faces_layer a faces_layer array
	 * @returns {number[]} a new faces_layer array
	 * @linkcode Origami ./src/layer/general.js 12
	 */var Tt=Object.freeze({__proto__:null,flipFacesLayer:e=>invertMap(invertMap(e).reverse())
/**
	 * @description Given a faces_layer ordering of faces in a graph,
	 * complute the edges_assignments, including "B", "F", "V", and "M".
	 * @param {FOLD} graph a FOLD graph, with the vertices already folded.
	 * @param {number[]} faces_layer a faces_layer array
	 * @returns {string[]} an edges_assignment array.
	 * @linkcode Origami ./src/layer/general.js 23
	 */,facesLayerToEdgesAssignments:(e,t)=>{const r=[],s=makeFacesWinding(e);return(e.edges_faces?e.edges_faces:makeEdgesFaces(e)).forEach(((e,o)=>{if(1===e.length&&(r[o]="B"),2===e.length){const n=e.map((e=>s[e]));if(n[0]===n[1])return void(r[o]="F");const a=e.map((e=>t[e])),c=a[0]<a[1],i=n[0]?c:!c;r[o]=i?"V":"M"}})),r},faceOrdersToMatrix:e=>{const t=[];e.forEach((e=>{t[e[0]]=void 0,t[e[1]]=void 0}));const r=t.map((()=>[]));return e.forEach((([e,t,s])=>{r[e][t]=s,r[t][e]=-s})),r}});
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * @description find a topological ordering from a set of faceOrders
	 * @param {number[]} faces a subset of face indices where all faces have been
	 * @param {FOLD} graph an optional FOLD graph
	 * @returns {number[]} layers_face, for every layer (key) which face (value) inhabits it.
	 * @linkcode Origami ./src/layer/topological.js 10
	 */const nudgeFacesWithFacesLayer=({faces_layer:e})=>{const t=[];return invertMap(e).forEach(((e,r)=>{t[e]={vector:[0,0,1],layer:r}})),t},nudgeFacesWithFaceOrders=({vertices_coords:e,faces_vertices:t,faceOrders:r})=>{const s=makeFacesNormal({vertices_coords:e,faces_vertices:t}),o=connectedComponents(makeVerticesVerticesUnsorted({edges_vertices:r.map((e=>[e[0],e[1]]))})),n=invertMap(o).map((e=>e.constructor===Array?e:[e])),a=n.map((e=>(({faceOrders:e,faces_normal:t},r)=>{if(!e)return[];const s={};r.forEach((e=>{s[e]=!0})),r[0];const o=[];r.forEach((e=>{o[e]=dot(t[e],t[r[0]])>0}));
// create an array where every face involved gets an index and an array as its value
// this array will contain every face that is "below" this face.
const n=[];
// const facesAbove = [];
r.forEach((e=>{n[e]=[]})),
// faces.forEach(face => { facesAbove[face] = []; })
e.forEach((e=>{
// "faces" is already disjoint. we only need to check one face in order
if(!s[e[0]])return;
// this pair states face [0] is above face [1]. according to the +1 -1 order,
// and whether or not the reference face [1] normal is flipped. (xor either)
const t=-1===e[2]^!o[e[1]]?[e[1],e[0]]:[e[0],e[1]];n[t[0]].push(t[1])}
// facesAbove[pair[1]].push(pair[0]);
));const a=[],c={},recurse=e=>{c[e]=!0,n[e].forEach((e=>{c[e]||recurse(e)})),a.push(e)};// this is the topological ordering
// console.log("faces", faces);
// console.log("faceOrders", faceOrders);
// console.log("faces_normal_match", faces_normal_match);
// console.log("facesBelow", facesBelow);
// console.log("facesAbove", facesAbove);
// console.log("layers_face", layers_face);
return r.forEach((e=>{c[e]||recurse(e)})),a})({faceOrders:r,faces_normal:s},e))),c=n.map((e=>s[e[0]])),i=[];
// create a graph where the vertices are the faces, and edges
// are connections between faces according to faceOrders
// using this representation, find the disjoint sets of faces,
// those which are isolated from each other according to layer orders
return a.forEach(((e,t)=>e.forEach(((e,r)=>{i[e]={vector:c[t],layer:r}})))),i};
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * @description Given a graph with a faces_layer, a topological sorting
	 * of faces, for a flat-folded 2D graph, get an array where every face
	 * is given a layer and a vector, which will always be [0, 0, 1].
	 * @param {FOLD} graph a FOLD graph with the parameter faces_layer.
	 * @returns {object[]} an array of objects, one for every face, each
	 * with properties "vector" and "layer".
	 * @linkcode Origami ./src/layer/nudge.js 15
	 */var Lt=Object.freeze({__proto__:null,nudgeFacesWithFacesLayer:nudgeFacesWithFacesLayer,nudgeFacesWithFaceOrders:nudgeFacesWithFaceOrders});
/**
	 * Rabbit Ear (c) Kraft
	 */
// todo, should epsilon be multiplied by 2?
/**
	 * @description make an array of objects where each object represents one
	 * fold line, and contains all the tacos and tortillas sharing the fold line.
	 * @param {number[][]} folded_faces sectors in their folded positions, the result
	 * of calling "foldStripWithAssignments"
	 * @param {boolean} is_circular if the folded strip wraps around and joins with itself.
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {object[]} array of taco objects. each taco object represents one
	 * fold location shared by multiple tacos. each taco object contains keys:
	 * "both", "left", "right" where the values are an array of pairs of faces,
	 * the pairs of adjacent faces around the taco edge. "left": [ [2,3] [6,0] ]
	 * @linkcode Origami ./src/layer/singleVertexSolver/makeFoldedStripTacos.js 18
	 */const between=(e,t,r)=>t<r?e.slice(t+1,r):e.slice(r+1,t)
/**
	 * because this test is meant to run during the intermediate steps while
	 * the a strip is being assembled, the strip may eventually be circular,
	 * but currently it isn't.
	 *
	 * @params {[number, number][]} for every sector, "start" and "end" of each sector
	 * this is the output of having run "foldStripWithAssignments"
	 * @param {number[]} layers_face, index is z-layer, value is the sector/face.
	 * @param {boolean} do assignments contain a boundary? (to test for loop around)
	 * @returns {boolean} does a violation occur. "false" means all good.
	 * @linkcode Origami ./src/layer/singleVertexSolver/validateTacoTortillaStrip.js 24
	 */,validateTacoTacoFacePairs=e=>{
// create a copy of "stack" that removes single faces currently missing
// their other pair partner. this removes boundary faces (with no adj. face)
// as well as stacks which are in the process of being constructed but not
// yet final
const t=nonUniqueElements(e),r={};let s=0;for(let e=0;e<t.length;e+=1)if(void 0===r[t[e]])s+=1,r[t[e]]=s;else if(void 0!==r[t[e]]){
// if we have seen this layer pair already, it MUST be appearing
// in the correct order, that is, as it gets popped off the stack,
// it must be the next-most-recently added pair to the stack.
if(r[t[e]]!==s)return!1;s-=1,r[t[e]]=void 0}return!0},build_layers=(e,t)=>e.map((e=>t[e])).filter((e=>void 0!==e)),validateLayerSolver=(e,t,r,s,o)=>{
// if the strip contains "F" assignments, layers_face will contain
// a mix of numbers and arrays of numbers, like: [1, 0, 5, [3, 4], 2]
// as [3,4] are on the same "layer".
// flatten this array so all numbers get pushed onto the top level, like:
// [1, 0, 5, [3, 4], 2] into [1, 0, 5, 3, 4, 2].
// now, this does create a layer preference between (3 and 4 in this example),
// but in this specific use case we can be guaranteed that only one of those
// will be used in the build_layers, as only one of a set of flat-
// strip faces can exist in one taco stack location.
const n=flattenArrays(t);
// taco-tortilla intersections
if(!((e,t,r=!0,s=I)=>{
// for every sector/face, the value is its index in the layers_face array
const o=invertMap(t),n=e.map((e=>e?e[1]:void 0)),a=e.map((e=>e?Math.min(...e):void 0)).map((e=>e+s)),c=e.map((e=>e?Math.max(...e):void 0)).map((e=>e-s)),i=o.length+(r?0:-1);
// for every sector, the location of the end of the sector after folding
// (the far end, the second end visited by the walk)
// iterate through all the faces, take each face together with the next face,
// establish the fold line between them, then check the layer stacking and
// gather all faces that exist between this pair of faces, test each
// of them to see if they cross through this pair's fold line.
for(let e=0;e<i;e+=1){
// this is the next face in the folding sequence
const r=(e+1)%o.length;
// if two adjacent faces are in the same layer, they will not be causing an
// overlap, at least not at their crease (because there is no crease).
if(o[e]===o[r])continue;
// todo consider prebuilding a table of comparing fold locations with face mins and maxs
// result of between contains both numbers and arrays: [5,[0,1],2,[3,4]]
// the reduce will bring everything to the top level: [5,0,1,2,3,4]
const s=between(t,o[e],o[r]).flat(),i=s.map((t=>n[e]<a[t])).reduce(((e,t)=>e&&t),!0),l=s.map((t=>n[e]>c[t])).reduce(((e,t)=>e&&t),!0);
// check if the fold line is (below/above) ALL of the sectors between it
// it will be above if
if(!i&&!l)return!1}return!0})(e,t,s,o))return!1;
// taco-taco intersections
for(let e=0;e<r.length;e+=1){const t=build_layers(n,r[e]);if(!validateTacoTacoFacePairs(t))return!1}return!0},Bt={V:!0,v:!0,M:!0,m:!0},It={V:1,v:1,M:-1,m:-1},assignmentsToFacesVertical=e=>{let t=0;
// because fencepost, we are relating assignments[1] to face[0]
return e.slice(1).concat([e[0]]).map((e=>{const r=(s=e,t%2==0?It[s]||0:-(It[s]||0));var s;
/**
	 * @description convert a list of assignments into an array of
	 * numbers stating if that face between the pair of assignments
	 * has been raised above or below the previous face in the +Z axis.
	 *
	 * +1 means this face lies above the previous face, -1 below.
	 * the first face implicitly starts at 0.
	 *
	 * These values describe the relationship between the current index
	 * and the next face (i + 1)%length index. and it describes the location
	 * of the second of the pair.
	 * index [0] indicates how face [1] is above/below face[0].
	 * @returns {number[]} unit directionality. +1 for up, -1 down
	 * @linkcode Origami ./src/layer/singleVertexSolver/general.js 58
	 */return t+=void 0===It[e]?0:1,r}))},foldStripWithAssignments=(e,t)=>{
// one number for each sector, locally, the movement away from 0.
const r=(e=>{let t=0;
// because fencepost, and we are hard-coding the first face to be false,
// we don't need to append the first post back to the end of this slice.
const r=e.slice(1);
// globally, the location that each fold takes place along the +X
return[!1].concat(r.map((e=>Bt[e]?++t:t)).map((e=>e%2==1)))})(t).map(((t,r)=>e[r]*(t?-1:1))),s=e.map((()=>{}));
// the cumulative position for each sector, stored as an array of 2:
// [ the start of the sector, the end of the sector ]
s[0]=[0,r[0]];for(let o=1;o<e.length&&("B"!==t[o]&&"b"!==t[o]);o+=1){const t=s[(o-1+e.length)%e.length][1];s[o]=[t,t+r[o]]}return s},Rt={B:!0,b:!0},singleVertexSolver=(e,t,r=I)=>{const s=foldStripWithAssignments(e,t),o=assignmentsToFacesVertical(t),n=t.map((e=>!Rt[e])).reduce(((e,t)=>e&&t),!0);
// if the sector contains no boundary (cuts), check if the folded state
// start and end line up, if not, it's clear no solution is possible.
if(n){const e=s[0][0],t=s[s.length-1][1];if(Math.abs(e-t)>r)return[]}
// prepare tacos ahead of time, since we know the fold locations
// only grab the left and right tacos. return their adjacent faces in the
// form of which pair they are a part of, as an inverted array.
// taco-tortilla testing will happen using a different data structure.
const a=((e,t,r)=>{
// center of each face, will be used to see if a taco faces left or right
const s=e.map((e=>e?(e[0]+e[1])/2:void 0)),o=[];
// ignore stacks which have only one taco. we know they pass the test.
// technically we can also filter out after they have been separated
// as we can ignore the case with 1 left and 1 right. it always passes too.
// but these will get ignored in the next function anyway
// gather all fold locations that match, add them to the same group.
// for every fold location, make one of these objects where the pairs are
// the two adjacent faces on either side of the crease line.
// {
//   min: -0.1,
//   max: 0.1,
//   pairs: [ [2,3], [0,1] ],
// };
return e.forEach(((n,a)=>{if(!n)return;
// if the strip is not circular, skip the final round and don't wrap around
if(!t&&a===e.length-1)return;const c=n[1],i=c-2*r,l=c+2*r,d=[a,(a+1)%e.length],m=d.map((e=>s[e])).map((e=>e>c)),g=1*(!m[0]&&!m[1])+2*(m[0]&&m[1]),p=o.filter((e=>e.min<c&&e.max>c)).shift(),v={faces:d,taco_type:g};p?p.pairs.push(v):o.push({min:i,max:l,pairs:[v]})})),o.map((e=>e.pairs)).filter((e=>e.length>1)).map((e=>({both:e.filter((e=>0===e.taco_type)).map((e=>e.faces)),left:e.filter((e=>1===e.taco_type)).map((e=>e.faces)),right:e.filter((e=>2===e.taco_type)).map((e=>e.faces))})))})(s,n,r).map((e=>[e.left,e.right].map(invertMap).filter((e=>e.length>1)))).reduce(((e,t)=>e.concat(t)),[]),recurse=(t=[0],c=0,i=0)=>{const l=c+1,d=o[c],m=c>=e.length-1,g=n&&m;
// will the next face be above or below the current face's position?
// test for any self-intersections throughout the entire layering
if(!validateLayerSolver(s,t,a,g,r))return[];
// just before exit.
// the final crease must turn the correct direction back to the start.
if(g){
// next_dir is now indicating the direction from the final face to the
// first face, test if this also matches the orientation of the faces.
const e=invertMap(t),r=e[0],s=e[c];if(d>0&&s>r)return[];if(d<0&&s<r)return[];
// todo: what about === 0 ?
}
// Exit case. all faces have been traversed.
if(m)return[t];
// Continue case.
// depending on the direction of the next face (above, below, same level),
// insert the face into one or many places, then repeat the recursive call.
// note: causing a self-intersection is possible, hence, check at beginning
if(0===d)
// no need to call .slice() on layers_face. only one path forward.
// append the next face into this layer (making it an array if necessary)
// and repeat the recursion with no additional layers, just this one.
return t[i]=[l].concat(t[i]),recurse(t,l,i);
// given our current position (layer) and next_dir (up or down),
// get the subarray that's either above or below the current layer.
// these are all the indices we will attempt to insert the new face.
// - below: [0, layer]. includes layer
// - above: (layer, length]. excludes layer. includes length (# of faces)
// this way all indices (including +1 at the end) are covered once.
// these are used in the splice() method, 0...Length, inserting an element
// will place the new element before the old element at that same index.
// so, we need +1 indices (at the end) to be able to append to the end.
const p=1===d?Array.from(Array(t.length-i)).map(((e,t)=>i+t+1)):Array.from(Array(i+1)).map(((e,t)=>t)),v=p.map((()=>clone(t)));
// recursively attempt to fit the next folded face at all possible layers.
// make a deep copy of the layers_face arrays.
// recursively call
// insert the next_face into all possible valid locations (above or below)
return v.forEach(((e,t)=>e.splice(p[t],0,l))),v.map(((e,t)=>recurse(e,l,p[t]))).reduce(((e,t)=>e.concat(t)),[])};
/**
		 * @description Consectively visit each face from 0...n, recursively
		 * inserting it above or below the current position (in all slots above
		 * or below). At the beginning of the recusive function check if there is a
		 * violation where the newly-inserted face is causing a self-intersection.
		 * @param {number[]} layering is an inverted form of the final return value.
		 * indices represent layers, from 0 to N, moving upwards in +Z space,
		 * and faces will be inserted into layers as we search for a layer ordering.
		 * @param {number} iteration count, relates directly to the face index
		 * @param {number} layer, the +Z index layer currently being added to,
		 * this is the splice index of layers_face we will be adding the face to.
		 */
// after collecting all layers_face solutions, convert them into faces_layer
return recurse().map(invertMap)},maekawaAssignments=e=>{const t=(r=e).map(((e,t)=>t)).filter((e=>"U"===r[e]||"u"===r[e]));var r;
// sectors and assignments are fenceposted.
// sectors[i] is bounded by assignment[i] assignment[i + 1]
/**
	 * @description given a set of assignments (M/V/F/B/U characters), which contains
	 * some U (unassigned), find all permutations of mountain valley to replace all U.
	 * This function solves only one single vertex, the assignments are sorted radially
	 * around the vertex. This validates according to Maekawa's theorem only.
	 * @param {string[]} vertices_edges_assignments array of single character
	 * FOLD spec edges assignments.
	 * @returns {string[][]} array of arrays of strings, all permutations where "U"
	 * assignments have been replaced with "V" or "M".
	 * @linkcode Origami ./src/singleVertex/maekawaAssignments.js 19
	 */const s=Array.from(Array(2**t.length)).map(((e,t)=>t.toString(2))).map((e=>Array(t.length-e.length+1).join("0")+e)).map((e=>Array.from(e).map((e=>"0"===e?"V":"M")))).map((r=>{const s=e.slice();return t.forEach(((e,t)=>{s[e]=r[t]})),s}));if(e.includes("B")||e.includes("b"))return s;const o=s.map((e=>e.filter((e=>"M"===e||"m"===e)).length)),n=s.map((e=>e.filter((e=>"V"===e||"v"===e)).length));return s.filter(((e,t)=>2===Math.abs(o[t]-n[t])))},make_lookup=e=>{
// the choose count can be inferred by the length of the valid states
// (assuming they are all the same length)
const t=e[0].length,r=Array.from(Array(t+1)).map((()=>({})));
// array of empty objects
// all permutations of 1s and 2s (no zeros), length of choose_count.
// examples for (6): 111112, 212221
// set the value of these to "false" (solution is impossible)
// with the valid cases to be overwritten in the next step.
Array.from(Array(Math.pow(2,t))).map(((e,t)=>t.toString(2))).map((e=>Array.from(e).map((e=>parseInt(e,10)+1)).join(""))).map((e=>`11111${e}`.slice(-t))).forEach((e=>{r[0][e]=!1})),
// set the valid cases to "true" (solution is possible)
e.forEach((e=>{r[0][e]=!0})),
// "t" relates to the number of unknowns (# zeros). layer 0 is complete,
// start at layer 1 and count up to choose_count.
Array.from(Array(t)).map(((e,t)=>t+1
// make all permuations of 0s, 1s, and 2s now, length of choose_count.
// (all possibile permuations of layer orders)
)).map((e=>Array.from(Array(Math.pow(3,t))).map(((e,t)=>t.toString(3))).map((e=>`000000${e}`.slice(-t))).forEach((t=>((e,t,r)=>{
// convert the key into an array of integers (0, 1, 2)
const s=Array.from(r).map((e=>parseInt(e,10)));
// for each "t" index of states, only include keys which contain
// "t" number of unknowns (0s).
if(s.filter((e=>0===e)).length!==t)return;e[t][r]=!1;
// solution will either be 0, 1, or an array of modifications
let o=!1;for(let r=0;r<s.length;r+=1){const n=[];
// look at the unknown layers only (index is 0)
if(0===s[r]){
// in place of the unknowns, try each of the possible states (1, 2)
for(let o=1;o<=2;o+=1)
// temporarily set the state to this new possible state.
s[r]=o,
// if this state exists in the previous set, save this solution.
!1!==e[t-1][s.join("")]&&n.push([r,o]);
// reset the state back to 0
s[r]=0,
// if we found modifications (even if we aren't using them), the
// solution is no longer 0. solution is either 1 or modifications.
n.length>0&&!1===o&&(o=[]),
// this round's modifications will be length of 2 if we added
// both possible states (1, 2), if this happens, we can't infer anything.
// only accept a modification when it's the only one (length is 1).
1===n.length&&o.push(n[0])}}
// if we invalidated a 0 solution (solution impossible), and no modifications
// were able to be added, solution is 1, meaning, currently valid (if unsolved).
!1!==o&&0===o.length&&(o=!0),e[t][r]=o})(r,e,t)))));
// todo: the filter at the beginning of check_state is throwing away
// a lot of solutions, duplicating work, in the first array here, instead
// of being smart about it, only doing one loop, and sorting them here
// before entering check_state.
// gather solutions together into one object. if a layer order has
// multiple suggested modifications, grab the first one
let s=[];
// array decrementing integers from [choose_count...0]
Array.from(Array(t+1)).map(((e,r)=>t-r)).forEach((e=>{const t=[];
// currently, each value is either a number (0 or 1), or
// an array of multiple modifications, in which case, we only need one.
Object.keys(r[e]).forEach((s=>{let o=r[e][s];
// multiple modifications are possible, get the first one.
o.constructor===Array&&(o=o[0]),
// if (out.constructor === Array) {
//   const key_correct = Array.from(key);
//   const key_flipped = Array.from(key);
//   key_correct[out[0][0]] = out[0][1];
//   key_flipped[out[0][0]] = flip[out[0][1]];
//   out = {
//     true: key_correct.join(""),
//     false: key_flipped.join(""),
//   };
// }
t.push([s,o])})),s=s.concat(t)})),
// this is unnecessary but because for Javascipt object keys,
// insertion order is preserved, sort keys for cleaner output.
s.sort(((e,t)=>parseInt(e[0],10)-parseInt(t[0],10)));
// return data as an object.
// recursively freeze result, this is intended to be an immutable reference
const o={};return s.forEach((e=>{o[e[0]]=Object.freeze(e[1])})),Object.freeze(o)},Ut={taco_taco:make_lookup(["111112","111121","111222","112111","121112","121222","122111","122212","211121","211222","212111","212221","221222","222111","222212","222221"]),taco_tortilla:make_lookup(["112","121","212","221"]),tortilla_tortilla:make_lookup(["11","22"]),transitivity:make_lookup(["112","121","122","211","212","221"])},Dt={
// taco_taco (A,C) (B,D) (B,C) (A,D) (A,B) (C,D)
taco_taco:e=>[[e[0],e[2]],[e[1],e[3]],[e[1],e[2]],[e[0],e[3]],[e[0],e[1]],[e[2],e[3]]]
// taco_tortilla (A,C) (A,B) (B,C)
,taco_tortilla:e=>[[e[0],e[2]],[e[0],e[1]],[e[1],e[2]]]
// tortilla_tortilla (A,C) (B,D)
,tortilla_tortilla:e=>[[e[0],e[2]],[e[1],e[3]]]
// transitivity (A,B) (B,C) (C,A)
,transitivity:e=>[[e[0],e[1]],[e[1],e[2]],[e[2],e[0]]]},pairArrayToSortedPairString=e=>e[0]<e[1]?`${e[0]} ${e[1]}`:`${e[1]} ${e[0]}`
/**
	 * @description Convert an array of faces which are involved in one
	 * taco/tortilla/transitivity condition into an array of arrays where
	 * each face is paired with the others in the precise combination that
	 * the solver is expecting for this particular condition.
	 * @param {number[]} an array of the faces involved in this particular condition.
	 * @linkcode Origami ./src/layer/solver2d/general.js 44
	 */,qt={
// taco_taco (A,C) (B,D) (B,C) (A,D) (A,B) (C,D)
taco_taco:e=>[pairArrayToSortedPairString([e[0],e[2]]),pairArrayToSortedPairString([e[1],e[3]]),pairArrayToSortedPairString([e[1],e[2]]),pairArrayToSortedPairString([e[0],e[3]]),pairArrayToSortedPairString([e[0],e[1]]),pairArrayToSortedPairString([e[2],e[3]])]
// taco_tortilla (A,C) (A,B) (B,C)
,taco_tortilla:e=>[pairArrayToSortedPairString([e[0],e[2]]),pairArrayToSortedPairString([e[0],e[1]]),pairArrayToSortedPairString([e[1],e[2]])]
// tortilla_tortilla (A,C) (B,D)
,tortilla_tortilla:e=>[pairArrayToSortedPairString([e[0],e[2]]),pairArrayToSortedPairString([e[1],e[3]])]
// transitivity (A,B) (B,C) (C,A)
,transitivity:e=>[pairArrayToSortedPairString([e[0],e[1]]),pairArrayToSortedPairString([e[1],e[2]]),pairArrayToSortedPairString([e[2],e[0]])]},Gt={0:0,1:1,2:-1},Wt=Object.freeze(Object.keys(Ut)),Ht={0:0,1:2,2:1},buildRuleAndLookup=(e,t,...r)=>{
// regroup the N faces into an array of pairs, giving us the
// facePair ("3 5") and booleans stating if the order was flipped.
const s=Dt[e](t),o=s.map((e=>e[1]<e[0])),n=s.map(((e,t)=>o[t]?`${e[1]} ${e[0]}`:`${e[0]} ${e[1]}`)),a=n.map(((e,t)=>{for(let s=0;s<r.length;s+=1)if(r[s][e])return o[t]?Ht[r[s][e]]:r[s][e];return 0})).join("");
// now, consult the lookup table. if the result is a boolean,
// return that boolean.
if(!0===Ut[e][a])return!0;if(!1===Ut[e][a])return!1;
// the table is giving us an implied state. return the implication's
// facePair and order as an array. make sure to flip the order if necessary.
const c=Ut[e][a];return[n[c[0]],o[c[0]]?Ht[c[1]]:c[1]]},getConstraintIndicesFromFacePairs=(e,t,r)=>{const s={};return Wt.forEach((o=>{
// given the array of modified facePairs since last round, get all
// the indices in the constraints array in which these facePairs exist.
// this array will contain duplicates
const n=r.flatMap((e=>t[o][e]));
// filter these constraint indices to remove duplicates
s[o]=uniqueElements(n).filter((t=>e[o][t]))})),s},propagate=(e,t,r,...s)=>{
// "modifiedFacePairs" is an array of facePair strings, as we make updates and
// apply changes and repeat, this will hold all changed facePair keys.
// the moment this array is empty, we have finished propagating all changes.
let o=r;
// this is the result which will be returned, it maps facePairs (keys)
// to layer orders, either 1 or 2 (values) and contains only those facePairs
// which were changed by this method, so it will never contain a 0 value condition.
const n={};do{
// using the facePairs which were modified in the last loop,
// get all constraint indices which involve any of the individual faces
// from any of these facePairs.
const r=getConstraintIndicesFromFacePairs(e,t,o),a={};
// todo: do you get better results by fast forwarding through all taco-taco
// newOrders (or transitivity, or any one in particular), before then
// moving onto the other sets, or is it faster to depth-first search through all?
// the modifications that happened this round
for(let t=0;t<Wt.length;t+=1){const o=Wt[t],c=r[o];for(let t=0;t<c.length;t+=1){const r=buildRuleAndLookup(o,e[o][c[t]],...s,n);if(!0!==r){if(!1===r)
// consider throwing an error, we can convey descriptive information
// about which faces are causing a problem
return console.warn("invalid state found",o,e[o][c[t]]),!1;if(n[r[0]]){
// rule already exists. make sure the results match
if(n[r[0]]!==r[1])return console.warn("order conflict",o,e[o][c[t]]),!1}else{const[e,t]=r;a[e]=!0,n[r[0]]=t}}}}o=Object.keys(a)}while(o.length);return n},getBranches=(e,t,r,s={})=>{const o=Object.keys(t),n={};
// move remainingKeys into a dictionary.
// we will delete keys from this dictionary as we visit them
e.forEach((e=>{n[e]=!0}));
// iterate through all remainingKeys
let a=0;
// the number of groups will grow as needed
// groupIndex is always groups.length - 1
const c=[];for(;a<e.length;){
// begin iterating through all keys in the remaining keys
// if the key already been visited, move onto the next.
if(!n[e[a]]){a+=1;continue}
// this marks the beginning of a new group.
const i=[],l=[e[a]],d={[e[a]]:!0};
// create a new stack (and stackHash containing duplicate data)
// beginning with the first unvisited key
do{
// pop a key off of the stack
const e=l.shift();
// mark the key as "visited" by removing it from "keys"
// we are about to loop through all of this key's neighbors
// if they already exist, use the data from the memo
let a;if(delete n[e],
// add this key to the current group
i.push(e),s[e])a=s[e];else{
// collect all neighbors into one hash to remove duplicates.
const n={};
// visit each taco/tortilla/transitivity type, and inside each type,
// visit all constraints, store the constraints in the neighborsHash.
o.forEach((s=>{
// skip if constraintsLookup for a type/key doesn't exist.
const o=r[s][e];o&&
// for each constraint index, convert it into its 3 or 4 face indices,
// then convert these into all permutations of face-pair strings.
o.map((e=>t[s][e])).map((e=>qt[s](e).forEach((e=>{n[e]=!0}))))})),a=Object.keys(n),s[e]=a}
// get all neighbors from the hash, filtering out facePairs
// which were already visited any time in this method ("keys"),
// and already visited and included inside this stack ("stackHash")
const c=a.filter((e=>n[e])).filter((e=>!d[e]));
// console.log("branch search", key, "connected to", neighborsArray);
// add these facePairs to the stack (and hash) to be visited next loop.
l.push(...c),c.forEach((e=>{d[e]=!0}))}while(l.length);a+=1,c.push(i)}return c},makeTortillaTortillaFacesCrossing=(e,t,r)=>{
// const tortilla_tortilla_edges = makeTortillaTortillaEdgesCrossing(
// 	graph,
// 	edges_faces_side,
// 	epsilon,
// );
// console.log("tortilla_tortilla_edges", tortilla_tortilla_edges);
const s=((e,t,r)=>{const s=makeFacesWinding(e),o=makeFacesPolygon(e,r);for(let e=0;e<o.length;e+=1)s[e]||o[e].reverse();const n=t.map((e=>2===e.length&&e[0]!==e[1])).map(((e,t)=>e?t:void 0)).filter((e=>void 0!==e)),a=n.map((t=>e.edges_vertices[t])).map((t=>t.map((t=>e.vertices_coords[t])))),c=a.map((e=>subtract2(e[1],e[0]))),i=[];
// console.log("faces_polygon", faces_polygon);
// console.log("tortilla_edge_indices", tortilla_edge_indices);
// console.log("edges_coords", edges_coords);
// console.log("edges_vector", edges_vector);
// console.log("result", result);
// console.log("matrix", matrix);
return n.forEach((e=>{i[e]=[]})),
// const result = tortilla_edge_indices
// 	.map((e, ei) => faces_polygon
// 		.map((poly, f) => intersectConvexPolygonLine(
// 			poly,
// 			{ vector: edges_vector[ei], origin: edges_coords[ei][0] },
// 			excludeS,
// 			includeL ))
// 			// epsilon))
// 		.map((result, f) => result !== undefined));
n.map(((e,t)=>o.map((e=>clipLineConvexPolygon(e,{vector:c[t],origin:a[t][0]},exclude,excludeS,r))).map((e=>void 0!==e)))).forEach(((e,t)=>e.forEach(((e,r)=>{e&&i[n[t]].push(r)})))),i})(e,t,r);
// const tortilla_tortilla_results = tortilla_tortilla_edges
// 	.map(el => ({
// 		tortilla_faces: graph.edges_faces[el.tortilla_edge],
// 		crossing_faces: el.crossing_edges.map(edge => graph.edges_faces[edge]),
// 	}))
// 	.map(el => el.crossing_faces
// 		// note, adjacent_faces could be singular in the case of a boundary edge,
// 		// and this is still valid.
// 		.map(adjacent_faces => adjacent_faces
// 			.map(face => [el.tortilla_faces, [face, face]]))
// 		.reduce((a, b) => a.concat(b), []))
// 	.reduce((a, b) => a.concat(b), []);
// console.log("tortillas_faces_crossing", tortillas_faces_crossing);
// console.log("tortilla_tortilla_results", tortilla_tortilla_results);
// console.log("tortilla_faces_results", tortilla_faces_results);
// return tortilla_tortilla_results;
return s.map(((t,r)=>t.map((t=>[e.edges_faces[r],[t,t]])))).reduce(((e,t)=>e.concat(t)),[])},classify_faces_pair=e=>1===e[0]&&-1===e[1]||-1===e[0]&&1===e[1]?"both":1===e[0]&&1===e[1]?"right":-1===e[0]&&-1===e[1]?"left":void 0,makeTacosTortillas=(e,t=I)=>{
// given a graph which is already in its folded state,
// find which edges are tacos, or in other words, find out which
// edges overlap with another edge.
const r=makeFacesConvexCenter(e),s=((e,t)=>{const r=e.edges_vertices.map((t=>e.vertices_coords[t[0]])),s=e.edges_vertices.map((t=>subtract2(e.vertices_coords[t[1]],e.vertices_coords[t[0]])));return e.edges_faces.map(((e,o)=>e.map((e=>cross2(subtract2(t[e],r[o]),s[o]))).map((e=>Math.sign(e)))))})(e,r),o=(e=>{const t=Array.from(Array(e.length)).map((()=>Array(e.length).fill(!1)));return e.forEach(((e,r)=>e.forEach((e=>{t[r][e]=!0})))),t})(makeEdgesEdgesParallelOverlap(e,t)),n=booleanMatrixToUniqueIndexPairs(o).filter((t=>t.map((t=>e.edges_faces[t].length>1)).reduce(((e,t)=>e&&t),!0))),a=n.map((t=>t.map((t=>e.edges_faces[t])))),c=((e,t,r,s)=>{
// there are two edges involved in a taco, grab the first one.
// we have to use the same origin/vector so that the face-sidedness is
// consistent globally, not local to its edge.
const o=r.map((t=>e.edges_vertices[t[0]].map((t=>e.vertices_coords[t])))),n=o.map((e=>e[0])),a=o.map((e=>subtract2(e[1],e[0])));return s.map((e=>e.map((e=>e.map((e=>t[e])))))).map(((e,t)=>e.map((e=>e.map((e=>cross2(subtract2(e,n[t]),a[t]))).map((e=>Math.sign(e)))))))})(e,r,n,a),i=c.map((e=>e.map(classify_faces_pair))),l=i.map(((e,t)=>{return(r=e)[0]===r[1]&&"both"!==r[0]?a[t]:void 0;var r;
// pairs of tortillas are valid tortillas if both of them are "both".
})).filter((e=>void 0!==e)),d=i.map(((e,t)=>{return(r=e)[0]===r[1]&&"both"===r[0]?a[t]:void 0;var r;
// pairs of face-pairs are valid taco-tortillas if one is "both" (tortilla)
// and the other is either a "left" or "right" taco.
})).map(((e,t)=>((e,t)=>{if(void 0!==e)return t[0][0]===t[1][0]?e:[e[0],[e[1][1],e[1][0]]]})(e,c[t]))).filter((e=>void 0!==e)),m=makeTortillaTortillaFacesCrossing(e,s,t),g=d.concat(m),p=i.map(((e,t)=>{return(r=e)[0]===r[1]||"both"!==r[0]&&"both"!==r[1]?void 0:((e,t,r)=>{const s="left"===t[0]||"left"===t[1]?-1:1,o="both"===t[0]?[...e[1]]:[...e[0]],n="both"===t[0]?0:1;
// deep copy these objects. ensures that no arrays share pointers.
return{taco:o,tortilla:r[n][0]===s?e[n][0]:e[n][1]}})(a[t],i[t],c[t]);var r;
/**
	 * @description this kind of taco-tortilla is edge-aligned with a tortilla
	 * that is made of two faces. there are 4 faces involved, we only need 3.
	 * given the direction of the taco ("left" or "right"), get the similarly-
	 * facing side of the tortilla and return this along with the taco.
	 */})).filter((e=>void 0!==e)),v=makeEdgesFacesOverlap(e,t),u=booleanMatrixToIndexedArray(v).map(((e,t)=>s[t].length>1&&s[t][0]===s[t][1]?e:[])).map(((t,r)=>({taco:e.edges_faces[r],tortillas:t}))).filter((e=>e.tortillas.length)).flatMap((e=>e.tortillas.map((t=>({taco:[...e.taco],tortilla:t})))));
// console.log("edges_faces_side", edges_faces_side);
// console.log("edge_edge_overlap_matrix", edge_edge_overlap_matrix);
// console.log("tacos_edges", tacos_edges);
// console.log("tortilla_tortilla_aligned", tortilla_tortilla_aligned);
// console.log("tortilla_tortilla_crossing", tortilla_tortilla_crossing);
return{taco_taco:l,tortilla_tortilla:g,taco_tortilla:p.concat(u)}},Jt={0:0,1:2,2:1},Zt={M:1,m:1,V:2,v:2},prepare=(e,t=1e-6)=>{
// let lastTime = new Date();
// 200ms: {boolean[][]} face-face matrix answering: do they overlap?
const r=getFacesFaces2DOverlap(e,t),s=makeFacesWinding(e),o=makeTacosTortillas(e,t),n=((e,t,r,s=I)=>{t||(t=getFacesFaces2DOverlap(e,s)),r||(r=makeFacesWinding(e));
// console.log("overlap_matrix", overlap_matrix);
// console.log("faces_winding", faces_winding);
// prepare a list of all faces in the graph as lists of vertices
// also, make sure they all have the same winding (reverse if necessary)
const o=e.faces_vertices.map((t=>t.map((t=>e.vertices_coords[t]))));o.forEach(((e,t)=>{r[t]||e.reverse()}));const n=e.faces_vertices.map((()=>[]));for(let e=0;e<n.length-1;e+=1)for(let r=e+1;r<n.length;r+=1){if(!t[e][r])continue;const a=clipPolygonPolygon(o[e],o[r],s);a&&(n[e][r]=a)}const a=[];for(let e=0;e<n.length-1;e+=1)for(let r=e+1;r<n.length;r+=1)if(n[e][r])for(let c=r+1;c<n.length;c+=1)e!==c&&r!==c&&t[e][c]&&t[r][c]&&clipPolygonPolygon(n[e][r],o[c],s)&&a.push([e,r,c].sort(((e,t)=>e-t)));
// console.log("matrix", matrix);
// console.log("trios", trios);
return a})(e,r,s,t),a=((e,t)=>{
// will contain taco-taco and taco-tortilla events encoded as all
// permutations of 3 faces involved in each event.
const r={};
// using the list of all taco-taco conditions, store all permutations of
// the three faces (sorted low to high) into a dictionary for quick lookup.
// store them as space-separated strings.
// return the filtered set of trios.
return t.taco_taco.map((e=>[e[0][0],e[0][1],e[1][0],e[1][1]].sort(((e,t)=>e-t)))).forEach((e=>[`${e[0]} ${e[1]} ${e[2]}`,`${e[0]} ${e[1]} ${e[3]}`,`${e[0]} ${e[2]} ${e[3]}`,`${e[1]} ${e[2]} ${e[3]}`].forEach((e=>{r[e]=!0})))),
// convert all taco-tortilla cases into similarly-formatted,
// space-separated strings.
t.taco_tortilla.map((e=>[e.taco[0],e.taco[1],e.tortilla].sort(((e,t)=>e-t)).join(" "))).forEach((e=>{r[e]=!0})),e.filter((e=>void 0===r[e.join(" ")]))})(n,o),c=((e,t)=>{const r={};
// A-C and B-D are connected. A:[0][0] C:[0][1] B:[1][0] D:[1][1]
// "(A,C) (B,D) (B,C) (A,D) (A,B) (C,D)"
return r.taco_taco=e.taco_taco.map((e=>[e[0][0],e[1][0],e[0][1],e[1][1]])),
// A-C is the taco, B is the tortilla. A:taco[0] C:taco[1] B:tortilla
// (A,C) (A,B) (B,C)
r.taco_tortilla=e.taco_tortilla.map((e=>[e.taco[0],e.tortilla,e.taco[1]])),
// A-B and C-D are connected, where A is above/below C and B is above/below D
// A:[0][0] B:[0][1] C:[1][0] D:[1][1]
// (A,C) (B,D)
r.tortilla_tortilla=e.tortilla_tortilla.map((e=>[e[0][0],e[0][1],e[1][0],e[1][1]])),
// transitivity. no relation between faces in the graph.
// (A,B) (B,C) (C,A)
r.transitivity=t.map((e=>[e[0],e[1],e[2]])),r})(o,a),i=(e=>{const t={};return Object.keys(e).forEach((e=>{t[e]={}})),Object.keys(e).forEach((r=>{e[r].forEach(((e,s)=>qt[r](e).forEach((e=>{void 0===t[r][e]&&(t[r][e]=[]),t[r][e].push(s)}))))})),t})(c),l=((e,t)=>(t||(t=getFacesFaces2DOverlap(e)),booleanMatrixToUniqueIndexPairs(t).map((e=>e.join(" ")))))(e,r),d=((e,t,r)=>{r||(r=makeFacesWinding(e));const s={};t.forEach((e=>{s[e]=!0}));const o={};return e.edges_faces.forEach(((t,n)=>{
// the crease assignment determines the order between pairs of faces.
const a=e.edges_assignment[n],c=Zt[a];
// skip boundary edges or edges with confusing assignments.
if(t.length<2||void 0===c)return;
// face[0] is the origin face.
// the direction of "m" or "v" will be inverted if face[0] is flipped.
const i=r[t[0]]?c:Jt[c],l=`${t[0]} ${t[1]}`,d=`${t[1]} ${t[0]}`;
// now we know from a global perspective the order between the face pair.
l in s&&(o[l]=i),d in s&&(o[d]=Jt[i])})),o})(e,l,s);
// console.log(Date.now() - lastTime, "overlap"); lastTime = new Date();
// 0ms: {boolean[]} for every face, true:counter-clockwise, false:flipped
// console.log(`transitivity: ${unfiltered_trios.length} down to ${transitivity_trios.length} (${unfiltered_trios.length - transitivity_trios.length} removed from tacos/tortillas)`);
// console.log(`${constraints.taco_taco.length} taco-taco, ${constraints.taco_tortilla.length} taco-tortilla, ${constraints.tortilla_tortilla.length} tortilla-tortilla, ${constraints.transitivity.length} transitivity`);
return console.log("overlap",r),console.log("graph",e),console.log("facesWinding",s),console.log("tacos_tortillas",o),console.log("unfiltered_trios",n),console.log("transitivity_trios",a),console.log("facePairs",l),console.log("constraints",c),console.log("constraintsLookup",i),console.log("edgeAdjacentOrders",d),{constraints:c,constraintsLookup:i,facePairs:l,edgeAdjacentOrders:d}},Yt={allSolutions:function(){return(e=>{const recurse=(e,t=[])=>{e.faceOrders&&t.push(e.faceOrders);const r=e.finished?e.finished.map((e=>[...t,e.faceOrders])):void 0;if(e.unfinished){const s=e.unfinished.map((e=>recurse(e,JSON.parse(JSON.stringify(t))))),o=s.length>1?((e,t)=>{const r=[];for(let s=0;s<e.length;s+=1)for(let o=0;o<t.length;o+=1)r.push([e[s],t[o]]);return r})(...s):s;o.forEach((e=>{e.branch=!0})),
// finished.push(...unfinished);
r.forEach((e=>e.push(...o)))}
// if (node.faceOrders) {
// 	solutions.forEach(orders => orders.push(...node.faceOrders));
// }
return r.finished=!0,r};return recurse(e)})(this)}},solveBranch=(e,t,r,s,o,...n)=>{if(!s.length)return[];const a=s[0],c=[],i=[];
// given the same guessKey with both 1 and 2 as the guess, run propagate.
[1,2].forEach((r=>{const o=propagate(e,t,[a],...n,{[a]:r});
// bad results will be false. skip these. if the result is valid,
// check if all variables are solved or more work is required.
!1!==o&&(
// currently, the one guess itself is left out of the result object.
// we could either combine the objects, or add this guess directly in.
o[a]=r,
// store the result as either completed or unfinished
Object.keys(o).length===s.length?c.push(o):i.push(o))}));
// recursively call this method with any unsolved solutions and filter
// any keys that were found in that solution out of the unsolved keys
// solutionNode.branches = unfinishedSolutions.map(order => ({ faceOrders: order }));
const l=i.map((e=>({faceOrders:e}))),d=i.map(((o,a)=>{const c=s.filter((e=>!(e in o)));return getBranches(c,e,t,r).map((s=>solveBranch(e,t,r,s,l[a],...n,o)))}));
// const recursed = unfinishedSolutions
// 	.map(order => solveBranch(
// 		constraints,
// 		constraintsLookup,
// 		unsolvedKeys.filter(key => !(key in order)),
// 		solutionNode,
// 		...orders,
// 		order,
// 	));
// if (childNodes.length === 1) {
// 	Object.assign(solutionNode, childNodes[0]);
// } else if (childNodes.length > 1) {
// 	solutionNode.choose = childNodes;
// }
// we will either have:
// - one or more completed solutions and AT MOST ONE unfinished solution
// - no completed solutions and TWO unfinished solutions
return c.length&&(o.finished=c.map((e=>({faceOrders:e})))),l.length&&(o.unfinished=l),
// const nextLevel = []
// 	.concat(childNodes)
// 	.concat(completedSolutions.map(order => ({ faceOrders: order })));
// if (nextLevel.length === 1) {
// 	Object.assign(solutionNode, nextLevel[0]);
// } else if (childNodes.length > 1) {
// 	solutionNode.and = nextLevel;
// } else {
// 	solutionNode.or = nextLevel;
// }
l.length>1&&c.length&&console.log("HAPPENED"),c.map((e=>[...n,e])).concat(...d)};
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * @description given two indices, return a copy of the array between them,
	 * excluding the elements at the indices themselves.
	 * @returns {any[]} the subarray exclusively between the two indices.
	 */
/**
	 * Rabbit Ear (c) Kraft
	 */
// import table from "./solver2d/table.js";
// import * as makeConstraints from "./solver2d/makeConstraints.js";
// import * as makeFacePairsOrder from "./solver2d/makeFacePairsOrder.js";
// import * as globalSolverGeneral from "./solver2d/general.js";
// import makeTacosTortillas from "./solver2d/tacos/makeTacosTortillas.js";
// import makeFoldedStripTacos from "./solver2d/tacos/makeFoldedStripTacos.js";
// import makeTransitivityTrios from "./solver2d/tacos/makeTransitivityTrios.js";
// import * as tortillaTortilla from "./solver2d/tacos/tortillaTortilla.js";
/**
	 * @description A collection of methods for calculating the layer order
	 * of the faces of an origami in its folded state.
	 */
var Xt=Object.assign(Object.create(null),{solver:(e,t=1e-6)=>{const r=new Date,{constraints:s,constraintsLookup:o,facePairs:n,edgeAdjacentOrders:a}=prepare(e,t),c=Date.now()-r,i=new Date,l=propagate(s,o,Object.keys(a),a);
// graph does not have a valid layer order. no solution
if(!l)return;console.log("2D initialResult",JSON.parse(JSON.stringify(l)));const d={},m=n.filter((e=>!(e in a))).filter((e=>!(e in l))),g={},p=getBranches(m,s,o,g);
// get all keys unsolved after the first round of propagate
console.log("branches",p);const v=p.map((()=>({}))),u=p.map(((e,t)=>solveBranch(s,o,g,e,v[t],a,l)));v.length&&(d.unfinished=v),d.faceOrders={...a,...l},
// solver is finished. each branch result is spread across multiple objects
// containing a solution for a subset of the entire set of faces, one for
// each recursion depth. for each branch solution, merge its objects into one.
// const topLevelBranches = branchResults;
// const branches = branchResults
// 	.map(branch => branch
// 		.map(solution => Object.assign({}, ...solution)));
// the set of face-pair solutions which are true for all branches
// const root = { ...edgeAdjacentOrders, ...initialResult };
// solution.branches[0].faceOrders = { ...edgeAdjacentOrders, ...initialResult };
console.log("2D solution",JSON.parse(JSON.stringify(d.faceOrders)));const h=e.faces_normal?e.faces_normal:makeFacesNormal(e),_=[0,0,1],recurse=e=>{e.faceOrders&&(e.faceOrders=((e,t,r)=>{const s=t.map((e=>dot(e,r)>0)),o=Object.keys(e),n=o.map((e=>e.split(" ").map((e=>parseInt(e,10)))));return n.forEach(((t,r)=>{const n=Gt[e[o[r]]],a=s[t[1]]?n:-n;
// const side = (value === -1) ^ (!faces_normal_match[faces[1]])
t.push(a)})),n})(e.faceOrders,h,_)),e.finished&&e.finished.forEach((e=>recurse(e))),e.unfinished&&e.unfinished.forEach((e=>recurse(e)))};
// this is hardcoded to flat foldings along the +Z. wait this is not needed
recurse(d),console.log("2D solution final",JSON.parse(JSON.stringify(d.faceOrders)));
// convert solutions from (1,2) to (+1,-1), both the root and each branch.
// unsignedToSignedOrders(root);
// branches
// 	.forEach(branch => branch
// 		.forEach(solutions => unsignedToSignedOrders(solutions)));
const b=Date.now()-i;
// console.log(`variables (${facePairs.length} total): ${Object.keys(edgeAdjacentOrders).length} neighbor faces, ${Object.keys(initialResult).length} propagate, ${remainingKeys.length} in branches`);
// if (duration > 50) {
// console.log("branchResults", branchResults);
return console.log(`prep ${c}ms solver ${b}ms`),
// }
console.log("solution",d),console.log("branches",u),Object.assign(Object.create(Yt),
// { root, branches: branchResults },
d)},
// solver2d,
// table,
topologicalOrder:(e,t)=>{if(!e)return[];const r=[];
// use the facePairOrders face pair relationships to fill an array where
// index: face, value: array of the face's children (faces below the face)
Object.keys(e).forEach((t=>{const s=t.split(" ").map((e=>parseInt(e,10)));-1===e[t]&&s.reverse(),void 0===r[s[0]]&&(r[s[0]]=[]),r[s[0]].push(s[1])})),
// not all faces are encoded in the facePairOrders. use the graph to fill in
// any remaining faces with empty arrays (no child faces / faces below)
t&&t.faces_vertices&&t.faces_vertices.forEach(((e,t)=>{void 0===r[t]&&(r[t]=[])}));
// console.log("faces_children", JSON.parse(JSON.stringify(faces_children)));
const s=[],o=[];let n=0;for(let e=0;e<r.length;e+=1){if(o[e])continue;const t=[e];for(;t.length&&n<2*r.length;){const e=t[t.length-1];if(r[e]&&r[e].length){const s=r[e].pop();o[s]||t.push(s)}else
// we reached a leaf, add it to the layers.
s.push(e),o[e]=!0,t.pop(),n+=1}}
// console.log("faces_children", faces_children);
// console.log("protection", protection);
// console.log("layers_face", layers_face);
// console.log("faces_visited", faces_visited);
return n>=2*r.length&&console.warn("fix protection in topological order"),s},
// makeTacosTortillas,
// makeFoldedStripTacos,
// makeTransitivityTrios,
singleVertexSolver:singleVertexSolver,singleVertexAssignmentSolver:(e,t,r)=>{null==t&&(t=e.map((()=>"U")));
// enumerate all possible assignments by replacing "U" with both "M" and "V"
const s=maekawaAssignments(t),o=s.map((t=>singleVertexSolver(e,t,r)));return s.map(((e,t)=>t)).filter((e=>o[e].length>0)).map((e=>({assignment:s[e],layer:o[e]})))},
// validateLayerSolver,
// validateTacoTacoFacePairs,
// validateTacoTortillaStrip,
foldStripWithAssignments:foldStripWithAssignments},Tt,Lt);
/**
	 * Rabbit Ear (c) Kraft
	 */var Kt=Object.freeze({__proto__:null,kawasakiSolutions:({vertices_coords:e,vertices_edges:t,edges_vertices:r,edges_vectors:s},o)=>{
// to calculate Kawasaki's theorem, we need the 3 edges
// as vectors, and we need them sorted radially.
s||(s=makeEdgesVector({vertices_coords:e,edges_vertices:r})),t||(t=makeVerticesEdgesUnsorted({edges_vertices:r}));const n=t[o].map((e=>s[e])),a=counterClockwiseOrder2(n).map((e=>n[e]));return kawasakiSolutionsVectors(a)}}),Qt=Object.assign(Object.create(null),{maekawaAssignments:maekawaAssignments,foldAngles4:(e,t,r=0)=>{const s=(e=>{let t=0,r=0;for(let s=0;s<e.length;s+=1)"M"!==e[s]&&"m"!==e[s]||(t+=1),"V"!==e[s]&&"v"!==e[s]||(r+=1);for(let s=0;s<e.length;s+=1){if(t>r&&("V"===e[s]||"v"===e[s]))return s;if(r>t&&("M"===e[s]||"m"===e[s]))return s}})(t);if(void 0===s)return;const o=e[(s+1)%e.length],n=e[(s+2)%e.length],a=Math.PI*r,c=-Math.cos(o)*Math.cos(n)+Math.sin(o)*Math.sin(n)*Math.cos(Math.PI-a),i=Math.cos(Math.PI-a)-Math.sin(Math.PI-a)**2*Math.sin(o)*Math.sin(n)/(1-c),l=-Math.acos(i)+Math.PI;return s%2==0?[l,a,l,a].map(((e,t)=>s===t?-e:e)):[a,l,a,l].map(((e,t)=>s===t?-e:e))}},Je,Kt,Ke);
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * @description A collection of operations done on single vertices
	 * (one vertex in a graph typically surrounded by edges).
	 */
/**
	 * Rabbit Ear (c) Kraft
	 */
const pairify=e=>e.map(((e,t,r)=>[e,r[(t+1)%r.length]])),getContainingValue=(e,t)=>Array.from(e.children).filter((e=>e.attributes.length&&void 0!==Array.from(e.attributes).filter((e=>e.nodeValue===t)).shift())).shift()
/**
	 * @description There are top level nodes which contain metadata,
	 * I'm not sure how many there are, but at least I've seen:
	 * memo, originalAuthorName, title
	 */,er={children:[{textContent:"0"}]},tr=["F","B","M","V","U"],setMetadata=(e,t)=>{const r={file_description:"memo",file_author:"originalAuthorName",file_title:"title"};Object.keys(r).forEach((t=>{r[t]=((e,t)=>{const r=getContainingValue(e,t),s=r?Array.from(r.children).shift():null;return s?s.textContent:void 0})(e,r[t])})),Object.keys(r).filter((e=>r[e])).forEach((e=>{t[e]=r[e]})),t.file_classes=["singleModel"],t.frame_classes=["creasePattern"]},flattenDomTree=e=>null!=e.children&&e.children.length?Array.from(e.children).flatMap((e=>flattenDomTree(e))):[e]
/**
	 * @description Get the furthest root parent up the DOM tree
	 */,getAttributeValue=(e,t,r,s=[])=>{
// 1. check inline style
const o=r.style?r.style.match(new RegExp(`${e}[\\s]*:[^;]*;`)):null;if(o)return o[0].split(":")[1].replace(";","");
// 2. check stylesheet
const n=((e,t,r,s=[])=>{const o=r.class?r.class.split(/\s/).filter(Boolean).map((e=>e.trim())).map((e=>`.${e}`)):[],n=r.id?`#${r.id}`:null;
// look for a matching id in the style sheets
if(n)for(let t=0;t<s.length;t+=1)if(s[t][n]&&s[t][n][e])return s[t][n][e];
// look for a matching class in the style sheets
for(let r=0;r<s.length;r+=1){for(let t=0;t<o.length;t+=1)if(s[r][o[t]]&&s[r][o[t]][e])return s[r][o[t]][e];if(s[r][t]&&s[r][t][e])return s[r][t][e]}})(e,t,r,s);return void 0!==n?n:
// todo
// 3. check inline attribute
r[e]?r[e]:null};var rr={line:{x1:1,y1:1,x2:1,y2:1},rect:{x:1,y:1,width:1,height:1},circle:{cx:1,cy:1,r:1},ellipse:{cx:1,cy:1,rx:1,ry:1},polygon:{points:1},polyline:{points:1},path:{d:1}};
/**
	 * Rabbit Ear (c) Kraft
	 */const getAttributesFloatValue=(e,t)=>t.map((t=>e.getAttribute(t))).map((e=>null==e?"0":e)).map(parseFloat)
/**
	 * Rabbit Ear (c) Kraft
	 */,PolygonToSegments=e=>(e=>{const t=e.split(/[\s,]+/).map((e=>parseFloat(e)));return Array.from(Array(Math.floor(t.length/2))).map(((e,r)=>[t[2*r+0],t[2*r+1]]))})(e.getAttribute("points")||"").map(((e,t,r)=>[r[t][0],r[t][1],r[(t+1)%r.length][0],r[(t+1)%r.length][1]]))
/**
	 * Rabbit Ear (c) Kraft
	 */,sr={L:!0,V:!0,H:!0,Z:!0},or={line:e=>[getAttributesFloatValue(e,["x1","y1","x2","y2"])]
/**
	 * Rabbit Ear (c) Kraft
	 */,rect:function(e){const[t,r,s,o]=getAttributesFloatValue(e,["x","y","width","height"]);return[[t,r,t+s,r],[t+s,r,t+s,r+o],[t+s,r+o,t,r+o],[t,r+o,t,r]]},polygon:PolygonToSegments,polyline:function(e){const t=PolygonToSegments(e);return t.pop(),t},path:e=>T.svg.core.parsePathCommandsEndpoints(e.getAttribute("d")||"").filter((e=>sr[e.command.toUpperCase()])).map((e=>[e.start,e.end])).filter((e=>!epsilonEqualVectors(...e))).map((e=>e.flat()))
/**
	 * Rabbit Ear (c) Kraft
	 */};
// export const pointStringToArray = function (str) {
// 	return str.split(/[\s,]+/)
// 		.filter(s => s !== "")
// 		.map(p => p.split(",")
// 			.map(n => parseFloat(n)));
// };
// SVG will occasionally remove x1="0", attribute absense is an implied 0.
var nr={black:"#000000",silver:"#c0c0c0",gray:"#808080",white:"#ffffff",maroon:"#800000",red:"#ff0000",purple:"#800080",fuchsia:"#ff00ff",green:"#008000",lime:"#00ff00",olive:"#808000",yellow:"#ffff00",navy:"#000080",blue:"#0000ff",teal:"#008080",aqua:"#00ffff",orange:"#ffa500",aliceblue:"#f0f8ff",antiquewhite:"#faebd7",aquamarine:"#7fffd4",azure:"#f0ffff",beige:"#f5f5dc",bisque:"#ffe4c4",blanchedalmond:"#ffebcd",blueviolet:"#8a2be2",brown:"#a52a2a",burlywood:"#deb887",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",cornflowerblue:"#6495ed",cornsilk:"#fff8dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",darkkhaki:"#bdb76b",darkmagenta:"#8b008b",darkolivegreen:"#556b2f",darkorange:"#ff8c00",darkorchid:"#9932cc",darkred:"#8b0000",darksalmon:"#e9967a",darkseagreen:"#8fbc8f",darkslateblue:"#483d8b",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",darkturquoise:"#00ced1",darkviolet:"#9400d3",deeppink:"#ff1493",deepskyblue:"#00bfff",dimgray:"#696969",dimgrey:"#696969",dodgerblue:"#1e90ff",firebrick:"#b22222",floralwhite:"#fffaf0",forestgreen:"#228b22",gainsboro:"#dcdcdc",ghostwhite:"#f8f8ff",gold:"#ffd700",goldenrod:"#daa520",greenyellow:"#adff2f",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",indianred:"#cd5c5c",indigo:"#4b0082",ivory:"#fffff0",khaki:"#f0e68c",lavender:"#e6e6fa",lavenderblush:"#fff0f5",lawngreen:"#7cfc00",lemonchiffon:"#fffacd",lightblue:"#add8e6",lightcoral:"#f08080",lightcyan:"#e0ffff",lightgoldenrodyellow:"#fafad2",lightgray:"#d3d3d3",lightgreen:"#90ee90",lightgrey:"#d3d3d3",lightpink:"#ffb6c1",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",lightskyblue:"#87cefa",lightslategray:"#778899",lightslategrey:"#778899",lightsteelblue:"#b0c4de",lightyellow:"#ffffe0",limegreen:"#32cd32",linen:"#faf0e6",magenta:"#ff00ff",mediumaquamarine:"#66cdaa",mediumblue:"#0000cd",mediumorchid:"#ba55d3",mediumpurple:"#9370db",mediumseagreen:"#3cb371",mediumslateblue:"#7b68ee",mediumspringgreen:"#00fa9a",mediumturquoise:"#48d1cc",mediumvioletred:"#c71585",midnightblue:"#191970",mintcream:"#f5fffa",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",navajowhite:"#ffdead",oldlace:"#fdf5e6",olivedrab:"#6b8e23",orangered:"#ff4500",orchid:"#da70d6",palegoldenrod:"#eee8aa",palegreen:"#98fb98",paleturquoise:"#afeeee",palevioletred:"#db7093",papayawhip:"#ffefd5",peachpuff:"#ffdab9",peru:"#cd853f",pink:"#ffc0cb",plum:"#dda0dd",powderblue:"#b0e0e6",rosybrown:"#bc8f8f",royalblue:"#4169e1",saddlebrown:"#8b4513",salmon:"#fa8072",sandybrown:"#f4a460",seagreen:"#2e8b57",seashell:"#fff5ee",sienna:"#a0522d",skyblue:"#87ceeb",slateblue:"#6a5acd",slategray:"#708090",slategrey:"#708090",snow:"#fffafa",springgreen:"#00ff7f",steelblue:"#4682b4",tan:"#d2b48c",thistle:"#d8bfd8",tomato:"#ff6347",turquoise:"#40e0d0",violet:"#ee82ee",wheat:"#f5deb3",whitesmoke:"#f5f5f5",yellowgreen:"#9acd32"};
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * @description Convert a hex string into an array of
	 * three numbers, the rgb values (between 0 and 1).
	 * This ignores any alpha values.
	 * @param {string} value a hex color code as a string
	 * @returns {number[]} three values between 0 and 1
	 * @linkcode Origami ./src/convert/svg/colors/hexToRGB.js 10
	 */const hexToRGB=e=>{const t=e.replace(/#(?=\S)/g,""),r=Array.from(Array(6)).map(((e,r)=>t[r]||"0")),s=t.length<=4?[0,0,1,1,2,2].map((e=>r[e])).join(""):r.join(""),o=parseInt(s,16);
// ensure a minimum number of characters (fill 0 if needed)
return[o>>16&255,o>>8&255,255&o].map((e=>e/255))},parseCSSColor=e=>{if(nr[e])return hexToRGB(nr[e]);if("#"===e[0])return hexToRGB(e);if("rgba"===e.substring(0,4)||"rgb"===e.substring(0,3)){const t=(e=>{const t=e.match(/\(([^\)]+)\)/g);if(null!=t&&t.length)return t[0].substring(1,t[0].length-1).split(/[\s,]+/).map(parseFloat)})(e);return[0,1,2].forEach(((e,r)=>{t[r]/=255})),t}
// if (string.substring(0, 4) === "hsla") {
// }
// if (string.substring(0, 3) === "hsl") {
// }
return[0,0,0]},ar={M:[1,0,0],// red
V:[0,0,1],// blue
F:[1,1,0],// yellow
U:[1,0,1],// magenta
C:[0,1,0]},parseCSSStyleSheet=e=>{if(!e.cssRules)return{};const t={};
// convert the array of type {CSSRule[]} to an object
// with the key:value being the key and the contents of that rule.
for(let r=0;r<e.cssRules.length;r+=1){const s=e.cssRules[r];if(1!==s.type)continue;const o=s.selectorText.split(/,/gm).filter(Boolean).map((e=>e.trim())),n={};Object.values(s.style).forEach((e=>{n[e]=s.style[e]})),o.forEach((e=>{t[e]=n}))}return t},parseStyleElement=e=>{if(e.sheet)return parseCSSStyleSheet(e.sheet);if(!((e=>{let t=e;for(;null!=t.parentNode;)t=t.parentNode;return t})(e).constructor===RabbitEarWindow().HTMLDocument)){
// remove style from parent. append to document.body
const t=e.parentNode;null!=t&&t.removeChild(e);const r=null!=RabbitEarWindow().document.body?RabbitEarWindow().document.body:RabbitEarWindow().document.createElement("body");r.appendChild(e);
// parse style sheet.
const s=parseCSSStyleSheet(e.sheet);
// remove style from document.body. append to previous parent
return r.removeChild(e),null!=t&&t.appendChild(e),s}return{}},objectifyAttributeList=function(e){const t={};return e.forEach((e=>{t[e.nodeName]=e.value})),t},svgToBasicGraph=e=>{const t="string"==typeof e?((e,t="text/xml")=>(new(RabbitEarWindow().DOMParser)).parseFromString(e,t).documentElement)
/**
	 * @description Recurse through a DOM element and flatten all elements
	 * into one array.
	 * @todo when doing this on an SVG, <g> group elements can contain
	 * upper level transforms and styles, doing this will loose
	 * track of any of these attributes on all of its children.
	 */(e,"image/svg+xml"):e,r=flattenDomTree(t),s=r.filter((e=>"style"===e.nodeName)).map(parseStyleElement),o=(e=>e.filter((e=>or[e.tagName])).flatMap((e=>or[e.tagName](e).map((t=>{return{nodeName:e.tagName,segment:t,attributes:objectifyAttributeList((r=e,Array.from(r.attributes).filter((e=>!rr[r.nodeName][e.nodeName]))))};var r})))))
/**
	 * @description This method will handle all of the SVG parsing
	 * and result in a very simple graph representation basically
	 * only containing line segments and their assignment/foldAngle.
	 * The graph will not be planar (edges will overlap), no faces
	 * will exist, and duplicate vertices will exist and need to
	 * be merged
	 * @param {Element|string} svg an SVG image as a DOM element
	 * or a string.
	 * @returns {FOLD} a FOLD representation of the SVG image.
	 */(r),n=o.map((e=>getAttributeValue("stroke",e.nodeName,e.attributes,s)||"black")).map((e=>(e=>{if(null==e||"string"!=typeof e)return"U";const t=parseCSSColor(e).slice(0,3),r=t.reduce(((e,t)=>e+t),0)/3,s="F",o=distance3(t,[r,r,r]),n=Object.keys(ar).map((e=>({key:e,distance:distance3(t,ar[e])}))).sort(((e,t)=>e.distance-t.distance)).shift();
// remove alpha value if it exists
return o<n.distance?s:n.key;
// cannot discern between flat and boundary
// boundary will be decided later by planar analysis
})(e))),a=o.map((e=>getAttributeValue("opacity",e.nodeName,e.attributes,s)||"1")).map(((e,t)=>((e,t)=>{switch(t){case"M":case"m":return-180*e;case"V":case"v":return 180*e;
// "F", "B", "U", "C", opacity value doesn't matter.
default:return 0}})(e,n[t])));return{vertices_coords:o.map((e=>e.segment)).flatMap((e=>[[e[0],e[1]],[e[2],e[3]]])),edges_vertices:o.map(((e,t)=>[2*t,2*t+1])),edges_assignment:n,edges_foldAngle:a}};
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * Rabbit Ear (c) Kraft
	 */
var cr={objToFold:e=>{const t=e.split("\n").map((e=>e.trim().split(/\s+/))),r=(()=>{const e={};return e.file_spec=mt,e.file_creator=gt,e.file_classes=["singleModel"],e.frame_classes=[],e.frame_attributes=[],e.vertices_coords=[],e.faces_vertices=[],e})();for(let e=0;e<t.length;e+=1)
// groups and objects ("g", "o") separation is currently ignored
switch(t[e][0].toLowerCase()){case"f":r.faces_vertices.push(t[e].slice(1).map((e=>parseInt(e,10)-1)));break;case"v":r.vertices_coords.push(t[e].slice(1).map((e=>parseFloat(e))))}return r.faces_normal=makeFacesNormal(r),r.faces_center=makeFacesConvexCenter(r),r.edges_vertices=(({faces_vertices:e})=>{const t={},r=[];return e.flatMap(pairify).forEach((e=>{const s=[e.join(" "),`${e[1]} ${e[0]}`];s[0]in t||s[1]in t||(r.push(e),t[s[0]]=!0)})),r})(r),r.faces_edges=makeFacesEdgesFromVertices(r),
// graph.edges_faces = makeEdgesFaces(graph);
r.edges_faces=makeEdgesFacesUnsorted(r),r.edges_foldAngle=makeEdgesFoldAngleFromFaces(r),r.edges_assignment=makeEdgesAssignment(r),r.vertices_vertices=makeVerticesVerticesFromFaces(r),
// faces_normal and faces_center are not a part of the spec.
// edges_faces was built unsorted. the sorted method is slower to construct,
// and unnecessary for our purposes. the user can build this (and the
// other incomplete fields) if they want them.
delete r.faces_normal,delete r.faces_center,delete r.edges_faces,(e=>{if(!e.edges_foldAngle||!e.edges_foldAngle.length)return;let t=!0;for(let r=0;r<e.edges_foldAngle.length;r+=1)if(0!==e.edges_foldAngle[r]&&-180!==e.edges_foldAngle[r]&&180!==e.edges_foldAngle[r]){t=!1;break}e.frame_classes.push(t?"creasePattern":"foldedForm"),e.frame_attributes.push(t?"2D":"3D")})(r),r},opxToFold:(e,t)=>{try{const r=(new(RabbitEarWindow().DOMParser)).parseFromString(e,"text/xml"),s=Array.from(r.documentElement.children).filter((e=>Array.from(e.classList).includes("oripa.DataSet"))).shift(),o=((e,t)=>{const r={};
// analysis on vertices_coords to find an appropriate epsilon
if(r.vertices_coords=e.flatMap((e=>[[e[1],e[3]],[e[2],e[4]]])),r.edges_vertices=e.map(((e,t)=>[2*t,2*t+1])),r.edges_assignment=e.map((e=>tr[e[0]])),r.edges_foldAngle=makeEdgesFoldAngle(r),void 0===t){const{span:e}=boundingBox$1(r.vertices_coords);t=1e-6*Math.min(...e)}removeDuplicateVertices(r,t),r.vertices_vertices=makeVerticesVertices(r);const s=makePlanarFaces(r);
// replace these values with their entry inside the OPX file (if exists)
return r.faces_vertices=s.map((e=>e.vertices)),r.faces_edges=s.map((e=>e.edges)),r})((e=>e.map((e=>{const t=Array.from(e.children[0].children);return["type","x0","x1","y0","y1"].map((e=>parseFloat((t.filter((t=>t.attributes[0].nodeValue===e)).shift()||er).children[0].textContent)))})))
/**
	 * @description ORIPA line assignments are numbered.
	 */((e=>{const t=getContainingValue(e,"lines"),r=t?Array.from(t.children).filter((e=>"oripa.OriLineProxy"===e.className)).shift():void 0;return r?Array.from(r.children):[]})(s)),t);return setMetadata(s,o),o}catch(e){console.error(e)}},svgToFold:e=>{const t=(e=>{const t={...e};removeDuplicateVertices(t),fragment(t),t.vertices_vertices=makeVerticesVertices(t);const r=makePlanarFaces(t);t.faces_vertices=r.map((e=>e.vertices)),t.faces_edges=r.map((e=>e.edges));const{edges:s}=planarBoundary(t);return s.forEach((e=>{t.edges_assignment[e]="B"})),t})(svgToBasicGraph(e));return{file_spec:1.1,file_creator:"Rabbit Ear",frame_classes:["creasePattern"],...t}}};
/**
	 * Rabbit Ear (c) Kraft
	 */
// this method allows you to attach an outside library to this one
// this library RabbitEar will have been bound to "this"
const addClassToClassList=(e,...t)=>{if(!e)return;const r={},s=e.getAttribute("class"),o=s?s.split(" "):[];o.push(...t),o.forEach((e=>{r[e]=!0}));const n=Object.keys(r).join(" ");e.setAttribute("class",n)},ir={},lr={stroke:b},fr={},dr={M:{stroke:"red"},m:{stroke:"red"},V:{stroke:"blue"},v:{stroke:"blue"},F:{stroke:"lightgray"},f:{stroke:"lightgray"}},edgesPathData=e=>(({vertices_coords:e,edges_vertices:t})=>e&&t?t.map((t=>t.map((t=>e[t])))):[])(e).map((e=>{return`M${(t=e)[0][0]} ${t[0][1]}L${t[1][0]} ${t[1][1]}`;var t})).join(""),edgesPathDataAssign=({vertices_coords:e,edges_vertices:t,edges_assignment:r})=>{if(!e||!t)return{};if(!r)return{u:edgesPathData({vertices_coords:e,edges_vertices:t})};
// const segments = edgesCoords({ vertices_coords, edges_vertices, edges_assignment });
const s=(e=>{const t={u:[],f:[],v:[],m:[],b:[]},r=e[m].map((e=>e.toLowerCase()));return e[l].map(((e,t)=>r[t]||"u")).forEach(((e,r)=>t[e].push(r))),t})({vertices_coords:e,edges_vertices:t,edges_assignment:r});
// replace each value in data from array of indices [1,2,3] to path string "M2,3L2.."
return Object.keys(s).forEach((r=>{s[r]=edgesPathData({vertices_coords:e,edges_vertices:s[r].map((e=>t[e]))})})),Object.keys(s).forEach((e=>{""===s[e]&&delete s[e]})),s},applyEdgesStyle=(e,t={})=>Object.keys(t).forEach((r=>e.setAttributeNS(null,r,t[r])))
/**
	 * @returns an array of SVG Path elements.
	 * if edges_assignment exists, there will be as many paths as there are types of edges
	 * if no edges_assignment exists, there will be an array of 1 path.
	 */,edgesPaths=(e,t={})=>{const r=T.svg.g();if(!e)return r;const s=isFoldedForm(e),o=(({vertices_coords:e,edges_vertices:t,edges_assignment:r})=>{const s=edgesPathDataAssign({vertices_coords:e,edges_vertices:t,edges_assignment:r});return Object.keys(s).forEach((e=>{const t=T.svg.path(s[e]);addClassToClassList(t,te[e]),
// path.setAttributeNS(null, S._class, edgesAssignmentNames[assignment]);
s[e]=t})),s})(e);return Object.keys(o).forEach((e=>{addClassToClassList(o[e],te[e]),
// paths[key].classList.add(edgesAssignmentNames[key]);
// paths[key].setAttributeNS(null, S._class, edgesAssignmentNames[key]);
applyEdgesStyle(o[e],s?fr[e]:dr[e]),applyEdgesStyle(o[e],t[e]),applyEdgesStyle(o[e],t[te[e]]),r.appendChild(o[e]),Object.defineProperty(r,te[e],{get:()=>o[e]})})),applyEdgesStyle(r,s?ir:lr),
// todo: everything else that isn't a class name. filter out classes
// const no_class_attributes = Object.keys(attributes).filter(
applyEdgesStyle(r,t.stroke?{stroke:t.stroke}:{}),r},edgesLines=(e,t={})=>{const r=T.svg.g();if(!e)return r;const s=isFoldedForm(e),o=(e.edges_assignment?e.edges_assignment:makeEdgesAssignment(e)).map((e=>e.toLowerCase())),n={};["b","m","v","f","u"].forEach((e=>{const o=T.svg.g();r.appendChild(o),addClassToClassList(o,te[e]),
// child_group.classList.add(edgesAssignmentNames[k]);
// child_group.setAttributeNS(null, S._class, edgesAssignmentNames[k]);
applyEdgesStyle(o,s?fr[e]:dr[e]),applyEdgesStyle(o,t[te[e]]),Object.defineProperty(r,te[e],{get:()=>o}),n[e]=o}));const a=e.edges_vertices.map((t=>t.map((t=>e.vertices_coords[t])))).map((e=>T.svg.line(e[0][0],e[0][1],e[1][0],e[1][1])));return e.edges_foldAngle&&a.forEach(((t,r)=>{const s=e.edges_foldAngle[r];var o;0!==s&&180!==s&&-180!==s&&t.setAttributeNS(null,"opacity",(o=s,Math.abs(o)/180))})),a.forEach(((e,t)=>n[o[t]].appendChild(e))),applyEdgesStyle(r,s?ir:lr),applyEdgesStyle(r,t.stroke?{stroke:t.stroke}:{}),r},mr={back:{fill:y},front:{fill:"#ddd"}},gr={back:{opacity:.1},front:{opacity:.1}},pr={},vr={stroke:b,"stroke-linejoin":"bevel"},ur={stroke:E,fill:b,"stroke-linejoin":"bevel"},hr={fill:E},applyFacesStyle=(e,t={})=>Object.keys(t).forEach((r=>e.setAttributeNS(null,r,t[r])))
/**
	 * @description this method will check for layer order, face windings,
	 * and apply a style to each face accordingly, adds them to the group,
	 * and applies style attributes to the group itself too.
	 */,finalize_faces=(e,t,r,s)=>{const o=isFoldedForm(e),n=null!=e[p],a=[[u],[h]],c=makeFacesWinding(e);
// currently, layer order is determined by "faces_layer" key, and
// ensuring that the length matches the number of faces in the graph.
// counter-clockwise faces are "face up", their front facing the camera
// clockwise faces means "flipped", their back is facing the camera.
// set these class names, and apply the style as attributes on each face.
c.map((e=>e?a[0]:a[1])).forEach(((e,r)=>{addClassToClassList(t[r],e),
// svg_faces[i].classList.add(className);
// svg_faces[i].setAttributeNS(null, S._class, className);
applyFacesStyle(t[r],o?n?mr[e]:gr[e]:pr[e]),applyFacesStyle(t[r],s[e])}));
// if the layer-order exists, sort the faces in order of faces_layer
const i=n?function(e,t){const r=t.faces_vertices.length||t.faces_edges.length;return Array.from(Array(r)).map(((e,t)=>t)).filter((t=>null==e[t])).concat(invertMap(e))}(e[p],e).map((e=>t[e])):t;return i.forEach((e=>r.appendChild(e))),
// these custom getters allows you to grab all "front" or "back" faces only.
Object.defineProperty(r,u,{get:()=>t.filter(((e,t)=>c[t]))}),Object.defineProperty(r,h,{get:()=>t.filter(((e,t)=>!c[t]))}),
// set style attributes to the group itself which contains the faces.
applyFacesStyle(r,o?n?vr:ur:hr),r},_r={
// stroke: "none",
fill:E},br={stroke:b,fill:y},yr={vertices:(e,t={})=>{const r=T.svg.g();return e&&e.vertices_coords?(e.vertices_coords.map((e=>T.svg.circle(e[0],e[1],.01)// radius overwritten in "style"
)).forEach((e=>r.appendChild(e))),
// default style
r.setAttributeNS(null,"fill",E),
// style attributes on group container
Object.keys(t).forEach((e=>r.setAttributeNS(null,e,t[e]))),r):r},edges:(e,t)=>edgesFoldAngleAreAllFlat(e)?edgesPaths(e,t):edgesLines(e,t)
// const make_edgesAssignmentNames = ({ edges_vertices, edges_assignment }) => {
// 	if (!edges_vertices) { return []; }
// 	if (!edges_assignment) { return edges_vertices.map(() => edgesAssignmentNames["u"]); }
// 	return edges_vertices
// 		.map((_, i) => edges_assignment[i])
// 		.map((a) => edgesAssignmentNames[(a ? a : "u")]);
// };
// const edgesLines = ({ vertices_coords, edges_vertices, edges_assignment }) => {
// 	if (!vertices_coords || !edges_vertices) { return []; }
//   const svg_edges = edgesCoords({ vertices_coords, edges_vertices })
//     .map(e => libraries.svg.line(e[0][0], e[0][1], e[1][0], e[1][1]));
//   make_edgesAssignmentNames(graph)
//     .foreach((a, i) => svg_edges[i][k.setAttributeNS](null, k._class, a));
//   return svg_edges;
// };
/**
	 * Rabbit Ear (c) Kraft
	 */,// edgesPaths
faces:(e,t)=>e&&e.faces_vertices?((e,t={})=>{const r=T.svg.g();if(!e||!e.vertices_coords||!e.faces_vertices)return r;const o=e.faces_vertices.map((t=>t.map((t=>[0,1].map((r=>e.vertices_coords[t][r])))))).map((e=>T.svg.polygon(e)));return o.forEach(((e,t)=>e.setAttributeNS(null,s,t))),// `${i}`));
r.setAttributeNS(null,"fill",y),finalize_faces(e,o,r,t)})(e,t):e&&e[d]?function(e,t={}){const r=T.svg.g();if(!e||d in e==0||l in e==0||i in e==0)return r;const o=e[d].map((t=>t.map((t=>e[l][t])).map(((e,t,r)=>{const s=r[(t+1)%r.length];return e[1]===s[0]||e[1]===s[1]?e[0]:e[1];
// }).map(v => graph[S._vertices_coords][v]))
})).map((t=>[0,1].map((r=>e[i][t][r])))))).map((e=>T.svg.polygon(e)));return o.forEach(((e,t)=>e.setAttributeNS(null,s,t))),// `${i}`));
r.setAttributeNS(null,"fill","white"),finalize_faces(e,o,r,t)}(e,t):T.svg.g(),boundaries:(e,t={})=>{const r=T.svg.g();if(!(e&&e.vertices_coords&&e.edges_vertices&&e.edges_assignment))return r;const s=boundary(e).vertices.map((t=>[0,1].map((r=>e.vertices_coords[t][r]))));if(0===s.length)return r;
// create polygon, append to group
const o=T.svg.polygon(s);return addClassToClassList(o,v),
// poly.setAttributeNS(null, S._class, S._boundary);
r.appendChild(o),
// style attributes on group container
((e,t={})=>{Object.keys(t).forEach((r=>e.setAttributeNS(null,r,t[r])));
// todo this needs to be able to handle multiple boundaries
})(r,isFoldedForm(e)?_r:br),Object.keys(t).forEach((e=>r.setAttributeNS(null,e,t[e]))),r}},drawGroup=(e,t,r)=>{const s=!1===r?T.svg.g():yr[e](t,r);
// group.classList.add(key);
// group.setAttributeNS(null, S._class, key);
return addClassToClassList(s,e),s},DrawGroups=(e,t={})=>[c,a,n,o].map((r=>drawGroup(r,e,t[r])))
// static style draw methods for individual components;
/**
	 * Rabbit Ear (c) Kraft
	 */[c,a,n,o].forEach((e=>{DrawGroups[e]=function(t,r={}){return drawGroup(e,t,r[e])}}));
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * link this library to the larger RabbitEar library. this allows
	 * Rabbit Ear to be built with or without this extension.
	 */
const getBoundingRect=({vertices_coords:e})=>{if(null==e||0===e.length)return;const t=Array(2).fill(1/0),r=Array(2).fill(-1/0);e.forEach((e=>{e[0]<t[0]&&(t[0]=e[0]),e[0]>r[0]&&(r[0]=e[0]),e[1]<t[1]&&(t[1]=e[1]),e[1]>r[1]&&(r[1]=e[1])}));return Number.isNaN(t[0])||Number.isNaN(t[1])||Number.isNaN(r[0])||Number.isNaN(r[1])?void 0:[t[0],t[1],r[0]-t[0],r[1]-t[1]]},findSVGInParents=e=>"SVG"===(e.nodeName||"").toUpperCase()?e:e.parentNode?findSVGInParents(e.parentNode):void 0,applyTopLevelOptions=(e,t,r,s)=>{const o=t[3]&&t[3].childNodes.length;if(!(s.strokeWidth||s.viewBox||o))return;const n=getBoundingRect(r),a=n?Math.max(n[2],n[3]):1,c=findSVGInParents(e);if(c&&s.viewBox){const e=n?n.join(" "):"0 0 1 1";c.setAttributeNS(null,"viewBox",e)}if(c&&s.padding){const e=c.getAttribute("viewBox");if(null!=e){const t=s.padding*a,r=e.split(" ").map((e=>parseFloat(e))),o=[-t,-t,2*t,2*t].map(((e,t)=>r[t]+e)).join(" ");c.setAttributeNS(null,"viewBox",o)}}if(s.strokeWidth||s["stroke-width"]){const t=s.strokeWidth?s.strokeWidth:s["stroke-width"],o=(({vertices_coords:e,edges_vertices:t,edges_length:r})=>{if(!e||!t)return;r||(r=makeEdgesLength({vertices_coords:e,edges_vertices:t}));const s=r.slice().sort(((e,t)=>e-t));return s[Math.floor(.1*s.length)]})(r);let n;n=o?"number"==typeof t?10*o*t:10*o*.01:"number"==typeof t?a*t:.01*a,e.setAttributeNS(null,"stroke-width",n)}if(o){const e=s.vertices&&null!=s.vertices.radius?s.vertices.radius:s.radius,r="string"==typeof e?parseFloat(e):e,o="number"!=typeof r||Number.isNaN(r)?.02*a:a*r;((e,t)=>{for(let r=0;r<e.childNodes.length;r+=1)e.childNodes[r].setAttributeNS(null,"r",t)})(t[3],o)}},drawInto=(e,t,r={})=>{const s=DrawGroups(t,r);return s.filter((e=>e.childNodes.length>0)).forEach((t=>e.appendChild(t))),applyTopLevelOptions(e,s,t,r),((e,t)=>{const r=[t.file_classes||[],t.frame_classes||[]].flat();r.length&&addClassToClassList(e,...r)})(e,t),
// set custom getters on the element to grab the component groups
Object.keys(DrawGroups).map(((e,t)=>({key:e,i:t}))).filter((t=>null==e[t.key])).forEach((t=>Object.defineProperty(e,t.key,{get:()=>s[t.i]}))),e},FOLDtoSVG=(e,t)=>drawInto(T.svg(),e,t)
/**
	 * @description adding static-like methods to the main function, four for
	 *  drawing the individual elements, and one drawInto for pre-initialized svgs.
	 */;
/**
	 * Rabbit Ear (c) Kraft
	 */Object.keys(DrawGroups).forEach((e=>{FOLDtoSVG[e]=DrawGroups[e]})),FOLDtoSVG.drawInto=drawInto,FOLDtoSVG.getViewBox=e=>{const t=getBoundingRect(e);return void 0===t?"":t.join(" ")},
// .use() to link library to Rabbit Ear, and optionally build without this.
Object.defineProperty(FOLDtoSVG,"linker",{enumerable:!1,value:function(e){
// bind fold-to-svg
e.graph.svg=this;const t={svg:this};Object.keys(t).forEach((r=>{e.graph.prototype[r]=function(){return t[r](this,...arguments)}}))}.bind(FOLDtoSVG)});
/* SVG (c) Kraft, MIT License */
/**
	 * SVG (c) Kraft
	 */
const Er={init:()=>{}};
/**
	 * @name svg
	 * @description Create an svg element, the object will be bound with instance
	 * methods for creating children and styles.
	 * @memberof svg
	 * @param {Element} [parent=undefined] optional parent DOM element, this will append to.
	 * @param {number} [width=undefined] optional width of viewBox (if present, include height)
	 * @param {number} [height=undefined] optional height of viewBox (if present, include width)
	 * @param {function} [callback=undefined] optional function which will be
	 * executed upon completion of initialization.
	 * @returns {Element} one svg DOM element
	 * @example
	 * var svg = ear.svg(document.body, 640, 480)
	 * @example
	 * ear.svg(640, 480, document.body, (svg) => {
	 *   // window did load, and "svg" is scoped
	 * })
	 * @linkcode SVG ./src/library.js 24
	 */function SVG(){return Er.init(...arguments)}
/**
	 * SVG (c) Kraft
	 */
// frequently-used strings
const xr="class",Ar="function",kr="undefined",Or="number",wr="string",Mr="object",jr="svg",Fr="path",Cr="id",Pr="style",Nr="viewBox",Sr="transform",Vr="points",$r="stroke",zr="none",Tr="arrow",Lr="head",Br="tail",Ir=typeof window!==kr&&typeof window.document!==kr,Rr=typeof process!==kr&&null!=process.versions&&null!=process.versions.node,Ur=[];Ur[10]='"error 010: window" not set. if using node/deno, include package @xmldom/xmldom, set to the main export ( ear.window = xmldom; )';
/**
	 * SVG (c) Kraft
	 */
const Dr={window:void 0};
// if we are in the browser, by default use the browser's "window".
Ir&&(Dr.window=window)
/**
	 * @description get the "window" object, which should have
	 * DOMParser, XMLSerializer, and document.
	 */;const SVGWindow=()=>{if(void 0===Dr.window)throw Ur[10];return Dr.window};
/**
	 * SVG (c) Kraft
	 */
/** @description The namespace of an SVG element, the value of the attribute xmlns */var qr="http://www.w3.org/2000/svg",Gr={s:[// svg
"svg"],d:[// defs
"defs"],h:[// header
"desc",// anywhere, usually top level SVG, or <defs>
"filter",// anywhere, usually top level SVG, or <defs>
"metadata",// anywhere, usually top level SVG, or <defs>
"style",// anywhere, usually top level SVG, or <defs>
"script",// anywhere, usually top level SVG, or <defs>
"title",// anywhere, usually top level SVG, or <defs>
"view"],c:[// cdata
"cdata"],g:[// group
"g"],v:[// visible (drawing)
"circle","ellipse","line","path","polygon","polyline","rect"],t:[// text
"text"],
// can contain drawings
i:[// invisible
"marker",// anywhere, usually top level SVG, or <defs>
"symbol",// anywhere, usually top level SVG, or <defs>
"clipPath",// anywhere, usually top level SVG, or <defs>
"mask"],p:[// patterns
"linearGradient",// <defs>
"radialGradient",// <defs>
"pattern"],cT:[// children of text
"textPath",// <text>  path and href attributes
"tspan"],cG:[// children of gradients
"stop"],cF:[// children of filter
"feBlend",// <filter>
"feColorMatrix",// <filter>
"feComponentTransfer",// <filter>
"feComposite",// <filter>
"feConvolveMatrix",// <filter>
"feDiffuseLighting",// <filter>
"feDisplacementMap",// <filter>
"feDistantLight",// <filter>
"feDropShadow",// <filter>
"feFlood",// <filter>
"feFuncA",// <filter>
"feFuncB",// <filter>
"feFuncG",// <filter>
"feFuncR",// <filter>
"feGaussianBlur",// <filter>
"feImage",// <filter>
"feMerge",// <filter>
"feMergeNode",// <filter>
"feMorphology",// <filter>
"feOffset",// <filter>
"fePointLight",// <filter>
"feSpecularLighting",// <filter>
"feSpotLight",// <filter>
"feTile",// <filter>
"feTurbulence"]};
/**
	 * SVG (c) Kraft
	 */
/**
	 * SVG (c) Kraft
	 */
const svg_add2=(e,t)=>[e[0]+t[0],e[1]+t[1]],svg_sub2=(e,t)=>[e[0]-t[0],e[1]-t[1]],svg_scale2=(e,t)=>[e[0]*t,e[1]*t],svg_magnitudeSq2=e=>e[0]**2+e[1]**2,svg_magnitude2=e=>Math.sqrt(svg_magnitudeSq2(e)),svg_distanceSq2=(e,t)=>svg_magnitudeSq2(svg_sub2(e,t)),svg_distance2=(e,t)=>Math.sqrt(svg_distanceSq2(e,t)),svg_polar_to_cart=(e,t)=>[Math.cos(e)*t,Math.sin(e)*t];var Wr=Object.freeze({__proto__:null,svg_add2:svg_add2,svg_sub2:svg_sub2,svg_scale2:svg_scale2,svg_magnitudeSq2:svg_magnitudeSq2,svg_magnitude2:svg_magnitude2,svg_distanceSq2:svg_distanceSq2,svg_distance2:svg_distance2,svg_polar_to_cart:svg_polar_to_cart});
/**
	 * SVG (c) Kraft
	 */const arcPath=(e,t,r,s,o,n=!1)=>{if(null==o)return"";const a=svg_polar_to_cart(s,r),c=svg_polar_to_cart(o,r),i=[c[0]-a[0],c[1]-a[1]],l=a[0]*c[1]-a[1]*c[0],d=a[0]*c[0]+a[1]*c[1],m=Math.atan2(l,d)>0?0:1;let g=n?`M ${e},${t} l ${a[0]},${a[1]} `:`M ${e+a[0]},${t+a[1]} `;return g+=["a ",r,r,0,m,1,i[0],i[1]].join(" "),n&&(g+=" Z"),g},arcArguments=(e,t,r,s,o)=>[arcPath(e,t,r,s,o,!1)];
/**
	 * SVG (c) Kraft
	 */var Hr={arc:{nodeName:Fr,attributes:["d"],args:arcArguments,methods:{setArc:(e,...t)=>e.setAttribute("d",arcArguments(...t))}}};
/**
	 * SVG (c) Kraft
	 */const wedgeArguments=(e,t,r,s,o)=>[arcPath(e,t,r,s,o,!0)];var Jr={wedge:{nodeName:Fr,args:wedgeArguments,attributes:["d"],methods:{setArc:(e,...t)=>e.setAttribute("d",wedgeArguments(...t))}}};
/**
	 * SVG (c) Kraft
	 */const parabolaArguments=(e=-1,t=0,r=2,s=1)=>Array.from(Array(129)).map(((e,t)=>(t-128)/128*2+1)).map((o=>[e+(o+1)*r*.5,t+o**2*s]));
/**
	 * SVG (c) Kraft
	 */
var Zr={parabola:{nodeName:"polyline",attributes:[Vr],args:(e,t,r,s)=>[parabolaArguments(e,t,r,s).map((e=>`${e[0]},${e[1]}`)).join(" ")]}};
/**
	 * SVG (c) Kraft
	 */const regularPolygonArguments=(e,t,r,s)=>{const o=[t,r];
// default is point-aligned along the axis.
// if we want edge-aligned, add this value to the angle.
// const halfwedge = Math.PI / sides;
return Array.from(Array(e)).map(((t,r)=>2*Math.PI*(r/e))).map((e=>[Math.cos(e),Math.sin(e)])).map((e=>o.map(((t,r)=>t+s*e[r]))))};
/**
	 * SVG (c) Kraft
	 */
var Yr={regularPolygon:{nodeName:"polygon",attributes:[Vr],args:(e,t=0,r=0,s=1)=>[regularPolygonArguments(e,t,r,s).map((e=>`${e[0]},${e[1]}`)).join(" ")]}};
/**
	 * SVG (c) Kraft
	 */
/**
	 * SVG (c) Kraft
	 */
var Xr={roundRect:{nodeName:Fr,attributes:["d"],args:(e,t,r,s,o=0)=>{o>r/2&&(o=r/2),o>s/2&&(o=s/2);const n=r-2*o,a=s-2*o,c=`A${o} ${o} 0 0 1`;return[[`M${e+(r-n)/2},${t}`,`h${n}`,c,`${e+r},${t+(s-a)/2}`,`v${a}`,c,`${e+r-o},${t+s}`,"h"+-n,c,`${e},${t+s-o}`,"v"+-a,c,`${e+o},${t}`].join(" ")]}}},Kr={toCamel:e=>e.replace(/([-_][a-z])/gi,(e=>e.toUpperCase().replace("-","").replace("_",""))),toKebab:e=>e.replace(/([a-z0-9])([A-Z])/g,"$1-$2").replace(/([A-Z])([A-Z])(?=[a-z])/g,"$1-$2").toLowerCase(),capitalized:e=>e.charAt(0).toUpperCase()+e.slice(1)};
/**
	 * SVG (c) Kraft
	 */
/**
	 * SVG (c) Kraft
	 */
const svg_is_iterable=e=>null!=e&&typeof e[Symbol.iterator]===Ar
/**
	 * @description flatten only until the point of comma separated entities. recursive
	 * @returns always an array
	 */,svg_semi_flatten_arrays=function(){switch(arguments.length){case void 0:case 0:return Array.from(arguments);
// only if its an array (is iterable) and NOT a string
case 1:return svg_is_iterable(arguments[0])&&typeof arguments[0]!==wr?svg_semi_flatten_arrays(...arguments[0]):[arguments[0]];default:return Array.from(arguments).map((e=>svg_is_iterable(e)?[...svg_semi_flatten_arrays(e)]:e))}};
/**
	 * SVG (c) Kraft
	 */
/**
	 * this will extract coordinates from a set of inputs
	 * and present them as a stride-2 flat array. length % 2 === 0
	 * a 1D array of numbers, alternating x y
	 *
	 * use flatten() everytime you call this!
	 * it's necessary the entries sit at the top level of ...args
	 * findCoordinates(...flatten(...args));
	 */
var coordinates=(...e)=>e.filter((e=>typeof e===Or)).concat(e.filter((e=>typeof e===Mr&&null!==e)).map((e=>typeof e.x===Or?[e.x,e.y]:typeof e[0]===Or?[e[0],e[1]]:void 0)).filter((e=>void 0!==e)).reduce(((e,t)=>e.concat(t)),[]))
// [top-level numbers] concat [{x:,y:} and [0,1]] style
/**
	 * SVG (c) Kraft
	 */;const Qr=[Br,Lr],stringifyPoint=e=>e.join(","),pointsToPath=e=>"M"+e.map((e=>e.join(","))).join("L")+"Z",setArrowheadOptions=(e,t,r)=>{"boolean"==typeof t?e.options[r].visible=t:typeof t===Mr?(Object.assign(e.options[r],t),null==t.visible&&(e.options[r].visible=!0)):null==t&&(e.options[r].visible=!0)},setArrowStyle=(e,t={},r=Lr)=>{const s=e.getElementsByClassName(`${Tr}-${r}`)[0];
// find options which translate to object methods (el.stroke("red"))
Object.keys(t).map((e=>({key:e,fn:s[Kr.toCamel(e)]}))).filter((e=>typeof e.fn===Ar&&"class"!==e.key)).forEach((e=>e.fn(t[e.key]))),
// find options which don't work as methods, set as attributes
// Object.keys(options)
// 	.map(key => ({ key, fn: path[Case.toCamel(key)] }))
// 	.filter(el => typeof el.fn !== S.str_function && el.key !== "class")
// 	.forEach(el => path.setAttribute(el.key, options[el.key]));
// apply a class attribute (add, don't overwrite existing classes)
Object.keys(t).filter((e=>"class"===e)).forEach((e=>s.classList.add(t[e])))},redraw=e=>{const t=function(e){
// throughout, tail is 0, head is 1
let t=[[0,1],[2,3]].map((t=>t.map((t=>e.points[t]||0)))),r=svg_sub2(t[1],t[0]),s=svg_add2(t[0],svg_scale2(r,.5));
// make sure arrow isn't too small
const o=svg_magnitude2(r),n=Qr.map((t=>e[t].visible?(1+e[t].padding)*e[t].height*2.5:0)).reduce(((e,t)=>e+t),0);if(o<n){
// check len === exactly 0. don't compare to epsilon here
const e=0===o?[n,0]:svg_scale2(r,n/o);t=[svg_sub2,svg_add2].map((t=>t(s,svg_scale2(e,.5)))),r=svg_sub2(t[1],t[0])}let a=[r[1],-r[0]],c=svg_add2(s,svg_scale2(a,e.bend));const i=t.map((e=>svg_sub2(c,e))),l=i.map((e=>svg_magnitude2(e))),d=i.map(((e,t)=>0===l[t]?e:svg_scale2(e,1/l[t]))),m=d.map((e=>svg_scale2(e,-1))),g=m.map((e=>[e[1],-e[0]])),p=Qr.map(((t,r)=>e[t].padding?e[t].padding:e.padding?e.padding:0)),v=Qr.map(((t,r)=>e[t].height*(e[t].visible?1:0))).map(((e,t)=>e+p[t])),u=t.map(((e,t)=>svg_add2(e,svg_scale2(d[t],v[t]))));
// readjust bezier curve now that the arrow heads push inwards
r=svg_sub2(u[1],u[0]),a=[r[1],-r[0]],s=svg_add2(u[0],svg_scale2(r,.5)),c=svg_add2(s,svg_scale2(a,e.bend));
// done adjust
const h=u.map(((t,r)=>svg_add2(t,svg_scale2(svg_sub2(c,t),e.pinch)))),_=Qr.map(((t,r)=>[svg_add2(u[r],svg_scale2(m[r],e[t].height)),svg_add2(u[r],svg_scale2(g[r],e[t].width/2)),svg_add2(u[r],svg_scale2(g[r],-e[t].width/2))]));return{line:`M${stringifyPoint(u[0])}C${stringifyPoint(h[0])},${stringifyPoint(h[1])},${stringifyPoint(u[1])}`,tail:pointsToPath(_[0]),head:pointsToPath(_[1])}}(e.options);return Object.keys(t).map((t=>({path:t,element:e.getElementsByClassName(`${Tr}-${t}`)[0]}))).filter((e=>e.element)).map((e=>(e.element.setAttribute("d",t[e.path]),e))).filter((t=>e.options[t.path])).forEach((t=>t.element.setAttribute("visibility",e.options[t.path].visible?"visible":"hidden"))),e},setPoints$3=(e,...t)=>(e.options.points=coordinates(...svg_semi_flatten_arrays(...t)).slice(0,4),redraw(e));var es={setPoints:setPoints$3,points:setPoints$3,bend:(e,t)=>(e.options.bend=t,redraw(e)),pinch:(e,t)=>(e.options.pinch=t,redraw(e)),padding:(e,t)=>(e.options.padding=t,redraw(e)),head:(e,t)=>(setArrowheadOptions(e,t,Lr),setArrowStyle(e,t,Lr),redraw(e)),tail:(e,t)=>(setArrowheadOptions(e,t,Br),setArrowStyle(e,t,Br),redraw(e)),getLine:e=>e.getElementsByClassName(`${Tr}-line`)[0],getHead:e=>e.getElementsByClassName(`${Tr}-${Lr}`)[0],getTail:e=>e.getElementsByClassName(`${Tr}-${Br}`)[0]};
/**
	 * SVG (c) Kraft
	 */const ts=Object.keys({head:{visible:!1,width:8,height:10,padding:0},tail:{visible:!1,width:8,height:10,padding:0},bend:0,padding:0,pinch:.618,points:[]});
/**
	 * SVG (c) Kraft
	 */
var rs={arrow:{nodeName:"g",attributes:[],args:()=>[]// one function
,methods:es,// object of functions
init:function(e,...t){e.classList.add(Tr);
// element.setAttribute(S.str_class, S.str_arrow);
const r=["line",Br,Lr].map((t=>SVG.path().addClass(`${Tr}-${t}`).appendTo(e)));r[0].setAttribute(Pr,"fill:none;"),r[1].setAttribute($r,zr),r[2].setAttribute($r,zr),e.options={head:{visible:!1,width:8,height:10,padding:0},tail:{visible:!1,width:8,height:10,padding:0},bend:0,padding:0,pinch:.618,points:[]},es.setPoints(e,...t);const s=((...e)=>{for(let t=0;t<e.length;t+=1){if(typeof e[t]!==Mr)continue;const r=Object.keys(e[t]);for(let s=0;s<r.length;s+=1)if(ts.includes(r[s]))return e[t]}})(...t);return s&&Object.keys(s).filter((e=>es[e])).forEach((t=>es[t](e,s[t]))),e}}};
/**
	 * SVG (c) Kraft
	 */
/**
	 * @description totally flatten, recursive
	 * @returns an array, always.
	 */const svg_flatten_arrays=function(){return svg_semi_flatten_arrays(arguments).reduce(((e,t)=>e.concat(t)),[])},makeCurvePath=(e=[],t=0,r=.5)=>{const s=[e[0]||0,e[1]||0],o=[e[2]||0,e[3]||0],n=svg_sub2(o,s),a=svg_add2(s,svg_scale2(n,.5)),c=[n[1],-n[0]],i=svg_add2(a,svg_scale2(c,t)),l=svg_add2(s,svg_scale2(svg_sub2(i,s),r)),d=svg_add2(o,svg_scale2(svg_sub2(i,o),r));return`M${s[0]},${s[1]}C${l[0]},${l[1]} ${d[0]},${d[1]} ${o[0]},${o[1]}`},getNumbersFromPathCommand=e=>e.slice(1).split(/[, ]+/).map((e=>parseFloat(e)))
// this gets the parameter numbers, in an array
,getCurveEndpoints=e=>{
// get only the first Move and Curve commands
const t=(e=>e.match(/[Mm][(0-9), .-]+/).map((e=>getNumbersFromPathCommand(e))))(e).shift(),r=(e=>e.match(/[Cc][(0-9), .-]+/).map((e=>getNumbersFromPathCommand(e))))(e).shift();return[...t?[t[t.length-2],t[t.length-1]]:[0,0],...r?[r[r.length-2],r[r.length-1]]:[0,0]]},setPoints$2=(e,...t)=>{const r=coordinates(...svg_flatten_arrays(...t)).slice(0,4);return e.setAttribute("d",makeCurvePath(r,e._bend,e._pinch)),e};
/**
	 * SVG (c) Kraft
	 */
// endpoints is an array of 4 numbers
var ss={curve:{nodeName:Fr,attributes:["d"],args:(...e)=>[makeCurvePath(coordinates(...svg_flatten_arrays(...e)))]
/**
	 * SVG (c) Kraft
	 */,// one function
methods:{setPoints:setPoints$2,bend:(e,t)=>(e._bend=t,setPoints$2(e,...getCurveEndpoints(e.getAttribute("d")))),pinch:(e,t)=>(e._pinch=t,setPoints$2(e,...getCurveEndpoints(e.getAttribute("d"))))}}};
/**
	 * SVG (c) Kraft
	 */
/**
	 * SVG (c) Kraft
	 */
const os={};Object.assign(os,
// to include/exclude nodes from this library
// comment out nodes below, rebuild
Hr,Jr,Zr,Yr,Xr,rs,ss);
/**
	 * SVG (c) Kraft
	 */
// arc, parabola, regularPolygon...
const ns=Object.keys(os),as=[Gr.h,Gr.p,Gr.i],cs=[Gr.g,Gr.v,Gr.t,ns],is={
// VISIBLE
svg:[Gr.s,Gr.d].concat(as).concat(cs),g:cs,text:[Gr.cT],linearGradient:[Gr.cG],radialGradient:[Gr.cG],
// NON VISIBLE
defs:as,filter:[Gr.cF],marker:cs,symbol:cs,clipPath:cs,mask:cs},ls=Object.create(null);
// todo, get rid of custom primitives here if possible
Object.keys(is).forEach((e=>{ls[e]=is[e].reduce(((e,t)=>e.concat(t)),[])}));
/**
	 * SVG (c) Kraft
	 */
const viewBoxValue=function(e,t,r,s,o=0){const n=r/1-r;return[e-n-o,t-n-o,r+2*n+2*o,s+2*n+2*o].join(" ")};
/**
	 * this will attempt to match a set of viewbox parameters
	 * undefined, if it cannot build a string
	 */function viewBox$1(){const e=coordinates(...svg_flatten_arrays(arguments));return 2===e.length&&e.unshift(0,0),4===e.length?viewBoxValue(...e):void 0}
/**
	 * SVG (c) Kraft
	 */const cdata=e=>(new(SVGWindow().DOMParser)).parseFromString("<root></root>","text/xml").createCDATASection(`${e}`)
/**
	 * SVG (c) Kraft
	 */,removeChildren=e=>{for(;e.lastChild;)e.removeChild(e.lastChild);return e},moveChildren=(e,t)=>{for(;t.childNodes.length>0;){const r=t.childNodes[0];t.removeChild(r),e.appendChild(r)}return e},assignSVG=(e,t)=>(Array.from(t.attributes).forEach((t=>e.setAttribute(t.name,t.value))),moveChildren(e,t));
// everything but clearSVG gets exported as the default and added
// as a method to many elements
var fs={removeChildren:removeChildren,appendTo:(e,t)=>(null!=t&&t.appendChild(e),e),setAttributes:(e,t)=>Object.keys(t).forEach((r=>e.setAttribute(Kr.toKebab(r),t[r])))};
/**
	 * SVG (c) Kraft
	 */
/** parser error to check against */
// const pErr = (new window.DOMParser())
//  .parseFromString("INVALID", "text/xml")
//  .getElementsByTagName("parsererror")[0]
//  .namespaceURI;
const filterWhitespaceNodes=e=>{if(null===e)return e;for(let t=e.childNodes.length-1;t>=0;t-=1){const r=e.childNodes[t];3===r.nodeType&&r.data.match(/^\s*$/)&&e.removeChild(r),1===r.nodeType&&filterWhitespaceNodes(r)}return e},parse=e=>(new(SVGWindow().DOMParser)).parseFromString(e,"text/xml"),checkParseError=e=>{const t=e.getElementsByTagName("parsererror");if(t.length>0)throw new Error(t[0]);return filterWhitespaceNodes(e.documentElement)},sync=function(e){if(typeof e===wr||e instanceof String)try{return checkParseError(parse(e))}catch(e){return e}if(null!=e.childNodes)return e},Load=e=>(e=>typeof e===wr&&/^[\w,\s-]+\.[A-Za-z]{3}$/.test(e)&&e.length<1e4)(e)&&Ir&&typeof SVGWindow().fetch===Ar?function(e){return new Promise(((t,r)=>{if(typeof e===wr||e instanceof String)fetch(e).then((e=>e.text())).then((e=>checkParseError(parse(e)))).then((e=>e.nodeName===jr?e:e.getElementsByTagName(jr)[0])).then((e=>null==e?r(new Error("valid XML found, but no SVG element")):t(e))).catch((e=>r(e)));else if(e instanceof SVGWindow().Document)return asyncDone(e)}))}(e):sync(e)
/**
	* vkBeautify
	*
	* Version - 0.99.00.beta
	* Copyright (c) 2012 Vadim Kiryukhin
	* vkiryukhin @ gmail.com
	* http://www.eslinstructor.net/vkbeautify/
	*
	* MIT license:
	*   http://www.opensource.org/licenses/mit-license.php
	*/;
/**
	 * parse and checkParseError go together.
	 * checkParseError needs to be called to pull out the .documentElement
	 */
/**
	 * SVG (c) Kraft
	 */
const save=function(e,t){
// if this SVG was created inside the browser, it inherited all the <link>
// stylesheets present on the window, this allows them to be included.
// default: not included.
if((t=Object.assign({download:!1,// trigger a file download (browser only)
output:wr,// output type ("string", "svg") string or XML DOM object
windowStyle:!1,// include any external stylesheets present on the window object
filename:"image.svg"},t)).windowStyle){const t=SVGWindow().document.createElementNS(qr,Pr);t.setAttribute("type","text/css"),t.innerHTML=function(){const e=[];if(SVGWindow().document.styleSheets)for(let t=0;t<SVGWindow().document.styleSheets.length;t+=1){const r=SVGWindow().document.styleSheets[t];try{const t="cssRules"in r?r.cssRules:r.rules;for(let r=0;r<t.length;r+=1){const s=t[r];"cssText"in s?e.push(s.cssText):e.push(`${s.selectorText} {\n${s.style.cssText}\n}\n`)}}catch(e){console.warn(e)}}return e.join("\n")}(),e.appendChild(t)}
// convert the SVG to a string and format it with good indentation
const r=function vkXML(e,t){const r=e.replace(/>\s{0,}</g,"><").replace(/</g,"~::~<").replace(/\s*xmlns\:/g,"~::~xmlns:").split("~::~"),s=r.length;let o=!1,n=0,a="";const c=null!=t&&"string"==typeof t?t:"\t",i=["\n"];for(let e=0;e<100;e+=1)i.push(i[e]+c);for(let e=0;e<s;e+=1)
// start comment or <![CDATA[...]]> or <!DOCTYPE //
r[e].search(/<!/)>-1?(a+=i[n]+r[e],o=!0,
// end comment  or <![CDATA[...]]> //
(r[e].search(/-->/)>-1||r[e].search(/\]>/)>-1||r[e].search(/!DOCTYPE/)>-1)&&(o=!1)):r[e].search(/-->/)>-1||r[e].search(/\]>/)>-1?(
// end comment  or <![CDATA[...]]> //
a+=r[e],o=!1):/^<\w/.exec(r[e-1])&&/^<\/\w/.exec(r[e])&&/^<[\w:\-\.\,]+/.exec(r[e-1])==/^<\/[\w:\-\.\,]+/.exec(r[e])[0].replace("/","")?(
// <elm></elm> //
a+=r[e],o||(n-=1)):r[e].search(/<\w/)>-1&&-1===r[e].search(/<\//)&&-1===r[e].search(/\/>/)?a=a+=o?r[e]:i[n++]+r[e]:r[e].search(/<\w/)>-1&&r[e].search(/<\//)>-1?
// <elm>...</elm> //
a=a+=o?r[e]:i[n]+r[e]:r[e].search(/<\//)>-1?
// </elm> //
a=a+=o?r[e]:i[--n]+r[e]:r[e].search(/\/>/)>-1?
// <elm/> //
a=a+=o?r[e]:i[n]+r[e]:r[e].search(/<\?/)>-1||r[e].search(/xmlns\:/)>-1||r[e].search(/xmlns\=/)>-1?
// <? xml ... ?> //
a+=i[n]+r[e]:a+=r[e];return"\n"===a[0]?a.slice(1):a}((new(SVGWindow().XMLSerializer)).serializeToString(e));
return t.download&&Ir&&!Rr&&function(e,t){const r=new(SVGWindow().Blob)([t],{type:"text/plain"}),s=SVGWindow().document.createElement("a");s.setAttribute("href",SVGWindow().URL.createObjectURL(r)),s.setAttribute("download",e),SVGWindow().document.body.appendChild(s),s.click(),SVGWindow().document.body.removeChild(s)}(t.filename,r),t.output===jr?e:r},setViewBox=(e,...t)=>{
// are they giving us pre-formatted string, or a list of numbers
const r=1===t.length&&typeof t[0]===wr?t[0]:viewBox$1(...t);return r&&e.setAttribute(Nr,r),e},getViewBox=function(e){const t=e.getAttribute(Nr);return null==t?void 0:t.split(" ").map((e=>parseFloat(e)))},convertToViewBox=function(e,t,r){const s=e.createSVGPoint();s.x=t,s.y=r;
// todo: i thought this threw an error once. something about getScreenCTM.
const o=s.matrixTransform(e.getScreenCTM().inverse());return[o.x,o.y]};
/*
	export const translateViewBox = function (svg, dx, dy) {
		const viewBox = getViewBox(svg);
		if (viewBox == null) {
			setDefaultViewBox(svg);
		}
		viewBox[0] += dx;
		viewBox[1] += dy;
		svg.setAttributeNS(null, vB, viewBox.join(" "));
	};

	export const scaleViewBox = function (svg, scale, origin_x = 0, origin_y = 0) {
		if (Math.abs(scale) < 1e-8) { scale = 0.01; }
		const matrix = svg.createSVGMatrix()
			.translate(origin_x, origin_y)
			.scale(1 / scale)
			.translate(-origin_x, -origin_y);
		const viewBox = getViewBox(svg);
		if (viewBox == null) {
			setDefaultViewBox(svg);
		}
		const top_left = svg.createSVGPoint();
		const bot_right = svg.createSVGPoint();
		[top_left.x, top_left.y] = viewBox;
		bot_right.x = viewBox[0] + viewBox[2];
		bot_right.y = viewBox[1] + viewBox[3];
		const new_top_left = top_left.matrixTransform(matrix);
		const new_bot_right = bot_right.matrixTransform(matrix);
		setViewBox(svg,
			new_top_left.x,
			new_top_left.y,
			new_bot_right.x - new_top_left.x,
			new_bot_right.y - new_top_left.y);
	};

	*/
var ds=Object.freeze({__proto__:null,setViewBox:setViewBox,getViewBox:getViewBox,convertToViewBox:convertToViewBox});
/**
	 * SVG (c) Kraft
	 */
// check if the loader is running synchronously or asynchronously
const loadSVG=(e,t)=>{const r=Load(t);if(null!=r)return typeof r.then===Ar?r.then((t=>assignSVG(e,t))):assignSVG(e,r)},getFrame=function(e){const t=getViewBox(e);if(void 0!==t)return t;if(typeof e.getBoundingClientRect===Ar){const t=e.getBoundingClientRect();return[t.x,t.y,t.width,t.height]}
// return Array(4).fill(undefined);
return[]},ms="svg-background-rectangle",stylesheet=function(e,t){let r=function(e){const t=e.getElementsByTagName(Pr);return 0===t.length?void 0:t[0]}(e);return null==r&&(r=this.Constructor(Pr),e.insertBefore(r,e.firstChild)),r.textContent="",r.appendChild(cdata(t)),r};
// these will end up as methods on the <svg> nodes
var gs={clear:e=>(Array.from(e.attributes).filter((e=>"xmlns"!==e)).forEach((t=>e.removeAttribute(t.name))),removeChildren(e)),size:setViewBox,setViewBox:setViewBox,getViewBox:getViewBox,padding:function(e,t){const r=getViewBox(e);return void 0!==r&&setViewBox(e,...[-t,-t,2*t,2*t].map(((e,t)=>r[t]+e))),e},background:function(e,t){let r=Array.from(e.childNodes).filter((e=>e.getAttribute(xr)===ms)).shift();return null==r&&(r=this.Constructor("rect",null,...getFrame(e)),r.setAttribute(xr,ms),r.setAttribute($r,zr),e.insertBefore(r,e.firstChild)),r.setAttribute("fill",t),e},getWidth:e=>getFrame(e)[2],getHeight:e=>getFrame(e)[3],stylesheet:function(e,t){return stylesheet.call(this,e,t)},load:loadSVG,save:save};
// svg.load = function (element, data, callback) {
//   return Load(data, (svg, error) => {
//     if (svg != null) { replaceSVG(element, svg); }
//     if (callback != null) { callback(element, error); }
//   });
// };
/**
	 * SVG (c) Kraft
	 */const ps={move:["mousemove","touchmove"],press:["mousedown","touchstart"],// "mouseover",
release:["mouseup","touchend"],leave:["mouseleave","touchcancel"]},vs=Object.values(ps).reduce(((e,t)=>e.concat(t)),[]),defineGetter=(e,t,r)=>Object.defineProperty(e,t,{get:()=>r,enumerable:!0,configurable:!0}),assignPress=(e,t)=>{["pressX","pressY"].filter((t=>!Object.prototype.hasOwnProperty.call(e,t))).forEach(((r,s)=>defineGetter(e,r,t[s]))),Object.prototype.hasOwnProperty.call(e,"press")||
// defineGetter(e, "press", Libraries.math.vector(...startPoint));
defineGetter(e,"press",[...t])},TouchEvents=function(e){
// todo, more pointers for multiple screen touches
let t=[];
// hold onto all handlers. to be able to turn them off
const r=[];Object.keys(ps).forEach((e=>{ps[e].forEach((e=>{r[e]=[]}))}));const s={press:(e,r)=>{t=r,assignPress(e,t)},release:()=>{},leave:()=>{},move:(e,r)=>{e.buttons>0&&void 0===t[0]?t=r:0===e.buttons&&void 0!==t[0]&&(t=[]),assignPress(e,t)}};
// add more properties depending on the type of handler
// assign handlers for onMove, onPress, onRelease
Object.keys(ps).forEach((t=>{const o=`on${Kr.capitalized(t)}`;Object.defineProperty(e,o,{set:o=>{null!=o?ps[t].forEach((n=>{const handlerFunc=r=>{
// const pointer = (e.touches != null && e.touches.length
const n=null!=r.touches?r.touches[0]:r;
// onRelease events don't have a pointer
if(void 0!==n){const o=convertToViewBox(e,n.clientX,n.clientY).map((e=>Number.isNaN(e)?void 0:e));// e.target
["x","y"].filter((e=>!Object.prototype.hasOwnProperty.call(r,e))).forEach(((e,t)=>defineGetter(r,e,o[t]))),Object.prototype.hasOwnProperty.call(r,"position")||
// defineGetter(e, "position", Libraries.math.vector(...viewPoint));
defineGetter(r,"position",[...o]),s[t](r,o)}o(r)};
// node.js doesn't have addEventListener
e.addEventListener&&(r[n].push(handlerFunc),e.addEventListener(n,handlerFunc))})):(t=>{ps[t].forEach((t=>r[t].forEach((r=>e.removeEventListener(t,r)))))})(t)},enumerable:!0})})),Object.defineProperty(e,"off",{value:()=>((e,t)=>vs.forEach((r=>{t[r].forEach((t=>e.removeEventListener(r,t))),t[r]=[]})))(e,r)})};
/**
	 * SVG (c) Kraft
	 */
var UUID=()=>Math.random().toString(36).replace(/[^a-z]+/g,"").concat("aaaaa").substr(0,5)
/**
	 * SVG (c) Kraft
	 */;const us=[["cx","cy"],["x","y"]],controlPoint=function(e,t={}){
// private properties. unless exposed
const r=[0,0],s={selected:!1,svg:void 0,
// to be overwritten
updatePosition:e=>e},updateSVG=()=>{s.svg&&(s.svg.parentNode||e.appendChild(s.svg),us.filter((e=>null!=s.svg[e[0]])).forEach((e=>e.forEach(((e,t)=>{s.svg.setAttribute(e,r[t])})))))},o=new Proxy(r,{set:(e,t,r)=>(e[t]=r,updateSVG(),!0)}),setPosition=function(...e){coordinates(...svg_flatten_arrays(...e)).forEach(((e,t)=>{r[t]=e})),updateSVG(),
// alert delegate
typeof r.delegate===Ar&&r.delegate.apply(r.pointsContainer,[o,r.pointsContainer])};// initialize below
// set default position
// setPosition(options.position);
return r.delegate=void 0,// to be set
r.setPosition=setPosition,r.onMouseMove=e=>s.selected?setPosition(s.updatePosition(e)):void 0,r.onMouseUp=()=>{s.selected=!1},r.distance=e=>Math.sqrt(svg_distanceSq2(e,r)),["x","y"].forEach(((e,t)=>Object.defineProperty(r,e,{get:()=>r[t],set:e=>{r[t]=e}}))),
// would be nice if "svg" also called removeFromParent(); on set()
[jr,"updatePosition","selected"].forEach((e=>Object.defineProperty(r,e,{get:()=>s[e],set:t=>{s[e]=t}}))),Object.defineProperty(r,"remove",{value:()=>{var e;(
// todo, do we need to do any other unwinding?
e=s.svg)&&e.parentNode&&e.parentNode.removeChild(e),r.delegate=void 0}}),o},controls=function(e,t,r){let s,o;const n=Array.from(Array(t)).map((()=>controlPoint(e,r))),protocol=e=>typeof o===Ar?o.call(n,e,s,n):void 0;
// hook up the delegate callback for the on change event
n.forEach((e=>{e.delegate=protocol,e.pointsContainer=n}));e.onPress=function(e){n.length>0&&(s=n.map(((t,r)=>({i:r,d:svg_distanceSq2(t,[e.x,e.y])}))).sort(((e,t)=>e.d-t.d)).shift().i,n[s].selected=!0)},e.onMove=function(e){n.forEach((t=>t.onMouseMove(e)))},e.onRelease=function(){n.forEach((e=>e.onMouseUp())),s=void 0},
// svg.addEventListener("touchcancel", touchUpHandler, false);
Object.defineProperty(n,"selectedIndex",{get:()=>s}),Object.defineProperty(n,"selected",{get:()=>n[s]}),Object.defineProperty(n,"add",{value:t=>{n.push(controlPoint(e,t))}}),n.removeAll=()=>{for(;n.length>0;)n.pop().remove()};const a={onChange:(e,t)=>{
// we need a point, give us the last one in the array
if(o=e,!0===t){const t=n.length-1;e.call(n,n[t],t,n)}},position:e=>n.forEach(((t,r)=>t.setPosition(e.call(n,t,r,n)))),svg:e=>n.forEach(((t,r)=>{t.svg=e.call(n,t,r,n)}))};return Object.keys(a).forEach((e=>{n[e]=function(){return typeof arguments[0]===Ar&&a[e](...arguments),n}})),n.parent=function(e){return null!=e&&null!=e.appendChild&&n.forEach((t=>{e.appendChild(t.svg)})),n},n},applyControlsToSVG=e=>{e.controls=(...t)=>controls.call(e,e,...t)};
/**
	 * SVG (c) Kraft
	 */
/**
	 * SVG (c) Kraft
	 */
// const findWindowBooleanParam = (...params) => params
//   .filter(arg => typeof arg === S.str_object)
//   .filter(o => typeof o.window === S.str_boolean)
//   .reduce((a, b) => a.window || b.window, false);
var hs={svg:{args:(...e)=>[viewBox$1(coordinates(...e))].filter((e=>null!=e)),methods:gs,init:(e,...t)=>{t.filter((e=>typeof e===wr)).forEach((t=>loadSVG(e,t))),t.filter((e=>null!=e
// .filter(arg => arg instanceof ElementConstructor)
)).filter((e=>typeof e.appendChild===Ar)).forEach((t=>t.appendChild(e))),TouchEvents(e),function(e){
// let fps; // todo: bring this back
let t;const r={};let s,o=0;const removeHandlers=()=>{SVGWindow().cancelAnimationFrame&&SVGWindow().cancelAnimationFrame(s),Object.keys(r).forEach((e=>delete r[e])),t=void 0,o=0};Object.defineProperty(e,"play",{set:e=>{if(removeHandlers(),null==e)return;const n=UUID();r[n]=a=>{t||(t=a,o=0),e({time:.001*(a-t),frame:o}),
// prepare next frame
o+=1,r[n]&&(s=SVGWindow().requestAnimationFrame(r[n]))},
// node.js doesn't have requestAnimationFrame
// we don't need to duplicate this if statement above, because it won't
// ever be called if this one is prevented.
SVGWindow().requestAnimationFrame&&(s=SVGWindow().requestAnimationFrame(r[n]))},enumerable:!0}),Object.defineProperty(e,"stop",{value:removeHandlers,enumerable:!0})}(e),applyControlsToSVG(e)}}};
/**
	 * SVG (c) Kraft
	 */const loadGroup=(e,...t)=>{const r=t.map((e=>sync(e))).filter((e=>void 0!==e));return r.filter((e=>e.tagName===jr)).forEach((t=>moveChildren(e,t))),r.filter((e=>e.tagName!==jr)).forEach((t=>e.appendChild(t))),e};var _s={g:{init:loadGroup,methods:{load:loadGroup}}},bs=Object.assign(Object.create(null),{
// the order of indices matter
svg:[Nr],line:["x1","y1","x2","y2"],rect:["x","y","width","height"],circle:["cx","cy","r"],ellipse:["cx","cy","rx","ry"],polygon:[Vr],polyline:[Vr],path:["d"],text:["x","y"],mask:[Cr],symbol:[Cr],clipPath:[Cr,"clip-rule"],marker:[Cr,"markerHeight","markerUnits","markerWidth","orient","refX","refY"],linearGradient:["x1",// <linearGradient>
"x2",// <linearGradient>
"y1",// <linearGradient>
"y2"],radialGradient:["cx",// <radialGradient>
"cy",// <radialGradient>
"r",// <radialGradient>
"fr",// <radialGradient>
"fx",// <radialGradient>
"fy"],stop:["offset","stop-color","stop-opacity"],pattern:["patternContentUnits",// only <pattern>
"patternTransform",// only <pattern>
"patternUnits"]});
/**
	 * SVG (c) Kraft
	 */
// this object will be completed with all remaining nodeName keys
// with an empty array value
/**
	 * SVG (c) Kraft
	 */
const setRadius=(e,t)=>(e.setAttribute(bs.circle[2],t),e),setOrigin=(e,t,r)=>([...coordinates(...svg_flatten_arrays(t,r)).slice(0,2)].forEach(((t,r)=>e.setAttribute(bs.circle[r],t))),e);
/**
	 * @name circle
	 * @memberof svg
	 * @description Draw an SVG Circle element.
	 * @param {number} radius the radius of the circle
	 * @param {...number|number[]} center the center of the circle
	 * @returns {Element} an SVG node element
	 * @linkcode SVG ./src/nodes/spec/circle.js 28
	 */
var ys={circle:{args:(e,t,r,s)=>{const o=coordinates(...svg_flatten_arrays(e,t,r,s));
// console.log("SVG circle coords", coords);
switch(o.length){case 0:case 1:return[,,...o];case 2:case 3:return o;
// case 4
default:return((e,t,r,s)=>[e,t,svg_distance2([e,t],[r,s])])(...o)}
// return coordinates(...flatten(a, b, c)).slice(0, 3);
},methods:{radius:setRadius,setRadius:setRadius,origin:setOrigin,setOrigin:setOrigin,center:setOrigin,setCenter:setOrigin,position:setOrigin,setPosition:setOrigin}}};
/**
	 * SVG (c) Kraft
	 */
// const setRadii = (el, rx, ry) => [,,rx,ry]
//   .forEach((value, i) => el.setAttribute(attributes.ellipse[i], value));
const setRadii=(e,t,r)=>([,,t,r].forEach(((t,r)=>e.setAttribute(bs.ellipse[r],t))),e),setCenter=(e,t,r)=>([...coordinates(...svg_flatten_arrays(t,r)).slice(0,2)].forEach(((t,r)=>e.setAttribute(bs.ellipse[r],t))),e);var Es={ellipse:{args:(e,t,r,s)=>{const o=coordinates(...svg_flatten_arrays(e,t,r,s)).slice(0,4);switch(o.length){case 0:case 1:case 2:return[,,...o];default:return o}},methods:{radius:setRadii,setRadius:setRadii,origin:setCenter,setOrigin:setCenter,center:setCenter,setCenter:setCenter,position:setCenter,setPosition:setCenter}}};
/**
	 * SVG (c) Kraft
	 */const Args$1=(...e)=>coordinates(...svg_semi_flatten_arrays(...e)).slice(0,4);
/**
	 * @name line
	 * @description SVG Line element
	 * @memberof SVG
	 * @linkcode SVG ./src/nodes/spec/line.js 18
	 */
var xs={line:{args:Args$1,methods:{setPoints:(e,...t)=>(Args$1(...t).forEach(((t,r)=>e.setAttribute(bs.line[r],t))),e)}}};
/**
	 * SVG (c) Kraft
	 */const As={m:"move",l:"line",v:"vertical",h:"horizontal",a:"ellipse",c:"curve",s:"smoothCurve",q:"quadCurve",t:"smoothQuadCurve",z:"close"},add2path=(e,t)=>[e[0]+(t[0]||0),e[1]+(t[1]||0)];
/**
	 * if the command is relative, it will build upon offset coordinate
	 */
// make capitalized copies of each command
Object.keys(As).forEach((e=>{const t=As[e];As[e.toUpperCase()]=t.charAt(0).toUpperCase()+t.slice(1)}
// expectedArguments[key.toUpperCase()] = expectedArguments[key];
));
// const expectedArguments = {
// 	m: 2, l: 2, v: 1, h: 1, a: 7, c: 6, s: 4, q: 4, t: 2, z: 0,
// 	// a can be 14 also
// };
const ks=/[MmLlSsQqLlHhVvCcSsQqTtAaZz]/g,Os=/-?[0-9]*\.?\d+/g,parsePathCommands=e=>{const t=[];let r;for(;null!==(r=ks.exec(e));)t.push(r);return t.map(((t,r,s)=>[t[0],t.index,r===s.length-1?e.length-1:s[(r+1)%s.length].index-1])).map((t=>{const r=t[0],s=e.substring(t[1]+1,t[2]).match(Os);return{command:r,values:s?s.map(parseFloat):[]}}))};var ws=Object.freeze({__proto__:null,pathCommandNames:As,parsePathCommands:parsePathCommands,parsePathCommandsEndpoints:e=>{let t=[0,0];const r=parsePathCommands(e);if(!r.length)return r;r.forEach(((e,s)=>{r[s].end=((e,t,r=[0,0])=>{const s=e.toUpperCase(),o=e===s?[0,0]:r;switch(s){case"M":case"L":case"V":case"H":case"T":return add2path(o,t);case"A":return add2path(o,[t[5],t[6]]);case"C":return add2path(o,[t[4],t[5]]);case"S":case"Q":return add2path(o,[t[2],t[3]]);case"Z":return;// cannot be set locally.
default:return o}})(e.command,e.values,t),r[s].start=0===s?t:r[s-1].end,t=r[s].end}));const s=r[r.length-1],o=r.filter((e=>"M"!==e.command.toUpperCase()&&"Z"!==e.command.toUpperCase())).shift();return"Z"===s.command.toUpperCase()&&(s.end=[...o.start]),r}});
/**
	 * SVG (c) Kraft
	 */
/**
	 * @param {SVGElement} one svg element, intended to be a <path> element
	 * @returns {string} the "d" attribute, or if unset, returns an empty string "".
	 */const getD=e=>{const t=e.getAttribute("d");return null==t?"":t},appendPathCommand=(e,t,...r)=>(e.setAttribute("d",`${getD(e)}${t}${svg_flatten_arrays(...r).join(" ")}`),e),getCommands=e=>parsePathCommands(getD(e))
// const setters = {
//   string: setPathString,
//   object: setPathCommands,
// };
// const appenders = {
//   string: appendPathString,
//   object: appendPathCommands,
// };
// depending on the user's argument, different setters will get called
// const noClearSet = (element, ...args) => {
//   if (args.length === 1) {
//     const typ = typeof args[0];
//     if (setters[typ]) {
//       setters[typ](element, args[0]);
//     }
//   }
// };
// const clearAndSet = (element, ...args) => {
//   if (args.length === 1) {
//     const typ = typeof args[0];
//     if (setters[typ]) {
//       clear(element);
//       setters[typ](element, args[0]);
//     }
//   }
// };
,Ms={addCommand:appendPathCommand,appendCommand:appendPathCommand,clear:e=>(e.removeAttribute("d"),e),getCommands:getCommands,get:getCommands,getD:e=>e.getAttribute("d")
// set: clearAndSet,
// add: noClearSet,
};Object.keys(As).forEach((e=>{Ms[As[e]]=(t,...r)=>appendPathCommand(t,e,...r)}));var js={path:{methods:Ms}};
/**
	 * SVG (c) Kraft
	 */const setRectSize=(e,t,r)=>([,,t,r].forEach(((t,r)=>e.setAttribute(bs.rect[r],t))),e),setRectOrigin=(e,t,r)=>([...coordinates(...svg_flatten_arrays(t,r)).slice(0,2)].forEach(((t,r)=>e.setAttribute(bs.rect[r],t))),e),fixNegatives=function(e){return[0,1].forEach((t=>{e[2+t]<0&&(void 0===e[0+t]&&(e[0+t]=0),e[0+t]+=e[2+t],e[2+t]=-e[2+t])})),e};
/**
	 * @name rect
	 * @memberof svg
	 * @description Draw an SVG Rect element.
	 * @param {number} x the x coordinate of the corner
	 * @param {number} y the y coordinate of the corner
	 * @param {number} width the length along the x dimension
	 * @param {number} height the length along the y dimension
	 * @returns {Element} an SVG node element
	 * @linkcode SVG ./src/nodes/spec/rect.js 40
	 */
var Fs={rect:{args:(e,t,r,s)=>{const o=coordinates(...svg_flatten_arrays(e,t,r,s)).slice(0,4);switch(o.length){case 0:case 1:case 2:case 3:return fixNegatives([,,...o]);default:return fixNegatives(o)}},methods:{origin:setRectOrigin,setOrigin:setRectOrigin,center:setRectOrigin,setCenter:setRectOrigin,size:setRectSize,setSize:setRectSize}}},Cs={style:{init:(e,t)=>{e.textContent="",e.appendChild(cdata(t))},methods:{setTextContent:(e,t)=>(e.textContent="",e.appendChild(cdata(t)),e)}}},Ps={text:{
// assuming people will at most supply coordinate (x,y,z) and text
args:(e,t,r)=>coordinates(...svg_flatten_arrays(e,t,r)).slice(0,2),init:(e,t,r,s,o)=>{const n=[t,r,s,o].filter((e=>typeof e===wr)).shift();n&&e.appendChild(SVGWindow().document.createTextNode(n))}}};
/**
	 * SVG (c) Kraft
	 */
/**
	 * SVG (c) Kraft
	 */
const makeIDString=function(){return Array.from(arguments).filter((e=>typeof e===wr||e instanceof String)).shift()||UUID()},maskArgs=(...e)=>[makeIDString(...e)];var Ns={mask:{args:maskArgs},clipPath:{args:maskArgs},symbol:{args:maskArgs},marker:{args:maskArgs,methods:{size:setViewBox,setViewBox:setViewBox}}};
/**
	 * SVG (c) Kraft
	 */const getPoints=e=>{const t=e.getAttribute(Vr);return null==t?"":t},polyString=function(){return Array.from(Array(Math.floor(arguments.length/2))).map(((e,t)=>`${arguments[2*t+0]},${arguments[2*t+1]}`)).join(" ")},stringifyArgs=(...e)=>[polyString(...coordinates(...svg_semi_flatten_arrays(...e)))],setPoints=(e,...t)=>(e.setAttribute(Vr,stringifyArgs(...t)[0]),e),addPoint=(e,...t)=>(e.setAttribute(Vr,[getPoints(e),stringifyArgs(...t)[0]].filter((e=>""!==e)).join(" ")),e),Args=function(...e){return 1===e.length&&typeof e[0]===wr?[e[0]]:stringifyArgs(...e)};var Ss={polyline:{args:Args,methods:{setPoints:setPoints,addPoint:addPoint}},polygon:{args:Args,methods:{setPoints:setPoints,addPoint:addPoint}}},Vs=Object.assign({},hs,_s,ys,Es,xs,js,Fs,Cs,Ps,
// multiple
Ns,Ss),$s={presentation:["color","color-interpolation","cursor",// mouse cursor
"direction",// rtl right to left
"display",// none, inherit
"fill","fill-opacity","fill-rule","font-family","font-size","font-size-adjust","font-stretch","font-style","font-variant","font-weight","image-rendering",// provides a hint to the browser about how to make speed vs. quality tradeoffs as it performs image processing
"letter-spacing","opacity","overflow","paint-order","pointer-events","preserveAspectRatio","shape-rendering","stroke","stroke-dasharray","stroke-dashoffset","stroke-linecap","stroke-linejoin","stroke-miterlimit","stroke-opacity","stroke-width","tabindex","transform-origin",// added by Robby
"user-select",// added by Robby
"vector-effect","visibility"],animation:["accumulate",// controls whether or not an animation is cumulative
"additive",// controls whether or not an animation is additive
"attributeName",// used by: <animate>, <animateColor>, <animateTransform>, and <set>
"begin","by","calcMode","dur","end","from","keyPoints",// used by: <animate>, <animateColor>, <animateMotion>, <animateTransform>, and <set>
"keySplines","keyTimes","max","min","repeatCount","repeatDur","restart","to",// final value of the attribute that will be modified during the animation
"values"],effects:["azimuth",// only used by: <feDistantLight>
"baseFrequency","bias","color-interpolation-filters","diffuseConstant","divisor","edgeMode","elevation","exponent","filter","filterRes","filterUnits","flood-color","flood-opacity","in",// identifies input for the given filter primitive.
"in2",// identifies the second input for the given filter primitive.
"intercept",// defines the intercept of the linear function of color component transfers
"k1",// only used by: <feComposite>
"k2",// only used by: <feComposite>
"k3",// only used by: <feComposite>
"k4",// only used by: <feComposite>
"kernelMatrix",// only used by: <feConvolveMatrix>
"lighting-color","limitingConeAngle","mode","numOctaves","operator","order","pointsAtX","pointsAtY","pointsAtZ","preserveAlpha","primitiveUnits","radius","result","seed","specularConstant","specularExponent","stdDeviation","stitchTiles","surfaceScale","targetX",// only used in: <feConvolveMatrix>
"targetY",// only used in: <feConvolveMatrix>
"type",// many different uses, in animate, and <style> <script>
"xChannelSelector",// <feDisplacementMap>
"yChannelSelector"],text:[
// "x",   // <text>
// "y",   // <text>
"dx",// <text>
"dy",// <text>
"alignment-baseline",// specifies how a text alignts vertically
"baseline-shift","dominant-baseline","lengthAdjust",// <text>
"method",// for <textPath> only
"overline-position","overline-thickness","rotate",// rotates each individual glyph
"spacing","startOffset",// <textPath>
"strikethrough-position","strikethrough-thickness","text-anchor","text-decoration","text-rendering","textLength",// <text>
"underline-position","underline-thickness","word-spacing","writing-mode"],gradient:["gradientTransform",// linear/radial gradient
"gradientUnits",// linear/radial gradient
"spreadMethod"]};
/**
	 * SVG (c) Kraft
	 */
/**
	 * in each of these instances, arguments maps the arguments to attributes
	 * as the attributes are listed in the "attributes" folder.
	 *
	 * arguments: function. this should convert the array of arguments into
	 * an array of (processed) arguments. 1:1. arguments into arguments.
	 * make sure it is returning an array.
	 *
	 */
/**
	 * SVG (c) Kraft
	 */
Object.values(Gr).reduce(((e,t)=>e.concat(t)),[]).filter((e=>void 0===bs[e])).forEach((e=>{bs[e]=[]})),[[[jr,"defs","g"].concat(Gr.v,Gr.t),$s.presentation],[["filter"],$s.effects],[Gr.cT.concat("text"),$s.text],// todo: should we include "svg" here?
[Gr.cF,$s.effects],[Gr.cG,$s.gradient]].forEach((e=>e[0].forEach((t=>{bs[t]=bs[t].concat(e[1])}))));
/**
	 * SVG (c) Kraft
	 */
const getClassList=e=>{if(null==e)return[];const t=e.getAttribute(xr);return null==t?[]:t.split(" ").filter((e=>""!==e))};var zs={addClass:(e,t)=>{const r=getClassList(e).filter((e=>e!==t));r.push(t),e.setAttributeNS(null,xr,r.join(" "))},removeClass:(e,t)=>{const r=getClassList(e).filter((e=>e!==t));e.setAttributeNS(null,xr,r.join(" "))},setClass:(e,t)=>{e.setAttributeNS(null,xr,t)},setId:(e,t)=>{e.setAttributeNS(null,Cr,t)}};
/**
	 * SVG (c) Kraft
	 */const getAttr=e=>{const t=e.getAttribute(Sr);return null==t||""===t?void 0:t},Ts={clearTransform:e=>(e.removeAttribute(Sr),e)};["translate","rotate","scale","matrix"].forEach((e=>{Ts[e]=(t,...r)=>t.setAttribute(Sr,[getAttr(t),`${e}(${r.join(" ")})`].filter((e=>void 0!==e)).join(" "))}));
/**
	 * SVG (c) Kraft
	 */
// for the clip-path and mask values. looks for the ID as a "url(#id-name)" string
const Ls={};
// these do not represent the nodes that these methods are applied to
// every node gets these attribute-setting method (pointing to a mask)
["clip-path","mask","symbol","marker-end","marker-mid","marker-start"].forEach((e=>{Ls[Kr.toCamel(e)]=(t,r)=>t.setAttribute(e,function(e){if(null==e)return"";if(typeof e===wr)return"url"===e.slice(0,3)?e:`url(#${e})`;if(null!=e.getAttribute)return`url(#${e.getAttribute(Cr)})`;return""}(r))}));
/**
	 * SVG (c) Kraft
	 */
const Bs={};
// assuming custom nodes are drawing-type, make them known to the library
Gr.v.push(...Object.keys(os)),
// assuming custom nodes are drawing-type, append presentation attributes
Object.keys(os).forEach((e=>{os[e].attributes=void 0===os[e].attributes?[...$s.presentation]:os[e].attributes.concat($s.presentation)})),
// incorporate custom nodes as if they are drawing primitives.
// Object.assign(Nodes, Spec);//, CustomNodes);
Object.assign(Bs,Vs,os),
// in most cases the key === value. "line": "line"
// except custom shapes: "regularPolygon": "polygon"
Object.keys(Gr).forEach((e=>Gr[e].filter((e=>void 0===Bs[e])).forEach((e=>{Bs[e]={}}))));const passthrough=function(){return Array.from(arguments)};
// complete the lookup table. empty entries where nothing existed
Object.keys(Bs).forEach((e=>{Bs[e].nodeName||(Bs[e].nodeName=e),Bs[e].init||(Bs[e].init=passthrough),Bs[e].args||(Bs[e].args=passthrough),Bs[e].methods||(Bs[e].methods={}),Bs[e].attributes||(Bs[e].attributes=bs[e]||[])}));const assignMethods=(e,t)=>{e.forEach((e=>Object.keys(t).forEach((r=>{Bs[e].methods[r]=function(){return t[r](...arguments),arguments[0]}}))))};assignMethods(svg_flatten_arrays(Gr.t,Gr.v,Gr.g,Gr.s,Gr.p,Gr.i,Gr.h,Gr.d),zs),assignMethods(svg_flatten_arrays(Gr.t,Gr.v,Gr.g,Gr.s,Gr.p,Gr.i,Gr.h,Gr.d),fs),assignMethods(svg_flatten_arrays(Gr.v,Gr.g,Gr.s),Ts),assignMethods(svg_flatten_arrays(Gr.t,Gr.v,Gr.g),Ls);
/**
	 * SVG (c) Kraft
	 */
const Is={svg:{version:"1.1",xmlns:qr},style:{type:"text/css"}},Rs={},constructor=(e,t,...r)=>{const s=SVGWindow().document.createElementNS(qr,Bs[e].nodeName);return t&&t.appendChild(s),((e,t)=>{Is[t]&&Object.keys(Is[t]).forEach((r=>e.setAttribute(r,Is[t][r])))})(s,e),Bs[e].init(s,...r),Bs[e].args(...r).forEach(((t,r)=>{null!=Bs[e].attributes[r]&&s.setAttribute(Bs[e].attributes[r],t)})),
// camelCase functional style attribute setters, like .stroke() .strokeWidth()
Bs[e].attributes.forEach((e=>{Object.defineProperty(s,Kr.toCamel(e),{value:function(){return s.setAttribute(e,...arguments),s}})})),
// custom methods from each primitive's definition
Object.keys(Bs[e].methods).forEach((t=>Object.defineProperty(s,t,{value:function(){
// all custom methods are attached to the node.
// if there is no return value specified,
// the method will return the element itself
// to encourage method-chaining design.
// nevermind.
// things need to be able to return undefined
return Bs[e].methods[t].call(Rs,s,...arguments);
// || element;
}}))),
// a method to create a child and automatically append it to this node
ls[e]&&ls[e].forEach((e=>{const value=function(){return constructor(e,s,...arguments)};
// static methods have to be created in runtime,
// after the object has been initialized.
Bs[e].static&&Object.keys(Bs[e].static).forEach((t=>{value[t]=function(){return Bs[e].static[t](s,...arguments)}})),Object.defineProperty(s,e,{value:value})})),s};
// required attributes for elements like <svg>, <style>
Rs.Constructor=constructor;
/**
	 * SVG (c) Kraft
	 */
const Us={};Object.keys(Gr).forEach((e=>Gr[e].forEach((e=>{Us[e]=(...t)=>constructor(e,null,...t)}))));
/**
	 * SVG (c) Kraft
	 */
/**
	 * The purpose of this section is to implant this library to become
	 * one small part of a larger library. This requires knowing about
	 * the larger library, for now, the linking is hard-coded to Rabbit Ear.
	 */
const link_rabbitear_math=(e,t)=>{
// give all primitives a .svg() method that turns them into a <path>
// ignoring primitives: "vector", "line", "ray", "matrix", "plane"
["segment","circle","ellipse","rect","polygon"].filter((e=>t[e]&&t[e].prototype)).forEach((r=>{t[r].prototype.svg=function(){return e.path(this.svgPath())}})),
// bind the other way. allow SVG library to return vector() objects,
// as in the onMove function, the location of the pointer.
t.vector},initialize=function(e,...t){t.filter((e=>typeof e===Ar)).forEach((t=>t.call(e,e)))};
// create a new svg element "origami", which is really a <svg>
Er.init=function(){const e=constructor(jr,null,...arguments);
// call initialize as soon as possible. check if page has loaded
return"loading"===SVGWindow().document.readyState?SVGWindow().document.addEventListener("DOMContentLoaded",(()=>initialize(e,...arguments))):initialize(e,...arguments),e},
// const SVG = function () {
// 	const svg = Constructor(S.str_svg, null, ...arguments);
// 	// call initialize as soon as possible. check if page has loaded
// 	if (window().document.readyState === "loading") {
// 		window().document.addEventListener("DOMContentLoaded", () => initialize(svg, ...arguments));
// 	} else {
// 		initialize(svg, ...arguments);
// 	}
// 	return svg;
// };
SVG.NS=qr,SVG.linker=function(e){
// is the library a familiar library?
// Rabbit Ear?
// todo: what is the best way to uniquely identify Rabbit Ear.
e.graph&&e.origami&&(e.svg=this,link_rabbitear_math(this,e),((e,t)=>{
// register this node name as a drawable element with the library.
const r="origami";
// actual drawing methods are contained in Rabbit Ear under "ear.graph.svg"
Bs[r]={nodeName:"g",init:function(e,...r){return t.graph.svg.drawInto(e,...r)},args:()=>[],methods:Bs.g.methods,attributes:Bs.g.attributes,static:{}},Object.keys(t.graph.svg).forEach((e=>{Bs[r].static[e]=(r,...s)=>{const o=t.graph.svg[e](...s);return r.appendChild(o),o}})),
// give "origami" the ability to act like a <svg> and create children, like <line>
ls[r]=[...ls.g],
// <svg> and <g> can call .origami() and it is appended as a child
ls.svg.push(r),ls.g.push(r),
// this sets a constructor as a child of the library itself: ear.svg.origami()
// as well as the static methods: ear.svg.origami.edges() / faces()...
// 'boundaries', 'faces', 'edges', 'vertices', 'drawInto', 'getViewBox'
e[r]=(...e)=>constructor(r,null,...e),Object.keys(t.graph.svg).forEach((s=>{e[r][s]=t.graph.svg[s]}))})(this,e))}.bind(SVG),
// SVG.use = use.bind(SVG);
Object.assign(SVG,Us),SVG.core=Object.assign(Object.create(null),{load:Load,save:save,coordinates:coordinates,flatten:svg_flatten_arrays,attributes:bs,children:ls,cdata:cdata},Kr,zs,fs,Wr,ws,Ts,ds),
// the window object, from which the document is used to createElement.
// when using Node.js, this must be set to to the
// default export of the library @xmldom/xmldom
Object.defineProperty(SVG,"window",{enumerable:!1,set:e=>{var t;
// make sure window has a document. xmldom does not, and requires it be built.
(t=e).document||(t.document=(e=>(new e.DOMParser).parseFromString("<!DOCTYPE html><title>.</title>","text/html"))(t)),Dr.window=t,Dr.window}});
/**
	 * Rabbit Ear (c) Kraft
	 */
// WebGL boilerplate from https://webglfundamentals.org
/**
	 * @description Creates and compiles a shader.
	 * @param {!WebGLRenderingContext} gl The WebGL Context.
	 * @param {string} shaderSource The GLSL source code for the shader.
	 * @param {number} shaderType The type of shader, VERTEX_SHADER or
	 *     FRAGMENT_SHADER.
	 * @returns {!WebGLShader} The shader.
	 */
const compileShader=(e,t,r)=>{const s=e.createShader(r);if(e.shaderSource(s,t),e.compileShader(s),!e.getShaderParameter(s,e.COMPILE_STATUS))throw new Error(e.getShaderInfoLog(s));return s},createProgram=(e,t,r)=>((e,t,r)=>{const s=e.createProgram();if(e.attachShader(s,t),e.attachShader(s,r),e.linkProgram(s),!e.getProgramParameter(s,e.LINK_STATUS))
// something went wrong with the link
throw new Error(e.getProgramInfoLog(s));return e.deleteShader(t),e.deleteShader(r),s})(e,compileShader(e,t,e.VERTEX_SHADER),compileShader(e,r,e.FRAGMENT_SHADER));
/**
	 * @description Creates a program from 2 shaders.
	 * @param {!WebGLRenderingContext) gl The WebGL context.
	 * @param {!WebGLShader} vertexShader A vertex shader.
	 * @param {!WebGLShader} fragmentShader A fragment shader.
	 * @returns {!WebGLProgram} A program.
	 */var Ds=Object.freeze({__proto__:null,rebuildViewport:(e,t)=>{if(!e)return;const r=window.devicePixelRatio||1,s=[t.clientWidth,t.clientHeight].map((e=>e*r));t.width===s[0]&&t.height===s[1]||(t.width=s[0],t.height=s[1]),e.viewport(0,0,e.canvas.width,e.canvas.height)},makeProjectionMatrix:(e,t="perspective",r=45)=>{if(!e)return yt;const s=[e.clientWidth,e.clientHeight],o=Math.min(...s),n=[0,1].map((e=>(s[e]-o)/o/2)).map((e=>e+.5));return"orthographic"===t?makeOrthographicMatrix4(n[1],n[0],-n[1],-n[0],-100,100):makePerspectiveMatrix4(r*(Math.PI/180),s[0]/s[1],.1,20)},makeModelMatrix:e=>{if(!e)return yt;const t=boundingBox(e);if(!t)return yt;const r=Math.max(...t.span),s=[r,0,0,0,0,r,0,0,0,0,r,0,...resize(3,midpoint(t.min,t.max)),1];// * Math.SQRT2;
return invertMatrix4(s)}});
/**
	 * Rabbit Ear (c) Kraft
	 */
// the uniform is an object and the object should be structured like this:
// {
// 	u_modelView: {
// 		func: "uniformMatrix4fv",
// 		value: [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],
// 	},
// 	u_opacity: {
// 		func: "uniform1f",
// 		value: opacity,
// 	},
// }
const uniformFunc=(e,t,r,s)=>{if("uniformMatrix4fv"===r)e[r](t,!1,s);else e[r](t,s)};
/**
	 * @param {object} gl a link to the WebGL instance
	 * @param {number} version 1 or 2, which WebGL version.
	 * @param {object} bundle the result of calling CreasePattern() FoldedForm()...
	 * @param {object} uniforms the result of calling makeUniforms()
	 */var qs=Object.freeze({__proto__:null,drawProgram:(e,t,r,s={})=>{e.useProgram(r.program),r.flags.forEach((t=>e.enable(t)));
// set uniforms
const o=e.getProgramParameter(r.program,e.ACTIVE_UNIFORMS);for(let t=0;t<o;t+=1){const o=e.getActiveUniform(r.program,t).name,n=s[o];if(n){const t=e.getUniformLocation(r.program,o);uniformFunc(e,t,n.func,n.value)}}
// set vertex arrays
r.vertexArrays.forEach((t=>{e.bindBuffer(e.ARRAY_BUFFER,t.buffer),e.bufferData(e.ARRAY_BUFFER,t.data,e.STATIC_DRAW),e.vertexAttribPointer(t.location,t.length,t.type,!1,0,0),e.enableVertexAttribArray(t.location)})),
// gl.linkProgram(bundle.program);
// draw elements
// WebGL 2 supports UNSIGNED_INT (Uint32Array)
// WebGL 1 cannot and must use UNSIGNED_SHORT (Uint16Array)
r.elementArrays.forEach((r=>{e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,r.buffer),e.bufferData(e.ELEMENT_ARRAY_BUFFER,r.data,e.STATIC_DRAW),e.drawElements(r.mode,// GL.TRIANGLES for example
r.data.length,2===t?e.UNSIGNED_INT:e.UNSIGNED_SHORT,r.buffer)})),r.flags.forEach((t=>e.disable(t)))},deallocProgram:(e,t)=>{t.vertexArrays.forEach((t=>e.disableVertexAttribArray(t.location))),t.vertexArrays.forEach((t=>e.deleteBuffer(t.buffer))),t.elementArrays.forEach((t=>e.deleteBuffer(t.buffer))),e.deleteProgram(t.program)}
// gl.deleteTexture(someTexture);
// gl.deleteRenderbuffer(someRenderbuffer);
// gl.deleteFramebuffer(someFramebuffer);
});
/**
	 * Rabbit Ear (c) Kraft
	 */const makeFacesVertexData=(e,t={})=>{const r=e.vertices_coords.map((e=>[...e].concat(Array(3-e.length).fill(0)))),s=makeVerticesNormal(e),o=r.map(((e,t)=>t%3)).map((e=>[0===e?1:0,1===e?1:0,2===e?1:0])),n=e.faces_edges.map((t=>t.map((t=>e.edges_assignment[t])).map((e=>"J"===e||"j"===e))));if(!t.showTrianglulation)for(let e=0;e<n.length;e+=1)n[e][0]&&(o[3*e+0][2]=o[3*e+1][2]=100),n[e][1]&&(o[3*e+1][0]=o[3*e+2][0]=100),n[e][2]&&(o[3*e+0][1]=o[3*e+2][1]=100);return{vertices_coords:r,vertices_normal:s,vertices_barycentric:o}},Gs={B:[.3,.3,.3],b:[.3,.3,.3],V:[.2,.4,.6],v:[.2,.4,.6],M:[.75,.25,.15],m:[.75,.25,.15],F:[.2,.2,.2],f:[.2,.2,.2],C:[1,.75,.25],c:[1,.75,.25],U:[.2,.2,.2],u:[.2,.2,.2]},makeThickEdgesVertexData=(e,t=Gs)=>{if(!e||!e.vertices_coords||!e.edges_vertices)return[];const r=e.vertices_coords.map((e=>[...e].concat(Array(3-e.length).fill(0)))),s=e.edges_vertices.flatMap((e=>e.map((e=>r[e])))).flatMap((e=>[e,e,e,e])),o=makeEdgesVector(e);return{vertices_coords:s,vertices_color:e.edges_assignment?e.edges_assignment.flatMap((e=>Array(8).fill(t[e]))):e.edges_vertices.flatMap((()=>Array(8).fill(t.U))),verticesEdgesVector:o.flatMap((e=>[e,e,e,e,e,e,e,e])),vertices_vector:e.edges_vertices.flatMap((()=>[[1,0],[0,1],[-1,0],[0,-1],[1,0],[0,1],[-1,0],[0,-1]]))}};
// thick edges
var Ws=Object.freeze({__proto__:null,makeFacesVertexData:makeFacesVertexData,makeThickEdgesVertexData:makeThickEdgesVertexData});
/**
	 * Rabbit Ear (c) Kraft
	 */const makeFoldedVertexArrays=(e,t,r,s={})=>{if(!r||!r.vertices_coords||!r.faces_vertices)return[];const{vertices_coords:o,vertices_normal:n,vertices_barycentric:a}=makeFacesVertexData(r,s);return[{location:e.getAttribLocation(t,"v_position"),buffer:e.createBuffer(),type:e.FLOAT,length:o[0].length,data:new Float32Array(o.flat())},{location:e.getAttribLocation(t,"v_normal"),buffer:e.createBuffer(),type:e.FLOAT,length:n[0].length,data:new Float32Array(n.flat())},{location:e.getAttribLocation(t,"v_barycentric"),buffer:e.createBuffer(),type:e.FLOAT,length:3,data:new Float32Array(a.flat())}].filter((e=>-1!==e.location))},makeFoldedElementArrays=(e,t=1,r={})=>r&&r.vertices_coords&&r.faces_vertices?[{mode:e.TRIANGLES,buffer:e.createBuffer(),data:2===t?new Uint32Array(r.faces_vertices.flat()):new Uint16Array(r.faces_vertices.flat())}]:[],makeThickEdgesVertexArrays=(e,t,r,s={})=>{if(!r||!r.vertices_coords||!r.edges_vertices)return[];const{vertices_coords:o,vertices_color:n,verticesEdgesVector:a,vertices_vector:c}=makeThickEdgesVertexData(r,s.assignment_color);return[{location:e.getAttribLocation(t,"v_position"),buffer:e.createBuffer(),type:e.FLOAT,length:o[0].length,data:new Float32Array(o.flat())},{location:e.getAttribLocation(t,"v_color"),buffer:e.createBuffer(),type:e.FLOAT,length:n[0].length,data:new Float32Array(n.flat())},{location:e.getAttribLocation(t,"edge_vector"),buffer:e.createBuffer(),type:e.FLOAT,length:a[0].length,data:new Float32Array(a.flat())},{location:e.getAttribLocation(t,"vertex_vector"),buffer:e.createBuffer(),type:e.FLOAT,length:c[0].length,data:new Float32Array(c.flat())}].filter((e=>-1!==e.location))},makeThickEdgesElementArrays=(e,t=1,r={})=>{if(!r||!r.edges_vertices)return[];const s=r.edges_vertices.map(((e,t)=>8*t)).flatMap((e=>[e+0,e+1,e+4,e+4,e+1,e+5,e+1,e+2,e+5,e+5,e+2,e+6,e+2,e+3,e+6,e+6,e+3,e+7,e+3,e+0,e+7,e+7,e+0,e+4]));return[{mode:e.TRIANGLES,buffer:e.createBuffer(),data:2===t?new Uint32Array(s):new Uint16Array(s)}]};
/**
	 * WebGL 2 can handle Uint32Array. WebGL 1 cannot and must use 16 bit.
	 */var Hs=Object.freeze({__proto__:null,makeFoldedVertexArrays:makeFoldedVertexArrays,makeFoldedElementArrays:makeFoldedElementArrays,makeThickEdgesVertexArrays:makeThickEdgesVertexArrays,makeThickEdgesElementArrays:makeThickEdgesElementArrays});
/**
	 * Rabbit Ear (c) Kraft
	 */
// const LAYER_NUDGE = 1e-4;
const makeExplodedGraph=(e,t=1e-5)=>{const r=JSON.parse(JSON.stringify(e));
// we render "J" joined edges differently from all others. if edges_assignment
// doesn't exist, make it with all assignments set to "U".
// the user will never see this data, it's just for visualization.
if(!r.edges_assignment){const t=count.edges(e)||countImplied.edges(e);r.edges_assignment=Array(t).fill("U")}let s=[];r.faceOrders?s=nudgeFacesWithFaceOrders(r):r.faces_layer&&(s=nudgeFacesWithFacesLayer(r));
// triangulate will modify faces and edges.
// use face information to match data.
const o=triangulate(r);
// explode will modify edges and vertices.
// we don't need the return information for anything just yet.
// Object.assign(change, change2);
if(explode(r),o.faces){invertMap(o.faces.map).forEach(((e,o)=>{const n=s[e];n&&r.faces_vertices[o].forEach((e=>{const s=scale(n.vector,n.layer*t);r.vertices_coords[e]=add(resize(3,r.vertices_coords[e]),s)}))}))}return r},makeUniforms$1=(e,{projectionMatrix:t,viewMatrix:r,modelMatrix:s,canvas:o,opacity:n,touchPoint:a,frontColor:c,backColor:i,strokeWidth:l})=>({u_matrix:{func:"uniformMatrix4fv",value:multiplyMatrices4(multiplyMatrices4(t,r),s)},u_projection:{func:"uniformMatrix4fv",value:t},u_modelView:{func:"uniformMatrix4fv",value:multiplyMatrices4(r,s)},u_opacity:{func:"uniform1f",value:n},u_touch:{func:"uniform2fv",value:a},u_resolution:{func:"uniform2fv",value:[o.clientWidth,o.clientHeight].map((e=>e*window.devicePixelRatio||1))},u_frontColor:{func:"uniform3fv",value:hexToRGB(c)},u_backColor:{func:"uniform3fv",value:hexToRGB(i)},u_strokeWidth:{func:"uniform1f",value:l}}),foldedFormFaces=(e,t=1,r={},s={})=>{const o=makeExplodedGraph(r,s.layerNudge),n=1===t?createProgram(e,"#version 100\nattribute vec3 v_position;\nattribute vec3 v_normal;\nuniform mat4 u_projection;\nuniform mat4 u_modelView;\nuniform mat4 u_matrix;\nuniform vec3 u_frontColor;\nuniform vec3 u_backColor;\nvarying vec3 normal_color;\nvarying vec3 front_color;\nvarying vec3 back_color;\nvoid main () {\n\tgl_Position = u_matrix * vec4(v_position, 1);\n\tvec3 light = abs(normalize((vec4(v_normal, 1) * u_modelView).xyz));\n\tfloat brightness = 0.5 + light.x * 0.15 + light.z * 0.35;\n\tfront_color = u_frontColor * brightness;\n\tback_color = u_backColor * brightness;\n}\n","#version 100\nprecision mediump float;\nuniform float u_opacity;\nvarying vec3 front_color;\nvarying vec3 back_color;\nvoid main () {\n\tvec3 color = gl_FrontFacing ? front_color : back_color;\n\tgl_FragColor = vec4(color, u_opacity);\n}\n"):createProgram(e,"#version 300 es\nuniform mat4 u_modelView;\nuniform mat4 u_matrix;\nuniform vec3 u_frontColor;\nuniform vec3 u_backColor;\nin vec3 v_position;\nin vec3 v_normal;\nout vec3 front_color;\nout vec3 back_color;\nvoid main () {\n\tgl_Position = u_matrix * vec4(v_position, 1);\n\tvec3 light = abs(normalize((vec4(v_normal, 1) * u_modelView).xyz));\n\tfloat brightness = 0.5 + light.x * 0.15 + light.z * 0.35;\n\tfront_color = u_frontColor * brightness;\n\tback_color = u_backColor * brightness;\n}\n","#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\nuniform float u_opacity;\nin vec3 front_color;\nin vec3 back_color;\nout vec4 outColor;\nvoid main () {\n\tgl_FragDepth = gl_FragCoord.z;\n\tvec3 color = gl_FrontFacing ? front_color : back_color;\n\toutColor = vec4(color, u_opacity);\n}\n");return{program:n,vertexArrays:makeFoldedVertexArrays(e,n,o,s),elementArrays:makeFoldedElementArrays(e,t,o),flags:[e.DEPTH_TEST],makeUniforms:makeUniforms$1}},foldedFormEdges=(e,t=1,r={},s={})=>{const o=1===t?createProgram(e,"#version 100\nattribute vec3 v_position;\nattribute vec3 v_color;\nattribute vec3 edge_vector;\nattribute vec2 vertex_vector;\nuniform mat4 u_matrix;\nuniform mat4 u_projection;\nuniform mat4 u_modelView;\nuniform float u_strokeWidth;\nvarying vec3 blend_color;\nvoid main () {\n\tvec3 edge_norm = normalize(edge_vector);\n\t// axis most dissimilar to edge_vector\n\tvec3 absNorm = abs(edge_norm);\n\tvec3 xory = absNorm.x < absNorm.y ? vec3(1,0,0) : vec3(0,1,0);\n\tvec3 axis = absNorm.x > absNorm.z && absNorm.y > absNorm.z ? vec3(0,0,1) : xory;\n\t// two perpendiculars. with edge_vector these make basis vectors\n\tvec3 one = cross(axis, edge_norm);\n\tvec3 two = cross(one, edge_norm);\n\tvec3 displaceNormal = normalize(\n\t\tone * vertex_vector.x + two * vertex_vector.y\n\t);\n\tvec3 displace = displaceNormal * u_strokeWidth;\n\tgl_Position = u_matrix * vec4(v_position + displace, 1);\n\tblend_color = v_color;\n}\n","#version 100\nprecision mediump float;\nvarying vec3 blend_color;\nvoid main () {\n\tgl_FragColor = vec4(blend_color.rgb, 1);\n}\n"):createProgram(e,"#version 300 es\nuniform mat4 u_matrix;\nuniform mat4 u_projection;\nuniform mat4 u_modelView;\nuniform float u_strokeWidth;\nin vec3 v_position;\nin vec3 v_color;\nin vec3 edge_vector;\nin vec2 vertex_vector;\nout vec3 blend_color;\nvoid main () {\n\tvec3 edge_norm = normalize(edge_vector);\n\t// axis most dissimilar to edge_vector\n\tvec3 absNorm = abs(edge_norm);\n\tvec3 xory = absNorm.x < absNorm.y ? vec3(1,0,0) : vec3(0,1,0);\n\tvec3 axis = absNorm.x > absNorm.z && absNorm.y > absNorm.z ? vec3(0,0,1) : xory;\n\t// two perpendiculars. with edge_vector these make basis vectors\n\tvec3 one = cross(axis, edge_norm);\n\tvec3 two = cross(one, edge_norm);\n\tvec3 displaceNormal = normalize(\n\t\tone * vertex_vector.x + two * vertex_vector.y\n\t);\n\tvec3 displace = displaceNormal * u_strokeWidth;\n\tgl_Position = u_matrix * vec4(v_position + displace, 1);\n\tblend_color = v_color;\n}\n","#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\nin vec3 blend_color;\nout vec4 outColor;\n \nvoid main() {\n\toutColor = vec4(blend_color.rgb, 1);\n}\n");return{program:o,vertexArrays:makeThickEdgesVertexArrays(e,o,r,s),elementArrays:makeThickEdgesElementArrays(e,t,r),flags:[e.DEPTH_TEST],makeUniforms:makeUniforms$1}},foldedFormFacesOutlined=(e,t=1,r={},s={})=>{const o=makeExplodedGraph(r,s.layerNudge),n=1===t?createProgram(e,"#version 100\nattribute vec3 v_position;\nattribute vec3 v_normal;\nattribute vec3 v_barycentric;\nuniform mat4 u_projection;\nuniform mat4 u_modelView;\nuniform mat4 u_matrix;\nuniform vec3 u_frontColor;\nuniform vec3 u_backColor;\nvarying vec3 normal_color;\nvarying vec3 barycentric;\nvarying vec3 front_color;\nvarying vec3 back_color;\nvoid main () {\n\tgl_Position = u_matrix * vec4(v_position, 1);\n\tbarycentric = v_barycentric;\n\tvec3 light = abs(normalize((vec4(v_normal, 1) * u_modelView).xyz));\n\tfloat brightness = 0.5 + light.x * 0.15 + light.z * 0.35;\n\tfront_color = u_frontColor * brightness;\n\tback_color = u_backColor * brightness;\n}\n","#version 100\nprecision mediump float;\nuniform float u_opacity;\nvarying vec3 barycentric;\nvarying vec3 front_color;\nvarying vec3 back_color;\nvoid main () {\n\tvec3 color = gl_FrontFacing ? front_color : back_color;\n\tvec3 boundary = vec3(0.0, 0.0, 0.0)\n\t// gl_FragDepth = 0.5;\n\tgl_FragColor = any(lessThan(barycentric, vec3(0.02)))\n\t\t? vec4(boundary, u_opacity)\n\t\t: vec4(color, u_opacity);\n}\n"):createProgram(e,"#version 300 es\nuniform mat4 u_modelView;\nuniform mat4 u_matrix;\nuniform vec3 u_frontColor;\nuniform vec3 u_backColor;\nin vec3 v_position;\nin vec3 v_normal;\nin vec3 v_barycentric;\nin float v_rawEdge;\nout vec3 front_color;\nout vec3 back_color;\nout vec3 barycentric;\n// flat out int rawEdge;\nflat out int provokedVertex;\nvoid main () {\n\tgl_Position = u_matrix * vec4(v_position, 1);\n\tprovokedVertex = gl_VertexID;\n\tbarycentric = v_barycentric;\n\t// rawEdge = int(v_rawEdge);\n\tvec3 light = abs(normalize((vec4(v_normal, 1) * u_modelView).xyz));\n\tfloat brightness = 0.5 + light.x * 0.15 + light.z * 0.35;\n\tfront_color = u_frontColor * brightness;\n\tback_color = u_backColor * brightness;\n}\n","#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\nuniform float u_opacity;\nin vec3 front_color;\nin vec3 back_color;\nin vec3 barycentric;\nout vec4 outColor;\nfloat edgeFactor(vec3 barycenter) {\n\tvec3 d = fwidth(barycenter);\n\tvec3 a3 = smoothstep(vec3(0.0), d*3.5, barycenter);\n\treturn min(min(a3.x, a3.y), a3.z);\n}\nvoid main () {\n\tgl_FragDepth = gl_FragCoord.z;\n\tvec3 color = gl_FrontFacing ? front_color : back_color;\n\toutColor = vec4(mix(vec3(0.0), color, edgeFactor(barycentric)), u_opacity);\n}\n");return{program:n,vertexArrays:makeFoldedVertexArrays(e,n,o,s),elementArrays:makeFoldedElementArrays(e,t,o),flags:[e.DEPTH_TEST],makeUniforms:makeUniforms$1}};
// const LAYER_NUDGE = 12e-6;
var Js=Object.freeze({__proto__:null,foldedFormFaces:foldedFormFaces,foldedFormEdges:foldedFormEdges,foldedFormFacesOutlined:foldedFormFacesOutlined});
/**
	 * Rabbit Ear (c) Kraft
	 */const Zs={B:[.3,.3,.3],b:[.3,.3,.3],V:[.2,.4,.6],v:[.2,.4,.6],M:[.75,.25,.15],m:[.75,.25,.15],F:[.2,.2,.2],f:[.2,.2,.2],U:[.2,.2,.2],u:[.2,.2,.2]},make2D$1=e=>e.map((e=>[0,1].map((t=>e[t]||0)))),makeCPEdgesVertexData=(e,t=Zs)=>{if(!e||!e.vertices_coords||!e.edges_vertices)return[];const r=make2D$1(e.edges_vertices.flatMap((t=>t.map((t=>e.vertices_coords[t])))).flatMap((e=>[e,e]))),s=make2D$1(makeEdgesVector(e));return{vertices_coords:r,vertices_color:e.edges_assignment?e.edges_assignment.flatMap((e=>[t[e],t[e],t[e],t[e]])):e.edges_vertices.flatMap((()=>[t.U,t.U,t.U,t.U])),verticesEdgesVector:s.flatMap((e=>[e,e,e,e])),vertices_vector:e.edges_vertices.flatMap((()=>[[1,0],[-1,0],[-1,0],[1,0]]))}};
/**
	 * Rabbit Ear (c) Kraft
	 */var Ys=Object.freeze({__proto__:null,makeCPEdgesVertexData:makeCPEdgesVertexData});
/**
	 * Rabbit Ear (c) Kraft
	 */const makeCPEdgesVertexArrays=(e,t,r)=>{if(!r||!r.vertices_coords||!r.edges_vertices)return[];const{vertices_coords:s,vertices_color:o,verticesEdgesVector:n,vertices_vector:a}=makeCPEdgesVertexData(r);return[{location:e.getAttribLocation(t,"v_position"),buffer:e.createBuffer(),type:e.FLOAT,length:2,data:new Float32Array(s.flat())},{location:e.getAttribLocation(t,"v_color"),buffer:e.createBuffer(),type:e.FLOAT,length:o[0].length,data:new Float32Array(o.flat())},{location:e.getAttribLocation(t,"edge_vector"),buffer:e.createBuffer(),type:e.FLOAT,length:n[0].length,data:new Float32Array(n.flat())},{location:e.getAttribLocation(t,"vertex_vector"),buffer:e.createBuffer(),type:e.FLOAT,length:a[0].length,data:new Float32Array(a.flat())}].filter((e=>-1!==e.location))},makeCPEdgesElementArrays=(e,t=1,r={})=>{if(!r||!r.edges_vertices)return[];const s=r.edges_vertices.map(((e,t)=>4*t)).flatMap((e=>[e+0,e+1,e+2,e+2,e+3,e+0]));return[{mode:e.TRIANGLES,buffer:e.createBuffer(),data:2===t?new Uint32Array(s):new Uint16Array(s)}]},makeCPFacesVertexArrays=(e,t,r)=>{if(!r||!r.vertices_coords)return[];const s=r.vertices_coords.map((()=>[.11,.11,.11]));return[{location:e.getAttribLocation(t,"v_position"),buffer:e.createBuffer(),type:e.FLOAT,length:2,data:new Float32Array((o=r.vertices_coords,o.map((e=>[0,1].map((t=>e[t]||0))))).flat())},{location:e.getAttribLocation(t,"v_color"),buffer:e.createBuffer(),type:e.FLOAT,length:s[0].length,data:new Float32Array(s.flat())}].filter((e=>-1!==e.location));var o},makeCPFacesElementArrays=(e,t=1,r={})=>r&&r.vertices_coords&&r.faces_vertices?[{mode:e.TRIANGLES,buffer:e.createBuffer(),data:2===t?new Uint32Array(triangulateConvexFacesVertices(r).flat()):new Uint16Array(triangulateConvexFacesVertices(r).flat())}]:[];var Xs=Object.freeze({__proto__:null,makeCPEdgesVertexArrays:makeCPEdgesVertexArrays,makeCPEdgesElementArrays:makeCPEdgesElementArrays,makeCPFacesVertexArrays:makeCPFacesVertexArrays,makeCPFacesElementArrays:makeCPFacesElementArrays});
/**
	 * Rabbit Ear (c) Kraft
	 */const makeUniforms=(e,{projectionMatrix:t,viewMatrix:r,modelMatrix:s,strokeWidth:o})=>({u_matrix:{func:"uniformMatrix4fv",value:multiplyMatrices4(multiplyMatrices4(t,r),s)},u_projection:{func:"uniformMatrix4fv",value:t},u_modelView:{func:"uniformMatrix4fv",value:multiplyMatrices4(r,s)},u_strokeWidth:{func:"uniform1f",value:o/2}}),Ks="#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\nin vec3 blend_color;\nout vec4 outColor;\nvoid main() {\n\toutColor = vec4(blend_color.rgb, 1);\n}\n",Qs="#version 100\nprecision mediump float;\nvarying vec3 blend_color;\nvoid main () {\n\tgl_FragColor = vec4(blend_color.rgb, 1);\n}\n",cpFacesV1=(e,t=1,r={})=>{const s=createProgram(e,"#version 100\nuniform mat4 u_matrix;\nattribute vec2 v_position;\nattribute vec3 v_color;\nvarying vec3 blend_color;\nvoid main () {\n\tgl_Position = u_matrix * vec4(v_position, 0, 1);\n\tblend_color = v_color;\n}\n",Qs);return{program:s,vertexArrays:makeCPFacesVertexArrays(e,s,r),elementArrays:makeCPFacesElementArrays(e,t,r),flags:[],makeUniforms:makeUniforms}},cpEdgesV1=(e,t=1,r={})=>{const s=createProgram(e,"#version 100\nuniform mat4 u_matrix;\nuniform float u_strokeWidth;\nattribute vec2 v_position;\nattribute vec3 v_color;\nattribute vec2 edge_vector;\nattribute vec2 vertex_vector;\nvarying vec3 blend_color;\nvoid main () {\n\tfloat sign = vertex_vector[0];\n\tvec2 side = normalize(vec2(edge_vector.y * sign, -edge_vector.x * sign)) * u_strokeWidth;\n\tgl_Position = u_matrix * vec4(side + v_position, 0, 1);\n\tblend_color = v_color;\n}\n",Qs);return{program:s,vertexArrays:makeCPEdgesVertexArrays(e,s,r),elementArrays:makeCPEdgesElementArrays(e,t,r),flags:[],makeUniforms:makeUniforms}},cpFacesV2=(e,t=2,r={})=>{const s=createProgram(e,"#version 300 es\nuniform mat4 u_matrix;\nin vec2 v_position;\nin vec3 v_color;\nout vec3 blend_color;\nvoid main () {\n\tgl_Position = u_matrix * vec4(v_position, 0, 1);\n\tblend_color = v_color;\n}\n",Ks);return{program:s,vertexArrays:makeCPFacesVertexArrays(e,s,r),elementArrays:makeCPFacesElementArrays(e,t,r),flags:[],makeUniforms:makeUniforms}},cpEdgesV2=(e,t=2,r={})=>{const s=createProgram(e,"#version 300 es\nuniform mat4 u_matrix;\nuniform float u_strokeWidth;\nin vec2 v_position;\nin vec3 v_color;\nin vec2 edge_vector;\nin vec2 vertex_vector;\nout vec3 blend_color;\nvoid main () {\n\tfloat sign = vertex_vector[0];\n\tvec2 side = normalize(vec2(edge_vector.y * sign, -edge_vector.x * sign)) * u_strokeWidth;\n\tgl_Position = u_matrix * vec4(side + v_position, 0, 1);\n\tblend_color = v_color;\n}\n",Ks);return{program:s,vertexArrays:makeCPEdgesVertexArrays(e,s,r),elementArrays:makeCPEdgesElementArrays(e,t,r),flags:[],makeUniforms:makeUniforms}};var eo=Object.freeze({__proto__:null,cpFacesV1:cpFacesV1,cpEdgesV1:cpEdgesV1,cpFacesV2:cpFacesV2,cpEdgesV2:cpEdgesV2});
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * Rabbit Ear (c) Kraft
	 */
/**
	 * @description WebGL methods
	 */
var to=Object.assign(Object.create(null),{createProgram:createProgram,initialize:(e,t)=>{const r=[null,"webgl","webgl2"],s=window.devicePixelRatio||1;
// set the size of the drawingBuffer to include retina display level pixels (if exist),
// the size can still change after, even with CSS, this only matters for getContext
if(e.width=e.clientWidth*s,e.height=e.clientHeight*s,t)return{gl:e.getContext(r[t]),version:t};
// no user preference. attempt version 2, if fails, return version 1.
const o=e.getContext(r[2]);if(o)return{gl:o,version:2};const n=e.getContext(r[1]);if(n)return{gl:n,version:1};throw new Error(N)},foldedForm:(e,t=1,r={},s={})=>{const o=[];
// either Faces, or FacesOutlined
return!1!==s.faces&&(!1===s.outlines?o.push(foldedFormFaces(e,t,r,s)):o.push(foldedFormFacesOutlined(e,t,r,s))),
// if edges option is on, also add thick edges
!0===s.edges&&o.push(foldedFormEdges(e,t,r,s)),o},creasePattern:(e,t=1,r={})=>1===t?[cpFacesV1(e,t,r),cpEdgesV1(e,t,r)]:[cpFacesV2(e,t,r),cpEdgesV2(e,t,r)]},Ds,qs,Hs,Ws,Js,Xs,Ys,eo);
/**
	 * Rabbit Ear (c) Kraft
	 */const ro=Object.assign(T,vt,{math:Ft,axiom:axiom,diagram:zt,layer:Xt,singleVertex:Qt,
// text,
convert:cr,webgl:to});
/**
	 * math is uniquely constructed where all the core methods are exposed
	 * under ".math", and the top-level class-style objects will be attached
	 * to this library's top level.
	 */
// Object.keys(math)
// 	.filter(key => key !== "core")
// 	.forEach((key) => { ear[key] = math[key]; });
/**
	 * use() must bind this library to "this", as a way of making this library
	 * mutable, so that the extension can bind itself throughout this library.
	 */return Object.defineProperty(ro,"use",{enumerable:!1,value:function(e){null!=e&&"function"==typeof e.linker&&e.linker(this)}.bind(ro)}),
/**
	 * binding the extensions must happen after the library has been initialized.
	 */
A||(ro.use(FOLDtoSVG),// must happen before SVG
ro.use(SVG)),Object.defineProperty(ro,"window",{enumerable:!1,set:e=>{var t;
// make sure window has a document. xmldom does not, and requires it be built.
(t=e).document||(t.document=(e=>(new e.DOMParser).parseFromString("<!DOCTYPE html><title>.</title>","text/html"))(t)),z.window=t,z.window,
// hardcoded. update window in extensions automatically, if we know them.
SVG.window=e}}),ro}));
