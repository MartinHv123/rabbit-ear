/* Rabbit Ear 0.9.4 alpha 2024-04-20 (c) Kraft, GNU GPLv3 License */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e="undefined"!=typeof globalThis?globalThis:e||self).ear=t()}(this,(function(){"use strict";const e="object"==typeof window&&"object"==typeof window.document,t="object"==typeof process&&"object"==typeof process.versions&&(null!=process.versions.node||null!=process.versions.bun),r="object"==typeof window&&"Deno"in window&&"object"==typeof window.Deno,s=t||r;var a="valid manifold required",o="cycle not allowed",c="replace() generated undefined",n="foldAngles cannot be determined from flat-folded faces without an assignment",i="WebGl not Supported",l="only convex faces are supported",d="window not set; if using node/deno include package @xmldom/xmldom and set ear.window = xmldom",_="non-convex triangulation requires vertices_coords",m="svgToFold found <style> in <svg>. rendering will be incomplete unless run in a major browser.",g="LayerSolver bad input. no solution possible";const v={window:void 0};e&&(v.window=window);const RabbitEarWindow$1=()=>{if(void 0===v.window)throw new Error(d);return v.window},p=1e-6,u=180/Math.PI,h=Math.PI/180,b=2*Math.PI;var y=Object.freeze({__proto__:null,D2R:h,EPSILON:p,R2D:u,TWO_PI:b});const safeAdd=(e,t)=>e+(t||0),magnitude=e=>Math.sqrt(e.map((e=>e*e)).reduce(safeAdd,0)),magnitude2=e=>Math.sqrt(e[0]*e[0]+e[1]*e[1]),magnitude3=e=>Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]),magSquared2=e=>e[0]*e[0]+e[1]*e[1],magSquared=e=>e.map((e=>e*e)).reduce(safeAdd,0),normalize$2=e=>{const t=magnitude(e);return 0===t?e:e.map((e=>e/t))},normalize2=e=>{const t=magnitude2(e);return 0===t?[e[0],e[1]]:[e[0]/t,e[1]/t]},normalize3=e=>{const t=magnitude3(e);return 0===t?e:[e[0]/t,e[1]/t,e[2]/t]},scale$1=(e,t)=>e.map((e=>e*t)),scale2$1=(e,t)=>[e[0]*t,e[1]*t],scale3$1=(e,t)=>[e[0]*t,e[1]*t,e[2]*t],scaleNonUniform=(e,t)=>e.map(((e,r)=>e*t[r])),scaleNonUniform2=(e,t)=>[e[0]*t[0],e[1]*t[1]],scaleNonUniform3=(e,t)=>[e[0]*t[0],e[1]*t[1],e[2]*t[2]],add=(e,t)=>e.map(((e,r)=>e+(t[r]||0))),add2=(e,t)=>[e[0]+t[0],e[1]+t[1]],add3=(e,t)=>[e[0]+t[0],e[1]+t[1],e[2]+t[2]],subtract=(e,t)=>e.map(((e,r)=>e-(t[r]||0))),subtract2=(e,t)=>[e[0]-t[0],e[1]-t[1]],subtract3=(e,t)=>[e[0]-t[0],e[1]-t[1],e[2]-t[2]],dot=(e,t)=>e.map(((r,s)=>e[s]*t[s])).reduce(safeAdd,0),dot2=(e,t)=>e[0]*t[0]+e[1]*t[1],dot3=(e,t)=>e[0]*t[0]+e[1]*t[1]+e[2]*t[2],midpoint=(e,t)=>e.map(((e,r)=>(e+t[r])/2)),midpoint2=(e,t)=>scale2$1(add2(e,t),.5),average=(...e)=>{if(0===e.length)return;const t=e[0].length>0?e[0].length:0,r=Array(t).fill(0);return Array.from(e).forEach((e=>r.forEach(((t,s)=>{r[s]+=e[s]||0})))),r.map((t=>t/e.length))},average2=(...e)=>{if(!e||!e.length)return;const t=e.reduce(((e,t)=>add2(e,t)),[0,0]);return[t[0]/e.length,t[1]/e.length]},average3=(...e)=>{if(!e||!e.length)return;const t=e.reduce(((e,t)=>add3(e,t)),[0,0,0]);return[t[0]/e.length,t[1]/e.length,t[2]/e.length]},lerp=(e,t,r=0)=>{const s=1-r;return e.map(((e,a)=>e*s+(t[a]||0)*r))},cross2=(e,t)=>e[0]*t[1]-e[1]*t[0],cross3=(e,t)=>[e[1]*t[2]-e[2]*t[1],e[2]*t[0]-e[0]*t[2],e[0]*t[1]-e[1]*t[0]],distance=(e,t)=>Math.sqrt(e.map(((r,s)=>(e[s]-t[s])**2)).reduce(safeAdd,0)),distance2=(e,t)=>{const r=e[0]-t[0],s=e[1]-t[1];return Math.sqrt(r*r+s*s)},distance3=(e,t)=>{const r=e[0]-t[0],s=e[1]-t[1],a=e[2]-t[2];return Math.sqrt(r*r+s*s+a*a)},flip=e=>e.map((e=>-e)),flip2=e=>[-e[0],-e[1]],flip3=e=>[-e[0],-e[1],-e[2]],rotate90=e=>[-e[1],e[0]],rotate270=e=>[e[1],-e[0]],parallelNormalized=(e,t,r=p)=>1-Math.abs(dot(e,t))<r,parallel=(e,t,r=p)=>parallelNormalized(normalize$2(e),normalize$2(t),r),parallel2=(e,t,r=p)=>Math.abs(cross2(e,t))<r,parallel3=(e,t,r=p)=>magnitude3(cross3(e,t))<r,resize=(e,t)=>t.length===e?t:Array(e).fill(0).map(((e,r)=>t[r]?t[r]:e)),resize2=e=>[e[0]||0,e[1]||0],resize3=e=>[e[0]||0,e[1]||0,e[2]||0],basisVectors2=(e=[1,0])=>{const t=normalize2(e);return[t,rotate90(t)]},basisVectors3=(e=[1,0,0])=>{const t=normalize3(e),r=[[1,0,0],[0,1,0],[0,0,1]].map((e=>cross3(e,t))),s=r.map(magnitude3).map(((e,t)=>({n:e,i:t}))).sort(((e,t)=>t.n-e.n)).map((e=>e.i)).shift(),a=normalize3(r[s]);return[t,a,cross3(t,a)]};var E=Object.freeze({__proto__:null,add:add,add2:add2,add3:add3,average:average,average2:average2,average3:average3,basisVectors:e=>2===e.length?basisVectors2([e[0],e[1]]):basisVectors3([e[0],e[1],e[2]]),basisVectors2:basisVectors2,basisVectors3:basisVectors3,cross2:cross2,cross3:cross3,degenerate:(e,t=p)=>e.map((e=>Math.abs(e))).reduce(safeAdd,0)<t,distance:distance,distance2:distance2,distance3:distance3,dot:dot,dot2:dot2,dot3:dot3,flip:flip,flip2:flip2,flip3:flip3,lerp:lerp,magSquared:magSquared,magSquared2:magSquared2,magnitude:magnitude,magnitude2:magnitude2,magnitude3:magnitude3,midpoint:midpoint,midpoint2:midpoint2,midpoint3:(e,t)=>scale3$1(add3(e,t),.5),normalize:normalize$2,normalize2:normalize2,normalize3:normalize3,parallel:parallel,parallel2:parallel2,parallel3:parallel3,parallelNormalized:parallelNormalized,resize:resize,resize2:resize2,resize3:resize3,resizeUp:(e,t)=>[e,t].map((r=>resize(Math.max(e.length,t.length),r))),rotate270:rotate270,rotate90:rotate90,scale:scale$1,scale2:scale2$1,scale3:scale3$1,scaleNonUniform:scaleNonUniform,scaleNonUniform2:scaleNonUniform2,scaleNonUniform3:scaleNonUniform3,subtract:subtract,subtract2:subtract2,subtract3:subtract3});const vectorToAngle=e=>Math.atan2(e[1],e[0]),angleToVector=e=>[Math.cos(e),Math.sin(e)],pointsToLine2=(e,t)=>({vector:subtract2(t,e),origin:resize2(e)}),pointsToLine3=(e,t)=>({vector:subtract3(t,e),origin:resize3(e)}),pointsToLine=(e,t)=>3===e.length&&3===t.length?pointsToLine3(e,t):pointsToLine2(e,t),vecLineToUniqueLine=({vector:e,origin:t})=>{const r=magnitude(e),s=rotate90([e[0],e[1]]),a=dot(t,s)/r;return{normal:scale2$1(s,1/r),distance:a}},uniqueLineToVecLine=({normal:e,distance:t})=>({vector:rotate270(e),origin:scale2$1(e,t)});var M=Object.freeze({__proto__:null,angleToVector:angleToVector,pointsToLine:pointsToLine,pointsToLine2:pointsToLine2,pointsToLine3:pointsToLine3,uniqueLineToVecLine:uniqueLineToVecLine,vecLineToUniqueLine:vecLineToUniqueLine,vectorToAngle:vectorToAngle});const epsilonEqual=(e,t,r=p)=>Math.abs(e-t)<r,epsilonCompare=(e,t,r=p)=>epsilonEqual(e,t,r)?0:Math.sign(e-t),epsilonEqualVectors=(e,t,r=p)=>{for(let s=0;s<Math.max(e.length,t.length);s+=1)if(!epsilonEqual(e[s]||0,t[s]||0,r))return!1;return!0},include=(e,t=p)=>e>-t,exclude=(e,t=p)=>e>t,includeL=(e,t)=>!0,A=include,x=exclude,includeS=(e,t=p)=>e>-t&&e<1+t,excludeS=(e,t=p)=>e>t&&e<1-t;var O=Object.freeze({__proto__:null,epsilonCompare:epsilonCompare,epsilonEqual:epsilonEqual,epsilonEqualVectors:epsilonEqualVectors,exclude:exclude,excludeL:(e,t)=>!0,excludeR:x,excludeS:excludeS,include:include,includeL:includeL,includeR:A,includeS:includeS});const isCounterClockwiseBetween=(e,t,r)=>{for(;r<t;)r+=b;for(;e>t;)e-=b;for(;e<t;)e+=b;return e<r},clockwiseAngleRadians=(e,t)=>{for(;e<0;)e+=b;for(;t<0;)t+=b;for(;e>b;)e-=b;for(;t>b;)t-=b;const r=e-t;return r>=0?r:b-(t-e)},counterClockwiseAngleRadians=(e,t)=>{for(;e<0;)e+=b;for(;t<0;)t+=b;for(;e>b;)e-=b;for(;t>b;)t-=b;const r=t-e;return r>=0?r:b-(e-t)},clockwiseAngle2=(e,t)=>{const r=t[0]*e[0]+t[1]*e[1],s=t[0]*e[1]-t[1]*e[0];let a=Math.atan2(s,r);return a<0&&(a+=b),a},counterClockwiseAngle2=(e,t)=>{const r=e[0]*t[0]+e[1]*t[1],s=e[0]*t[1]-e[1]*t[0];let a=Math.atan2(s,r);return a<0&&(a+=b),a},clockwiseBisect2=(e,t)=>angleToVector(vectorToAngle(e)-clockwiseAngle2(e,t)/2),clockwiseSubsectRadians=(e,t,r)=>{const s=clockwiseAngleRadians(e,t)/r;return Array.from(Array(r-1)).map(((t,r)=>e+s*(r+1)))},counterClockwiseSubsectRadians=(e,t,r)=>{const s=counterClockwiseAngleRadians(e,t)/r;return Array.from(Array(r-1)).map(((t,r)=>e+s*(r+1)))},counterClockwiseSubsect2=(e,t,r)=>{const s=Math.atan2(e[1],e[0]),a=Math.atan2(t[1],t[0]);return counterClockwiseSubsectRadians(s,a,r).map(angleToVector)},counterClockwiseOrderRadians=e=>{const t=e.map(((e,t)=>t)).sort(((t,r)=>e[t]-e[r]));return t.slice(t.indexOf(0),t.length).concat(t.slice(0,t.indexOf(0)))},counterClockwiseOrder2=e=>counterClockwiseOrderRadians(e.map(vectorToAngle)),counterClockwiseSectorsRadians=e=>counterClockwiseOrderRadians(e).map((t=>e[t])).map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>counterClockwiseAngleRadians(e[0],e[1]))),counterClockwiseSectors2=e=>counterClockwiseSectorsRadians(e.map(vectorToAngle)),threePointTurnDirection=(e,t,r,s=p)=>{const a=normalize2(subtract2(t,e)),o=normalize2(subtract2(r,e)),c=cross2(a,o);return epsilonEqual(c,0,s)?epsilonEqual(distance2(e,t)+distance2(t,r),distance2(e,r))?0:void 0:Math.sign(c)};var j=Object.freeze({__proto__:null,clockwiseAngle2:clockwiseAngle2,clockwiseAngleRadians:clockwiseAngleRadians,clockwiseBisect2:clockwiseBisect2,clockwiseSubsect2:(e,t,r)=>{const s=Math.atan2(e[1],e[0]),a=Math.atan2(t[1],t[0]);return clockwiseSubsectRadians(s,a,r).map(angleToVector)},clockwiseSubsectRadians:clockwiseSubsectRadians,counterClockwiseAngle2:counterClockwiseAngle2,counterClockwiseAngleRadians:counterClockwiseAngleRadians,counterClockwiseBisect2:(e,t)=>angleToVector(vectorToAngle(e)+counterClockwiseAngle2(e,t)/2),counterClockwiseOrder2:counterClockwiseOrder2,counterClockwiseOrderRadians:counterClockwiseOrderRadians,counterClockwiseSectors2:counterClockwiseSectors2,counterClockwiseSectorsRadians:counterClockwiseSectorsRadians,counterClockwiseSubsect2:counterClockwiseSubsect2,counterClockwiseSubsectRadians:counterClockwiseSubsectRadians,isCounterClockwiseBetween:isCounterClockwiseBetween,threePointTurnDirection:threePointTurnDirection});const clampLine=e=>e,clampSegment=e=>e<-p?0:e>1.000001?1:e,collinearPoints=(e,t,r,s=p)=>{const a=[[e,t],[t,r]].map((e=>subtract(e[1],e[0]))).map((e=>normalize$2(e)));return epsilonEqual(1,Math.abs(dot(a[0],a[1])),s)},collinearBetween=(e,t,r,s=!1,a=p)=>{if([e,r].map((e=>epsilonEqualVectors(t,e,a))).reduce(((e,t)=>e||t),!1))return s;const o=[[e,t],[t,r]].map((e=>subtract(e[1],e[0]))).map((e=>normalize$2(e)));return epsilonEqual(1,dot(o[0],o[1]),p)},collinearLines3=(e,t,r=p)=>parallel3(e.vector,t.vector,r)&&parallel3(e.vector,subtract3(t.origin,e.origin),r),pleat$2=(e,t,r,s=p)=>{const a=cross2(e.vector,t.vector),o=cross2(subtract2(t.origin,e.origin),t.vector)/a,[c,n]=[e.vector,t.vector].map(normalize2);if(Math.abs(cross2(c,n))<s)return((e,t,r)=>{const s=dot(e.vector,t.vector)<0,a=e.vector,o=s?flip(t.vector):t.vector,c=Array.from(Array(r-1)).map(((s,a)=>lerp(e.origin,t.origin,(a+1)/r))),n=Array.from(Array(r-1)).map(((e,t)=>lerp(a,o,(t+1)/r))).map(((e,t)=>({vector:[e[0],e[1]],origin:[c[t][0],c[t][1]]}))),i=[n,n];return i[s?0:1]=[],i})(e,t,r);const i=a>-s?[[e.vector,t.vector],[flip2(t.vector),e.vector]]:[[t.vector,e.vector],[flip2(e.vector),t.vector]],l=[counterClockwiseSubsect2(i[0][0],i[0][1],r),counterClockwiseSubsect2(i[1][0],i[1][1],r)],d=add2(e.origin,scale2$1(e.vector,o)),_=Array.from(Array(r-1)).map((()=>d)),[m,g]=l.map((e=>e.map(((e,t)=>({vector:e,origin:_[t]})))));return[m,g]},bisectLines2=(e,t,r=p)=>{const[s,a]=pleat$2(e,t,2,r).map((e=>e[0])),o=[s,a];return o.forEach(((e,t)=>{void 0===e&&delete o[t]})),o};var w=Object.freeze({__proto__:null,bisectLines2:bisectLines2,clampLine:clampLine,clampRay:e=>e<-p?0:e,clampSegment:clampSegment,collinearBetween:collinearBetween,collinearLines2:(e,t,r=p)=>parallel2(e.vector,t.vector,r)&&parallel2(e.vector,subtract2(t.origin,e.origin),r),collinearLines3:collinearLines3,collinearPoints:collinearPoints,pleat:pleat$2});const rangeUnion=(e,t)=>{const r=t[0]<=t[1];return e[0]<=e[1]?[Math.min(e[0],r?t[0]:t[1]),Math.max(e[1],r?t[1]:t[0])]:[Math.min(e[1],r?t[0]:t[1]),Math.max(e[0],r?t[1]:t[0])]},doRangesOverlap=(e,t,r=p)=>{const s=e[0]<e[1]?e:[e[1],e[0]],a=t[0]<t[1]?t:[t[1],t[0]];return Math.min(s[1],a[1])-Math.max(s[0],a[0])>r};var F=Object.freeze({__proto__:null,doRangesOverlap:doRangesOverlap,rangeUnion:rangeUnion});const clusterSortedGeneric=(e,t)=>{if(!e.length)return[];const r=e.map(((e,t)=>t)),s=[[r.shift()]];return r.forEach((r=>{const a=s[s.length-1],o=a[a.length-1];t(e[o],e[r])?a.push(r):s.push([r])})),s},clusterUnsortedIndices=(e,t)=>{if(!e.length)return[];const r=e.slice(),s=[[r.shift()]];return r.forEach((e=>{const r=s.map(((r,s)=>t(r[0],e)?s:void 0)).filter((e=>void 0!==e)).shift();void 0!==r?s[r].push(e):s.push([e])})),s},clusterScalars=(e,t=p)=>{const r=e.map(((e,t)=>({v:e,i:t}))).sort(((e,t)=>e.v-t.v)).map((e=>e.i)).filter((()=>!0)),s=r.map((t=>e[t]));return clusterSortedGeneric(s,((e,r)=>Math.abs(e-r)<t)).map((e=>e.map((e=>r[e]))))},clusterParallelVectors=(e,t=p)=>{const r=e.map(normalize$2),s=[[0]];e:for(let e=1;e<r.length;e+=1){for(let a=0;a<s.length;a+=1)if(parallelNormalized(r[e],r[s[a][0]],t)){s[a].push(e);continue e}s.push([e])}return s};var S=Object.freeze({__proto__:null,clusterParallelVectors:clusterParallelVectors,clusterRanges:(e,t=p)=>{const r=e.map((([e,t],r)=>({v:Math.min(e,t),i:r}))).sort(((e,t)=>e.v-t.v)).map((e=>e.i)).filter((()=>!0)),s=r.map((t=>e[t]));let a=[...s[0]];return clusterSortedGeneric(s,((e,r)=>{const s=doRangesOverlap(a,r,t);return a=s?rangeUnion(a,r):[...r],s})).map((e=>e.map((e=>r[e]))))},clusterScalars:clusterScalars,clusterSortedGeneric:clusterSortedGeneric,clusterUnsortedIndices:clusterUnsortedIndices});const intersectLineLine=(e,t,r=includeL,s=includeL,a=p)=>{const o=cross2(normalize2(e.vector),normalize2(t.vector));if(Math.abs(o)<a)return{a:void 0,b:void 0,point:void 0};const c=cross2(e.vector,t.vector),n=-c,i=[t.origin[0]-e.origin[0],t.origin[1]-e.origin[1]],l=[-i[0],-i[1]],d=cross2(i,t.vector)/c,_=cross2(l,e.vector)/n;return r(d,a/magnitude2(e.vector))&&s(_,a/magnitude2(t.vector))?{a:d,b:_,point:add2(e.origin,scale2$1(e.vector,d))}:{a:void 0,b:void 0,point:void 0}},intersectCircleLine=(e,t,r=include,s=includeL,a=p)=>{const o=t.vector[0]**2+t.vector[1]**2,c=Math.sqrt(o),n=0===c?t.vector:scale2$1(t.vector,1/c),i=rotate90(n),l=subtract2(t.origin,e.origin),d=cross2(l,n);if(Math.abs(d)>e.radius+a)return;const _=Math.sqrt(e.radius**2-d**2),f=(t,r)=>e.origin[r]-i[r]*d+n[r]*t,m=Math.abs(e.radius-Math.abs(d))<a?[_].map((e=>[f(e,0),f(e,1)])):[-_,_].map((e=>[f(e,0),f(e,1)])),g=m.map((e=>e.map(((e,r)=>e-t.origin[r])))).map((e=>e[0]*t.vector[0]+t.vector[1]*e[1])).map((e=>e/o));return m.filter(((e,t)=>s(g[t],a)))},intersectPolygonLine=(e,t,r=includeL,s=p)=>{const a=e.map(((e,t,r)=>({vector:subtract2(r[(t+1)%r.length],e),origin:resize2(e)}))).map((e=>intersectLineLine(t,e,r,includeS,s))).filter((({point:e})=>void 0!==e)).sort(((e,t)=>e.a-t.a)).map((({a:e,point:t})=>({a:e,point:t})));return clusterSortedGeneric(a,((e,t)=>epsilonEqual(e.a,t.a,s))).map((([e])=>a[e]))};var C=Object.freeze({__proto__:null,intersectCircleLine:intersectCircleLine,intersectLineLine:intersectLineLine,intersectPolygonLine:intersectPolygonLine});const cubeRootSigned=e=>e<0?-((-e)**(1/3)):e**(1/3),normalAxiom1=(e,t)=>{const r=normalize2(rotate90(subtract2(t,e)));return[{normal:r,distance:dot2(add2(e,t),r)/2}]},axiom1=(e,t)=>[{vector:normalize2(subtract2(t,e)),origin:e}],normalAxiom2=(e,t)=>{const r=normalize2(subtract2(t,e));return[{normal:r,distance:dot2(add2(e,t),r)/2}]},axiom2=(e,t)=>[{vector:normalize2(rotate90(subtract2(t,e))),origin:midpoint2(e,t)}],normalAxiom3=(e,t)=>{const r=cross2(e.normal,t.normal);if(Math.abs(r)<p)return[{normal:e.normal,distance:(e.distance+t.distance*dot2(e.normal,t.normal))/2}];const s=[(e.distance*t.normal[1]-t.distance*e.normal[1])/r,(t.distance*e.normal[0]-e.distance*t.normal[0])/r],[a,o]=[add2,subtract2].map((r=>normalize2(r(e.normal,t.normal)))).map((e=>({normal:e,distance:dot2(s,e)})));return[a,o]},axiom3=(e,t)=>bisectLines2(e,t),normalAxiom4=(e,t)=>{const r=rotate90(e.normal);return[{normal:r,distance:dot2(t,r)}]},axiom4=({vector:e},t)=>[{vector:rotate90(normalize2(e)),origin:t}],normalAxiom5=(e,t,r)=>{const s=dot2(t,e.normal),a=e.distance-s,o=distance2(t,r);if(a>o)return[];const c=Math.sqrt(o*o-a*a),n=scale2$1(e.normal,a),i=add2(t,n),l=scale2$1(rotate90(e.normal),c),d=c<p?[i]:[add2(i,l),subtract2(i,l)],[_,m]=d.map((e=>normalize2(subtract2(r,e)))).map((e=>({normal:e,distance:dot2(t,e)})));return[_,m]},axiom5=(e,t,r)=>(intersectCircleLine({radius:distance2(t,r),origin:t},e)||[]).map((e=>({vector:normalize2(rotate90(subtract2(e,r))),origin:midpoint2(r,e)}))),normalAxiom6=(e,t,r,s)=>{if(Math.abs(1-dot2(e.normal,r)/e.distance)<.02)return[];const a=rotate90(e.normal),o=subtract2(add2(r,scale2$1(e.normal,e.distance)),scale2$1(s,2)),c=subtract2(scale2$1(e.normal,e.distance),r),n=dot2(s,t.normal)-t.distance,i=2*dot2(c,a),l=dot2(c,c),d=dot2(add2(o,c),a),_=dot2(o,c),m=dot2(a,t.normal),g=dot2(c,t.normal),v=m,u=n+d*m+g,h=n*i+_*m+d*g,b=n*l+_*g;let y=[];return Math.abs(v)>p?y=[b,h,u,v]:Math.abs(u)>p?y=[b,h,u]:Math.abs(h)>p&&(y=[b,h]),(e=>{const[t,r,s,a]=e;switch(e.length){case 2:return[-t/r];case 3:{const e=r**2-4*t*s;if(e<-p)return[];const a=-r/(2*s);if(e<p)return[a];const o=Math.sqrt(e)/(2*s);return[a+o,a-o]}case 4:{const e=s/a,o=r/a,c=(9*e*o-t/a*27-2*e**3)/54,n=((3*o-e**2)/9)**3+c**2,i=-e/3;if(n>0){const e=Math.sqrt(n);return[i+cubeRootSigned(c+e)+cubeRootSigned(c-e)]}if(Math.abs(n)<p){if(c<0)return[];const e=c**(1/3);return[i+2*e,i-e]}const l=Math.sqrt(-n),d=Math.atan2(l,c)/3,_=(c**2-n)**(1/6),m=_*Math.cos(d),g=_*Math.sin(d);return[i+2*m,i-m-Math.sqrt(3)*g,i-m+Math.sqrt(3)*g]}default:return[]}})(y).map((t=>add2(scale2$1(e.normal,e.distance),scale2$1(a,t)))).map((e=>({p:e,normal:normalize2(subtract2(e,r))}))).map((e=>({normal:e.normal,distance:dot2(e.normal,midpoint2(e.p,r))})))},axiom6=(e,t,r,s)=>normalAxiom6(vecLineToUniqueLine(e),vecLineToUniqueLine(t),r,s).map(uniqueLineToVecLine),normalAxiom7=(e,t,r)=>{const s=rotate90(e.normal),a=dot2(s,t.normal);if(Math.abs(a)<p)return;const o=dot2(r,s),c=dot2(r,t.normal);return[{normal:s,distance:(t.distance+2*o*a-c)/(2*a)}]},axiom7=(e,t,r)=>{const s=intersectLineLine(e,{vector:t.vector,origin:r},includeL,includeL).point;return void 0===s?[]:[{vector:normalize2(rotate90(subtract2(s,r))),origin:midpoint2(r,s)}]};var V=Object.freeze({__proto__:null,axiom1:axiom1,axiom2:axiom2,axiom3:axiom3,axiom4:axiom4,axiom5:axiom5,axiom6:axiom6,axiom7:axiom7,normalAxiom1:normalAxiom1,normalAxiom2:normalAxiom2,normalAxiom3:normalAxiom3,normalAxiom4:normalAxiom4,normalAxiom5:normalAxiom5,normalAxiom6:normalAxiom6,normalAxiom7:normalAxiom7});const z=[1,0,0,1],T=z.concat(0,0),multiplyMatrix2Vector2=(e,t)=>[e[0]*t[0]+e[2]*t[1]+e[4],e[1]*t[0]+e[3]*t[1]+e[5]],multiplyMatrix2Line2=(e,{vector:t,origin:r})=>({vector:[e[0]*t[0]+e[2]*t[1],e[1]*t[0]+e[3]*t[1]],origin:[e[0]*r[0]+e[2]*r[1]+e[4],e[1]*r[0]+e[3]*r[1]+e[5]]}),multiplyMatrices2=(e,t)=>[e[0]*t[0]+e[2]*t[1],e[1]*t[0]+e[3]*t[1],e[0]*t[2]+e[2]*t[3],e[1]*t[2]+e[3]*t[3],e[0]*t[4]+e[2]*t[5]+e[4],e[1]*t[4]+e[3]*t[5]+e[5]],determinant2=e=>e[0]*e[3]-e[1]*e[2],invertMatrix2=e=>{const t=determinant2(e);if(!(Math.abs(t)<1e-12||Number.isNaN(t))&&Number.isFinite(e[4])&&Number.isFinite(e[5]))return[e[3]/t,-e[1]/t,-e[2]/t,e[0]/t,(e[2]*e[5]-e[3]*e[4])/t,(e[1]*e[4]-e[0]*e[5])/t]},makeMatrix2Scale=(e=[1,1],t=[0,0])=>[e[0],0,0,e[1],e[0]*-t[0]+t[0],e[1]*-t[1]+t[1]],makeMatrix2Reflect=(e,t=[0,0])=>{const r=Math.atan2(e[1],e[0]),s=Math.cos(r),a=Math.sin(r),o=Math.cos(-r),c=Math.sin(-r),n=s*o+a*c,i=s*-c+a*o,l=a*o+-s*c,d=a*-c+-s*o;return[n,i,l,d,t[0]+n*-t[0]+-t[1]*l,t[1]+i*-t[0]+-t[1]*d]};var P=Object.freeze({__proto__:null,determinant2:determinant2,identity2x2:z,identity2x3:T,invertMatrix2:invertMatrix2,makeMatrix2Reflect:makeMatrix2Reflect,makeMatrix2Rotate:(e,t=[0,0])=>{const r=Math.cos(e),s=Math.sin(e);return[r,s,-s,r,t[0],t[1]]},makeMatrix2Scale:makeMatrix2Scale,makeMatrix2Translate:(e=0,t=0)=>z.concat(e,t),makeMatrix2UniformScale:(e=1,t=[0,0])=>makeMatrix2Scale([e,e],t),multiplyMatrices2:multiplyMatrices2,multiplyMatrix2Line2:multiplyMatrix2Line2,multiplyMatrix2Vector2:multiplyMatrix2Vector2});const overlapLinePoint=({vector:e,origin:t},r,s=includeL,a=p)=>{const o=subtract2(r,t),c=magSquared(e),n=Math.sqrt(c);if(n<a)return!1;const i=[e[0]/n,e[1]/n],l=cross2(o,i),d=dot2(o,e)/c;return Math.abs(l)<a&&s(d,a/n)},overlapConvexPolygonPoint=(e,t,r=exclude,s=p)=>{const a=e.map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((([e,r])=>[subtract2(r,e),subtract2(t,e)])).map((([e,t])=>cross2(e,t))),o=Math.sign(a.reduce(((e,t)=>e+t),0));return{overlap:a.map((e=>e*o)).map((e=>r(e,s))).map(((e,t,r)=>e===r[0])).reduce(((e,t)=>e&&t),!0),t:a}},overlapConvexPolygons=(e,t,r=p)=>{for(let s=0;s<2;s+=1){const a=0===s?e:t,o=0===s?t:e;for(let e=0;e<a.length;e+=1){const t=a[e],s=rotate90(subtract2(a[(e+1)%a.length],a[e])),c=o.map((e=>subtract2(e,t))).map((e=>dot2(s,e))),n=a[(e+2)%a.length],i=dot2(s,subtract2(n,t))>0;if(c.map((e=>i?e<r:e>-r)).reduce(((e,t)=>e&&t),!0))return!1}}return!0},overlapBoundingBoxes=(e,t,r=p)=>{const s=Math.min(e.min.length,t.min.length);for(let a=0;a<s;a+=1)if(e.min[a]>t.max[a]+r||e.max[a]<t.min[a]-r)return!1;return!0};var $=Object.freeze({__proto__:null,overlapBoundingBoxes:overlapBoundingBoxes,overlapConvexPolygonPoint:overlapConvexPolygonPoint,overlapConvexPolygons:overlapConvexPolygons,overlapLinePoint:overlapLinePoint});const clipLineConvexPolygon=(e,{vector:t,origin:r},s=include,a=includeL,o=p)=>{const c=intersectPolygonLine(e,{vector:t,origin:r},includeL,o).map((({a:e})=>e));if(c.length<2)return;const n=((e,t,r)=>{if(e.length<2)return;let s=0,a=e.length-1;for(;s<a&&!t(e[s+1]-e[s],r);)s+=1;for(;a>s&&!t(e[a]-e[a-1],r);)a-=1;return s>=a?void 0:[e[s],e[a]]})(c,s,2*o/magnitude2(t));if(void 0===n)return;const i=n.map((e=>a(e)?e:e<.5?0:1));if(Math.abs(i[0]-i[1])<2*o/magnitude2(t))return;const l=add2(r,scale2$1(t,(i[0]+i[1])/2));return overlapConvexPolygonPoint(e,l,s,o).overlap?i.map((e=>add2(r,scale2$1(t,e)))):void 0},clipPolygonPolygon=(e,t,r=p)=>{const inside=(e,t,s)=>(s[0]-t[0])*(e[1]-t[1])>(s[1]-t[1])*(e[0]-t[0])+r,intersection=(e,t,r,s)=>{const a=subtract2(e,t),o=subtract2(s,r),c=cross2(e,t),n=cross2(s,r),i=1/cross2(a,o);return scale2$1(subtract2(scale2$1(o,c),scale2$1(a,n)),i)};let s=e,a=t[t.length-1];for(let e=0;e<t.length;e+=1){const r=t[e],o=s;s=[];let c=o[o.length-1];for(let e=0;e<o.length;e+=1){const t=o[e];inside(t,a,r)?(inside(c,a,r)||s.push(intersection(a,r,t,c)),s.push(t)):inside(c,a,r)&&s.push(intersection(a,r,t,c)),c=t}a=r}return 0===s.length?void 0:s};var B=Object.freeze({__proto__:null,clipLineConvexPolygon:clipLineConvexPolygon,clipPolygonPolygon:clipPolygonPolygon});const reflectPoint=(e,t)=>{const r=makeMatrix2Reflect(e.vector,e.origin);return multiplyMatrix2Vector2(r,t)},validateAxiom1And2=(e,t,r)=>[[t,r].map((t=>overlapConvexPolygonPoint(e,t,include).overlap)).reduce(((e,t)=>e&&t),!0)],validateAxiom3=(e,t,r,s)=>{const a=[r,s].map((t=>clipLineConvexPolygon(e,t,include,includeL)));if(void 0===a[0]||void 0===a[1])return[!1,!1];const o=t.map((t=>void 0===t?void 0:clipLineConvexPolygon(e,t,include,includeL))),c=[0,1].map((e=>void 0!==o[e])),n=t.map((e=>void 0===e?void 0:[reflectPoint(e,a[0][0]),reflectPoint(e,a[0][1])])),i=n.map((e=>void 0!==e&&(overlapLinePoint({vector:subtract2(a[1][1],a[1][0]),origin:a[1][0]},e[0],includeS)||overlapLinePoint({vector:subtract2(a[1][1],a[1][0]),origin:a[1][0]},e[1],includeS)||overlapLinePoint({vector:subtract2(e[1],e[0]),origin:e[0]},a[1][0],includeS)||overlapLinePoint({vector:subtract2(e[1],e[0]),origin:e[0]},a[1][1],includeS))));return[0,1].map((e=>!0===i[e]&&!0===c[e]))},validateAxiom4=(e,t,r,s)=>{const a={vector:rotate90(r.vector),origin:s},o=intersectLineLine(r,a).point;return o?[[s,o].map((t=>overlapConvexPolygonPoint(e,t,include).overlap)).reduce(((e,t)=>e&&t),!0)]:[!1]},validateAxiom5=(e,t,r,s,a)=>{if(0===t.length)return[];const o=[s,a].map((t=>overlapConvexPolygonPoint(e,t,include).overlap)).reduce(((e,t)=>e&&t),!0),c=t.map((e=>reflectPoint(e,a))).map((t=>overlapConvexPolygonPoint(e,t,include).overlap));return c.map((e=>e&&o))},validateAxiom6=function(e,t,r,s,a,o){if(0===t.length)return[];if(![a,o].map((t=>overlapConvexPolygonPoint(e,t,include).overlap)).reduce(((e,t)=>e&&t),!0))return t.map((()=>!1));const c=t.map((e=>reflectPoint(e,a))).map((t=>overlapConvexPolygonPoint(e,t,include).overlap)),n=t.map((e=>reflectPoint(e,o))).map((t=>overlapConvexPolygonPoint(e,t,include).overlap));return t.map(((e,t)=>c[t]&&n[t]))},validateAxiom7=(e,t,r,s,a)=>{const o=overlapConvexPolygonPoint(e,a,include).overlap;if(!t.length)return[!1];const c=reflectPoint(t[0],a),n=overlapConvexPolygonPoint(e,c,include).overlap,i=intersectPolygonLine(e,s,includeL).length>=2,l=intersectLineLine(s,t[0],includeL,includeL).point,d=!!l&&overlapConvexPolygonPoint(e,l,include).overlap;return[o&&n&&i&&d]};var N=Object.freeze({__proto__:null,validateAxiom1And2:validateAxiom1And2,validateAxiom3:validateAxiom3,validateAxiom4:validateAxiom4,validateAxiom5:validateAxiom5,validateAxiom6:validateAxiom6,validateAxiom7:validateAxiom7});var R=Object.freeze({__proto__:null,axiom1InPolygon:(e,t,r)=>{const s=validateAxiom1And2(e,t,r);return axiom1(t,r).filter(((e,t)=>s[t]))},axiom2InPolygon:(e,t,r)=>{const s=validateAxiom1And2(e,t,r);return axiom2(t,r).filter(((e,t)=>s[t]))},axiom3InPolygon:(e,t,r)=>{const s=axiom3(t,r),a=validateAxiom3(e,s,t,r);return s.filter(((e,t)=>a[t]))},axiom4InPolygon:(e,t,r)=>{const s=axiom4(t,r),a=validateAxiom4(e,0,t,r);return s.filter(((e,t)=>a[t]))},axiom5InPolygon:(e,t,r,s)=>{const a=axiom5(t,r,s),o=validateAxiom5(e,a,0,r,s);return a.filter(((e,t)=>o[t]))},axiom6InPolygon:(e,t,r,s,a)=>{const o=axiom6(t,r,s,a),c=validateAxiom6(e,o,0,0,s,a);return o.filter(((e,t)=>c[t]))},axiom7InPolygon:(e,t,r,s)=>{const a=axiom7(t,r,s),o=validateAxiom7(e,a,0,r,s);return a.filter(((e,t)=>o[t]))},normalAxiom1InPolygon:(e,t,r)=>{const s=validateAxiom1And2(e,t,r);return normalAxiom1(t,r).filter(((e,t)=>s[t]))},normalAxiom2InPolygon:(e,t,r)=>{const s=validateAxiom1And2(e,t,r);return normalAxiom2(t,r).filter(((e,t)=>s[t]))},normalAxiom3InPolygon:(e,t,r)=>{const s=normalAxiom3(t,r),a=validateAxiom3(e,s.map(uniqueLineToVecLine),uniqueLineToVecLine(t),uniqueLineToVecLine(r));return s.filter(((e,t)=>a[t]))},normalAxiom4InPolygon:(e,t,r)=>{const s=normalAxiom4(t,r),a=validateAxiom4(e,s.map(uniqueLineToVecLine),uniqueLineToVecLine(t),r);return s.filter(((e,t)=>a[t]))},normalAxiom5InPolygon:(e,t,r,s)=>{const a=normalAxiom5(t,r,s),o=validateAxiom5(e,a.map(uniqueLineToVecLine),uniqueLineToVecLine(t),r,s);return a.filter(((e,t)=>o[t]))},normalAxiom6InPolygon:(e,t,r,s,a)=>{const o=normalAxiom6(t,r,s,a),c=validateAxiom6(e,o.map(uniqueLineToVecLine),uniqueLineToVecLine(t),uniqueLineToVecLine(r),s,a);return o.filter(((e,t)=>c[t]))},normalAxiom7InPolygon:(e,t,r,s)=>{const a=normalAxiom7(t,r,s),o=validateAxiom7(e,a.map(uniqueLineToVecLine),uniqueLineToVecLine(t),uniqueLineToVecLine(r),s);return a.filter(((e,t)=>o[t]))}}),L={...V,...R,...N};const I="Rabbit Ear",makePairsMap=(e,t)=>{const r={};return(t||e.map(((e,t)=>t))).forEach((t=>e[t].map(((e,t,r)=>[0,1].map((e=>(t+e)%r.length)).map((e=>r[e])).join(" "))).forEach((e=>{r[e]=t})))),r},makeVerticesToEdge=({edges_vertices:e},t)=>makePairsMap(e,t),makeVerticesToFace=({faces_vertices:e},t)=>makePairsMap(e,t),makeEdgesToFace=({faces_edges:e},t)=>makePairsMap(e,t);var U=Object.freeze({__proto__:null,makeEdgesToFace:makeEdgesToFace,makeVerticesToEdge:makeVerticesToEdge,makeVerticesToFace:makeVerticesToFace});const makeVerticesEdgesUnsorted=({edges_vertices:e})=>{const t=[];return e.forEach(((e,r)=>e.forEach((e=>{void 0===t[e]&&(t[e]=[]),t[e].push(r)})))),t},makeVerticesEdges=({edges_vertices:e,vertices_vertices:t})=>{const r=makeVerticesToEdge({edges_vertices:e});return t.map(((e,t)=>e.map((e=>r[`${t} ${e}`]))))};var D=Object.freeze({__proto__:null,makeVerticesEdges:makeVerticesEdges,makeVerticesEdgesUnsorted:makeVerticesEdgesUnsorted});const uniqueElements=e=>Array.from(new Set(e)),uniqueSortedNumbers=e=>{const t={};return e.forEach((e=>{t[e]=!0})),Object.keys(t).map(parseFloat)},epsilonUniqueSortedNumbers=(e,t=p)=>{const r=e.slice().sort(((e,t)=>e-t));if(r.length<2)return r;const s=[!0];for(let e=1;e<r.length;e+=1)s[e]=!epsilonEqual(r[e],r[e-1],t);return r.filter(((e,t)=>s[t]))},rotateCircularArray=(e,t)=>t<=0?e:e.slice(t).concat(e.slice(0,t)),splitCircularArray$1=(e,t)=>(t.sort(((e,t)=>e-t)),[e.slice(t[1]).concat(e.slice(0,t[0]+1)),e.slice(t[0],t[1]+1)]),chooseTwoPairs=e=>{const t=Array(e.length*(e.length-1)/2);let r=0;for(let s=0;s<e.length-1;s+=1)for(let a=s+1;a<e.length;a+=1,r+=1)t[r]=[e[s],e[a]];return t},setDifferenceSortedEpsilonNumbers=(e,t,r=p)=>{const s=[];let a=0,o=0;for(;a<e.length&&o<t.length;)epsilonEqual(e[a],t[o],r)?a+=1:e[a]>t[o]?o+=1:t[o]>e[a]&&(s.push(e[a]),a+=1);return s},arrayMinimumIndex=(e,t)=>{if(!e.length)return;const r="function"==typeof t?e.map((e=>t(e))):e;let s=0;return r.forEach(((e,t,r)=>{e<r[s]&&(s=t)})),s},arrayMaximumIndex=(e,t)=>{if(!e.length)return;const r="function"==typeof t?e.map((e=>t(e))):e;let s=0;return r.forEach(((e,t,r)=>{e>r[s]&&(s=t)})),s},mergeArraysWithHoles=(...e)=>{const t=[];return e.forEach((e=>e.forEach(((e,r)=>{t[r]=e})))),t},clustersToReflexiveArrays=e=>{const t=[];return e.flat().forEach((e=>{t[e]=[]})),e.flatMap(chooseTwoPairs).forEach((([e,r])=>{t[e].push(r),t[r].push(e)})),t},arrayArrayToLookupArray=e=>e.map((e=>{const t=[];return e.forEach((e=>{t[e]=!0})),t}));var Q=Object.freeze({__proto__:null,arrayArrayToLookupArray:arrayArrayToLookupArray,arrayIntersection:(e,t)=>{const r={};return t.forEach((e=>{r[e]=0})),t.forEach((e=>{r[e]+=1})),e.filter((e=>r[e]>0&&(r[e]-=1,!0)))},arrayMaximumIndex:arrayMaximumIndex,arrayMinimumIndex:arrayMinimumIndex,chooseTwoPairs:chooseTwoPairs,clustersToReflexiveArrays:clustersToReflexiveArrays,epsilonUniqueSortedNumbers:epsilonUniqueSortedNumbers,lookupArrayToArrayArray:e=>e.map((e=>e.map(((e,t)=>e?t:void 0)).filter((e=>void 0!==e)))),mergeArraysWithHoles:mergeArraysWithHoles,nonUniqueElements:e=>{const t={};return e.forEach((e=>{void 0===t[e]&&(t[e]=0),t[e]+=1})),e.filter((e=>t[e]>1))},rotateCircularArray:rotateCircularArray,setDifferenceSortedEpsilonNumbers:setDifferenceSortedEpsilonNumbers,setDifferenceSortedNumbers:(e,t)=>{const r=[];let s=0,a=0;for(;s<e.length&&a<t.length;)e[s]===t[a]?s+=1:e[s]>t[a]?a+=1:t[a]>e[s]&&(r.push(e[s]),s+=1);return r},splitCircularArray:splitCircularArray$1,uniqueElements:uniqueElements,uniqueSortedNumbers:uniqueSortedNumbers});const edgeifyFaces=({vertices_coords:e,faces_vertices:t},r=0)=>t.map((t=>[t.reduce(((t,s)=>e[t][r]<e[s][r]?t:s)),t.reduce(((t,s)=>e[t][r]>e[s][r]?t:s))])),sweepValues=({edges_vertices:e,vertices_edges:t},r,s=p)=>{t||(t=makeVerticesEdgesUnsorted({edges_vertices:e}));const a=e.map((e=>e.map((e=>r[e])))),o=a.map((([e,t])=>epsilonEqual(e,t,s))),c=a.map((([e,t])=>Math.sign(e-t))),n=e.map((([e,t],r)=>o[r]?{[e]:0,[t]:0}:{[e]:c[r],[t]:-c[r]}));return clusterScalars(r,s).map((e=>e.filter((e=>t[e])))).filter((e=>e.length)).map((e=>({vertices:e,t:e.reduce(((e,t)=>e+r[t]),0)/e.length,start:uniqueElements(e.flatMap((e=>t[e].filter((t=>n[t][e]<=0))))),end:uniqueElements(e.flatMap((e=>t[e].filter((t=>n[t][e]>=0)))))})))},sweepEdges=({vertices_coords:e,edges_vertices:t,vertices_edges:r},s=0,a=p)=>sweepValues({edges_vertices:t,vertices_edges:r},e.map((e=>e[s])),a),sweepFaces=({vertices_coords:e,faces_vertices:t},r=0,s=p)=>sweepValues({edges_vertices:edgeifyFaces({vertices_coords:e,faces_vertices:t},r)},e.map((e=>e[r])),s);var W=Object.freeze({__proto__:null,sweep:({vertices_coords:e,edges_vertices:t,faces_vertices:r},s=0,a=p)=>{const o=e.map((e=>e[s])),c=edgeifyFaces({vertices_coords:e,faces_vertices:r},s),n=makeVerticesEdgesUnsorted({edges_vertices:t}),i=makeVerticesEdgesUnsorted({edges_vertices:c}),l=t.map((e=>e.map((e=>o[e])))),d=c.map((e=>e.map((e=>o[e])))),_=l.map((([e,t])=>epsilonEqual(e,t,a))),m=d.map((([e,t])=>epsilonEqual(e,t,a))),g=l.map((([e,t])=>Math.sign(e-t))),v=d.map((([e,t])=>Math.sign(e-t))),u=t.map((([e,t],r)=>_[r]?{[e]:0,[t]:0}:{[e]:g[r],[t]:-g[r]})),h=r.map((([e,t],r)=>m[r]?{[e]:0,[t]:0}:{[e]:v[r],[t]:-v[r]}));return clusterScalars(o,a).map((e=>({vertices:e,t:e.reduce(((e,t)=>e+o[t]),0)/e.length,edges:{start:uniqueElements(e.filter((e=>void 0!==n[e])).flatMap((e=>n[e].filter((t=>u[t][e]<=0))))),end:uniqueElements(e.filter((e=>void 0!==n[e])).flatMap((e=>n[e].filter((t=>u[t][e]>=0)))))},faces:{start:uniqueElements(e.filter((e=>void 0!==i[e])).flatMap((e=>i[e].filter((t=>h[t][e]<=0))))),end:uniqueElements(e.filter((e=>void 0!==i[e])).flatMap((e=>i[e].filter((t=>h[t][e]>=0)))))}})))},sweepEdges:sweepEdges,sweepFaces:sweepFaces,sweepValues:sweepValues,sweepVertices:({vertices_coords:e},t=0,r=p)=>clusterScalars(e.map((e=>e[t])),r).map((r=>({vertices:r,t:r.reduce(((r,s)=>r+e[s][t]),0)/r.length})))});const doEdgesOverlap=({vertices_coords:e,edges_vertices:t},r=p)=>{const s=(({vertices_coords:e,edges_vertices:t},r=0)=>t.map((t=>t.map((t=>e[t])))).map((([e,t])=>[Math.min(e[1],t[1])-r,Math.max(e[1],t[1])+r])).map((e=>epsilonEqual(e[0],e[1],Math.abs(2.5*r))?void 0:e)))({vertices_coords:e,edges_vertices:t},-r),a=e.map(resize2),o=t.map((e=>[a[e[0]],a[e[1]]])).map((([e,t])=>pointsToLine2(e,t))),c=[],n=sweepEdges({vertices_coords:e,edges_vertices:t});try{n.forEach((({start:e,end:t})=>{e.forEach((e=>{c[e]=!0})),Object.keys(c).map((e=>parseInt(e,10))).forEach((t=>e.forEach((e=>{if(t!==e&&(!s[t]||!s[e]||doRangesOverlap(s[t],s[e]))&&intersectLineLine(o[t],o[e],excludeS,excludeS,r).point)throw new Error})))),t.forEach((e=>{delete c[e]}))}))}catch(e){return!0}return!1};var q=Object.freeze({__proto__:null,doEdgesOverlap:doEdgesOverlap});const G={file:["file_spec","file_creator","file_author","file_title","file_description","file_classes","file_frames"],frame:["frame_author","frame_title","frame_description","frame_attributes","frame_classes","frame_unit","frame_parent","frame_inherit"],graph:["vertices_coords","vertices_vertices","vertices_edges","vertices_faces","edges_vertices","edges_faces","edges_assignment","edges_foldAngle","edges_length","faces_vertices","faces_edges","faces_faces"],orders:["edgeOrders","faceOrders"]},H=["vertices","edges","faces"],J=Array.from("BbMmVvFfJjCcUu"),Z={B:"boundary",M:"mountain",V:"valley",F:"flat",J:"join",C:"cut",U:"unassigned"};Object.keys(Z).forEach((e=>{Z[e.toLowerCase()]=Z[e]}));const Y={B:0,b:0,M:-180,m:-180,V:180,v:180,F:0,f:0,J:0,j:0,C:0,c:0,U:0,u:0},X={B:!1,b:!1,M:!0,m:!0,V:!0,v:!0,F:!1,f:!1,J:!1,j:!1,C:!1,c:!1,U:!0,u:!0},K={B:!0,b:!0,M:!1,m:!1,V:!1,v:!1,F:!1,f:!1,J:!1,j:!1,C:!0,c:!0,U:!1,u:!1},edgeAssignmentToFoldAngle=e=>Y[e]||0,edgeFoldAngleToAssignment=e=>e>p?"V":e<-p?"M":"U",edgeFoldAngleIsFlatFolded=e=>epsilonEqual(-180,e)||epsilonEqual(180,e),edgeFoldAngleIsFlat=e=>epsilonEqual(0,e)||edgeFoldAngleIsFlatFolded(e),edgesFoldAngleAreAllFlat=({edges_foldAngle:e})=>{if(!e)return!0;for(let t=0;t<e.length;t+=1)if(!edgeFoldAngleIsFlat(e[t]))return!1;return!0},filterKeys=(e,t)=>Object.keys(e).filter((e=>t(e))),filterKeysWithPrefix=(e,t)=>filterKeys(e,(e=>e.substring(0,t.length+1)===`${t}_`)),filterKeysWithSuffix=(e,t)=>filterKeys(e,(e=>e.substring(e.length-t.length-1,e.length)===`_${t}`)),getAllPrefixes=e=>{const t={};return Object.keys(e).filter((e=>e.includes("_"))).map((e=>e.substring(0,e.indexOf("_")))).forEach((e=>{t[e]=!0})),Object.keys(t)},getAllSuffixes=e=>{const t={};return Object.keys(e).filter((e=>e.includes("_"))).map((e=>e.substring(e.lastIndexOf("_")+1,e.length))).forEach((e=>{t[e]=!0})),Object.keys(t)},ee=Object.freeze([].concat(G.file).concat(G.frame).concat(G.graph).concat(G.orders)),getDimensionQuick=({vertices_coords:e})=>{if(!e||!e.length)return;if(void 0!==e[0])return e[0].length;const t=e.filter((()=>!0)).shift();return t?t.length:void 0},isFoldedForm=({vertices_coords:e,edges_vertices:t,faces_vertices:r,faces_edges:s,frame_classes:a,file_classes:o},c=p)=>{if(a&&a.includes("foldedForm")||o&&o.includes("foldedForm"))return!0;if(a&&a.includes("creasePattern")||o&&o.includes("creasePattern"))return!1;if(!e)return!1;const n=getDimensionQuick({vertices_coords:e});if(!r&&!s)return 3===n;if(t&&2===n)return doEdgesOverlap({vertices_coords:e,edges_vertices:t});for(let t=0;t<e.length;t+=1)if(e[t]&&"number"==typeof e[t][2]&&!epsilonEqual(e[t][2],0,c))return!0;return 3===n},makeEdgesIsFolded=({edges_vertices:e,edges_foldAngle:t,edges_assignment:r})=>void 0===r?void 0===t?e.map((()=>!0)):t.map((e=>e<-p||e>p)):r.map((e=>X[e])),te={M:"V",m:"v",V:"M",v:"m"},invertAssignment=e=>te[e]||e,invertAssignments=e=>(e.edges_assignment&&(e.edges_assignment=e.edges_assignment.map((e=>te[e]?te[e]:e))),e.edges_foldAngle&&(e.edges_foldAngle=e.edges_foldAngle.map((e=>-e))),e),sortEdgesByAssignment=({edges_vertices:e,edges_assignment:t=[]})=>{const r=Array.from(new Set(J.map((e=>e.toUpperCase())))),s=e.map(((e,r)=>t[r]||"U")).map((e=>e.toUpperCase())),a={};return r.forEach((e=>{a[e]=[]})),s.forEach(((e,t)=>a[e].push(t))),a};var re=Object.freeze({__proto__:null,VEF:H,assignmentCanBeFolded:X,assignmentFlatFoldAngle:Y,assignmentIsBoundary:K,edgeAssignmentToFoldAngle:edgeAssignmentToFoldAngle,edgeFoldAngleIsFlat:edgeFoldAngleIsFlat,edgeFoldAngleIsFlatFolded:edgeFoldAngleIsFlatFolded,edgeFoldAngleToAssignment:edgeFoldAngleToAssignment,edgesAssignmentNames:Z,edgesAssignmentValues:J,edgesFoldAngleAreAllFlat:edgesFoldAngleAreAllFlat,filterKeysWithPrefix:filterKeysWithPrefix,filterKeysWithSuffix:filterKeysWithSuffix,foldFileClasses:["singleModel","multiModel","animation","diagrams"],foldFrameAttributes:["2D","3D","abstract","manifold","nonManifold","orientable","nonOrientable","selfTouching","nonSelfTouching","selfIntersecting","nonSelfIntersecting"],foldFrameClasses:["creasePattern","foldedForm","graph","linkage"],foldKeys:G,getAllPrefixes:getAllPrefixes,getAllSuffixes:getAllSuffixes,getDimension:({vertices_coords:e},t=p)=>{for(let r=0;r<e.length;r+=1)if(e[r]&&3===e[r].length&&!epsilonEqual(0,e[r][2],t))return 3;return 2},getDimensionQuick:getDimensionQuick,getFileMetadata:(e={})=>{const t={};return G.file.filter((e=>"file_frames"!==e)).filter((t=>void 0!==e[t])).forEach((r=>{t[r]=e[r]})),t},invertAssignment:invertAssignment,invertAssignments:invertAssignments,isFoldObject:(e={})=>0===Object.keys(e).length?0:ee.filter((t=>e[t])).length/Object.keys(e).length,isFoldedForm:isFoldedForm,makeEdgesIsFolded:makeEdgesIsFolded,sortEdgesByAssignment:sortEdgesByAssignment,transposeGraphArrayAtIndex:(e,t,r)=>{const s=filterKeysWithPrefix(e,t);if(0===s.length)return;const a={};return s.forEach((t=>{a[t]=e[t][r]})),a},transposeGraphArrays:(e,t)=>{const r=filterKeysWithPrefix(e,t);if(0===r.length)return[];const s=Math.max(...r.map((t=>e[t].length))),a=Array.from(Array(s)).map((()=>({})));return r.forEach((t=>a.forEach(((r,s)=>{a[s][t]=e[t][s]})))),a}});const se={edges:"edgeOrders",faces:"faceOrders"},maxArraysLength=e=>Math.max(0,...e.filter((e=>void 0!==e)).map((e=>e.length))),count=(e,t)=>maxArraysLength(filterKeysWithPrefix(e,t).map((t=>e[t]))),countEdges=({edges_vertices:e,edges_faces:t})=>maxArraysLength([e,t]),countImplied=(e,t)=>Math.max((e=>{let t=-1;return e.filter((e=>void 0!==e)).forEach((e=>e.forEach((e=>e.forEach((e=>{e>t&&(t=e)})))))),t})(filterKeysWithSuffix(e,t).map((t=>e[t]))),e[se[t]]?(e=>{let t=-1;return e.forEach((e=>{e[0]>t&&(t=e[0]),e[1]>t&&(t=e[1])})),t})(e[se[t]]):-1)+1,countImpliedVertices=e=>countImplied(e,"vertices"),countImpliedEdges=e=>countImplied(e,"edges");var ae=Object.freeze({__proto__:null,count:count,countEdges:countEdges,countFaces:({faces_vertices:e,faces_edges:t,faces_faces:r})=>maxArraysLength([e,t,r]),countImplied:countImplied,countImpliedEdges:countImpliedEdges,countImpliedFaces:e=>countImplied(e,"faces"),countImpliedVertices:countImpliedVertices,countVertices:({vertices_coords:e,vertices_vertices:t,vertices_edges:r,vertices_faces:s})=>maxArraysLength([e,t,r,s])});const makeVerticesFacesUnsorted=({vertices_coords:e,vertices_edges:t,faces_vertices:r})=>{const s=e||t;if(!r)return(s||[]).map((()=>[]));const a=void 0!==s?s.map((()=>[])):Array.from(Array(countImpliedVertices({faces_vertices:r}))).map((()=>[]));return r.forEach(((e,t)=>{const r=[];e.forEach((e=>{r[e]=t})),r.forEach(((e,t)=>a[t].push(e)))})),a},makeVerticesFaces=({vertices_coords:e,vertices_vertices:t,faces_vertices:r})=>{if(!r)return e.map((()=>[]));if(!t)return makeVerticesFacesUnsorted({vertices_coords:e,faces_vertices:r});const s=makeVerticesToFace({faces_vertices:r});return t.map(((e,t)=>e.map((e=>[t,e].join(" "))))).map((e=>e.map((e=>s[e]))))};var oe=Object.freeze({__proto__:null,makeVerticesFaces:makeVerticesFaces,makeVerticesFacesUnsorted:makeVerticesFacesUnsorted});const projectPointOnPlane=(e,t=[1,0,0],r=[0,0,0])=>{const s=resize3(e),a=subtract3(s,resize3(r)),o=normalize3(resize3(t)),c=dot3(o,a),n=scale3$1(o,c);return subtract3(s,n)};var ce=Object.freeze({__proto__:null,projectPointOnPlane:projectPointOnPlane});const sortPointsAlongVector=(e,t)=>{return r=t,s=dot,e.map(((e,t)=>({i:t,n:s(e,r)}))).sort(((e,t)=>e.n-t.n)).map((e=>e.i));var r,s},radialSortUnitVectors2=e=>{const t=[[],[]];e.map((e=>e[1]>=0?0:1)).forEach(((e,r)=>t[e].push(r)));const r=[(t,r)=>e[r][0]-e[t][0],(t,r)=>e[t][0]-e[r][0]];return t.flatMap(((e,t)=>e.sort(r[t])))},radialSortVectors3=(e,t=[1,0,0],r=[0,0,0])=>{const s=basisVectors3(t),a=[s[1],s[2],s[0]],o=e.map((e=>projectPointOnPlane(e,t,r))).map((e=>subtract(e,r))).map((e=>[dot(e,a[0]),dot(e,a[1])])).map(normalize2);return radialSortUnitVectors2(o)};var ne=Object.freeze({__proto__:null,radialSortUnitVectors2:radialSortUnitVectors2,radialSortVectors3:radialSortVectors3,sortPointsAlongVector:sortPointsAlongVector});const sortVerticesCounterClockwise=({vertices_coords:e},t,r)=>t.map((t=>e[t])).map((t=>subtract(t,e[r]))).map((e=>Math.atan2(e[1],e[0]))).map((e=>e>-p?e:e+2*Math.PI)).map(((e,t)=>({a:e,i:t}))).sort(((e,t)=>e.a-t.a)).map((e=>e.i)).map((e=>t[e]));var ie=Object.freeze({__proto__:null,sortVerticesAlongVector:({vertices_coords:e},t,r)=>sortPointsAlongVector(t.map((t=>e[t])),r).map((e=>t[e])),sortVerticesCounterClockwise:sortVerticesCounterClockwise});const makeVerticesVertices2D=({vertices_coords:e,vertices_edges:t,edges_vertices:r})=>{t||(t=makeVerticesEdgesUnsorted({edges_vertices:r}));const s=t.map(((e,t)=>e.map((e=>r[e].filter((e=>e!==t)))).reduce(((e,t)=>e.concat(t)),[])));return void 0===e?s:s.map(((t,r)=>sortVerticesCounterClockwise({vertices_coords:e},t,r)))},makeVerticesVerticesFromFaces=({vertices_coords:e,vertices_faces:t,faces_vertices:r})=>{t||(t=makeVerticesFacesUnsorted({vertices_coords:e,faces_vertices:r}));const s=t.map((e=>e.map((e=>r[e])))),a=s.map(((e,t)=>e.map((e=>e.indexOf(t))))),o=s.map(((e,t)=>e.map(((e,r)=>[(a[t][r]+e.length-1)%e.length,a[t][r],(a[t][r]+1)%e.length])))),c=o.map(((e,t)=>e.map(((e,r)=>e.map((e=>s[t][r][e])))))),n=c.map((e=>{const t=e.map((e=>[[0,1],[1,2]].map((t=>t.map((t=>e[t])).join(" "))))),r={},s={};return t.forEach(((e,t)=>{r[e[0]]=t,s[e[1]]=t})),{facesVerts:t,to:s,from:r}}));return n.map((e=>{const t=Object.keys(e.to),r=t.map((e=>e.split(" ").reverse().join(" "))),s=t.filter(((t,s)=>!(r[s]in e.from)));if(s.length>2)return console.warn("vertices_vertices found an unsolvable vertex"),[];const a=s.length?s:[t[0]],o=[],c={};for(let t=0;t<a.length;t+=1){const r=a[t],s=[r];c[r]=!0;let n=!1;do{const t=s[s.length-1],r=e.to[t];if(!(r in e.facesVerts))break;let a;if(e.facesVerts[r][0]===t&&(a=e.facesVerts[r][1]),e.facesVerts[r][1]===t&&(a=e.facesVerts[r][0]),void 0===a)return[];const o=a.split(" ").reverse().join(" ");s.push(a),n=o in c,n||s.push(o),c[a]=!0,c[o]=!0}while(!n);const i=s.filter(((e,t)=>t%2==0)).map((e=>e.split(" ")[1])).map((e=>parseInt(e,10)));o.push(...i)}return o}))},makeVerticesVertices=e=>{if(!e.vertices_coords||!e.vertices_coords.length)return[];return 3===e.vertices_coords.filter((()=>!0)).shift().length?makeVerticesVerticesFromFaces(e):makeVerticesVertices2D(e)},makeVerticesVerticesUnsorted=({vertices_edges:e,edges_vertices:t})=>(e||(e=makeVerticesEdgesUnsorted({edges_vertices:t})),e.map(((e,r)=>e.flatMap((e=>t[e].filter((e=>e!==r)))))));var le=Object.freeze({__proto__:null,makeVerticesVertices:makeVerticesVertices,makeVerticesVertices2D:makeVerticesVertices2D,makeVerticesVerticesFromFaces:makeVerticesVerticesFromFaces,makeVerticesVerticesUnsorted:makeVerticesVerticesUnsorted});const makeFacesVerticesFromEdges=({edges_vertices:e,faces_edges:t})=>t.map((t=>t.map((t=>e[t])).map(((e,t,r)=>{const s=r[(t+1)%r.length];return e[0]===s[0]||e[0]===s[1]?e[1]:e[0]}))));var fe=Object.freeze({__proto__:null,makeFacesVerticesFromEdges:makeFacesVerticesFromEdges});const makeFacesEdgesFromVertices=({edges_vertices:e,faces_vertices:t})=>{const r=makeVerticesToEdge({edges_vertices:e});return t.map((e=>e.map(((e,t,r)=>[e,r[(t+1)%r.length]].join(" "))))).map((e=>e.map((e=>r[e]))))};var de=Object.freeze({__proto__:null,makeFacesEdgesFromVertices:makeFacesEdgesFromVertices});const angleArray=e=>Array.from(Array(Math.floor(e))).map(((t,r)=>b*(r/e))),anglesToVecs=(e,t)=>e.map((e=>[t*Math.cos(e),t*Math.sin(e)])),makePolygonCircumradius=(e=3,t=1)=>anglesToVecs(angleArray(e),t),makePolygonCircumradiusSide=(e=3,t=1)=>{const r=Math.PI/e,s=angleArray(e).map((e=>e+r));return anglesToVecs(s,t)},makePolygonNonCollinear=(e,t=p)=>{const r=e.map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>subtract(e[1],e[0]))).map(((e,t,r)=>[e,r[(t+r.length-1)%r.length]])).map((e=>!parallel(e[1],e[0],t)));return e.filter(((e,t)=>r[t]))},makePolygonNonCollinear3=(e,t=p)=>{const r=e.map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>subtract3(e[1],e[0]))).map(((e,t,r)=>[e,r[(t+r.length-1)%r.length]])).map((e=>!parallel(e[1],e[0],t)));return e.filter(((e,t)=>r[t]))},signedArea=e=>.5*e.map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((([e,t])=>cross2(e,t))).reduce(((e,t)=>e+t),0),centroid=e=>{const t=1/(6*signedArea(e)),r=e.map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((([e,t])=>scale2$1(add2(e,t),cross2(e,t)))).reduce(((e,t)=>add2(e,t)),[0,0]);return[r[0]*t,r[1]*t]},boundingBox$1=(e,t=0)=>{if(!e||!e.length)return;const r=(e=>{for(let t=0;t<e.length;t+=1)if(e[t]&&e[t].length)return e[t].length;return 0})(e),s=Array(r).fill(1/0),a=Array(r).fill(-1/0);e.filter((e=>void 0!==e)).forEach((e=>e.forEach(((e,r)=>{e<s[r]&&(s[r]=e-t),e>a[r]&&(a[r]=e+t)}))));const o=a.map(((e,t)=>e-s[t]));return{min:s,max:a,span:o}};var _e=Object.freeze({__proto__:null,boundingBox:boundingBox$1,centroid:centroid,makePolygonCircumradius:makePolygonCircumradius,makePolygonCircumradiusSide:makePolygonCircumradiusSide,makePolygonInradius:(e=3,t=1)=>makePolygonCircumradius(e,t/Math.cos(Math.PI/e)),makePolygonInradiusSide:(e=3,t=1)=>makePolygonCircumradiusSide(e,t/Math.cos(Math.PI/e)),makePolygonNonCollinear:makePolygonNonCollinear,makePolygonNonCollinear3:makePolygonNonCollinear3,makePolygonSideLength:(e=3,t=1)=>makePolygonCircumradius(e,t/2/Math.sin(Math.PI/e)),makePolygonSideLengthSide:(e=3,t=1)=>makePolygonCircumradiusSide(e,t/2/Math.sin(Math.PI/e)),signedArea:signedArea});const makeEdgesCoords=({vertices_coords:e,edges_vertices:t})=>t.map((t=>[e[t[0]],e[t[1]]])),makeEdgesVector=({vertices_coords:e,edges_vertices:t})=>{const r=2===getDimensionQuick({vertices_coords:e})?resize2:resize3;return makeEdgesCoords({vertices_coords:e,edges_vertices:t}).map((([e,t])=>r(subtract(t,e))))},makeEdgesLength=({vertices_coords:e,edges_vertices:t})=>makeEdgesVector({vertices_coords:e,edges_vertices:t}).map(magnitude);var me=Object.freeze({__proto__:null,makeEdgesBoundingBox:({vertices_coords:e,edges_vertices:t},r)=>makeEdgesCoords({vertices_coords:e,edges_vertices:t}).map((e=>boundingBox$1(e,r))),makeEdgesCoords:makeEdgesCoords,makeEdgesLength:makeEdgesLength,makeEdgesVector:makeEdgesVector});const walkSingleFace=({vertices_vertices:e,vertices_sectors:t},r,s,a={})=>{const o={};let c=r,n=s;const i={vertices:[r],edges:[`${r} ${s}`],angles:[]};for(;;){const r=e[n],s=(r.indexOf(c)+r.length-1)%r.length,l=r[s],d=`${n} ${l}`;if(a[d])return;if(o[d])return Object.assign(a,o),i.vertices.pop(),i.edges.pop(),i.angles.length||delete i.angles,i;o[d]=!0,i.vertices.push(n),i.edges.push(d),t&&i.angles.push(t[n][s]),c=n,n=l}},walkPlanarFaces=({vertices_vertices:e,vertices_sectors:t})=>{const r={},s={vertices_vertices:e,vertices_sectors:t};return e.flatMap(((e,t)=>e.map((e=>walkSingleFace(s,t,e,r))).filter((e=>void 0!==e))))},filterWalkedBoundaryFace=e=>e.filter((e=>e.angles.map((e=>Math.PI-e)).reduce(((e,t)=>e+t),0)>0));var ge=Object.freeze({__proto__:null,filterWalkedBoundaryFace:filterWalkedBoundaryFace,walkPlanarFaces:walkPlanarFaces,walkSingleFace:walkSingleFace});const makeVerticesVerticesVector=({vertices_coords:e,vertices_vertices:t,vertices_edges:r,vertices_faces:s,edges_vertices:a,edges_vector:o,faces_vertices:c})=>{o||(o=makeEdgesVector({vertices_coords:e,edges_vertices:a})),t||(t=makeVerticesVertices({vertices_coords:e,vertices_edges:r,vertices_faces:s,edges_vertices:a,faces_vertices:c}));const n={};return a.map((e=>e.join(" "))).forEach(((e,t)=>{n[e]=t})),t.map(((e,r)=>t[r].map((e=>{const t=n[`${r} ${e}`],s=n[`${e} ${r}`];return void 0!==t?resize2(o[t]):void 0!==s?flip2(o[s]):void 0}))))},makeVerticesSectors=({vertices_coords:e,vertices_vertices:t,edges_vertices:r,edges_vector:s})=>makeVerticesVerticesVector({vertices_coords:e,vertices_vertices:t,edges_vertices:r,edges_vector:s}).map((e=>1===e.length?[b]:counterClockwiseSectors2(e)));var ve=Object.freeze({__proto__:null,makeVerticesSectors:makeVerticesSectors,makeVerticesVerticesVector:makeVerticesVerticesVector});const makePlanarFaces=({vertices_coords:e,vertices_vertices:t,vertices_edges:r,vertices_sectors:s,edges_vertices:a,edges_vector:o})=>{t||(t=makeVerticesVertices({vertices_coords:e,edges_vertices:a,vertices_edges:r})),s||(s=makeVerticesSectors({vertices_coords:e,vertices_vertices:t,edges_vertices:a,edges_vector:o}));const c=makeVerticesToEdge({edges_vertices:a}),n=filterWalkedBoundaryFace(walkPlanarFaces({vertices_vertices:t,vertices_sectors:s})).map((e=>({...e,edges:e.edges.map((e=>c[e]))})));return{faces_vertices:n.map((e=>e.vertices)),faces_edges:n.map((e=>e.edges)),faces_sectors:n.map((e=>e.angles))}},makeFacesPolygon=({vertices_coords:e,faces_vertices:t},r)=>t.map((t=>t.map((t=>e[t])))).map((e=>makePolygonNonCollinear(e,r))),makeFacesPolygonQuick=({vertices_coords:e,faces_vertices:t})=>t.map((t=>t.map((t=>e[t])))),makeFacesCenter2DQuick=({vertices_coords:e,faces_vertices:t})=>makeFacesPolygonQuick({vertices_coords:e,faces_vertices:t}).map((e=>e.map(resize2))).map((e=>average2(...e))),makeFacesCenter3DQuick=({vertices_coords:e,faces_vertices:t})=>makeFacesPolygonQuick({vertices_coords:e,faces_vertices:t}).map((e=>e.map(resize3))).map((e=>average3(...e))).map((e=>Number.isNaN(e[2])?[e[0],e[1],0]:e)),makeFacesCenterQuick=({vertices_coords:e,faces_vertices:t})=>2===getDimensionQuick({vertices_coords:e})?makeFacesCenter2DQuick({vertices_coords:e,faces_vertices:t}):makeFacesCenter3DQuick({vertices_coords:e,faces_vertices:t});var pe=Object.freeze({__proto__:null,makeFacesCenter2DQuick:makeFacesCenter2DQuick,makeFacesCenter3DQuick:makeFacesCenter3DQuick,makeFacesCenterQuick:makeFacesCenterQuick,makeFacesCentroid2D:({vertices_coords:e,faces_vertices:t})=>t.map((t=>t.map((t=>e[t])))).map((e=>e.map(resize2))).map((e=>centroid(e))),makeFacesPolygon:makeFacesPolygon,makeFacesPolygonQuick:makeFacesPolygonQuick,makePlanarFaces:makePlanarFaces});const makeEdgesFacesUnsorted=({edges_vertices:e,faces_vertices:t,faces_edges:r})=>{r||(r=makeFacesEdgesFromVertices({edges_vertices:e,faces_vertices:t}));const s=void 0!==e?e.map((()=>[])):Array.from(Array(countImpliedEdges({faces_edges:r}))).map((()=>[]));return r.forEach(((e,t)=>{const r=[];e.forEach((e=>{r[e]=t})),r.forEach(((e,t)=>s[t].push(e)))})),s};var ue=Object.freeze({__proto__:null,makeEdgesFaces:({vertices_coords:e,edges_vertices:t,edges_vector:r,faces_vertices:s,faces_edges:a,faces_center:o})=>{if(!t||!s&&!a)return makeEdgesFacesUnsorted({faces_edges:a});s||(s=makeFacesVerticesFromEdges({edges_vertices:t,faces_edges:a})),a||(a=makeFacesEdgesFromVertices({edges_vertices:t,faces_vertices:s})),r||(r=makeEdgesVector({vertices_coords:e,edges_vertices:t}));const c=t.map((t=>e[t[0]]));o||(o=makeFacesCenterQuick({vertices_coords:e,faces_vertices:s}));const n=t.map((()=>[]));return a.forEach(((e,t)=>{const r=[];e.forEach((e=>{r[e]=t})),r.forEach(((e,t)=>n[t].push(e)))})),n.forEach(((e,t)=>{const s=e.map((e=>o[e])).map((e=>subtract2(e,c[t]))).map((e=>cross2(e,r[t])));e.sort(((e,t)=>s[e]-s[t]))})),n},makeEdgesFacesUnsorted:makeEdgesFacesUnsorted});const makeFacesNormal=({vertices_coords:e,faces_vertices:t})=>{const r=e.map(resize3);return t.map((e=>e.map((e=>r[e])))).map((e=>{let t,r,s=0;do{t=subtract3(e[(s+1)%e.length],e[s]),r=subtract3(e[(s+2)%e.length],e[s]),s+=1}while(s<e.length&&parallel(t,r));return normalize3(cross3(t,r))}))},makeVerticesNormal=({vertices_coords:e,faces_vertices:t,faces_normal:r})=>{r||(r=makeFacesNormal({vertices_coords:e,faces_vertices:t}));const s=e.map((()=>[0,0,0]));return t.forEach(((e,t)=>e.forEach((e=>{s[e][0]+=r[t][0],s[e][1]+=r[t][1],s[e][2]+=r[t][2]})))),s.map((e=>normalize3(e)))};var he=Object.freeze({__proto__:null,makeFacesNormal:makeFacesNormal,makeVerticesNormal:makeVerticesNormal});const be={M:-180,m:-180,V:180,v:180},makeEdgesFoldAngle=({edges_assignment:e})=>e.map((e=>be[e]||0)),makeEdgesFoldAngleFromFaces=({vertices_coords:e,edges_vertices:t,edges_faces:r,edges_assignment:s,faces_vertices:o,faces_edges:c,faces_normal:i,faces_center:l})=>(r||(c||(c=makeFacesEdgesFromVertices({edges_vertices:t,faces_vertices:o})),r=makeEdgesFacesUnsorted({edges_vertices:t,faces_edges:c})),i||(i=makeFacesNormal({vertices_coords:e,faces_vertices:o})),l||(l=makeFacesCenterQuick({vertices_coords:e,faces_vertices:o})),r.map(((e,t)=>{if(e.length>2)throw new Error(a);if(e.length<2)return 0;const r=i[e[0]],o=i[e[1]],c=normalize$2(subtract(l[e[1]],l[e[0]]));let d=Math.sign(dot(r,c));if(0===d){if(!s||!s[t])throw new Error(n);"F"!==s[t]&&"F"!==s[t]||(d=0),"M"!==s[t]&&"m"!==s[t]||(d=-1),"V"!==s[t]&&"v"!==s[t]||(d=1)}return Math.acos(dot(r,o))*(180/Math.PI)*d})));var ye=Object.freeze({__proto__:null,makeEdgesFoldAngle:makeEdgesFoldAngle,makeEdgesFoldAngleFromFaces:makeEdgesFoldAngleFromFaces});const makeEdgesAssignmentSimple=({edges_foldAngle:e})=>e.map((e=>0===e?"F":e<0?"M":"V")),makeEdgesAssignment=({edges_vertices:e,edges_foldAngle:t,edges_faces:r,faces_vertices:s,faces_edges:a})=>(e&&!r&&(!a&&s&&(a=makeFacesEdgesFromVertices({edges_vertices:e,faces_vertices:s})),a&&(r=makeEdgesFacesUnsorted({edges_vertices:e,faces_edges:a}))),t?r?t.map(((e,t)=>r[t].length<2?"B":0===e?"F":e<0?"M":"V")):makeEdgesAssignmentSimple({edges_foldAngle:t}):e.map((()=>"U")));var Ee=Object.freeze({__proto__:null,makeEdgesAssignment:makeEdgesAssignment,makeEdgesAssignmentSimple:makeEdgesAssignmentSimple});const pairify=e=>e.map(((e,t,r)=>[e,r[(t+1)%r.length]])),parseFace=e=>e.slice(1).map((e=>parseInt(e,10)-1)),parseVertex=e=>{const[t,r,s]=e.slice(1).map((e=>parseFloat(e)));return[t||0,r||0,s||0]};var Me=Object.freeze({__proto__:null,objToFold:e=>{const t=e.split("\n").map((e=>e.trim().split(/\s+/))),r={file_spec:1.2,file_creator:I,file_classes:["singleModel"],frame_classes:[],frame_attributes:[],vertices_coords:[],faces_vertices:[]},s=t.map((e=>e[0].toLowerCase()));return r.vertices_coords=t.filter(((e,t)=>"v"===s[t])).map(parseVertex),r.faces_vertices=t.filter(((e,t)=>"f"===s[t])).map(parseFace),r.edges_vertices=(({faces_vertices:e})=>{const t={},r=[];return e.flatMap(pairify).forEach((e=>{const s=[e.join(" "),`${e[1]} ${e[0]}`];s[0]in t||s[1]in t||(r.push(e),t[s[0]]=!0)})),r})(r),r.faces_edges=makeFacesEdgesFromVertices(r),r.edges_faces=makeEdgesFacesUnsorted(r),r.edges_foldAngle=makeEdgesFoldAngleFromFaces(r),r.edges_assignment=makeEdgesAssignment(r),r.vertices_vertices=makeVerticesVerticesFromFaces(r),delete r.edges_faces,(e=>{if(!e.edges_foldAngle||!e.edges_foldAngle.length)return;let t=!0;for(let r=0;r<e.edges_foldAngle.length;r+=1)if(0!==e.edges_foldAngle[r]&&-180!==e.edges_foldAngle[r]&&180!==e.edges_foldAngle[r]){t=!1;break}e.frame_classes.push(t?"creasePattern":"foldedForm"),e.frame_attributes.push(t?"2D":"3D")})(r),r}});const invertFlatMap=e=>{const t=[];return e.forEach(((e,r)=>{t[e]=r})),t},invertArrayToFlatMap=e=>{const t=[];return e.forEach(((e,r)=>e.forEach((e=>{t[e]=r})))),t},invertFlatToArrayMap=e=>{const t=[];return e.forEach(((e,r)=>{void 0===t[e]&&(t[e]=[]),t[e].push(r)})),t},invertArrayMap=e=>{const t=[];return e.forEach(((e,r)=>e.forEach((e=>{void 0===t[e]&&(t[e]=[]),t[e].push(r)})))),t},mergeFlatNextmaps=(...e)=>{if(0===e.length)return[];const t=e[0].map(((e,t)=>t));return e.forEach((e=>t.forEach(((r,s)=>{t[s]=e[r]})))),t},mergeNextmaps=(...e)=>{if(0===e.length)return[];const t=e[0].map(((e,t)=>[t]));return e.forEach((e=>{t.forEach(((r,s)=>r.forEach(((r,a)=>{t[s][a]=e[r]})))),t.forEach(((e,r)=>{t[r]=e.flat().filter((e=>void 0!==e))}))})),t},mergeBackmaps=(...e)=>{if(0===e.length)return[];let t=e[0].flat().map(((e,t)=>[t]));return e.forEach((e=>{const r=[];e.forEach(((e,s)=>{r[s]="number"==typeof e?t[e]:e.map((e=>t[e])).reduce(((e,t)=>e.concat(t)),[])})),t=r})),t},remapKey=(e,t,r)=>{const s=[];r.forEach(((e,t)=>{s[e]=void 0===s[e]?t:s[e]})),filterKeysWithSuffix(e,t).forEach((t=>e[t].forEach(((s,a)=>e[t][a].forEach(((s,o)=>{e[t][a][o]=r[s]})))))),filterKeysWithPrefix(e,t).forEach((t=>{e[t]=s.map((r=>e[t][r]))})),"faces"===t&&e.faceOrders&&(e.faceOrders=e.faceOrders.map((([e,t,s])=>[r[e],r[t],s]))),"edges"===t&&e.edgeOrders&&(e.edgeOrders=e.edgeOrders.map((([e,t,s])=>[r[e],r[t],s])))};var Ae=Object.freeze({__proto__:null,invertArrayMap:invertArrayMap,invertArrayToFlatMap:invertArrayToFlatMap,invertFlatMap:invertFlatMap,invertFlatToArrayMap:invertFlatToArrayMap,mergeBackmaps:mergeBackmaps,mergeFlatBackmaps:(...e)=>{if(0===e.length)return[];let t=e[0].map(((e,t)=>t));return e.forEach((e=>{const r=e.map((e=>t[e]));t=r})),t},mergeFlatNextmaps:mergeFlatNextmaps,mergeNextmaps:mergeNextmaps,remapKey:remapKey});const remove=(e,t,r)=>{const s=((e,t,r)=>{const s=uniqueSortedNumbers(r),a=count(e,t),o=[];for(let e=0,t=0,r=0;e<a;e+=1,t+=1){for(;e===s[r];)o[e]=void 0,e+=1,r+=1;e<a&&(o[e]=t)}return o})(e,t,r);return remapKey(e,t,s),s};var xe=Object.freeze({__proto__:null,remove:remove});const edgeIsolatedVertices=({vertices_coords:e,edges_vertices:t})=>{if(!e||!t)return[];let r=e.length;const s=Array(r).fill(!1);return t.forEach((e=>{e.filter((e=>!s[e])).forEach((e=>{s[e]=!0,r-=1}))})),s.map(((e,t)=>e?void 0:t)).filter((e=>void 0!==e))},isolatedVertices=({vertices_coords:e,edges_vertices:t,faces_vertices:r})=>{if(!e)return[];let s=e.length;const a=Array(s).fill(!1);return t&&t.forEach((e=>{e.filter((e=>!a[e])).forEach((e=>{a[e]=!0,s-=1}))})),r&&r.forEach((e=>{e.filter((e=>!a[e])).forEach((e=>{a[e]=!0,s-=1}))})),a.map(((e,t)=>e?void 0:t)).filter((e=>void 0!==e))},removeIsolatedVertices=(e,t)=>(t||(t=isolatedVertices(e)),{map:remove(e,"vertices",t),remove:t});var Oe=Object.freeze({__proto__:null,edgeIsolatedVertices:edgeIsolatedVertices,faceIsolatedVertices:({vertices_coords:e,faces_vertices:t})=>{if(!e||!t)return[];let r=e.length;const s=Array(r).fill(!1);return t.forEach((e=>{e.filter((e=>!s[e])).forEach((e=>{s[e]=!0,r-=1}))})),s.map(((e,t)=>e?void 0:t)).filter((e=>void 0!==e))},isolatedVertices:isolatedVertices,removeIsolatedVertices:removeIsolatedVertices});const getOtherVerticesInEdges=({edges_vertices:e},t,r)=>r.map((r=>e[r][0]===t?e[r][1]:e[r][0])),isVertexCollinear=({vertices_coords:e,vertices_edges:t,edges_vertices:r},s,a=p)=>{if(!e||!r)return!1;t||(t=makeVerticesEdgesUnsorted({edges_vertices:r}));const o=t[s];if(void 0===o||2!==o.length)return!1;const c=getOtherVerticesInEdges({edges_vertices:r},s,o),[n,i,l]=[c[0],s,c[1]].map((t=>e[t]));return collinearBetween(n,i,l,!1,a)};var je=Object.freeze({__proto__:null,getOtherVerticesInEdges:getOtherVerticesInEdges,isVertexCollinear:isVertexCollinear});const getVerticesClusters=({vertices_coords:e},t=p)=>{if(!e)return[];const r=getDimensionQuick({vertices_coords:e}),s=Array.from(Array(r)),a=[];let o=0;const c=e.map(((e,t)=>({i:t,d:e[0]}))).sort(((e,t)=>e.d-t.d)).map((e=>e.i)).filter((()=>!0)),n=s.map((()=>[0,0])),isInsideCluster=t=>s.map(((r,s)=>e[t][s]>n[s][0]&&e[t][s]<n[s][1])).reduce(((e,t)=>e&&t),!0);let i=0;const updateRange=s=>{const a=s[s.length-1];for(;e[a][0]-e[s[i]][0]>t;)i+=1;const o=s.slice(i,s.length).map((t=>e[t]));n[0]=[o[0][0]-t,o[o.length-1][0]+t];for(let e=1;e<r;e+=1){const r=o.map((t=>t[e]));n[e]=[Math.min(...r)-t,Math.max(...r)+t]}};for(;o<e.length&&c.length;){const t=[],r=c.shift();t.push(r),o+=1,i=0,updateRange(t);let s=0;for(;s<c.length&&e[c[s]][0]<n[0][1];)if(isInsideCluster(c[s])){const e=c.splice(s,1).shift();t.push(e),o+=1,updateRange(t)}else s+=1;a.push(t)}return a};var we=Object.freeze({__proto__:null,getVerticesClusters:getVerticesClusters});const replace=(e,t,r)=>{Object.entries(r).map((([e,t])=>[parseInt(e,10),t])).filter((([e,t])=>e<t)).forEach((([e,t])=>{delete r[e],r[t]=e}));const s=Object.keys(r).map((e=>parseInt(e,10))),a=uniqueSortedNumbers(s),o=((e,t,r,s)=>{const a=count(e,t),o=[];for(let e=0,t=0,n=0;e<a;e+=1,t+=1){for(;e===s[n];){if(o[e]=o[r[s[n]]],void 0===o[e])throw new Error(c);e+=1,n+=1}e<a&&(o[e]=t)}return o})(e,t,r,a);return remapKey(e,t,o),o};var ke=Object.freeze({__proto__:null,replace:replace});const removeDuplicateVertices=(e,t=p,r=!0)=>{const s=[],a=[],o=getVerticesClusters(e,t).filter((e=>e.length>1));o.forEach((e=>{Math.min(...e)!==e[0]&&e.sort(((e,t)=>e-t));for(let t=1;t<e.length;t+=1)s[e[t]]=e[0],a.push(e[t])}));const c=getDimensionQuick(e);return r&&o.map((t=>t.map((t=>e.vertices_coords[t])))).map((e=>average(...e))).forEach((([t,r,s],a)=>{const n=2===c?[t,r]:[t,r,s];e.vertices_coords[o[a][0]]=n})),{map:replace(e,"vertices",s),remove:a}};var Fe=Object.freeze({__proto__:null,duplicateVertices:({vertices_coords:e},t)=>getVerticesClusters({vertices_coords:e},t).filter((e=>e.length>1)),removeDuplicateVertices:removeDuplicateVertices});const nearestPointOnLine=({vector:e,origin:t},r,s=clampLine,a=p)=>{const o=resize(e.length,t),c=resize(e.length,r),n=magSquared(e),i=subtract(c,o),l=s(dot(e,i)/n,a),[d,_,m]=add(o,scale$1(e,l));return 2===e.length?[d,_]:[d,_,m]};var Se=Object.freeze({__proto__:null,nearestPoint:(e,t)=>{const r=arrayMinimumIndex(e,(e=>distance(e,t)));return void 0===r?void 0:e[r]},nearestPoint2:(e,t)=>{const r=arrayMinimumIndex(e,(e=>distance2(e,t)));return void 0===r?void 0:e[r]},nearestPointOnCircle:({radius:e,origin:t},r)=>add2(t,scale2$1(normalize2(subtract2(r,t)),e)),nearestPointOnLine:nearestPointOnLine,nearestPointOnPolygon:(e,t)=>e.map(((e,t,r)=>subtract2(r[(t+1)%r.length],e))).map(((t,r)=>({vector:t,origin:e[r]}))).map((e=>nearestPointOnLine(e,t,clampSegment))).map(((e,r)=>({point:e,edge:r,distance:distance2(e,t)}))).sort(((e,t)=>e.distance-t.distance)).shift()});const connectedComponents=e=>{const t=[],recurse=(r,s)=>void 0!==t[r]?0:(t[r]=s,e[r].forEach((e=>recurse(e,s))),1);for(let t=0,r=0;t<e.length;t+=1)t in e&&(r+=recurse(t,r));return t},connectedComponentsPairs=e=>{const t=[],r=[];return e.forEach(((e,s)=>e.forEach((e=>{s<e&&t.push([s,e]),s!==e||r[s]||(r[s]=!0,t.push([s,e]))})))),t};var Ce=Object.freeze({__proto__:null,connectedComponents:connectedComponents,connectedComponentsPairs:connectedComponentsPairs});const edgeToLine2=({vertices_coords:e,edges_vertices:t},r)=>{const[s,a]=t[r].map((t=>e[t]));return{vector:subtract2(a,s),origin:resize2(s)}},edgesToLines2=({vertices_coords:e,edges_vertices:t})=>{const r=e.map(resize2);return t.map((e=>[r[e[0]],r[e[1]]])).map((([e,t])=>pointsToLine2(e,t)))},edgesToLines3=({vertices_coords:e,edges_vertices:t})=>{const r=e.map(resize3);return t.map((e=>[r[e[0]],r[e[1]]])).map((([e,t])=>pointsToLine3(e,t)))},getEdgesLine=({vertices_coords:e,edges_vertices:t},r=p)=>{if(!e||!t||!t.length)return{edges_line:[],lines:[]};const s=edgesToLines3({vertices_coords:e,edges_vertices:t}),a=s.map((e=>nearestPointOnLine(e,[0,0,0],clampLine))).map((e=>magnitude(e))),o=clusterScalars(a,r),c=o.map((e=>e.map((e=>s[e].vector)))).map((e=>clusterParallelVectors(e,.001))).map(((e,t)=>e.map((e=>e.map((e=>o[t][e])))))).map((o=>o.map((o=>{if(Math.abs(a[o[0]])<r)return[o];const c=s[o[0]].vector,n=o.map((r=>e[t[r][0]])).map((e=>projectPointOnPlane(e,c))),i=radialSortVectors3(n,c),compareFn=(e,t)=>epsilonEqualVectors(n[e],n[t],r),remap=e=>e.map((e=>i[e])).map((e=>o[e])),l=clusterSortedGeneric(i,compareFn);if(1===l.length)return l.map(remap);const d=l[0][0],_=l[l.length-1],m=[d,_[_.length-1]].map((e=>i[e]));if(compareFn(m[0],m[1])){const e=l.pop();l[0]=e.concat(l[0])}return l.map(remap)})))).flatMap((e=>e.flatMap((e=>e)))),n=invertArrayToFlatMap(c),i=c.map((e=>e.flatMap((e=>t[e])))).map(uniqueElements),l=c.map((e=>s[e[0]].vector)),d=i.map(((t,r)=>t.map((t=>dot(e[t],l[r]))))),_=d.map(((e,t)=>i[t][arrayMinimumIndex(e)])),m=d.map(((e,t)=>i[t][arrayMaximumIndex(e)])),g=i.map(((t,r)=>subtract(e[m[r]],e[_[r]]))),v=2===getDimensionQuick({vertices_coords:e})?g.map(resize2):g.map(resize3),u=_.map((t=>e[t])),h=v.map(((e,t)=>({vector:e,origin:u[t]})));return{lines:h,edges_line:n}};var Ve=Object.freeze({__proto__:null,edgeToLine2:edgeToLine2,edgesToLines:({vertices_coords:e,edges_vertices:t})=>t.map((t=>[e[t[0]],e[t[1]]])).map((([e,t])=>pointsToLine(e,t))),edgesToLines2:edgesToLines2,edgesToLines3:edgesToLines3,getEdgesLine:getEdgesLine,getEdgesLineBruteForce:({vertices_coords:e,edges_vertices:t},r=p)=>{if(!e||!t||!t.length)return{edges_line:[],lines:[]};const s=edgesToLines3({vertices_coords:e,edges_vertices:t}),a=s.map((()=>[]));s.forEach(((e,t)=>s.forEach(((s,o)=>{o<=t||collinearLines3(e,s,r)&&(a[t].push(o),a[o].push(t))}))));const o=connectedComponents(a),c=invertFlatToArrayMap(o),n=c.map((e=>e.flatMap((e=>t[e])))).map(uniqueElements),i=c.map((e=>s[e[0]].vector)),l=n.map(((t,r)=>t.map((t=>dot(e[t],i[r]))))),d=l.map(((e,t)=>n[t][arrayMinimumIndex(e)])),_=l.map(((e,t)=>n[t][arrayMaximumIndex(e)])),m=n.map(((t,r)=>subtract(e[_[r]],e[d[r]]))),g=2===getDimensionQuick({vertices_coords:e})?m.map(resize2):m.map(resize3),v=d.map((t=>e[t])),u=g.map(((e,t)=>({vector:e,origin:v[t]})));return{lines:u,edges_line:o}}});const duplicateEdges=({edges_vertices:e})=>{if(!e)return[];const t={},r=[];return e.map((e=>e[0]<e[1]?e:e.slice().reverse())).map((e=>e.join(" "))).forEach(((e,s)=>{void 0!==t[e]?r[s]=t[e]:t[e]=s})),r},removeDuplicateEdges=(e,t)=>{t||(t=duplicateEdges(e));const r=Object.keys(t).map((e=>parseInt(e,10))),s=replace(e,"edges",t);return r.length&&(e.vertices_edges||e.vertices_vertices||e.vertices_faces)&&(e.vertices_edges=makeVerticesEdgesUnsorted(e),e.vertices_vertices=makeVerticesVertices(e),e.vertices_edges=makeVerticesEdges(e),e.vertices_faces=makeVerticesFaces(e)),{map:s,remove:r}};var ze=Object.freeze({__proto__:null,duplicateEdges:duplicateEdges,getSimilarEdges:({vertices_coords:e,vertices_edges:t,edges_vertices:r},s=p)=>{const a=getVerticesClusters({vertices_coords:e},s),o=invertArrayToFlatMap(a),comparison=(e,t)=>{const[s,a]=r[e].map((e=>o[e])),[c,n]=r[t].map((e=>o[e]));return s===c&&a===n||s===n&&a===c};return sweepEdges({vertices_coords:e,vertices_edges:t,edges_vertices:r}).map((({start:e})=>e)).flatMap((e=>clusterUnsortedIndices(e,comparison)))},removeDuplicateEdges:removeDuplicateEdges});const circularEdges=({edges_vertices:e=[]})=>e.map(((e,t)=>e[0]===e[1]?t:void 0)).filter((e=>void 0!==e)),removeCircularEdges=(e,t)=>(t||(t=circularEdges(e)),t.length&&((e,t,r)=>{const s={};r.forEach((e=>{s[e]=!0})),filterKeysWithSuffix(e,t).forEach((t=>e[t].forEach(((r,a)=>{for(let o=r.length-1;o>=0;o-=1)!0===s[r[o]]&&e[t][a].splice(o,1)}))))})(e,"edges",t),{map:remove(e,"edges",t),remove:t});var Te=Object.freeze({__proto__:null,circularEdges:circularEdges,removeCircularEdges:removeCircularEdges});const planarize$2=({vertices_coords:e,edges_vertices:t,edges_assignment:r,edges_foldAngle:s},a=p)=>{const{lines:o,edges_line:c}=getEdgesLine({vertices_coords:e,edges_vertices:t},a),n=o.map((({vector:e})=>magSquared2(e))),i=invertFlatToArrayMap(c),l=t.map(((t,r)=>t.map((t=>e[t])).map((e=>dot2(subtract2(e,o[c[r]].origin),o[c[r]].vector))))),d=i.map((e=>e.flatMap((e=>l[e])))).map((e=>epsilonUniqueSortedNumbers(e,a))),_=((e,t=p)=>{const r=e.map((({vector:e,origin:t})=>({vector:resize2(e),origin:resize2(t)}))),s=r.map((()=>[]));for(let e=0;e<r.length-1;e+=1)for(let a=e+1;a<r.length;a+=1){const{a:o,b:c,point:n}=intersectLineLine(r[e],r[a],includeS,includeS,t);void 0!==n&&(s[e].push(o),s[a].push(c))}return s})(o,a).map((e=>epsilonUniqueSortedNumbers(e,a))).map(((e,t)=>e.map((e=>e*n[t])))).map(((e,t)=>setDifferenceSortedEpsilonNumbers(e,d[t],a))),m=i.map((e=>e.flatMap((e=>l[e])))),g=i.map((e=>invertFlatMap(e).map((e=>[2*e,2*e+1])))),v=i.map(((e,t)=>sweepValues({edges_vertices:g[t]},m[t],a))),u=v.map((e=>e.map((e=>e.t)))),h=v.map((e=>{const t={},r=e.map((e=>(e.start.forEach((e=>{t[e]=!0})),e.end.forEach((e=>{delete t[e]})),Object.keys(t).map((e=>parseInt(e,10))))));return r.pop(),r}));_.forEach(((e,t)=>{const r=u[t],s=h[t];let a=0,o=0;for(;a<e.length&&o<r.length-1;){if(e[a]<=r[o])throw new Error("bad algorithm");e[a]>r[o+1]?o+=1:(r.splice(o+1,0,e[a]),s.splice(o+1,0,s[o]),a+=1)}}));const b=u.flatMap(((e,t)=>e.map((e=>e/n[t])).map((e=>add2(o[t].origin,scale2$1(o[t].vector,e))))));let y=0;const E=h.map((e=>{const t=e.map((()=>[y,++y]));return y+=1,t})).flatMap(((e,t)=>e.filter(((e,r)=>h[t][r].length)))).map(resize2),M={vertices_coords:b,edges_vertices:E};if(r||s){const e=h.flatMap((e=>e.filter((e=>e.length))));r&&(M.edges_assignment=e.map((e=>r[e[0]]))),s&&(M.edges_foldAngle=e.map((e=>s[e[0]])))}removeIsolatedVertices(M,edgeIsolatedVertices(M)),removeDuplicateVertices(M,a),removeCircularEdges(M),M.vertices_edges=makeVerticesEdgesUnsorted(M);const A=M.vertices_edges.map(((e,t)=>2===e.length?t:void 0)).filter((e=>void 0!==e)).filter((e=>isVertexCollinear(M,e,a))).reverse(),x=A.map((e=>(({edges_vertices:e,vertices_edges:t},r)=>{const s=t[r].sort(((e,t)=>e-t)),a=s.flatMap((t=>e[t])).filter((e=>e!==r)),o=[a[0],a[1]];return e[s[0]]=o,e[s[1]]=void 0,o.forEach((e=>{const r=t[e].indexOf(s[1]);-1!==r&&(t[e][r]=s[0])})),s[1]})(M,e)));remove(M,"edges",x),remove(M,"vertices",A);const O=duplicateEdges(M);return O.length&&removeDuplicateEdges(M,O),circularEdges(M).length&&console.error("planarize: found circular edges"),delete M.vertices_edges,M},planarizeGraph=(e,t)=>{const r=planarize$2(e,t);r.vertices_vertices=makeVerticesVertices(r);const s=makePlanarFaces(r);return r.faces_vertices=s.faces_vertices,r.faces_edges=s.faces_edges,delete r.vertices_edges,r};var Pe=Object.freeze({__proto__:null,planarizeGraph:planarizeGraph});const disjointGraphsIndices=e=>{const t=e.edges_vertices||[],r=e.faces_vertices||[],s=e.vertices_edges?e.vertices_edges:makeVerticesEdgesUnsorted({edges_vertices:t}),a=e.vertices_vertices?e.vertices_vertices:makeVerticesVerticesUnsorted({vertices_edges:s,edges_vertices:t}),o=e.vertices_faces?e.vertices_faces:makeVerticesFacesUnsorted({vertices_edges:s,faces_vertices:r}),c=invertFlatToArrayMap(connectedComponents(a)),n=c.map((e=>e.flatMap((e=>s[e])))).map(uniqueElements),i=c.map((e=>e.flatMap((e=>o[e])))).map(uniqueElements);return Array.from(Array(c.length)).map(((e,t)=>({vertices:c[t]||[],edges:n[t]||[],faces:i[t]||[]})))},disjointGraphs=e=>{const t=disjointGraphsIndices(e),r=filterKeysWithPrefix(e,"vertices"),s=filterKeysWithPrefix(e,"edges"),a=filterKeysWithPrefix(e,"faces");return t.map((({vertices:t,edges:o,faces:c})=>{const n={};return r.forEach((r=>{n[r]=[],t.forEach((t=>{n[r][t]=e[r][t]}))})),s.forEach((t=>{n[t]=[],o.forEach((r=>{n[t][r]=e[t][r]}))})),a.forEach((t=>{n[t]=[],c.forEach((r=>{n[t][r]=e[t][r]}))})),n}))};var $e=Object.freeze({__proto__:null,disjointGraphs:disjointGraphs,disjointGraphsIndices:disjointGraphsIndices});const boundingBox=({vertices_coords:e},t)=>boundingBox$1(e,t),boundaryVertices=({edges_vertices:e,edges_assignment:t=[]})=>uniqueElements(e.filter(((e,r)=>K[t[r]])).flat()),boundary=({vertices_edges:e,edges_vertices:t,edges_assignment:r})=>{if(!r||!t)return{vertices:[],edges:[]};e||(e=makeVerticesEdgesUnsorted({edges_vertices:t}));const s=r.map((e=>"B"===e||"b"===e)),a={},o=[],c=[];let n=s.map(((e,t)=>e?t:void 0)).filter((e=>void 0!==e)).shift();if(void 0===n)return{vertices:[],edges:[]};s[n]=!1,c.push(n),o.push(t[n][0]),a[t[n][0]]=!0;let i=t[n][1];for(;!a[i];){if(o.push(i),a[i]=!0,n=e[i].filter((e=>s[e])).shift(),void 0===n)return{vertices:[],edges:[]};t[n][0]===i?[,i]=t[n]:[i]=t[n],c.push(n),s[n]=!1}return{vertices:o,edges:c}},boundaries$1=({vertices_edges:e,edges_vertices:t,edges_assignment:r})=>{if(!r||!t)return[{vertices:[],edges:[]}];e||(e=makeVerticesEdgesUnsorted({edges_vertices:t}));const s=[...t];r.map((e=>"B"===e||"b"===e)).map(((e,t)=>e?void 0:t)).filter((e=>void 0!==e)).forEach((e=>delete s[e]));const a=makeVerticesEdgesUnsorted({edges_vertices:s}),o=makeVerticesVerticesUnsorted({vertices_edges:a,edges_vertices:s}),c=connectedComponents(o),n=invertFlatToArrayMap(c).map((e=>e[0])),i=n.map((e=>(e=>{let t,r,s=e;const a=[],filterFunc=e=>e!==t;for(;;){if(o[s]=o[s].filter(filterFunc),r=o[s].shift(),void 0===r)return a;a.push(s),t=s,s=r}})(e))),l=makeVerticesToEdge({edges_vertices:s}),d=i.map((e=>e.map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>l[e.join(" ")]))));return i.map(((e,t)=>({vertices:e,edges:d[t]})))},planarBoundary=({vertices_coords:e,vertices_edges:t,vertices_vertices:r,edges_vertices:s})=>{r||(r=makeVerticesVertices2D({vertices_coords:e,vertices_edges:t,edges_vertices:s}));const a=makeVerticesToEdge({edges_vertices:s}),o=[],c=[],n={vertices:c,edges:o};let i=-1/0,l=-1;if(e.forEach(((e,t)=>{e[0]>i&&(i=e[0],l=t)})),-1===l)return n;c.push(l);const d=e[l],_=r[l];if(!_)return n;const m=_.map((t=>e[t])).map((e=>[e[0]-d[0],e[1]-d[1]])).map((e=>Math.atan2(e[1],e[0]))).map((e=>e<0?e+2*Math.PI:e)).map(((e,t)=>({a:e,i:t}))).sort(((e,t)=>e.a-t.a)).shift().i,g=_[m],v=a[l<g?`${l} ${g}`:`${g} ${l}`];o.push(v);let p=l,u=g;const h={[`${p} ${u}`]:!0};for(;;){const e=r[u],t=e.indexOf(p),s=e[(t+1)%e.length],i=a[u<s?`${u} ${s}`:`${s} ${u}`];if(h[`${u} ${s}`])return i!==o[0]&&console.warn("bad boundary"),n;h[`${u} ${s}`]=!0,c.push(u),o.push(i),p=u,u=s}},planarBoundaries=({vertices_coords:e,vertices_edges:t,vertices_vertices:r,edges_vertices:s})=>(r||(r=makeVerticesVertices2D({vertices_coords:e,vertices_edges:t,edges_vertices:s})),disjointGraphs({vertices_coords:e,vertices_vertices:r,edges_vertices:s}).map(planarBoundary));var Be=Object.freeze({__proto__:null,boundaries:boundaries$1,boundary:boundary,boundaryPolygon:({vertices_coords:e,vertices_edges:t,edges_vertices:r,edges_assignment:s})=>boundary({vertices_edges:t,edges_vertices:r,edges_assignment:s}).vertices.map((t=>e[t])),boundaryPolygons:({vertices_coords:e,vertices_edges:t,edges_vertices:r,edges_assignment:s})=>boundaries$1({vertices_edges:t,edges_vertices:r,edges_assignment:s}).map((({vertices:t})=>t.map((t=>e[t])))),boundaryVertices:boundaryVertices,boundingBox:boundingBox,planarBoundaries:planarBoundaries,planarBoundary:planarBoundary});const shortestEdgeLength=({vertices_coords:e,edges_vertices:t})=>{const r=t.map((t=>t.map((t=>e[t])))).map((([e,t])=>distance(e,t))).filter((e=>e>1e-4)).reduce(((e,t)=>Math.min(e,t)),1/0);return r===1/0?void 0:r},makeEpsilon=({vertices_coords:e,edges_vertices:t})=>{const r=shortestEdgeLength({vertices_coords:e,edges_vertices:t});if(r)return Math.max(1e-4*r,1e-10);const s=boundingBox({vertices_coords:e});return s&&s.span?Math.max(1e-6*Math.max(...s.span),1e-10):1e-6},countPlaces=function(e){const t=`${e}`.match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);return Math.max(0,(t[1]?t[1].length:0)-(t[2]?+t[2]:0))},cleanNumber=function(e,t=15){const r="number"==typeof e?e:parseFloat(e);if(Number.isNaN(r))return e;const s=parseFloat(r.toFixed(t));return countPlaces(s)===Math.min(t,countPlaces(r))?r:s};var Ne=Object.freeze({__proto__:null,cleanNumber:cleanNumber});const findEpsilonInObject=(e,t,r="epsilon")=>"object"==typeof t&&"number"==typeof t[r]?t[r]:"number"==typeof t?t:(({vertices_coords:e,edges_vertices:t})=>{const r=shortestEdgeLength({vertices_coords:e,edges_vertices:t}),s=boundingBox({vertices_coords:e}),a=.01*(s&&s.span?Math.max(...s.span):1),o=r/20;return void 0===r?a:Math.min(a,o)})(e),invertVertical=e=>{const t=boundingBox({vertices_coords:e}),r=t.min[1]+t.span[1]/2,s=Math.min(-t.min[1],-t.max[1]),a=Math.max(-t.min[1],-t.max[1]),o=cleanNumber(r-(s+(a-s)/2),8);for(let t=0;t<e.length;t+=1)e[t][1]=-e[t][1]+o};var Re=Object.freeze({__proto__:null,findEpsilonInObject:findEpsilonInObject,invertVertical:invertVertical});const xmlStringToDocument=(e,t="text/xml")=>(new(RabbitEarWindow$1().DOMParser)).parseFromString(e,t),getContainingValue=(e,t)=>null==e?null:Array.from(e.childNodes).filter((e=>e.attributes&&e.attributes.length)).filter((e=>void 0!==Array.from(e.attributes).filter((e=>e.nodeValue===t)).shift())).shift(),parseOriLineProxy=e=>Array.from(e.childNodes).filter((e=>"void"===e.nodeName)).filter((e=>e.childNodes)).map((e=>getContainingValue(e,"oripa.OriLineProxy"))).filter((e=>e)).map((e=>["type","x0","x1","y0","y1"].map((t=>getContainingValue(e,t))).map((e=>e?Array.from(e.childNodes):[])).map((e=>e.filter((e=>"double"===e.nodeName||"int"===e.nodeName)).shift())).map((e=>e&&e.childNodes[0]&&"data"in e.childNodes[0]?e.childNodes[0].data:"0")).map(parseFloat))),Le=["F","B","M","V","U"],makeLineGraph=e=>{const t=e.flatMap((e=>[[e[1],e[3]],[e[2],e[4]]])),r=e.map(((e,t)=>[2*t,2*t+1])),s=e.map((e=>Le[e[0]]));return{vertices_coords:t,edges_vertices:r,edges_assignment:s,edges_foldAngle:makeEdgesFoldAngle({edges_assignment:s})}};var Ie=Object.freeze({__proto__:null,opxEdgeGraph:e=>{const t=xmlStringToDocument(e,"text/xml"),r=Array.from(t.getElementsByClassName("oripa.OriLineProxy")).filter((e=>"array"===e.nodeName||"array"===e.tagName)).shift(),s=parseOriLineProxy(r);return makeLineGraph(s)},opxToFold:(e,t)=>{const r=xmlStringToDocument(e,"text/xml"),s=Array.from(r.getElementsByClassName("oripa.OriLineProxy")).filter((e=>"array"===e.nodeName||"array"===e.tagName)).shift();if(void 0===Array.from(r.getElementsByClassName("oripa.DataSet")).filter((e=>"object"===e.nodeName||"object"===e.tagName)).shift()||void 0===s)return;const a=parseOriLineProxy(s),o=(e=>{const t=Array.from(e.getElementsByTagName("string")).map((e=>Array.from(e.childNodes).map((e=>e.nodeValue)).filter((e=>""!==e)).shift())),r=t.indexOf("title"),s=t.indexOf("editorName"),a=t.indexOf("originalAuthorName"),o=t.indexOf("reference"),c=t.indexOf("memo"),n={file_spec:1.2,file_creator:"Rabbit Ear",file_classes:["singleModel"],frame_classes:["creasePattern"]},i=[],l=[];return-1!==r&&t[r+1]&&(n.file_title=t[r+1]),-1!==s&&t[s+1]&&i.push(t[s+1]),-1!==a&&t[a+1]&&i.push(t[a+1]),-1!==o&&t[o+1]&&l.push(t[o+1]),-1!==c&&t[c+1]&&l.push(t[c+1]),i.length&&(n.file_author=i.join(", ")),l.length&&(n.file_description=l.join(", ")),n})(r),c=makeLineGraph(a);t&&"object"==typeof t&&t.invertVertical&&c.vertices_coords&&invertVertical(c.vertices_coords);const n=findEpsilonInObject(c,t);return{...o,...planarizeGraph(c,n)}}});const Ue={black:"#000000",silver:"#c0c0c0",gray:"#808080",white:"#ffffff",maroon:"#800000",red:"#ff0000",purple:"#800080",fuchsia:"#ff00ff",green:"#008000",lime:"#00ff00",olive:"#808000",yellow:"#ffff00",navy:"#000080",blue:"#0000ff",teal:"#008080",aqua:"#00ffff",orange:"#ffa500",aliceblue:"#f0f8ff",antiquewhite:"#faebd7",aquamarine:"#7fffd4",azure:"#f0ffff",beige:"#f5f5dc",bisque:"#ffe4c4",blanchedalmond:"#ffebcd",blueviolet:"#8a2be2",brown:"#a52a2a",burlywood:"#deb887",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",cornflowerblue:"#6495ed",cornsilk:"#fff8dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",darkkhaki:"#bdb76b",darkmagenta:"#8b008b",darkolivegreen:"#556b2f",darkorange:"#ff8c00",darkorchid:"#9932cc",darkred:"#8b0000",darksalmon:"#e9967a",darkseagreen:"#8fbc8f",darkslateblue:"#483d8b",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",darkturquoise:"#00ced1",darkviolet:"#9400d3",deeppink:"#ff1493",deepskyblue:"#00bfff",dimgray:"#696969",dimgrey:"#696969",dodgerblue:"#1e90ff",firebrick:"#b22222",floralwhite:"#fffaf0",forestgreen:"#228b22",gainsboro:"#dcdcdc",ghostwhite:"#f8f8ff",gold:"#ffd700",goldenrod:"#daa520",greenyellow:"#adff2f",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",indianred:"#cd5c5c",indigo:"#4b0082",ivory:"#fffff0",khaki:"#f0e68c",lavender:"#e6e6fa",lavenderblush:"#fff0f5",lawngreen:"#7cfc00",lemonchiffon:"#fffacd",lightblue:"#add8e6",lightcoral:"#f08080",lightcyan:"#e0ffff",lightgoldenrodyellow:"#fafad2",lightgray:"#d3d3d3",lightgreen:"#90ee90",lightgrey:"#d3d3d3",lightpink:"#ffb6c1",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",lightskyblue:"#87cefa",lightslategray:"#778899",lightslategrey:"#778899",lightsteelblue:"#b0c4de",lightyellow:"#ffffe0",limegreen:"#32cd32",linen:"#faf0e6",magenta:"#ff00ff",mediumaquamarine:"#66cdaa",mediumblue:"#0000cd",mediumorchid:"#ba55d3",mediumpurple:"#9370db",mediumseagreen:"#3cb371",mediumslateblue:"#7b68ee",mediumspringgreen:"#00fa9a",mediumturquoise:"#48d1cc",mediumvioletred:"#c71585",midnightblue:"#191970",mintcream:"#f5fffa",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",navajowhite:"#ffdead",oldlace:"#fdf5e6",olivedrab:"#6b8e23",orangered:"#ff4500",orchid:"#da70d6",palegoldenrod:"#eee8aa",palegreen:"#98fb98",paleturquoise:"#afeeee",palevioletred:"#db7093",papayawhip:"#ffefd5",peachpuff:"#ffdab9",peru:"#cd853f",pink:"#ffc0cb",plum:"#dda0dd",powderblue:"#b0e0e6",rosybrown:"#bc8f8f",royalblue:"#4169e1",saddlebrown:"#8b4513",salmon:"#fa8072",sandybrown:"#f4a460",seagreen:"#2e8b57",seashell:"#fff5ee",sienna:"#a0522d",skyblue:"#87ceeb",slateblue:"#6a5acd",slategray:"#708090",slategrey:"#708090",snow:"#fffafa",springgreen:"#00ff7f",steelblue:"#4682b4",tan:"#d2b48c",thistle:"#d8bfd8",tomato:"#ff6347",turquoise:"#40e0d0",violet:"#ee82ee",wheat:"#f5deb3",whitesmoke:"#f5f5f5",yellowgreen:"#9acd32"},hslToRgb=(e,t,r,s)=>{const a=r/100,k=t=>(t+e/30)%12,o=t/100*Math.min(a,1-a),f=e=>a-o*Math.max(-1,Math.min(k(e)-3,Math.min(9-k(e),1)));return void 0===s?[255*f(0),255*f(8),255*f(4)]:[255*f(0),255*f(8),255*f(4),s]},mapHexNumbers=(e,t)=>{const r=Array.from(Array(t.length)).map(((t,r)=>e[r]||"0"));return e.length<=4?t.map((e=>r[e])).join(""):r.join("")},hexToRgb=e=>{const t=e.replace(/#(?=\S)/g,""),r=4===t.length||8===t.length,s=mapHexNumbers(t,r?[0,0,1,1,2,2,3,3]:[0,0,1,1,2,2]),a=parseInt(s,16);return r?[a>>24&255,a>>16&255,a>>8&255,(o=(255&a)/256,Math.round(100*o)/100)]:[a>>16&255,a>>8&255,255&a];var o},rgbToHex=(e,t,r,s)=>{const to16=e=>`00${Math.max(0,Math.min(Math.round(e),255)).toString(16)}`.slice(-2),a=`#${[e,t,r].map(to16).join("")}`;return void 0===s?a:`${a}${to16(255*s)}`};var De=Object.freeze({__proto__:null,hexToRgb:hexToRgb,hslToRgb:hslToRgb,rgbToHex:rgbToHex});const getParenNumbers=e=>{const t=e.match(/\(([^\)]+)\)/g);return null!=t&&t.length?t[0].substring(1,t[0].length-1).split(/[\s,]+/).map(parseFloat):[]},parseColorToRgb=e=>{if(Ue[e])return hexToRgb(Ue[e]);if("#"===e[0])return hexToRgb(e);if("rgba"===e.substring(0,4)||"rgb"===e.substring(0,3)){const t=getParenNumbers(e);return[0,1,2].filter((e=>void 0===t[e])).forEach((e=>{t[e]=0})),t}if("hsla"===e.substring(0,4)||"hsl"===e.substring(0,3)){const t=getParenNumbers(e);return[0,1,2].filter((e=>void 0===t[e])).forEach((e=>{t[e]=0})),hslToRgb(t[0],t[1],t[2],t[3])}},parseColorToHex=e=>{if(Ue[e])return Ue[e].toUpperCase();if("#"===e[0]){const[t,r,s,a]=hexToRgb(e);return rgbToHex(t,r,s,a)}if("rgba"===e.substring(0,4)||"rgb"===e.substring(0,3)){const[t,r,s,a]=getParenNumbers(e);return rgbToHex(t,r,s,a)}if("hsla"===e.substring(0,4)||"hsl"===e.substring(0,3)){const t=getParenNumbers(e);[0,1,2].filter((e=>void 0===t[e])).forEach((e=>{t[e]=0}));const[r,s,a,o]=t,[c,n,i]=hslToRgb(r,s,a,o);return rgbToHex(c,n,i,o)}};var Qe=Object.freeze({__proto__:null,parseColorToHex:parseColorToHex,parseColorToRgb:parseColorToRgb});const We="object"==typeof window&&"object"==typeof window.document;"object"==typeof process&&"object"==typeof process.versions&&(null!=process.versions.node||process.versions.bun);const qe="window not set; svg.window = @xmldom/xmldom",Ge={window:void 0};We&&(Ge.window=window);const RabbitEarWindow=()=>{if(void 0===Ge.window)throw new Error(qe);return Ge.window},svg_add2=(e,t)=>[e[0]+t[0],e[1]+t[1]],svg_sub2=(e,t)=>[e[0]-t[0],e[1]-t[1]],svg_scale2=(e,t)=>[e[0]*t,e[1]*t],svg_magnitudeSq2=e=>e[0]**2+e[1]**2,svg_magnitude2=e=>Math.sqrt(svg_magnitudeSq2(e)),svg_distanceSq2=(e,t)=>svg_magnitudeSq2(svg_sub2(e,t)),svg_distance2=(e,t)=>Math.sqrt(svg_distanceSq2(e,t)),svg_polar_to_cart=(e,t)=>[Math.cos(e)*t,Math.sin(e)*t],svg_multiplyMatrices2=(e,t)=>[e[0]*t[0]+e[2]*t[1],e[1]*t[0]+e[3]*t[1],e[0]*t[2]+e[2]*t[3],e[1]*t[2]+e[3]*t[3],e[0]*t[4]+e[2]*t[5]+e[4],e[1]*t[4]+e[3]*t[5]+e[5]];var He=Object.freeze({__proto__:null,svg_add2:svg_add2,svg_distance2:svg_distance2,svg_distanceSq2:svg_distanceSq2,svg_magnitude2:svg_magnitude2,svg_magnitudeSq2:svg_magnitudeSq2,svg_multiplyMatrices2:svg_multiplyMatrices2,svg_polar_to_cart:svg_polar_to_cart,svg_scale2:svg_scale2,svg_sub2:svg_sub2});const parseTransform=e=>{const t=e.match(/(\w+\((\-?\d+\.?\d*e?\-?\d*,?\s*)+\))+/g);if(!t)return[];return t.map((e=>e.match(/[\w\.\-]+/g))).map((e=>({transform:e.shift(),parameters:e.map((e=>parseFloat(e)))})))},matrixForm=function(e,t){switch(e){case"translate":return function(e){switch(e.length){case 1:return[1,0,0,1,e[0],0];case 2:return[1,0,0,1,e[0],e[1]];default:console.warn(`improper translate, ${e}`)}}(t);case"rotate":return function(e){const t=Math.cos(e[0]/(180*Math.PI)),r=Math.sin(e[0]/(180*Math.PI));switch(e.length){case 1:return[t,r,-r,t,0,0];case 3:return[t,r,-r,t,-e[1]*t+e[2]*r+e[1],-e[1]*r-e[2]*t+e[2]];default:console.warn(`improper rotate, ${e}`)}}(t);case"scale":return function(e){switch(e.length){case 1:return[e[0],0,0,e[0],0,0];case 2:return[e[0],0,0,e[1],0,0];default:console.warn(`improper scale, ${e}`)}}(t);case"skewX":return function(e){return[1,0,Math.tan(e[0]/(180*Math.PI)),1,0,0]}(t);case"skewY":return function(e){return[1,Math.tan(e[0]/(180*Math.PI)),0,1,0,0]}(t);case"matrix":return t;default:console.warn(`unknown transform type ${e}`)}},transformStringToMatrix=function(e){return parseTransform(e).map((e=>matrixForm(e.transform,e.parameters))).filter((e=>void 0!==e)).reduce(((e,t)=>svg_multiplyMatrices2(e,t)),[1,0,0,1,0,0])};var Je=Object.freeze({__proto__:null,parseTransform:parseTransform,transformStringToMatrix:transformStringToMatrix});const xmlStringToElement=(e,t="text/xml")=>{const r=(new(RabbitEarWindow().DOMParser)).parseFromString(e,t);return r?r.documentElement:null},getRootParent=e=>{let t=e;for(;t&&null!=t.parentElement;)t=t.parentElement;return t},findElementTypeInParents=(e,t)=>{if((e.nodeName||"")===t)return e;const r=e.parentElement;return r?findElementTypeInParents(r,t):null},addClass=(e,...t)=>{if(e&&t.length)return e.classList?e.classList.add(...t):((e,...t)=>{const r={},s=e.getAttribute("class"),a=s?s.split(" "):[];a.push(...t),a.forEach((e=>{r[e]=!0}));const o=Object.keys(r).join(" ");e.setAttribute("class",o)})(e,...t)},flattenDomTree=e=>null!=e.childNodes&&e.childNodes.length?Array.from(e.childNodes).flatMap((e=>flattenDomTree(e))):[e],Ze={svg:["viewBox","xmlns","version"],line:["x1","y1","x2","y2"],rect:["x","y","width","height"],circle:["cx","cy","r"],ellipse:["cx","cy","rx","ry"],polygon:["points"],polyline:["points"],path:["d"]},attrAssign=(e,t)=>{const r=(e=>{const t={};return e.forEach((e=>{t[e.nodeName]=e.value})),t})((e=>{const t=e.attributes;if(null==t)return[];const r=Array.from(t);return Ze[e.nodeName]?r.filter((t=>!Ze[e.nodeName].includes(t.name))):r})(t));if(!r.transform&&!e.transform)return{...e,...r};const s=r.transform||"",a=e.transform||"",o=transformStringToMatrix(s),c=transformStringToMatrix(a),n=`matrix(${svg_multiplyMatrices2(c,o).join(", ")})`;return{...e,...r,transform:n}},flattenDomTreeWithStyle=(e,t={})=>null!=e.childNodes&&e.childNodes.length?Array.from(e.childNodes).flatMap((e=>flattenDomTreeWithStyle(e,attrAssign(t,e)))):[{element:e,attributes:t}];var Ye=Object.freeze({__proto__:null,addClass:addClass,findElementTypeInParents:findElementTypeInParents,flattenDomTree:flattenDomTree,flattenDomTreeWithStyle:flattenDomTreeWithStyle,getRootParent:getRootParent,xmlStringToElement:xmlStringToElement});const invisibleParent=e=>{if(!RabbitEarWindow$1().document.body)return;const t=RabbitEarWindow$1().document.createElement("div");return t.setAttribute("display","none"),RabbitEarWindow$1().document.body.appendChild(t),t.appendChild(e),t};var Xe=Object.freeze({__proto__:null,invisibleParent:invisibleParent});const Ke={B:"black",M:"crimson",V:"royalblue",F:"lightgray",J:"gold",C:"limegreen",U:"orchid"};Object.keys(Ke).forEach((e=>{Ke[e.toLowerCase()]=Ke[e]}));const et={M:[1,0,0],V:[0,0,1],J:[1,1,0],U:[1,0,1],C:[0,1,0]},rgbToAssignment=(e=0,t=0,r=0)=>{const s=scale3$1([e,t,r],1/255),a=magnitude3(s);if(a<.05)return"B";const o=s.reduce(((e,t)=>e+t),0)/3,c=distance3(s,[o,o,o]),n=Object.keys(et).map((e=>({key:e,dist:distance3(s,et[e])}))).sort(((e,t)=>e.dist-t.dist)).shift();return n.dist<4*c?n.key:a<.1?"B":"F"};var tt=Object.freeze({__proto__:null,assignmentColor:Ke,rgbToAssignment:rgbToAssignment});const colorToAssignment=(e,t)=>{const r=parseColorToHex(e).toUpperCase();return t&&t[r]?t[r]:rgbToAssignment(...parseColorToRgb(e))},opacityToFoldAngle=(e,t)=>{switch(t){case"M":case"m":return-180*e;case"V":case"v":return 180*e;default:return 0}},getEdgeStroke=(e,t)=>{const r=null!=RabbitEarWindow$1().getComputedStyle?RabbitEarWindow$1().getComputedStyle(e).stroke:"";return""!==r&&"none"!==r?r:void 0!==t.stroke?t.stroke:void 0},getEdgeOpacity=(e,t)=>{const r=null!=RabbitEarWindow$1().getComputedStyle?RabbitEarWindow$1().getComputedStyle(e).opacity:"";if(""!==r){const e=parseFloat(r);if(!Number.isNaN(e))return e}if(void 0!==t.opacity){const e=parseFloat(t.opacity);if(!Number.isNaN(e))return e}};var rt=Object.freeze({__proto__:null,colorToAssignment:colorToAssignment,getEdgeOpacity:getEdgeOpacity,getEdgeStroke:getEdgeStroke,opacityToFoldAngle:opacityToFoldAngle});const st=/[MmLlSsQqLlHhVvCcSsQqTtAaZz]/g,at=/-?[0-9]*\.?\d+/g,ot={m:"move",l:"line",v:"vertical",h:"horizontal",a:"ellipse",c:"curve",s:"smoothCurve",q:"quadCurve",t:"smoothQuadCurve",z:"close"};Object.keys(ot).forEach((e=>{const t=ot[e];ot[e.toUpperCase()]=t.charAt(0).toUpperCase()+t.slice(1)}));const add2path=(e,t)=>[e[0]+(t[0]||0),e[1]+(t[1]||0)],parsePathCommands=e=>{const t=[];let r=st.exec(e);for(;null!==r;)t.push(r),r=st.exec(e);return t.map(((t,r,s)=>({command:t[0],start:t.index,end:r===s.length-1?e.length-1:s[(r+1)%s.length].index-1}))).map((({command:t,start:r,end:s})=>{const a=e.substring(r+1,s+1).match(at);return{command:t,values:a?a.map(parseFloat):[]}}))},parsePathCommandsWithEndpoints=e=>{let t=[0,0];const r=parsePathCommands(e).map((e=>({...e,end:void 0,start:void 0})));if(!r.length)return r;r.forEach(((e,s)=>{r[s].end=((e,t,r=[0,0])=>{const s=e.toUpperCase();let a=e===s?[0,0]:r;switch("V"===e&&(a=[r[0],0]),"H"===e&&(a=[0,r[1]]),s){case"V":return add2path(a,[0,t[0]]);case"H":return add2path(a,[t[0],0]);case"M":case"L":case"T":return add2path(a,t);case"A":return add2path(a,[t[5],t[6]]);case"C":return add2path(a,[t[4],t[5]]);case"S":case"Q":return add2path(a,[t[2],t[3]]);case"Z":return;default:return a}})(e.command,e.values,t),r[s].start=0===s?t:r[s-1].end,t=r[s].end}));const s=r[r.length-1],a=r.filter((e=>"M"!==e.command.toUpperCase()&&"Z"!==e.command.toUpperCase())).shift();return"Z"===s.command.toUpperCase()&&(s.end=[...a.start]),r};var ct=Object.freeze({__proto__:null,parsePathCommands:parsePathCommands,parsePathCommandsWithEndpoints:parsePathCommandsWithEndpoints,pathCommandNames:ot});const nt={L:!0,V:!0,H:!0,Z:!0},getAttributesFloatValue=(e,t)=>t.map((t=>e.getAttribute(t))).map((e=>null==e?0:e)).map(parseFloat),lineToSegments=e=>{const[t,r,s,a]=getAttributesFloatValue(e,["x1","y1","x2","y2"]);return[[t,r,s,a]]},pathToSegments=e=>parsePathCommandsWithEndpoints(e.getAttribute("d")||"").filter((e=>nt[e.command.toUpperCase()])).map((e=>[e.start,e.end])).filter((([e,t])=>!epsilonEqualVectors(e,t))).map((([e,t])=>[e[0],e[1],t[0],t[1]])),polygonToSegments=e=>(e=>{const t=e.split(/[\s,]+/).map(parseFloat);return Array.from(Array(Math.floor(t.length/2))).map(((e,r)=>[t[2*r+0],t[2*r+1]]))})(e.getAttribute("points")||"").map(((e,t,r)=>[r[t][0],r[t][1],r[(t+1)%r.length][0],r[(t+1)%r.length][1]])),polylineToSegments=function(e){const t=polygonToSegments(e);return t.pop(),t},rectToSegments=function(e){const[t,r,s,a]=getAttributesFloatValue(e,["x","y","width","height"]);return[[t,r,t+s,r],[t+s,r,t+s,r+a],[t+s,r+a,t,r+a],[t,r+a,t,r]]};var it=Object.freeze({__proto__:null,lineToSegments:lineToSegments,pathToSegments:pathToSegments,polygonToSegments:polygonToSegments,polylineToSegments:polylineToSegments,rectToSegments:rectToSegments});const lt={line:lineToSegments,rect:rectToSegments,polygon:polygonToSegments,polyline:polylineToSegments,path:pathToSegments},flatSegments=e=>flattenDomTreeWithStyle(e).filter((e=>lt[e.element.nodeName])).flatMap((e=>lt[e.element.nodeName](e.element).map((t=>((e,t)=>{const r=[[e[0],e[1]],[e[2],e[3]]];if(!t)return r;const s=transformStringToMatrix(t);return s?r.map((e=>multiplyMatrix2Vector2(s,e))):r})(t,e.attributes.transform))).map((t=>({...e,segment:t}))))),svgSegments=e=>{const t="string"==typeof e?xmlStringToElement(e,"image/svg+xml"):e;(e=>flattenDomTree(e).map((e=>"style"===e.nodeName)).reduce(((e,t)=>e||t),!1))(t)&&s&&console.warn(m);const r=getRootParent(t)===RabbitEarWindow$1().document?void 0:invisibleParent(t),a=flatSegments(t),o=a.map((e=>({data:{assignment:e.attributes["data-assignment"],foldAngle:e.attributes["data-foldAngle"]},stroke:getEdgeStroke(e.element,e.attributes),opacity:getEdgeOpacity(e.element,e.attributes)}))).map(((e,t)=>({...a[t],...e})));return r&&r.parentNode&&r.parentNode.removeChild(r),o},makeAssignmentFoldAngle=(e,t)=>{const r=(e=>{if(!e||!e.assignments)return;const t={};return Object.keys(e.assignments).forEach((r=>{const s=parseColorToHex(r).toUpperCase();t[s]=e.assignments[r]})),t})(t);r&&e.forEach((e=>{delete e.data.assignment,delete e.data.foldAngle}));const s=e.map((e=>((e,t="#f0f",r)=>e||colorToAssignment(t,r))(e.data.assignment,e.stroke,r))),a=e.map(((e,t)=>((e,t=1,r)=>e?parseFloat(e):opacityToFoldAngle(t,r))(e.data.foldAngle,e.opacity,s[t])));return{edges_assignment:s,edges_foldAngle:a}},passthrough=e=>e,svgEdgeGraph=(e,t)=>{const r=svgSegments(e),{edges_assignment:s,edges_foldAngle:a}=makeAssignmentFoldAngle(r,t),o=t&&t.fast?passthrough:cleanNumber;return{vertices_coords:r.flatMap((e=>e.segment)).map((([e,t])=>[o(e,12),o(t,12)])),edges_vertices:r.map(((e,t)=>[2*t,2*t+1])),edges_assignment:s,edges_foldAngle:a}};var ft=Object.freeze({__proto__:null,svgEdgeGraph:svgEdgeGraph,svgSegments:svgSegments,svgToFold:(e,t)=>{const r=svgEdgeGraph(e,t),s=findEpsilonInObject(r,t);t&&t.invertVertical&&r.vertices_coords&&invertVertical(r.vertices_coords);const a=planarizeGraph(r,s),o=t&&t.fast?passthrough:cleanNumber;if(a.vertices_coords=a.vertices_coords.map((e=>e.map((e=>o(e,12))))).map(resize2),"object"!=typeof t||!1!==t.boundary){a.edges_assignment.map(((e,t)=>t)).filter((e=>"B"===a.edges_assignment[e]||"b"===a.edges_assignment[e])).forEach((e=>{a.edges_assignment[e]="F"}));const{edges:e}=planarBoundary(a);e.forEach((e=>{a.edges_assignment[e]="B"}))}return{file_spec:1.2,file_creator:I,frame_classes:["creasePattern"],...a}}});const dt="http://www.w3.org/2000/svg",_t={presentation:["color","color-interpolation","cursor","direction","display","fill","fill-opacity","fill-rule","font-family","font-size","font-size-adjust","font-stretch","font-style","font-variant","font-weight","image-rendering","letter-spacing","opacity","overflow","paint-order","pointer-events","preserveAspectRatio","shape-rendering","stroke","stroke-dasharray","stroke-dashoffset","stroke-linecap","stroke-linejoin","stroke-miterlimit","stroke-opacity","stroke-width","tabindex","transform-origin","user-select","vector-effect","visibility"],animation:["accumulate","additive","attributeName","begin","by","calcMode","dur","end","from","keyPoints","keySplines","keyTimes","max","min","repeatCount","repeatDur","restart","to","values"],effects:["azimuth","baseFrequency","bias","color-interpolation-filters","diffuseConstant","divisor","edgeMode","elevation","exponent","filter","filterRes","filterUnits","flood-color","flood-opacity","in","in2","intercept","k1","k2","k3","k4","kernelMatrix","lighting-color","limitingConeAngle","mode","numOctaves","operator","order","pointsAtX","pointsAtY","pointsAtZ","preserveAlpha","primitiveUnits","radius","result","seed","specularConstant","specularExponent","stdDeviation","stitchTiles","surfaceScale","targetX","targetY","type","xChannelSelector","yChannelSelector"],text:["dx","dy","alignment-baseline","baseline-shift","dominant-baseline","lengthAdjust","method","overline-position","overline-thickness","rotate","spacing","startOffset","strikethrough-position","strikethrough-thickness","text-anchor","text-decoration","text-rendering","textLength","underline-position","underline-thickness","word-spacing","writing-mode"],gradient:["gradientTransform","gradientUnits","spreadMethod"]},mt={svg:["svg"],defs:["defs"],header:["desc","filter","metadata","style","script","title","view"],cdata:["cdata"],group:["g"],visible:["circle","ellipse","line","path","polygon","polyline","rect","arc","arrow","curve","parabola","roundRect","wedge","origami"],text:["text"],invisible:["marker","symbol","clipPath","mask"],patterns:["linearGradient","radialGradient","pattern"],childrenOfText:["textPath","tspan"],gradients:["stop"],filter:["feBlend","feColorMatrix","feComponentTransfer","feComposite","feConvolveMatrix","feDiffuseLighting","feDisplacementMap","feDistantLight","feDropShadow","feFlood","feFuncA","feFuncB","feFuncG","feFuncR","feGaussianBlur","feImage","feMerge","feMergeNode","feMorphology","feOffset","fePointLight","feSpecularLighting","feSpotLight","feTile","feTurbulence"]},gt="class",vt="function",pt="number",ut="string",ht="object",bt="svg",yt="path",Et="id",Mt="style",At="viewBox",xt="transform",Ot="points",jt="stroke",wt="none",kt="arrow",Ft="head",St="tail",Ct={svg:[At],line:["x1","y1","x2","y2"],rect:["x","y","width","height"],circle:["cx","cy","r"],ellipse:["cx","cy","rx","ry"],polygon:[Ot],polyline:[Ot],path:["d"],text:["x","y"],mask:[Et],symbol:[Et],clipPath:[Et,"clip-rule"],marker:[Et,"markerHeight","markerUnits","markerWidth","orient","refX","refY"],linearGradient:["x1","x2","y1","y2"],radialGradient:["cx","cy","r","fr","fx","fy"],stop:["offset","stop-color","stop-opacity"],pattern:["patternContentUnits","patternTransform","patternUnits"]};[{nodes:[bt,"defs","g"].concat(mt.visible,mt.text),attr:_t.presentation},{nodes:["filter"],attr:_t.effects},{nodes:mt.childrenOfText.concat("text"),attr:_t.text},{nodes:mt.filter,attr:_t.effects},{nodes:mt.gradients,attr:_t.gradient}].forEach((e=>e.nodes.forEach((t=>{Ct[t]||(Ct[t]=[]),Ct[t].push(...e.attr)}))));const Vt=[mt.header,mt.invisible,mt.patterns].flat(),zt=[mt.group,mt.visible,mt.text].flat(),Tt={svg:[["svg","defs"],Vt,zt].flat(),defs:Vt,filter:mt.filter,g:zt,text:mt.childrenOfText,marker:zt,symbol:zt,clipPath:zt,mask:zt,linearGradient:mt.gradients,radialGradient:mt.gradients},Pt={cssColors:Ue,...De,...Qe},makeCDATASection=e=>(new(RabbitEarWindow().DOMParser)).parseFromString("<root></root>","text/xml").createCDATASection(e);const makeCoordinates=(...e)=>e.filter((e=>typeof e===pt)).concat(e.filter((e=>typeof e===ht&&null!==e)).map((e=>typeof e.x===pt?[e.x,e.y]:typeof e[0]===pt?[e[0],e[1]]:void 0)).filter((e=>void 0!==e)).reduce(((e,t)=>e.concat(t)),[])),makeViewBox=(...e)=>{const t=makeCoordinates(...e.flat());return 2===t.length&&t.unshift(0,0),4===t.length?function(e,t,r,s,a=0){const o=r/1-r;return[e-o-a,t-o-a,r+2*o+2*a,s+2*o+2*a].join(" ")}(t[0],t[1],t[2],t[3]):void 0},setViewBox=(e,...t)=>{const r=1===t.length&&typeof t[0]===ut?t[0]:makeViewBox(...t);return r&&e.setAttribute(At,r),e},getViewBox$1=function(e){const t=e.getAttribute(At);return null==t?void 0:t.split(" ").map((e=>parseFloat(e)))},convertToViewBox=function(e,t,r){const s=e.createSVGPoint();s.x=t,s.y=r;const a=s.matrixTransform(e.getScreenCTM().inverse());return[a.x,a.y]};const $t={...He,...Ye,...Object.freeze({__proto__:null,makeCDATASection:makeCDATASection}),...ct,...Je,...Object.freeze({__proto__:null,convertToViewBox:convertToViewBox,foldToViewBox:({vertices_coords:e})=>{if(!e)return;const t=[1/0,1/0],r=[-1/0,-1/0];return e.forEach((e=>[0,1].forEach((s=>{t[s]=Math.min(e[s],t[s]),r[s]=Math.max(e[s],r[s])})))),[t[0],t[1],r[0]-t[0],r[1]-t[1]].join(" ")},getViewBox:getViewBox$1,setViewBox:setViewBox})},getSVGFrame=function(e){const t=getViewBox$1(e);if(void 0!==t)return t;if(typeof e.getBoundingClientRect===vt){const t=e.getBoundingClientRect();return[t.x,t.y,t.width,t.height]}return[]},Bt="svg-background-rectangle",getAttr=e=>{const t=e.getAttribute(xt);return null==t||""===t?void 0:t},Nt={clearTransform:e=>(e.removeAttribute(xt),e)};["translate","rotate","scale","matrix"].forEach((e=>{Nt[e]=(t,...r)=>(t.setAttribute(xt,[getAttr(t),`${e}(${r.join(" ")})`].filter((e=>void 0!==e)).join(" ")),t)}));const makeUUID=()=>Math.random().toString(36).replace(/[^a-z]+/g,"").concat("aaaaa").substring(0,5),toCamel$1=e=>e.replace(/([-_][a-z])/gi,(e=>e.toUpperCase().replace("-","").replace("_",""))),removeChildren=e=>{for(;e.lastChild;)e.removeChild(e.lastChild);return e},appendTo=(e,t)=>(t&&t.appendChild&&t.appendChild(e),e),setAttributes=(e,t)=>(Object.keys(t).forEach((r=>e.setAttribute(r.replace(/([a-z0-9])([A-Z])/g,"$1-$2").replace(/([A-Z])([A-Z])(?=[a-z])/g,"$1-$2").toLowerCase(),t[r]))),e);var Rt=Object.freeze({__proto__:null,appendTo:appendTo,removeChildren:removeChildren,setAttributes:setAttributes});const stylesheet$1=function(e,t){let r=function(e,t){const r=e.getElementsByTagName(t);return r.length?r[0]:null}(e,Mt);return null==r&&(r=RabbitEarWindow().document.createElementNS(dt,Mt),r.setTextContent=e=>(r.textContent="",r.appendChild(makeCDATASection(e)),r),e.insertBefore(r,e.firstChild)),r.textContent="",r.appendChild(makeCDATASection(t)),r},Lt={clear:e=>(Array.from(e.attributes).filter((e=>"xmlns"!==e.name&&"version"!==e.name)).forEach((t=>e.removeAttribute(t.name))),removeChildren(e)),size:setViewBox,setViewBox:setViewBox,getViewBox:getViewBox$1,padding:function(e,t){const r=getViewBox$1(e);return void 0!==r&&setViewBox(e,...[-t,-t,2*t,2*t].map(((e,t)=>r[t]+e))),e},background:function(e,t){let r=Array.from(e.childNodes).filter((e=>e.getAttribute(gt)===Bt)).shift();return null==r&&(r=RabbitEarWindow().document.createElementNS(dt,"rect"),getSVGFrame(e).forEach(((e,t)=>r.setAttribute(Ct.rect[t],e))),r.setAttribute(gt,Bt),r.setAttribute(jt,wt),e.insertBefore(r,e.firstChild)),r.setAttribute("fill",t),e},getWidth:e=>getSVGFrame(e)[2],getHeight:e=>getSVGFrame(e)[3],stylesheet:function(e,t){return stylesheet$1.call(this,e,t)},...Nt,...Rt},It={move:["mousemove","touchmove"],press:["mousedown","touchstart"],release:["mouseup","touchend"],leave:["mouseleave","touchcancel"]},defineGetter=(e,t,r)=>Object.defineProperty(e,t,{get:()=>r,enumerable:!0,configurable:!0}),TouchEvents=function(e){const t=[];Object.keys(It).forEach((e=>{It[e].forEach((e=>{t[e]=[]}))}));Object.keys(It).forEach((r=>{var s;Object.defineProperty(e,`on${s=r,s.charAt(0).toUpperCase()+s.slice(1)}`,{set:s=>{e.addEventListener&&(null!=s?It[r].forEach((r=>{const handlerFunc=t=>{const r=null!=t.touches?t.touches[0]:t;if(void 0!==r){const{clientX:s,clientY:a}=r,[o,c]=convertToViewBox(e,s,a);defineGetter(t,"x",o),defineGetter(t,"y",c)}s(t)};t[r].push(handlerFunc),e.addEventListener(r,handlerFunc)})):(r=>{It[r].forEach((r=>t[r].forEach((t=>e.removeEventListener(r,t)))))})(r))},enumerable:!0})})),Object.defineProperty(e,"off",{value:()=>((e,t)=>Object.values(It).flat().forEach((r=>{t[r].forEach((t=>e.removeEventListener(r,t))),t[r]=[]})))(e,t)})},Ut={svg:{args:(...e)=>[makeViewBox(makeCoordinates(...e))].filter((e=>null!=e)),methods:Lt,init:(e,...t)=>{const r=RabbitEarWindow().document.createElementNS(dt,"svg");return r.setAttribute("version","1.1"),r.setAttribute("xmlns",dt),t.filter((e=>null!=e)).filter((e=>e.appendChild)).forEach((e=>e.appendChild(r))),TouchEvents(r),function(e){let t,r,s=0;const a={},stop=()=>{RabbitEarWindow().cancelAnimationFrame&&RabbitEarWindow().cancelAnimationFrame(r),Object.keys(a).forEach((e=>delete a[e]))};Object.defineProperty(e,"play",{set:e=>{if(stop(),!e||!RabbitEarWindow().requestAnimationFrame)return;t=performance.now(),s=0;const o=makeUUID();a[o]=c=>{e({time:.001*(c-t),frame:s}),s+=1,a[o]&&(r=RabbitEarWindow().requestAnimationFrame(a[o]))},r=RabbitEarWindow().requestAnimationFrame(a[o])},enumerable:!0}),Object.defineProperty(e,"stop",{value:stop,enumerable:!0})}(r),r}}},Dt={};["clip-path","mask","symbol","marker-end","marker-mid","marker-start"].forEach((e=>{Dt[toCamel$1(e)]=(t,r)=>(t.setAttribute(e,function(e){if(null==e)return"";if(typeof e===ut)return"url"===e.slice(0,3)?e:`url(#${e})`;if(null!=e.getAttribute)return`url(#${e.getAttribute(Et)})`;return""}(r)),t)}));const Qt={g:{methods:{...Nt,...Dt,...Rt}}},setRadius=(e,t)=>(e.setAttribute(Ct.circle[2],t),e),setOrigin$1=(e,t,r)=>([...makeCoordinates(...[t,r].flat()).slice(0,2)].forEach(((t,r)=>e.setAttribute(Ct.circle[r],t))),e),Wt={circle:{args:(e,t,r,s)=>{const a=makeCoordinates(...[e,t,r,s].flat());switch(a.length){case 0:case 1:return[,,...a];case 2:case 3:return a;default:return((e,t,r,s)=>[e,t,svg_distance2([e,t],[r,s])])(...a)}},methods:{radius:setRadius,setRadius:setRadius,origin:setOrigin$1,setOrigin:setOrigin$1,center:setOrigin$1,setCenter:setOrigin$1,position:setOrigin$1,setPosition:setOrigin$1,...Nt,...Dt,...Rt}}},setRadii=(e,t,r)=>([,,t,r].forEach(((t,r)=>e.setAttribute(Ct.ellipse[r],t))),e),setOrigin=(e,t,r)=>([...makeCoordinates(...[t,r].flat()).slice(0,2)].forEach(((t,r)=>e.setAttribute(Ct.ellipse[r],t))),e),qt={ellipse:{args:(e,t,r,s)=>{const a=makeCoordinates(...[e,t,r,s].flat()).slice(0,4);switch(a.length){case 0:case 1:case 2:return[,,...a];default:return a}},methods:{radius:setRadii,setRadius:setRadii,origin:setOrigin,setOrigin:setOrigin,center:setOrigin,setCenter:setOrigin,position:setOrigin,setPosition:setOrigin,...Nt,...Dt,...Rt}}},svgIsIterable=e=>null!=e&&typeof e[Symbol.iterator]===vt,svgSemiFlattenArrays=function(){switch(arguments.length){case 0:return Array.from(arguments);case 1:return svgIsIterable(arguments[0])&&typeof arguments[0]!==ut?svgSemiFlattenArrays(...arguments[0]):[arguments[0]];default:return Array.from(arguments).map((e=>svgIsIterable(e)?[...svgSemiFlattenArrays(e)]:e))}},Args$1=(...e)=>makeCoordinates(...svgSemiFlattenArrays(...e)).slice(0,4),Gt={line:{args:Args$1,methods:{setPoints:(e,...t)=>(Args$1(...t).forEach(((t,r)=>e.setAttribute(Ct.line[r],t))),e),...Nt,...Dt,...Rt}}},getD=e=>{const t=e.getAttribute("d");return null==t?"":t},appendPathCommand=(e,t,...r)=>(e.setAttribute("d",`${getD(e)}${t}${r.flat().join(" ")}`),e),getCommands=e=>parsePathCommands(getD(e)),Ht={addCommand:appendPathCommand,appendCommand:appendPathCommand,clear:e=>(e.removeAttribute("d"),e),getCommands:getCommands,get:getCommands,getD:e=>e.getAttribute("d"),...Nt,...Dt,...Rt};Object.keys(ot).forEach((e=>{Ht[ot[e]]=(t,...r)=>appendPathCommand(t,e,...r)}));const Jt={path:{methods:Ht}},setRectSize=(e,t,r)=>([,,t,r].forEach(((t,r)=>e.setAttribute(Ct.rect[r],t))),e),setRectOrigin=(e,t,r)=>([...makeCoordinates(...[t,r].flat()).slice(0,2)].forEach(((t,r)=>e.setAttribute(Ct.rect[r],t))),e),fixNegatives=function(e){return[0,1].forEach((t=>{e[2+t]<0&&(void 0===e[0+t]&&(e[0+t]=0),e[0+t]+=e[2+t],e[2+t]=-e[2+t])})),e},Zt={rect:{args:(e,t,r,s)=>{const a=makeCoordinates(...[e,t,r,s].flat()).slice(0,4);switch(a.length){case 0:case 1:case 2:case 3:return fixNegatives([,,...a]);default:return fixNegatives(a)}},methods:{origin:setRectOrigin,setOrigin:setRectOrigin,center:setRectOrigin,setCenter:setRectOrigin,size:setRectSize,setSize:setRectSize,...Nt,...Dt,...Rt}}},Yt={style:{init:(e,t)=>{const r=RabbitEarWindow().document.createElementNS(dt,"style");return r.setAttribute("type","text/css"),r.textContent="",r.appendChild(makeCDATASection(t)),r},methods:{setTextContent:(e,t)=>(e.textContent="",e.appendChild(makeCDATASection(t)),e)}}},Xt={text:{args:(e,t,r)=>makeCoordinates(...[e,t,r].flat()).slice(0,2),init:(e,t,r,s,a)=>{const o=RabbitEarWindow().document.createElementNS(dt,"text"),c=[t,r,s,a].filter((e=>typeof e===ut)).shift();return o.appendChild(RabbitEarWindow().document.createTextNode(c||"")),o},methods:{...Nt,...Dt,appendTo:appendTo,setAttributes:setAttributes}}},makeIDString=function(){return Array.from(arguments).filter((e=>typeof e===ut||e instanceof String)).shift()||makeUUID()},maskArgs=(...e)=>[makeIDString(...e)],Kt={mask:{args:maskArgs,methods:{...Nt,...Dt,...Rt}},clipPath:{args:maskArgs,methods:{...Nt,...Dt,...Rt}},symbol:{args:maskArgs,methods:{...Nt,...Dt,...Rt}},marker:{args:maskArgs,methods:{size:setViewBox,setViewBox:setViewBox,...Nt,...Dt,...Rt}}},getPoints=e=>{const t=e.getAttribute(Ot);return null==t?"":t},polyString=function(){return Array.from(Array(Math.floor(arguments.length/2))).map(((e,t)=>`${arguments[2*t+0]},${arguments[2*t+1]}`)).join(" ")},stringifyArgs=(...e)=>[polyString(...makeCoordinates(...svgSemiFlattenArrays(...e)))],setPoints$2=(e,...t)=>(e.setAttribute(Ot,stringifyArgs(...t)[0]),e),addPoint=(e,...t)=>(e.setAttribute(Ot,[getPoints(e),stringifyArgs(...t)[0]].filter((e=>""!==e)).join(" ")),e),Args=function(...e){return 1===e.length&&typeof e[0]===ut?[e[0]]:stringifyArgs(...e)},er={polyline:{args:Args,methods:{setPoints:setPoints$2,addPoint:addPoint,...Nt,...Dt,...Rt}},polygon:{args:Args,methods:{setPoints:setPoints$2,addPoint:addPoint,...Nt,...Dt,...Rt}}},arcPath=(e,t,r,s,a,o=!1)=>{if(null==a)return"";const c=svg_polar_to_cart(s,r),n=svg_polar_to_cart(a,r),i=[n[0]-c[0],n[1]-c[1]],l=c[0]*n[1]-c[1]*n[0],d=c[0]*n[0]+c[1]*n[1],_=Math.atan2(l,d)>0?0:1;let m=o?`M ${e},${t} l ${c[0]},${c[1]} `:`M ${e+c[0]},${t+c[1]} `;return m+=["a ",r,r,0,_,1,i[0],i[1]].join(" "),o&&(m+=" Z"),m},arcArguments=(e,t,r,s,a)=>[arcPath(e,t,r,s,a,!1)],tr={arc:{nodeName:yt,attributes:["d"],args:arcArguments,methods:{setArc:(e,...t)=>e.setAttribute("d",arcArguments(...t)),...Nt}}},rr=[St,Ft],stringifyPoint=e=>e.join(","),pointsToPath=e=>"M"+e.map((e=>e.join(","))).join("L")+"Z",setArrowheadOptions=(e,t,r)=>{"boolean"==typeof t?e.options[r].visible=t:typeof t===ht?(Object.assign(e.options[r],t),null==t.visible&&(e.options[r].visible=!0)):null==t&&(e.options[r].visible=!0)},setArrowStyle=(e,t={},r=Ft)=>{const s=Array.from(e.childNodes).filter((e=>e.getAttribute("class")===`${kt}-${r}`)).shift();Object.keys(t).map((e=>({key:e,fn:s[toCamel$1(e)]}))).filter((e=>typeof e.fn===vt&&"class"!==e.key)).forEach((e=>e.fn(t[e.key]))),Object.keys(t).filter((e=>"class"===e)).forEach((e=>s.classList.add(t[e])))},redraw=e=>{const t=(e=>{let t=[[e.points[0]||0,e.points[1]||0],[e.points[2]||0,e.points[3]||0]],r=svg_sub2(t[1],t[0]),s=svg_add2(t[0],svg_scale2(r,.5));const a=svg_magnitude2(r),o=rr.map((t=>e[t].visible?(1+e[t].padding)*e[t].height*2.5:0)).reduce(((e,t)=>e+t),0);if(a<o){const e=0===a?[o,0]:svg_scale2(r,o/a);t=[svg_sub2(s,svg_scale2(e,.5)),svg_add2(s,svg_scale2(e,.5))],r=svg_sub2(t[1],t[0])}let c=[r[1],-r[0]],n=svg_add2(s,svg_scale2(c,e.bend));const i=t.map((e=>svg_sub2(n,e))),l=i.map((e=>svg_magnitude2(e))),d=i.map(((e,t)=>0===l[t]?e:svg_scale2(e,1/l[t]))),_=d.map((e=>svg_scale2(e,-1))),m=[[_[0][1],-_[0][0]],[_[1][1],-_[1][0]]],g=rr.map(((t,r)=>e[t].padding?e[t].padding:e.padding?e.padding:0)),v=rr.map(((t,r)=>e[t].height*(e[t].visible?1:0))).map(((e,t)=>e+g[t])),p=t.map(((e,t)=>svg_add2(e,svg_scale2(d[t],v[t]))));r=svg_sub2(p[1],p[0]),c=[r[1],-r[0]],s=svg_add2(p[0],svg_scale2(r,.5)),n=svg_add2(s,svg_scale2(c,e.bend));const u=p.map(((t,r)=>svg_add2(t,svg_scale2(svg_sub2(n,t),e.pinch)))),h=rr.map(((t,r)=>[svg_add2(p[r],svg_scale2(_[r],e[t].height)),svg_add2(p[r],svg_scale2(m[r],e[t].width/2)),svg_add2(p[r],svg_scale2(m[r],-e[t].width/2))]));return{line:`M${stringifyPoint(p[0])}C${stringifyPoint(u[0])},${stringifyPoint(u[1])},${stringifyPoint(p[1])}`,tail:pointsToPath(h[0]),head:pointsToPath(h[1])}})(e.options);return Object.keys(t).map((t=>({path:t,element:Array.from(e.childNodes).filter((e=>e.getAttribute("class")===`${kt}-${t}`)).shift()}))).filter((e=>e.element)).map((e=>(e.element.setAttribute("d",t[e.path]),e))).filter((t=>e.options[t.path])).forEach((t=>t.element.setAttribute("visibility",e.options[t.path].visible?"visible":"hidden"))),e},setPoints$1=(e,...t)=>(e.options.points=makeCoordinates(...svgSemiFlattenArrays(...t)).slice(0,4),redraw(e)),sr={setPoints:setPoints$1,points:setPoints$1,bend:(e,t)=>(e.options.bend=t,redraw(e)),pinch:(e,t)=>(e.options.pinch=t,redraw(e)),padding:(e,t)=>(e.options.padding=t,redraw(e)),head:(e,t)=>(setArrowheadOptions(e,t,Ft),setArrowStyle(e,t,Ft),redraw(e)),tail:(e,t)=>(setArrowheadOptions(e,t,St),setArrowStyle(e,t,St),redraw(e)),getLine:e=>Array.from(e.childNodes).filter((e=>e.getAttribute("class")===`${kt}-line`)).shift(),getHead:e=>Array.from(e.childNodes).filter((e=>e.getAttribute("class")===`${kt}-${Ft}`)).shift(),getTail:e=>Array.from(e.childNodes).filter((e=>e.getAttribute("class")===`${kt}-${St}`)).shift(),...Nt},ar=Object.keys({head:{visible:!1,width:8,height:10,padding:0},tail:{visible:!1,width:8,height:10,padding:0},bend:0,padding:0,pinch:.618,points:[]}),or={arrow:{nodeName:"g",attributes:[],args:()=>[],methods:sr,init:function(e,...t){const r=RabbitEarWindow().document.createElementNS(dt,"g");r.setAttribute(gt,kt);const s=["line",St,Ft].map((e=>{const t=RabbitEarWindow().document.createElementNS(dt,yt);return t.setAttribute(gt,`${kt}-${e}`),r.appendChild(t),t}));s[0].setAttribute(Mt,"fill:none;"),s[1].setAttribute(jt,wt),s[2].setAttribute(jt,wt),r.options={head:{visible:!1,width:8,height:10,padding:0},tail:{visible:!1,width:8,height:10,padding:0},bend:0,padding:0,pinch:.618,points:[]};const a=((...e)=>{for(let t=0;t<e.length;t+=1){if(typeof e[t]!==ht)continue;const r=Object.keys(e[t]);for(let s=0;s<r.length;s+=1)if(ar.includes(r[s]))return e[t]}})(...t);return sr.setPoints(r,...a.segment||t),a&&Object.keys(a).filter((e=>sr[e])).forEach((e=>sr[e](r,a[e]))),r}}},makeCurvePath=(e=[],t=0,r=.5)=>{const s=[e[0]||0,e[1]||0],a=[e[2]||0,e[3]||0],o=svg_sub2(a,s),c=svg_add2(s,svg_scale2(o,.5)),n=[o[1],-o[0]],i=svg_add2(c,svg_scale2(n,t)),l=svg_add2(s,svg_scale2(svg_sub2(i,s),r)),d=svg_add2(a,svg_scale2(svg_sub2(i,a),r));return`M${s[0]},${s[1]}C${l[0]},${l[1]} ${d[0]},${d[1]} ${a[0]},${a[1]}`},getNumbersFromPathCommand=e=>e.slice(1).split(/[, ]+/).map((e=>parseFloat(e))),getCurveEndpoints=e=>{const t=(e=>e.match(/[Mm][(0-9), .-]+/).map((e=>getNumbersFromPathCommand(e))))(e).shift(),r=(e=>e.match(/[Cc][(0-9), .-]+/).map((e=>getNumbersFromPathCommand(e))))(e).shift();return[...t?[t[t.length-2],t[t.length-1]]:[0,0],...r?[r[r.length-2],r[r.length-1]]:[0,0]]},setPoints=(e,...t)=>{const r=makeCoordinates(...t.flat()).slice(0,4);return e.setAttribute("d",makeCurvePath(r,e._bend,e._pinch)),e},cr={setPoints:setPoints,bend:(e,t)=>(e._bend=t,setPoints(e,...getCurveEndpoints(e.getAttribute("d")))),pinch:(e,t)=>(e._pinch=t,setPoints(e,...getCurveEndpoints(e.getAttribute("d")))),...Nt},nr={curve:{nodeName:yt,attributes:["d"],args:(...e)=>[makeCurvePath(makeCoordinates(...e.flat()))],methods:cr}},wedgeArguments=(e,t,r,s,a)=>[arcPath(e,t,r,s,a,!0)],ir={wedge:{nodeName:yt,args:wedgeArguments,attributes:["d"],methods:{setArc:(e,...t)=>e.setAttribute("d",wedgeArguments(...t)),...Nt}}},lr={},getChildWithClass=(e,t)=>{const r=e?e.childNodes:void 0;return r?Array.from(r).filter((e=>e.getAttribute("class")===t)).shift():null},fr={...Ut,...Qt,...Wt,...qt,...Gt,...Jt,...Zt,...Yt,...Xt,...Kt,...er,...tr,...or,...nr,...ir,...{origami:{nodeName:"g",init:(e,t,r={})=>{const s=RabbitEarWindow().document.createElementNS(dt,"g");return lr.ear.convert.renderSVG(t,s,{viewBox:!0,strokeWidth:!0,...r}),((e,t,r,s={})=>{const a=lr.ear.graph.boundingBox(r)||{min:[0,0],max:[1,1],span:[1,1]},o=findElementTypeInParents(e,"svg");if(o&&s&&s.viewBox){const e=[a.min,a.span].flatMap((e=>[e[0],e[1]])).join(" ");o.setAttributeNS(null,"viewBox",e)}})(e,0,t,{viewBox:!0,strokeWidth:!0,...r}),s},args:()=>[],methods:{vertices:(...e)=>getChildWithClass(e[0],"vertices"),edges:(...e)=>getChildWithClass(e[0],"edges"),faces:(...e)=>getChildWithClass(e[0],"faces"),boundaries:(...e)=>getChildWithClass(e[0],"boundaries"),...Nt,...Dt,...Rt}}}},dr=Object.values(mt).flat(),passthroughArgs=(...e)=>e,Constructor=(e,t,...r)=>{const s=fr[e]&&fr[e].nodeName?fr[e].nodeName:e,{init:a,args:o,methods:c}=fr[e]||{},n=Ct[s]||[],i=Tt[s]||[],l=a?a(t,...r):RabbitEarWindow().document.createElementNS(dt,s);t&&!l.parentElement&&t.appendChild(l);return(o||passthroughArgs)(...r).forEach(((e,t)=>{l.setAttribute(Ct[s][t],e)})),c&&Object.keys(c).forEach((e=>Object.defineProperty(l,e,{value:function(){return c[e](l,...arguments)}}))),n.forEach((e=>{const t=toCamel$1(e);l[t]||Object.defineProperty(l,t,{value:function(){return l.setAttribute(e,...arguments),l}})})),i.forEach((e=>{if(l[e])return;Object.defineProperty(l,e,{value:function(){return Constructor(e,l,...arguments)}})})),l},_r={};dr.forEach((e=>{_r[e]=(...t)=>Constructor(e,null,...t)}));const mr=Object.assign(_r),gr={NS:dt,nodes_attributes:Ct,nodes_children:Tt,extensions:fr,...Pt,...$t,...mr,window:void 0},vr=Object.assign(((...e)=>{const t=Constructor(bt,null,...e),initialize=()=>e.filter((e=>"function"==typeof e)).forEach((e=>e.call(t,t)));return"loading"===RabbitEarWindow().document.readyState?RabbitEarWindow().document.addEventListener("DOMContentLoaded",initialize):initialize(),t}),gr);Object.defineProperty(vr,"window",{enumerable:!1,set:e=>(e.document||(e.document=(e=>(new e.DOMParser).parseFromString("<!DOCTYPE html><title>.</title>","text/html"))(e)),Ge.window=e,Ge.window)});const pr={min:[0,0],span:[1,1]},setKeysAndValues=(e,t={})=>Object.keys(t).forEach((r=>e.setAttributeNS(null,r,t[r]))),boundingBoxToViewBox=e=>[e.min,e.span].flatMap((e=>[e[0],e[1]])).join(" "),getNthPercentileEdgeLength=({vertices_coords:e,edges_vertices:t,edges_length:r},s=.1)=>{if(!e||!t)return;r||(r=makeEdgesLength({vertices_coords:e,edges_vertices:t}));const a=r.slice().sort(((e,t)=>e-t));return a[Math.max(0,Math.min(Math.floor(a.length*s),a.length-1))]},getStrokeWidth=(e,t)=>{const r=void 0===t?Math.max(...(boundingBox(e)||pr).span):t,s=getNthPercentileEdgeLength(e,.1);return s?.1*s:.01*r};var ur=Object.freeze({__proto__:null,boundingBoxToViewBox:boundingBoxToViewBox,getNthPercentileEdgeLength:getNthPercentileEdgeLength,getStrokeWidth:getStrokeWidth,getViewBox:e=>{const t=boundingBox(e);return void 0===t?"":boundingBoxToViewBox(t)},setKeysAndValues:setKeysAndValues});const drawVertices=(e,t={})=>{const r=vr.g();return e&&e.vertices_coords?(e.vertices_coords.map((e=>vr.circle(e[0],e[1],.01))).forEach((e=>r.appendChild(e))),setKeysAndValues(r,t),r):r};var hr=Object.freeze({__proto__:null,drawVertices:drawVertices});const clonePolyfill=function(e){let t,r;if("object"!=typeof e)return e;if(!e)return e;if("[object Array]"===Object.prototype.toString.apply(e)){for(t=[],r=0;r<e.length;r+=1)t[r]=clonePolyfill(e[r]);return t}for(r in t={},e)e.hasOwnProperty(r)&&(t[r]=clonePolyfill(e[r]));return t},br="function"==typeof structuredClone?structuredClone:clonePolyfill,yr={foldedForm:{},creasePattern:{stroke:"black"}},Er={foldedForm:{},creasePattern:{}};Object.keys(Ke).forEach((e=>{Er.creasePattern[e]={stroke:Ke[e]}}));const setDataValue=(e,t,r)=>e.setAttribute(`data-${t}`,r),edgesPathData=e=>e.vertices_coords&&e.edges_vertices?makeEdgesCoords(e).map((e=>{return`M${(t=e)[0][0]} ${t[0][1]}L${t[1][0]} ${t[1][1]}`;var t})).join(""):"",getStyles=(e,t)=>{const r=isFoldedForm(e)?"foldedForm":"creasePattern",s=br(yr[r]),a=br(Er[r]),o=(e=>{const t={boolean:!0,number:!0,string:!0},r=br(e);return Object.keys(r).filter((e=>!t[typeof r[e]])).forEach((e=>delete r[e])),r})((e=>{const t=br(e);return Object.keys(t).filter((e=>void 0!==Z[e])).forEach((e=>delete t[e])),t})(t));return Object.assign(s,o),J.forEach((e=>{a[e]={...a[e],...o}})),{groupStyle:s,edgeStyle:a}},edgesPaths=(e,t={})=>{const r=vr.g();if(!e)return r;const{groupStyle:s,edgeStyle:a}=getStyles(e,t),o=(({vertices_coords:e,edges_vertices:t,edges_assignment:r})=>{if(!e||!t)return{};if(!r)return{U:edgesPathData({vertices_coords:e,edges_vertices:t})};const s=sortEdgesByAssignment({vertices_coords:e,edges_vertices:t,edges_assignment:r});Object.keys(s).forEach((e=>{s[e].length||delete s[e]}));const a={};return Object.keys(s).forEach((r=>{const o=edgesPathData({vertices_coords:e,edges_vertices:s[r].map((e=>t[e]))});a[r]=vr.path(o)})),a})(e);return Object.keys(o).forEach((e=>{addClass(o[e],Z[e]),setKeysAndValues(o[e],a[e]),setKeysAndValues(o[e],t[e]),setKeysAndValues(o[e],t[Z[e]])})),setKeysAndValues(r,s),Object.keys(o).forEach((e=>r.appendChild(o[e]))),Object.keys(o).forEach((e=>setDataValue(o[e],"assignment",e))),Object.keys(o).forEach((e=>setDataValue(o[e],"foldAngle",Y[e]))),r},edgesLines=(e,t={})=>{const r=vr.g();if(!e)return r;const{groupStyle:s,edgeStyle:a}=getStyles(e,t),o={};Array.from(new Set(J.map((e=>e.toUpperCase())))).forEach((e=>{const r=vr.g();addClass(r,Z[e]),setKeysAndValues(r,a[e]),setKeysAndValues(r,t[e]),setKeysAndValues(r,t[Z[e]]),o[e]=r}));const c=makeEdgesCoords(e).map((e=>vr.line(e[0][0],e[0][1],e[1][0],e[1][1])));return e.edges_foldAngle&&e.edges_foldAngle.forEach(((e,t)=>setDataValue(c[t],"foldAngle",e))),e.edges_assignment&&e.edges_assignment.forEach(((e,t)=>setDataValue(c[t],"assignment",e))),e.edges_foldAngle&&c.forEach(((t,r)=>{const s=e.edges_foldAngle[r];var a;null!=s&&0!==s&&180!==s&&-180!==s&&t.setAttributeNS(null,"opacity",(a=s,String(Math.abs(a)/180)))})),e.edges_assignment?c.forEach(((t,r)=>{const s=e.edges_assignment[r]||"U";o[s].appendChild(t)})):c.forEach((e=>o.U.appendChild(e))),Object.keys(o).filter((e=>o[e].childNodes.length)).forEach((e=>r.appendChild(o[e]))),setKeysAndValues(r,s),r},drawEdges=(e,t)=>edgesFoldAngleAreAllFlat(e)?edgesPaths(e,t):edgesLines(e,t);var Mr=Object.freeze({__proto__:null,drawEdges:drawEdges,edgesLines:edgesLines,edgesPaths:edgesPaths});const makeFacesWinding=({vertices_coords:e,faces_vertices:t})=>t.map((t=>t.map((t=>e[t])).map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>(e[1][0]-e[0][0])*(e[1][1]+e[0][1]))).reduce(((e,t)=>e+t),0))).map((e=>e<0)),makeFacesWindingFromMatrix2=e=>e.map((e=>e[0]*e[3]-e[1]*e[2])).map((e=>e>=0));var Ar=Object.freeze({__proto__:null,makeFacesWinding:makeFacesWinding,makeFacesWindingFromMatrix:e=>e.map((e=>e[0]*e[4]-e[1]*e[3])).map((e=>e>=0)),makeFacesWindingFromMatrix2:makeFacesWindingFromMatrix2});const topologicalSortQuick=e=>{const t=uniqueSortedNumbers(e.flat()),r=[];t.forEach((e=>{r[e]=[]})),e.forEach((e=>{r[e[1]].push(e[0])}));const s=[],a={},recurse=e=>{a[e]||(a[e]=!0,r[e].forEach(recurse),s.push(e))};return t.forEach(recurse),s},topologicalSort=e=>{const t=topologicalSortQuick(e),r=invertFlatMap(t);return e.filter((([e,t])=>r[e]>r[t])).length?void 0:t};var xr=Object.freeze({__proto__:null,topologicalSort:topologicalSort,topologicalSortQuick:topologicalSortQuick});const faceOrdersSubset=(e,t)=>{const r={};return t.forEach((e=>{r[e]=!0})),e.filter((e=>r[e[0]]&&r[e[1]]))},overlappingFaceOrdersClusters=({faceOrders:e})=>{const t=connectedComponents(makeVerticesVerticesUnsorted({edges_vertices:e.map((([e,t])=>[e,t]))})),r=invertFlatToArrayMap(t),s=r.map((t=>faceOrdersSubset(e,t)));return{clusters_faces:r,clusters_faceOrders:s}},faceOrdersToDirectedEdges=({vertices_coords:e,faces_vertices:t,faceOrders:r,faces_normal:s},a)=>{if(!r||!r.length)return[];s||(s=makeFacesNormal({vertices_coords:e,faces_vertices:t}));const o=uniqueSortedNumbers(r.flatMap((([e,t])=>[e,t]))),c=void 0!==a&&o.includes(a)?s[a]:s[o[0]],n={};return o.forEach((e=>{n[e]=dot(s[e],c)>0})),r.map((e=>-1===e[2]!=!n[e[1]]?[e[0],e[1]]:[e[1],e[0]]))},linearizeFaceOrders=({vertices_coords:e,faces_vertices:t,faceOrders:r,faces_normal:s},a)=>topologicalSort(faceOrdersToDirectedEdges({vertices_coords:e,faces_vertices:t,faceOrders:r,faces_normal:s},a)),fillInMissingFaces=({faces_vertices:e},t)=>{if(!e)return t;return e.map(((e,t)=>t)).filter((e=>null==t[e])).concat(invertFlatMap(t))},linearize2DFaces=({vertices_coords:e,faces_vertices:t,faceOrders:r,faces_layer:s,faces_normal:a},o)=>{if(a||(a=makeFacesNormal({vertices_coords:e,faces_vertices:t})),r){const e=linearizeFaceOrders({faceOrders:r,faces_normal:a},o);return e?fillInMissingFaces({faces_vertices:t},invertFlatMap(e)):[]}return s?fillInMissingFaces({faces_vertices:t},s):t.map(((e,t)=>t)).filter((()=>!0))},nudgeFacesWithFaceOrders=({vertices_coords:e,faces_vertices:t,faceOrders:r,faces_normal:s})=>{const a=s?s.map(resize3):makeFacesNormal({vertices_coords:e,faces_vertices:t}),{clusters_faces:o,clusters_faceOrders:c}=overlappingFaceOrdersClusters({faceOrders:r}),n=c.map((e=>linearizeFaceOrders({faceOrders:e,faces_normal:a})));if(n.includes(void 0))return;const i=o.map((e=>a[e[0]])),l=[];return n.forEach(((e,t)=>e.forEach(((e,r)=>{l[e]={vector:i[t],layer:r}})))),l};var Or=Object.freeze({__proto__:null,faceOrdersSubset:faceOrdersSubset,faceOrdersToDirectedEdges:faceOrdersToDirectedEdges,flipFacesLayer:e=>invertArrayToFlatMap(invertFlatToArrayMap(e).reverse()),linearize2DFaces:linearize2DFaces,linearizeFaceOrders:linearizeFaceOrders,makeFacesLayer:({vertices_coords:e,faces_vertices:t,faceOrders:r,faces_normal:s})=>{s||(s=makeFacesNormal({vertices_coords:e,faces_vertices:t}));const a=linearizeFaceOrders({faceOrders:r,faces_normal:s});return a?invertFlatMap(a):[]},nudgeFacesWithFaceOrders:nudgeFacesWithFaceOrders,nudgeFacesWithFacesLayer:({faces_layer:e})=>{const t=[];return invertFlatMap(e).forEach(((e,r)=>{t[e]={vector:[0,0,1],layer:r}})),t},overlappingFaceOrdersClusters:overlappingFaceOrdersClusters});const jr=["front","back"],wr={foldedForm:{ordered:{back:{fill:"white"},front:{fill:"#ddd"}},unordered:{back:{opacity:.1},front:{opacity:.1}}},creasePattern:{}},kr={foldedForm:{ordered:{stroke:"black","stroke-linejoin":"bevel"},unordered:{stroke:"none",fill:"black","stroke-linejoin":"bevel"}},creasePattern:{fill:"none"}},finalize_faces=(e,t,r,s={})=>{const a=isFoldedForm(e),o=!(!e.faceOrders&&!e.faces_layer);makeFacesWinding(e).map((e=>e?jr[0]:jr[1])).forEach(((e,r)=>{addClass(t[r],e),t[r].setAttribute("data-side",e);const c=o?wr.foldedForm.ordered[e]:wr.foldedForm.unordered[e],n=a?c:wr.creasePattern[e];setKeysAndValues(t[r],n),setKeysAndValues(t[r],s[e])})),linearize2DFaces(e).forEach((e=>r.appendChild(t[e])));const c=o?kr.foldedForm.ordered:kr.foldedForm.unordered;return setKeysAndValues(r,a?c:kr.creasePattern),r},facesVerticesPolygon=(e,t)=>{const r=e.faces_vertices.map((t=>t.map((t=>[0,1].map((r=>e.vertices_coords[t][r])))))).map((e=>vr.polygon(e)));return r.forEach(((e,t)=>e.setAttributeNS(null,"index",t))),finalize_faces(e,r,vr.g(),t)},facesEdgesPolygon=function(e,t){const r=e.faces_edges.map((t=>t.map((t=>e.edges_vertices[t])).map(((e,t,r)=>{const s=r[(t+1)%r.length];return e[1]===s[0]||e[1]===s[1]?e[0]:e[1]})).map((t=>[0,1].map((r=>e.vertices_coords[t][r])))))).map((e=>vr.polygon(e)));return r.forEach(((e,t)=>e.setAttributeNS(null,"index",t))),finalize_faces(e,r,vr.g(),t)},drawFaces=(e,t)=>e&&e.vertices_coords&&e.faces_vertices?facesVerticesPolygon(e,t):e&&e.vertices_coords&&e.edges_vertices&&e.faces_edges?facesEdgesPolygon(e,t):vr.g();var Fr=Object.freeze({__proto__:null,drawFaces:drawFaces,facesEdgesPolygon:facesEdgesPolygon,facesVerticesPolygon:facesVerticesPolygon});const Sr={fill:"none"},Cr={stroke:"black",fill:"white"},drawBoundaries=(e,t={})=>{const r=vr.g();if(!e)return r;const s=boundaries$1(e).map((({vertices:t})=>t.map((t=>e.vertices_coords[t])))).filter((e=>e.length));return s.forEach((e=>{const t=vr.polygon(e);addClass(t,"boundary"),r.appendChild(t)})),setKeysAndValues(r,isFoldedForm(e)?Sr:Cr),setKeysAndValues(r,t),r};var Vr=Object.freeze({__proto__:null,drawBoundaries:drawBoundaries});const zr={vertices:drawVertices,edges:drawEdges,faces:drawFaces,boundaries:drawBoundaries},Tr={min:[0,0],max:[1,1],span:[1,1]},Pr=["boundaries","faces","edges","vertices"],renderSVG=(e,t,r={})=>{((e,t)=>{void 0===t.vertices&&(t.vertices=!1),isFoldedForm(e)||void 0===t.faces&&(t.faces=!1)})(e,r);const s=((e,t={})=>Pr.map((r=>!1===t[r]?vr.g():zr[r](e,t[r]))).map(((e,t)=>(addClass(e,Pr[t]),e))))(e,r);return s.filter((e=>e.childNodes.length>0)).forEach((e=>t.appendChild(e))),((e,t,r,s)=>{const a=t[3]&&t[3].childNodes.length;if(!(a||void 0!==s.strokeWidth&&!1!==s.strokeWidth||void 0!==s.viewBox&&!1!==s.viewBox))return;const o=boundingBox(r)||Tr,c=Math.max(...o.span),n=findElementTypeInParents(e,"svg");if(n&&s.viewBox){const e=boundingBoxToViewBox(o);n.setAttributeNS(null,"viewBox",e)}if(n&&s.padding){const e=n.getAttribute("viewBox");if(null!=e){const t=s.padding*c,r=e.split(" ").map((e=>parseFloat(e))),a=[-t,-t,2*t,2*t].map(((e,t)=>r[t]+e)).join(" ");n.setAttributeNS(null,"viewBox",a)}}if(s.strokeWidth||s["stroke-width"]){const t=s.strokeWidth?s.strokeWidth:s["stroke-width"],a="number"==typeof t?c*t:getStrokeWidth(r);e.setAttributeNS(null,"stroke-width",a)}if(a){const e=s.vertices&&null!=s.vertices.radius?s.vertices.radius:s.radius,r="string"==typeof e?parseFloat(e):e,a="number"!=typeof r||Number.isNaN(r)?.02*c:c*r;for(let e=0;e<t[3].childNodes.length;e+=1)t[3].childNodes[e].setAttributeNS(null,"r",a)}})(t,s,e,r),addClass(t,...[e.file_classes||[],e.frame_classes||[]].flat()),t},foldToSvg=(e,t={})=>{const r=renderSVG("string"==typeof e?JSON.parse(e):e,vr.svg(),{viewBox:!0,strokeWidth:!0,...t});return t&&t.string?(new(RabbitEarWindow$1().XMLSerializer)).serializeToString(r):r};const foldToObj=e=>{const t="string"==typeof e?JSON.parse(e):e,r=(e=>["file_title","file_author","file_description","frame_title","frame_author","frame_description"].filter((t=>e[t])).map((t=>`# ${t.split("_")[1]}: ${e[t]}`)).join("\n"))(t);return`${[r,(t.vertices_coords||[]).map((e=>e.join(" "))).map((e=>`v ${e}`)).join("\n"),(t.faces_vertices||[]).map((e=>e.map((e=>e+1)).join(" "))).map((e=>`f ${e}`)).join("\n")].filter((e=>""!==e)).join("\n")}\n`};const parseCSSStyleSheet=e=>{if(!e.cssRules)return{};const t={};for(let r=0;r<e.cssRules.length;r+=1){const s=e.cssRules[r];if("CSSStyleRule"!==s.constructor.name)continue;const a=s,o=a.selectorText.split(/,/gm).filter(Boolean).map((e=>e.trim())),c={};Object.values(a.style).forEach((e=>{c[e]=a.style[e]})),o.forEach((e=>{t[e]=c}))}return t};var $r={...Me,...Ie,...ft,...Object.freeze({__proto__:null,foldToSvg:foldToSvg,renderSVG:renderSVG}),...Object.freeze({__proto__:null,foldToObj:foldToObj}),...Xe,...Re,...Pe,...ur,...{...rt,...Vr,...hr,...Mr,...Fr,...it,...Object.freeze({__proto__:null,getStylesheetStyle:(e,t,r,s=[])=>{const a=r.class?r.class.split(/\s/).filter(Boolean).map((e=>e.trim())).map((e=>`.${e}`)):[],o=r.id?`#${r.id}`:null;if(o)for(let t=0;t<s.length;t+=1)if(s[t][o]&&s[t][o][e])return s[t][o][e];for(let r=0;r<s.length;r+=1){for(let t=0;t<a.length;t+=1)if(s[r][a[t]]&&s[r][a[t]][e])return s[r][a[t]][e];if(s[r][t]&&s[r][t][e])return s[r][t][e]}},parseCSSStyleSheet:parseCSSStyleSheet,parseStyleElement:e=>{const t="sheet"in e?e.sheet:void 0;if(t)return parseCSSStyleSheet(t);if(!(getRootParent(e).constructor===RabbitEarWindow$1().HTMLDocument)){const r=e.parentNode;null!=r&&r.removeChild(e);const s=null!=RabbitEarWindow$1().document.body?RabbitEarWindow$1().document.body:RabbitEarWindow$1().document.createElement("body");s.appendChild(e);const a=parseCSSStyleSheet(t);return s.removeChild(e),null!=r&&r.appendChild(e),a}return[]}})}};var Br={...Q,...S,...Ne,...ne,...Object.freeze({__proto__:null,capitalized:e=>e.charAt(0).toUpperCase()+e.slice(1),toCamel:e=>e.replace(/([-_][a-z])/gi,(e=>e.toUpperCase().replace("-","").replace("_",""))),toKebab:e=>e.replace(/([a-z0-9])([A-Z])/g,"$1-$2").replace(/([A-Z])([A-Z])(?=[a-z])/g,"$1-$2").toLowerCase()})};const flattenFrame=(e,t=0)=>{if(!e.file_frames||e.file_frames.length<t)return e;const r={},s={};filterKeysWithPrefix(e,"file").filter((e=>"file_frames"!==e)).forEach((t=>{s[t]=e[t]}));const recurse=(t,s)=>{if(r[t])throw new Error(o);r[t]=!0;const a=[t].concat(s),c=t>0?{...e.file_frames[t-1]}:{...e};return c.frame_inherit&&null!=c.frame_parent?recurse(c.frame_parent,a):a},a=recurse(t,[]).map((t=>{const r=t>0?{...e.file_frames[t-1]}:{...e};return["file_frames","frame_parent","frame_inherit"].forEach((e=>delete r[e])),r})).reduce(((e,t)=>({...e,...t})),s);return br(a)},countFrames=({file_frames:e})=>e?e.length+1:1;var Nr=Object.freeze({__proto__:null,countFrames:countFrames,flattenFrame:flattenFrame,getFileFramesAsArray:e=>{if(!e)return[];if(!e.file_frames||!e.file_frames.length)return[e];const t={...e};return delete t.file_frames,[t,...e.file_frames]},getFramesByClassName:(e,t)=>Array.from(Array(countFrames(e))).map(((t,r)=>flattenFrame(e,r))).filter((e=>e.frame_classes&&e.frame_classes.includes(t)))});const addVertices=(e,t=[])=>{e.vertices_coords||(e.vertices_coords=[]);const r=t.map(((t,r)=>e.vertices_coords.length+r));return r.forEach(((r,s)=>{e.vertices_coords[r]=t[s],e.vertices_vertices&&(e.vertices_vertices[r]=[]),e.vertices_edges&&(e.vertices_edges[r]=[]),e.vertices_faces&&(e.vertices_faces[r]=[])})),r};var Rr=Object.freeze({__proto__:null,addVertex:(e,t,r=[],s=[],a=[])=>{e.vertices_coords||(e.vertices_coords=[]);const o=e.vertices_coords.length;return e.vertices_coords[o]=t,e.vertices_vertices&&(e.vertices_vertices[o]=r),e.vertices_edges&&(e.vertices_edges[o]=s),e.vertices_faces&&(e.vertices_faces[o]=a),o},addVertices:addVertices});const addEdge=(e,t,r=[],s="U",a=0)=>{e.edges_vertices||(e.edges_vertices=[]);const o=e.edges_vertices.length;return e.edges_vertices[o]=t,e.edges_faces&&(e.edges_faces[o]=r),e.edges_assignment&&(e.edges_assignment[o]=s),e.edges_foldAngle&&(e.edges_foldAngle[o]=a),o},addIsolatedEdge=(e,t,r="U",s=0)=>{const a=addEdge(e,t,[],r,s);if(e.vertices_vertices){t.filter((t=>!e.vertices_vertices[t])).forEach((t=>{e.vertices_vertices[t]=[]}));const r=[t[1],t[0]];t.forEach(((t,s)=>{e.vertices_vertices[t].push(r[s])}))}return e.vertices_edges&&(t.filter((t=>!e.vertices_edges[t])).forEach((t=>{e.vertices_edges[t]=[]})),t.forEach((t=>{e.vertices_edges[t].push(a)}))),e.vertices_faces&&t.filter((t=>!e.vertices_faces[t])).forEach((t=>{e.vertices_faces[t]=[]})),a};var Lr=Object.freeze({__proto__:null,addEdge:addEdge,addIsolatedEdge:addIsolatedEdge});const Ir=Object.freeze([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),multiplyMatrix4Vector3=(e,t)=>[e[0]*t[0]+e[4]*t[1]+e[8]*t[2]+e[12],e[1]*t[0]+e[5]*t[1]+e[9]*t[2]+e[13],e[2]*t[0]+e[6]*t[1]+e[10]*t[2]+e[14]],multiplyMatrix4Line3=(e,t,r)=>({vector:[e[0]*t[0]+e[4]*t[1]+e[8]*t[2],e[1]*t[0]+e[5]*t[1]+e[9]*t[2],e[2]*t[0]+e[6]*t[1]+e[10]*t[2]],origin:[e[0]*r[0]+e[4]*r[1]+e[8]*r[2]+e[12],e[1]*r[0]+e[5]*r[1]+e[9]*r[2]+e[13],e[2]*r[0]+e[6]*r[1]+e[10]*r[2]+e[14]]}),multiplyMatrices4=(e,t)=>[e[0]*t[0]+e[4]*t[1]+e[8]*t[2]+e[12]*t[3],e[1]*t[0]+e[5]*t[1]+e[9]*t[2]+e[13]*t[3],e[2]*t[0]+e[6]*t[1]+e[10]*t[2]+e[14]*t[3],e[3]*t[0]+e[7]*t[1]+e[11]*t[2]+e[15]*t[3],e[0]*t[4]+e[4]*t[5]+e[8]*t[6]+e[12]*t[7],e[1]*t[4]+e[5]*t[5]+e[9]*t[6]+e[13]*t[7],e[2]*t[4]+e[6]*t[5]+e[10]*t[6]+e[14]*t[7],e[3]*t[4]+e[7]*t[5]+e[11]*t[6]+e[15]*t[7],e[0]*t[8]+e[4]*t[9]+e[8]*t[10]+e[12]*t[11],e[1]*t[8]+e[5]*t[9]+e[9]*t[10]+e[13]*t[11],e[2]*t[8]+e[6]*t[9]+e[10]*t[10]+e[14]*t[11],e[3]*t[8]+e[7]*t[9]+e[11]*t[10]+e[15]*t[11],e[0]*t[12]+e[4]*t[13]+e[8]*t[14]+e[12]*t[15],e[1]*t[12]+e[5]*t[13]+e[9]*t[14]+e[13]*t[15],e[2]*t[12]+e[6]*t[13]+e[10]*t[14]+e[14]*t[15],e[3]*t[12]+e[7]*t[13]+e[11]*t[14]+e[15]*t[15]],determinant4=e=>{const t=e[10]*e[15]-e[11]*e[14],r=e[9]*e[15]-e[11]*e[13],s=e[9]*e[14]-e[10]*e[13],a=e[8]*e[15]-e[11]*e[12],o=e[8]*e[14]-e[10]*e[12],c=e[8]*e[13]-e[9]*e[12];return e[0]*(e[5]*t-e[6]*r+e[7]*s)-e[1]*(e[4]*t-e[6]*a+e[7]*o)+e[2]*(e[4]*r-e[5]*a+e[7]*c)-e[3]*(e[4]*s-e[5]*o+e[6]*c)},invertMatrix4=e=>{const t=determinant4(e);if(Math.abs(t)<1e-12||Number.isNaN(t)||!Number.isFinite(e[12])||!Number.isFinite(e[13])||!Number.isFinite(e[14]))return;const r=e[10]*e[15]-e[11]*e[14],s=e[9]*e[15]-e[11]*e[13],a=e[9]*e[14]-e[10]*e[13],o=e[8]*e[15]-e[11]*e[12],c=e[8]*e[14]-e[10]*e[12],n=e[8]*e[13]-e[9]*e[12],i=e[6]*e[15]-e[7]*e[14],l=e[5]*e[15]-e[7]*e[13],d=e[5]*e[14]-e[6]*e[13],_=e[6]*e[11]-e[7]*e[10],m=e[5]*e[11]-e[7]*e[9],g=e[5]*e[10]-e[6]*e[9],v=e[4]*e[15]-e[7]*e[12],p=e[4]*e[14]-e[6]*e[12],u=e[4]*e[11]-e[7]*e[8],h=e[4]*e[10]-e[6]*e[8],b=e[4]*e[13]-e[5]*e[12],y=e[4]*e[9]-e[5]*e[8],E=[+(e[5]*r-e[6]*s+e[7]*a),-(e[1]*r-e[2]*s+e[3]*a),+(e[1]*i-e[2]*l+e[3]*d),-(e[1]*_-e[2]*m+e[3]*g),-(e[4]*r-e[6]*o+e[7]*c),+(e[0]*r-e[2]*o+e[3]*c),-(e[0]*i-e[2]*v+e[3]*p),+(e[0]*_-e[2]*u+e[3]*h),+(e[4]*s-e[5]*o+e[7]*n),-(e[0]*s-e[1]*o+e[3]*n),+(e[0]*l-e[1]*v+e[3]*b),-(e[0]*m-e[1]*u+e[3]*y),-(e[4]*a-e[5]*c+e[6]*n),+(e[0]*a-e[1]*c+e[2]*n),-(e[0]*d-e[1]*p+e[2]*b),+(e[0]*g-e[1]*h+e[2]*y)],M=1/t;return E.map((e=>e*M))},Ur=Object.freeze([1,0,0,0,0,1,0,0,0,0,1,0]),makeMatrix4Translate=(e=0,t=0,r=0)=>[...Ur,e,t,r,1],singleAxisRotate4=(e,t,r,s,a)=>{const o=Math.cos(e),c=Math.sin(e),n=[...Ir];n[4*r+r]=o,n[4*r+s]=(a?1:-1)*c,n[4*s+r]=(a?-1:1)*c,n[4*s+s]=o;const i=[0,1,2].map((e=>t[e]||0)),l=[...Ir],d=[...Ir];return[12,13,14].forEach(((e,t)=>{l[e]=-i[t],d[e]=i[t]})),multiplyMatrices4(d,multiplyMatrices4(n,l))},makeMatrix4Scale=(e=[1,1,1],t=[0,0,0])=>[e[0],0,0,0,0,e[1],0,0,0,0,e[2],0,e[0]*-t[0]+t[0],e[1]*-t[1]+t[1],e[2]*-t[2]+t[2],1],makePerspectiveMatrix4=(e,t,r,s)=>{const a=Math.tan(.5*Math.PI-.5*e),o=1/(r-s);return[t<1?a:a/t,0,0,0,0,t<1?a*t:a,0,0,0,0,(r+s)*o,-1,0,0,r*s*o*2,0]},makeOrthographicMatrix4=(e,t,r,s,a,o)=>[2/(t-s),0,0,0,0,2/(e-r),0,0,0,0,2/(a-o),0,(s+t)/(s-t),(r+e)/(r-e),(a+o)/(a-o),1];var Dr=Object.freeze({__proto__:null,determinant4:determinant4,identity4x4:Ir,invertMatrix4:invertMatrix4,isIdentity4x4:e=>Ir.map(((t,r)=>Math.abs(t-e[r])<p)).reduce(((e,t)=>e&&t),!0),makeLookAtMatrix4:(e,t,r)=>{const s=normalize3(subtract3(e,t)),a=normalize3(cross3(r,s)),o=normalize3(cross3(s,a));return[a[0],a[1],a[2],0,o[0],o[1],o[2],0,s[0],s[1],s[2],0,e[0],e[1],e[2],1]},makeMatrix4ReflectZ:(e,t=[0,0])=>{const r=makeMatrix2Reflect(e,t);return[r[0],r[1],0,0,r[2],r[3],0,0,0,0,1,0,r[4],r[5],0,1]},makeMatrix4Rotate:(e,t=[0,0,1],r=[0,0,0])=>{const s=[0,1,2].map((e=>r[e]||0)),[a,o,c]=resize(3,normalize$2(t)),n=Math.cos(e),i=Math.sin(e),l=1-n,d=makeMatrix4Translate(-s[0],-s[1],-s[2]),_=makeMatrix4Translate(s[0],s[1],s[2]);return multiplyMatrices4(_,multiplyMatrices4([l*a*a+n,l*o*a+c*i,l*c*a-o*i,0,l*a*o-c*i,l*o*o+n,l*c*o+a*i,0,l*a*c+o*i,l*o*c-a*i,l*c*c+n,0,0,0,0,1],d))},makeMatrix4RotateX:(e,t=[0,0,0])=>singleAxisRotate4(e,t,1,2,!0),makeMatrix4RotateY:(e,t=[0,0,0])=>singleAxisRotate4(e,t,0,2,!1),makeMatrix4RotateZ:(e,t=[0,0,0])=>singleAxisRotate4(e,t,0,1,!0),makeMatrix4Scale:makeMatrix4Scale,makeMatrix4Translate:makeMatrix4Translate,makeMatrix4UniformScale:(e=1,t=[0,0,0])=>makeMatrix4Scale([e,e,e],t),makeOrthographicMatrix4:makeOrthographicMatrix4,makePerspectiveMatrix4:makePerspectiveMatrix4,multiplyMatrices4:multiplyMatrices4,multiplyMatrix4Line3:multiplyMatrix4Line3,multiplyMatrix4Vector3:multiplyMatrix4Vector3});const quaternionFromTwoVectors=(e,t)=>{const r=cross3(e,t),s=[r[0],r[1],r[2],dot(e,t)];s[3]+=magnitude(s);const[a,o,c,n]=normalize$2(s);return[a,o,c,n]},matrix4FromQuaternion=e=>multiplyMatrices4([+e[3],+e[2],-e[1],+e[0],-e[2],+e[3],+e[0],+e[1],+e[1],-e[0],+e[3],+e[2],-e[0],-e[1],-e[2],+e[3]],[+e[3],+e[2],-e[1],-e[0],-e[2],+e[3],+e[0],-e[1],+e[1],-e[0],+e[3],-e[2],+e[0],+e[1],+e[2],+e[3]]);var Qr=Object.freeze({__proto__:null,matrix4FromQuaternion:matrix4FromQuaternion,quaternionFromTwoVectors:quaternionFromTwoVectors});const makeFacesFaces=({faces_vertices:e})=>{const t={},r=e.map((e=>e.map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>e.join(" ")))));return r.flat().forEach((e=>{t[e]=[]})),r.forEach(((e,r)=>e.forEach((e=>t[e].push(r))))),e.map(((e,r)=>e.map(((e,t,r)=>[r[(t+1)%r.length],e])).map((e=>e.join(" "))).map((e=>t[e])).map((e=>void 0===e?[void 0]:e)).flatMap((e=>e.filter((e=>r!==e)).shift()))))};var Wr=Object.freeze({__proto__:null,makeFacesFaces:makeFacesFaces});const selfRelationalArraySubset=(e,t)=>{const r={};t.forEach((e=>{r[e]=!0}));const s=[];return t.forEach((t=>{s[t]=e[t].filter((e=>r[e]))})),s},subgraphExclusive=(e,t={})=>{const r={vertices:[],edges:[],faces:[],...t},s=Object.keys(r),a={...e};G.graph.forEach((e=>delete a[e])),delete a.file_frames;const o={};s.forEach((e=>{o[e]={}})),s.forEach((e=>r[e].forEach((t=>{o[e][t]=!0}))));const c={};return s.forEach((t=>{filterKeysWithPrefix(e,t).forEach((e=>{c[e]={}})),filterKeysWithSuffix(e,t).forEach((e=>{c[e]={}}))})),s.forEach((t=>{filterKeysWithPrefix(e,t).forEach((e=>{c[e].prefix=t})),filterKeysWithSuffix(e,t).forEach((e=>{c[e].suffix=t}))})),Object.keys(c).forEach((e=>{a[e]=[]})),Object.keys(c).forEach((t=>{const{prefix:s,suffix:n}=c[t];s&&n?r[s].forEach((r=>{a[t][r]=e[t][r].filter((e=>o[n][e]))})):s?r[s].forEach((r=>{a[t][r]=e[t][r]})):a[t]=n?e[t].map((e=>e.filter((e=>o[n][e])))):e[t]})),a},subgraph=(e,t={})=>{const r={vertices:[],edges:[],faces:[],...t},s={vertices:{},edges:{},faces:{}};return r.vertices.forEach((e=>{s.vertices[e]=!0})),r.edges.forEach((e=>{s.edges[e]=!0})),r.edges.forEach((t=>e.edges_vertices[t].forEach((e=>{s.vertices[e]=!0})))),r.faces.forEach((e=>{s.faces[e]=!0})),r.faces.forEach((t=>e.faces_vertices[t].forEach((e=>{s.vertices[e]=!0})))),e.faces_vertices.map(((e,t)=>t)).filter((t=>e.faces_vertices[t].map((e=>s.vertices[e])).reduce(((e,t)=>e&&t),!0))).forEach((e=>{s.faces[e]=!0})),e.edges_vertices.map(((e,t)=>t)).filter((t=>e.edges_vertices[t].map((e=>s.vertices[e])).reduce(((e,t)=>e&&t),!0))).forEach((e=>{s.edges[e]=!0})),subgraphExclusive(e,{vertices:Object.keys(s.vertices),edges:Object.keys(s.edges),faces:Object.keys(s.faces)})},subgraphWithFaces=(e,t)=>{let r=[];e.faces_vertices&&(r=uniqueSortedNumbers(t.flatMap((t=>e.faces_vertices[t]))));let s=[];if(e.faces_edges)s=uniqueSortedNumbers(t.flatMap((t=>e.faces_edges[t])));else if(e.edges_vertices){const t={};r.forEach((e=>{t[e]=!0})),s=e.edges_vertices.map(((e,r)=>t[e[0]]&&t[e[1]]?r:void 0)).filter((e=>void 0!==e))}return subgraphExclusive(e,{vertices:r,edges:s,faces:t})};var qr=Object.freeze({__proto__:null,selfRelationalArraySubset:selfRelationalArraySubset,subgraph:subgraph,subgraphExclusive:subgraphExclusive,subgraphWithFaces:subgraphWithFaces,subgraphWithVertices:(e,t=[])=>{const r={vertices:[],edges:[]};return t.forEach((e=>{r.vertices[e]=!0})),e.vertices_edges&&r.vertices.forEach(((t,s)=>e.vertices_edges[s].forEach((e=>{r.edges[e]=!0})))),e.edges_vertices&&r.edges.forEach(((t,s)=>e.edges_vertices[s].forEach((e=>{r.vertices[e]=!0})))),subgraphExclusive(e,{vertices:r.vertices.map(((e,t)=>e?t:void 0)).filter((e=>void 0!==e)),edges:r.edges.map(((e,t)=>e?t:void 0)).filter((e=>void 0!==e))})}});const getFacesPlane=({vertices_coords:e,faces_vertices:t},r=p)=>{const s=makeFacesNormal({vertices_coords:e,faces_vertices:t}),a=t.map((()=>[]));for(let e=0;e<t.length-1;e+=1)for(let o=e+1;o<t.length;o+=1)parallelNormalized(s[e],s[o],r)&&(a[e].push(o),a[o].push(e));const o=connectedComponents(a),c=invertFlatToArrayMap(o),n=c.map((e=>s[e[0]])),i=[];c.forEach(((e,t)=>e.forEach((e=>{i[e]=dot3(s[e],n[t])>0}))));const l=t.map((t=>e[t[0]])).map(resize3),d=c.map(((e,t)=>e.map((e=>dot3(n[t],l[e]))))),_=d.map(((e,t)=>clusterScalars(e).map((e=>e.map((e=>c[t][e])))))),m=_.flat(),g=_.flatMap(((e,t)=>e.map((()=>n[t])))).map(resize3),v=m.map((e=>e[0])).map((e=>l[e])).map(((e,t)=>dot3(g[t],e))).map(((e,t)=>scale3$1(g[t],e))),u=m.map(((e,t)=>({normal:g[t],origin:v[t]}))),h=invertArrayToFlatMap(m),b=[0,0,1],y=u.map((({normal:e})=>Math.abs(dot(e,b)+1)<r?[1,0,0,0,0,-1,0,0,0,0,-1,0,0,0,0,1]:matrix4FromQuaternion(quaternionFromTwoVectors(e,b))));return u.forEach((({origin:e},t)=>{const r=multiplyMatrix4Vector3(y[t],flip3(e));y[t][12]=r[0],y[t][13]=r[1],y[t][14]=r[2]})),{planes:u,planes_faces:m,planes_transform:y,faces_plane:h,faces_winding:i}},getCoplanarAdjacentOverlappingFaces=({vertices_coords:e,faces_vertices:t,faces_faces:r},s=p)=>{r||(r=makeFacesFaces({faces_vertices:t}));const{planes:a,planes_faces:o,planes_transform:c,faces_plane:n,faces_winding:i}=getFacesPlane({vertices_coords:e,faces_vertices:t},s),l=e.map(resize3),d=t.map(((e,t)=>i[t]?e:e.slice().reverse())).map((e=>e.map((e=>l[e])))).map((e=>makePolygonNonCollinear3(e,s))).map(((e,t)=>e.map((e=>multiplyMatrix4Vector3(c[n[t]],e))).map(resize2))),_=o.map((e=>selfRelationalArraySubset(r,e))),m=_.map(connectedComponents),g=m.map((e=>invertFlatToArrayMap(e))),v=m.map((e=>{const t=e.map(((e,t)=>t));return e.map((r=>t.filter((t=>e[t]!==r))))})),u=g.map((e=>e.map((()=>[]))));v.forEach(((e,t)=>{const r={};e.forEach(((e,a)=>e.forEach((e=>{const o=[a,e].map((e=>m[t][e])),c=o.join(" ");if(r[c])return;if(overlapConvexPolygons(d[a],d[e],s)){const e=o.reverse().join(" ");r[c]=!0,r[e]=!0,u[t][o[0]].push(o[1]),u[t][o[1]].push(o[0])}}))))}));const h=u.map((e=>invertFlatToArrayMap(connectedComponents(e)))),b=h.flatMap(((e,t)=>e.map((()=>t)))),y=invertFlatToArrayMap(b),E=h.flatMap(((e,t)=>e.map((e=>e.flatMap((e=>g[t][e])))))),M=invertArrayToFlatMap(E);return{planes:a,planes_faces:o,planes_transform:c,planes_clusters:y,faces_winding:i,faces_plane:n,faces_cluster:M,clusters_plane:b,clusters_faces:E}};var Gr=Object.freeze({__proto__:null,getCoplanarAdjacentOverlappingFaces:getCoplanarAdjacentOverlappingFaces,getFacesPlane:getFacesPlane});const Hr=Object.freeze([1,0,0,0,1,0,0,0,1]),Jr=Object.freeze(Hr.concat(0,0,0)),multiplyMatrix3Vector3=(e,t)=>[e[0]*t[0]+e[3]*t[1]+e[6]*t[2]+e[9],e[1]*t[0]+e[4]*t[1]+e[7]*t[2]+e[10],e[2]*t[0]+e[5]*t[1]+e[8]*t[2]+e[11]],multiplyMatrices3=(e,t)=>[e[0]*t[0]+e[3]*t[1]+e[6]*t[2],e[1]*t[0]+e[4]*t[1]+e[7]*t[2],e[2]*t[0]+e[5]*t[1]+e[8]*t[2],e[0]*t[3]+e[3]*t[4]+e[6]*t[5],e[1]*t[3]+e[4]*t[4]+e[7]*t[5],e[2]*t[3]+e[5]*t[4]+e[8]*t[5],e[0]*t[6]+e[3]*t[7]+e[6]*t[8],e[1]*t[6]+e[4]*t[7]+e[7]*t[8],e[2]*t[6]+e[5]*t[7]+e[8]*t[8],e[0]*t[9]+e[3]*t[10]+e[6]*t[11]+e[9],e[1]*t[9]+e[4]*t[10]+e[7]*t[11]+e[10],e[2]*t[9]+e[5]*t[10]+e[8]*t[11]+e[11]],determinant3=e=>e[0]*e[4]*e[8]-e[0]*e[7]*e[5]-e[3]*e[1]*e[8]+e[3]*e[7]*e[2]+e[6]*e[1]*e[5]-e[6]*e[4]*e[2],invertMatrix3=e=>{const t=determinant3(e);if(Math.abs(t)<1e-12||Number.isNaN(t)||!Number.isFinite(e[9])||!Number.isFinite(e[10])||!Number.isFinite(e[11]))return;const r=[e[4]*e[8]-e[7]*e[5],-e[1]*e[8]+e[7]*e[2],e[1]*e[5]-e[4]*e[2],-e[3]*e[8]+e[6]*e[5],e[0]*e[8]-e[6]*e[2],-e[0]*e[5]+e[3]*e[2],e[3]*e[7]-e[6]*e[4],-e[0]*e[7]+e[6]*e[1],e[0]*e[4]-e[3]*e[1],-e[3]*e[7]*e[11]+e[3]*e[8]*e[10]+e[6]*e[4]*e[11]-e[6]*e[5]*e[10]-e[9]*e[4]*e[8]+e[9]*e[5]*e[7],e[0]*e[7]*e[11]-e[0]*e[8]*e[10]-e[6]*e[1]*e[11]+e[6]*e[2]*e[10]+e[9]*e[1]*e[8]-e[9]*e[2]*e[7],-e[0]*e[4]*e[11]+e[0]*e[5]*e[10]+e[3]*e[1]*e[11]-e[3]*e[2]*e[10]-e[9]*e[1]*e[5]+e[9]*e[2]*e[4]],s=1/t;return r.map((e=>e*s))},singleAxisRotate=(e,t,r,s,a)=>{const o=Math.cos(e),c=Math.sin(e),n=Hr.concat([0,0,0]);n[3*r+r]=o,n[3*r+s]=(a?1:-1)*c,n[3*s+r]=(a?-1:1)*c,n[3*s+s]=o;const i=[0,1,2].map((e=>t[e]||0)),l=Hr.concat(flip(i)),d=Hr.concat(i);return multiplyMatrices3(d,multiplyMatrices3(n,l))},makeMatrix3RotateX=(e,t=[0,0,0])=>singleAxisRotate(e,t,1,2,!0),makeMatrix3RotateY=(e,t=[0,0,0])=>singleAxisRotate(e,t,0,2,!1),makeMatrix3RotateZ=(e,t=[0,0,0])=>singleAxisRotate(e,t,0,1,!0),makeMatrix3Rotate=(e,t=[0,0,1],r=[0,0,0])=>{const s=[0,1,2].map((e=>r[e]||0)),[a,o,c]=resize(3,normalize$2(t)),n=Math.cos(e),i=Math.sin(e),l=1-n,d=Hr.concat(-s[0],-s[1],-s[2]),_=Hr.concat(s[0],s[1],s[2]);return multiplyMatrices3(_,multiplyMatrices3([l*a*a+n,l*o*a+c*i,l*c*a-o*i,l*a*o-c*i,l*o*o+n,l*c*o+a*i,l*a*c+o*i,l*o*c-a*i,l*c*c+n,0,0,0],d))},makeMatrix3Scale=(e=[1,1,1],t=[0,0,0])=>[e[0],0,0,0,e[1],0,0,0,e[2],e[0]*-t[0]+t[0],e[1]*-t[1]+t[1],e[2]*-t[2]+t[2]];var Zr=Object.freeze({__proto__:null,determinant3:determinant3,identity3x3:Hr,identity3x4:Jr,invertMatrix3:invertMatrix3,isIdentity3x4:e=>Jr.map(((t,r)=>Math.abs(t-e[r])<p)).reduce(((e,t)=>e&&t),!0),makeMatrix3ReflectZ:(e,t=[0,0])=>{const r=makeMatrix2Reflect(e,t);return[r[0],r[1],0,r[2],r[3],0,0,0,1,r[4],r[5],0]},makeMatrix3Rotate:makeMatrix3Rotate,makeMatrix3RotateX:makeMatrix3RotateX,makeMatrix3RotateY:makeMatrix3RotateY,makeMatrix3RotateZ:makeMatrix3RotateZ,makeMatrix3Scale:makeMatrix3Scale,makeMatrix3Translate:(e=0,t=0,r=0)=>Hr.concat(e,t,r),makeMatrix3UniformScale:(e=1,t=[0,0,0])=>makeMatrix3Scale([e,e,e],t),multiplyMatrices3:multiplyMatrices3,multiplyMatrix3Line3:(e,t,r)=>({vector:[e[0]*t[0]+e[3]*t[1]+e[6]*t[2],e[1]*t[0]+e[4]*t[1]+e[7]*t[2],e[2]*t[0]+e[5]*t[1]+e[8]*t[2]],origin:[e[0]*r[0]+e[3]*r[1]+e[6]*r[2]+e[9],e[1]*r[0]+e[4]*r[1]+e[7]*r[2]+e[10],e[2]*r[0]+e[5]*r[1]+e[8]*r[2]+e[11]]}),multiplyMatrix3Vector3:multiplyMatrix3Vector3});const minimumSpanningTrees=(e=[],t=[])=>{if(0===e.length)return[];const r=[],s={};e.forEach(((e,t)=>{s[t]=!0}));do{const a=t.filter((e=>s[e])).shift(),o=void 0!==a?a:parseInt(Object.keys(s).shift(),10);delete s[o];const c=[];let n=[{index:o}];do{c.push(n);const t=n.flatMap((t=>e[t.index].filter((e=>s[e]&&null!=e)).map((e=>({index:e,parent:t.index}))))),r={};t.forEach(((e,t)=>{s[e.index]||(r[t]=!0),delete s[e.index]})),n=t.filter(((e,t)=>!r[t]))}while(n.length);r.push(c)}while(Object.keys(s).length);return r};var Yr=Object.freeze({__proto__:null,minimumSpanningTrees:minimumSpanningTrees});const facesSharedEdgesVertices=(e,t)=>{const r={};t.forEach((e=>{r[e]=!0}));const s=e.map((e=>r[e]?e:void 0));return rotateCircularArray(s,s.indexOf(void 0)).map(((e,t,r)=>[e,r[(t+1)%r.length]])).filter((e=>void 0!==e[0]&&void 0!==e[1]))},Xr={U:!0,u:!0},makeFacesMatrix=({vertices_coords:e,edges_vertices:t,edges_foldAngle:r,edges_assignment:s,faces_vertices:a,faces_faces:o},c)=>{!s&&r&&(s=makeEdgesAssignmentSimple({edges_foldAngle:r})),r||(r=s?makeEdgesFoldAngle({edges_assignment:s}):Array(t.length).fill(0)),o||(o=makeFacesFaces({faces_vertices:a}));const n=makeVerticesToEdge({edges_vertices:t}),i=a.map((()=>[...Jr]));return minimumSpanningTrees(o,c).forEach((t=>t.slice(1).forEach((t=>t.forEach((t=>{const o=facesSharedEdgesVertices(a[t.index],a[t.parent]).shift(),c=o.map((t=>e[t])).map(resize3),l=o.join(" "),d=n[l],_=Xr[s[d]]?Math.PI:r[d]*Math.PI/180,m=makeMatrix3Rotate(_,subtract3(c[1],c[0]),c[0]);i[t.index]=multiplyMatrices3(i[t.parent],m)})))))),i},makeFacesMatrix2=({vertices_coords:e,edges_vertices:t,edges_foldAngle:r,edges_assignment:s,faces_vertices:a,faces_faces:o},c)=>{r||(r=s?makeEdgesFoldAngle({edges_assignment:s}):Array(t.length).fill(0)),o||(o=makeFacesFaces({faces_vertices:a}));const n=makeEdgesIsFolded({edges_vertices:t,edges_foldAngle:r,edges_assignment:s}),i=makeVerticesToEdge({edges_vertices:t}),l=a.map((()=>T));return minimumSpanningTrees(o,c).forEach((t=>t.slice(1).forEach((t=>t.forEach((t=>{const r=facesSharedEdgesVertices(a[t.index],a[t.parent]).shift(),s=r.map((t=>e[t])),o=r.join(" "),c=i[o],d=subtract2(s[1],s[0]),_=resize2(s[0]),m=n[c]?makeMatrix2Reflect(d,_):T;l[t.index]=multiplyMatrices2(l[t.parent],m)})))))),l};var Kr=Object.freeze({__proto__:null,facesSharedEdgesVertices:facesSharedEdgesVertices,makeFacesMatrix:makeFacesMatrix,makeFacesMatrix2:makeFacesMatrix2});const makeVerticesCoords3DFolded=({vertices_coords:e,vertices_faces:t,edges_vertices:r,edges_foldAngle:s,edges_assignment:a,faces_vertices:o,faces_faces:c,faces_matrix:n},i)=>{if(!e||!e.length)return[];if(!o||!o.length)return e.map(resize3);n=makeFacesMatrix({vertices_coords:e,edges_vertices:r,edges_foldAngle:s,edges_assignment:a,faces_vertices:o,faces_faces:c},i),t||(t=makeVerticesFaces({faces_vertices:o}));const l=t.map((e=>e.find((e=>null!=e)))).map((e=>void 0===e?[...Jr]:n[e]));return e.map(resize3).map(((e,t)=>multiplyMatrix3Vector3(l[t],e)))},makeVerticesCoordsFlatFolded=({vertices_coords:e,edges_vertices:t,edges_foldAngle:r,edges_assignment:s,faces_vertices:a,faces_faces:o},c=[])=>{if(!e||!e.length)return[];if(!a||!a.length)return e.map(resize2);o||(o=makeFacesFaces({faces_vertices:a}));const n=makeEdgesIsFolded({edges_vertices:t,edges_foldAngle:r,edges_assignment:s}),i=[],l=[],d=makeVerticesToEdge({edges_vertices:t});return minimumSpanningTrees(o,c).forEach((r=>{const s=r.shift();if(!s||!s.length)return;const o=s[0];l[o.index]=!1,a[o.index].forEach((t=>{i[t]=[...e[t]]})),r.forEach((r=>r.forEach((r=>{const s=facesSharedEdgesVertices(a[r.index],a[r.parent]).shift().join(" "),o=d[s],c=t[o].map((e=>i[e]));if(void 0===c[0]||void 0===c[1])return;const _=t[o].map((t=>e[t])),m=_[0],g=normalize2(subtract2(_[1],_[0])),v=rotate90(g);l[r.index]=n[o]?!l[r.parent]:l[r.parent];const p=normalize2(subtract2(c[1],c[0])),u=c[0],h=l[r.index]?rotate270(p):rotate90(p);a[r.index].filter((e=>void 0===i[e])).forEach((t=>{const r=subtract2(e[t],m),s=dot(r,v),a=dot(r,g),o=scale2$1(p,a),c=scale2$1(h,s),n=add2(add2(u,o),c);i[t]=n}))}))))})),i},makeVerticesCoordsFolded=(e,t)=>edgesFoldAngleAreAllFlat(e)?makeVerticesCoordsFlatFolded(e,t):makeVerticesCoords3DFolded(e,t),makeVerticesCoordsFoldedFromMatrix2=({vertices_coords:e,vertices_faces:t,faces_vertices:r},s)=>{t||(t=makeVerticesFaces({faces_vertices:r}));const a=t.map((e=>e.find((e=>null!=e)))),o=a.map((e=>void 0===e?T:s[e]));return e.map(resize2).map(((e,t)=>multiplyMatrix2Vector2(o[t],e)))};var es=Object.freeze({__proto__:null,makeVerticesCoords3DFolded:makeVerticesCoords3DFolded,makeVerticesCoordsFlatFolded:makeVerticesCoordsFlatFolded,makeVerticesCoordsFolded:makeVerticesCoordsFolded,makeVerticesCoordsFoldedFromMatrix2:makeVerticesCoordsFoldedFromMatrix2});const faceContainingPoint=({vertices_coords:e,faces_vertices:t},r,s)=>{const a=(({vertices_coords:e,faces_vertices:t=[]},r,s=include)=>e?t.map(((t,r)=>({face:t.map((t=>e[t])),i:r}))).filter((e=>overlapConvexPolygonPoint(e.face,r,s).overlap)).map((e=>e.i)):[])({vertices_coords:e,faces_vertices:t},r,include);switch(a.length){case 0:return;case 1:return a[0]}if(!s)return a[0];const o=add2(r,scale2$1(s,.01)),c=a.map((r=>t[r].map((t=>e[t])))),n=a.filter(((e,t)=>overlapConvexPolygonPoint(c[t],o,exclude).overlap));return 0===n.length?a.find(((e,t)=>overlapConvexPolygonPoint(c[t],o,include).overlap)):n[0]},makeVerticesFacesForVertex=({vertices_vertices:e,vertices_edges:t,edges_vertices:r},s,a)=>e?e[s].map((e=>[s,e].join(" "))).map((e=>a[e])):t&&r?t[s].map((e=>r[e])).map((([e,t])=>s===e?[s,t]:[s,e])).map((e=>e.join(" "))).map((e=>a[e])):void 0,makeEdgesFacesForEdge=({vertices_faces:e,edges_vertices:t,edges_faces:r,faces_vertices:s,faces_edges:a},o)=>{if(r&&r[o])return r[o];if(!t)return[];if(s){const r={[t[o][0]]:!0,[t[o][1]]:!0},a=e?uniqueElements(t[o].flatMap((t=>e[t]))):s.map(((e,t)=>t));return(({faces_vertices:e},t,r)=>t.filter((t=>2===new Set(e[t].filter((e=>r[e]))).size)))({faces_vertices:s},a,r)}return a?a.map(((e,t)=>t)).filter((e=>a[e].includes(o))):[]},updateFacesVertices=({faces_vertices:e},t,r,s)=>{if(!e)return;s.map((t=>e[t])).forEach((e=>e.map(((e,t,s)=>{return a=e,o=s[(t+1)%s.length],a===r[0]&&o===r[1]||a===r[1]&&o===r[0]?(t+1)%s.length:void 0;var a,o})).filter((e=>void 0!==e)).sort(((e,t)=>t-e)).forEach((r=>e.splice(r,0,t)))))},splitEdge=(e,t,r=void 0)=>{const s=e.edges_vertices[t];if(!r){const[t,a]=s.map((t=>e.vertices_coords[t]));r=midpoint(t,a)}const a=e.vertices_coords.length;e.vertices_coords[a]=3===r.length?[r[0],r[1],r[2]]:[r[0],r[1]];const[o,c]=[0,1].map((t=>t+e.edges_vertices.length)),n=[o,c];((e,t,r)=>{const s=e.edges_vertices[t],a=[{edges_vertices:[s[0],r]},{edges_vertices:[r,s[1]]}];return a.forEach((r=>["edges_assignment","edges_foldAngle"].filter((r=>e[r]&&void 0!==e[r][t])).forEach((s=>{r[s]=e[s][t]})))),a})(e,t,a).forEach(((t,r)=>Object.keys(t).forEach((s=>{e[s][n[r]]=t[s]})))),(({vertices_vertices:e},t,r)=>{if(!e)return;e[t]=[...r];const s=r.map(((t,r,s)=>e[t].indexOf(s[(r+1)%s.length])));r.forEach(((r,a)=>-1===s[a]?e[r].push(t):e[r].splice(s[a],1,t)))})(e,a,s),(({vertices_edges:e},t,r,s,a)=>{e&&(e[r]=[...a],s.map((r=>e[r].indexOf(t))).map(((e,t)=>({index:e,vertex:s[t],edge:a[t]}))).filter((e=>-1!==e.index)).forEach((({index:t,vertex:r,edge:s})=>{e[r][t]=s})))})(e,t,a,s,n);const i=makeEdgesFacesForEdge(e,t).filter((e=>void 0!==e));updateFacesVertices(e,a,s,i),(({edges_vertices:e,faces_vertices:t,faces_edges:r},s,a)=>{if(!r||!t)return;const o=s.flatMap((e=>r[e])).concat(a).filter((e=>void 0!==e)),c=makeVerticesToEdge({edges_vertices:e},o);(({faces_vertices:e},t,r)=>t.map((t=>e[t].map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>e.join(" "))).map((e=>r[e])))))({faces_vertices:t},s,c).forEach(((e,t)=>{r[s[t]]=e}))})(e,i,n),(({vertices_vertices:e,vertices_edges:t,vertices_faces:r,edges_vertices:s,faces_vertices:a},o,c)=>{if(!r)return;if(!a)return void(r[o]=[...c]);const n=makeVerticesToFace({faces_vertices:a},c),i=makeVerticesFacesForVertex({vertices_vertices:e,vertices_edges:t,edges_vertices:s},o,n);r[o]=void 0===i?[...c]:i})(e,a,i),(({edges_faces:e},t,r)=>{e&&t.forEach((t=>{e[t]=[...r]}))})(e,n,i),(({faces_vertices:e,faces_faces:t},r,s)=>{if(!e||!t)return;const a=s.map((t=>e[t].indexOf(r))),o=a.map(((e,r)=>(e+t[s[r]].length-1)%t[s[r]].length)).map(((e,r)=>t[s[r]][e]));s.forEach(((e,r)=>-1===a[r]?void 0:t[e].splice(a[r],0,o[r])))})(e,a,i);const l=remove(e,"edges",[t]);n.forEach(((e,t)=>{n[t]=l[n[t]]}));const d=l.slice();return d.splice(-2),d[t]=n,{vertex:a,edges:{map:d,add:n,remove:t}}};var ts=Object.freeze({__proto__:null,splitEdge:splitEdge});const build_faces=(e,t,r)=>{const s=[0,1].map((t=>e.faces_vertices.length+t));return(({edges_vertices:e,faces_vertices:t,faces_edges:r},s,a)=>{const o=a.map((e=>t[s].indexOf(e))),c=((e,t)=>(t.sort(((e,t)=>e-t)),[e.slice(t[1]).concat(e.slice(0,t[0]+1)),e.slice(t[0],t[1]+1)]))(t[s],o).map((e=>({faces_vertices:e,faces_edges:[]})));if(r){const t=makeVerticesToEdge({edges_vertices:e});c.map((e=>e.faces_vertices.map(((e,t,r)=>`${e} ${r[(t+1)%r.length]}`)).map((e=>t[e])))).forEach(((e,t)=>{c[t].faces_edges=e}))}return c})(e,t,r).forEach(((t,r)=>Object.keys(t).forEach((a=>{e[a][s[r]]=t[a]})))),s},rebuild_edge=(e,t,r)=>{const s=e.edges_vertices.length,a=(({vertices_coords:e},t,r)=>{const s=t.slice().map((t=>e[t])).reverse();return{edges_vertices:[...t],edges_foldAngle:0,edges_assignment:"U",edges_length:distance(s[0],s[1]),edges_vector:subtract(s[0],s[1]),edges_faces:[r,r]}})(e,r,t);return Object.keys(a).filter((t=>void 0!==e[t])).forEach((t=>{e[t][s]=a[t]})),s},splitFaceWithLine=(e,t,r,s)=>{const a=(({vertices_coords:e,edges_vertices:t,faces_vertices:r,faces_edges:s},a,{vector:o,origin:c},n=p)=>{const i=e.map(resize2),l=r[a].map((e=>i[e])).map((e=>overlapLinePoint({vector:o,origin:c},e,(()=>!0),n))).map(((e,t)=>e?t:void 0)).filter((e=>void 0!==e)),d=l.map((e=>r[a][e]));if(l.concat(l.map((e=>e+r[a].length))).map(((e,t,r)=>r[t+1]-e==1)).reduce(((e,t)=>e||t),!1))return;if(d.length>1)return{vertices:d,edges:[]};const _=s[a].map((e=>t[e].map((e=>i[e])))).map((e=>intersectLineLine({vector:o,origin:c},{vector:subtract2(e[1],e[0]),origin:e[0]},includeL,excludeS,n).point)).map(((e,t)=>({coords:e,edge:s[a][t]}))).filter((e=>void 0!==e.coords)).filter((e=>!d.map((r=>t[e.edge].includes(r))).reduce(((e,t)=>e||t),!1)));return _.length+d.length===2?{vertices:d,edges:_}:void 0})(e,t,r,s);if(void 0===a)return;const o=((e,{vertices:t,edges:r})=>{let s;const a=r.map((t=>{const r=splitEdge(e,s?s[t.edge]:t.edge,t.coords);return s=s?mergeNextmaps(s,r.edges.map):r.edges.map,r}));let o;return t.push(...a.map((e=>e.vertex))),a.forEach((e=>{e.edges.remove=o?o[e.edges.remove]:e.edges.remove;const t=invertFlatMap(e.edges.map);o=o?mergeBackmaps(o,t):t})),{vertices:t,edges:{map:s,remove:a.map((e=>e.edges.remove))}}})(e,a);o.edges.new=rebuild_edge(e,t,o.vertices),(({vertices_coords:e,vertices_vertices:t,edges_vertices:r},s)=>{const a=r[s][0],o=r[s][1];t[a]=sortVerticesCounterClockwise({vertices_coords:e},t[a].concat(o),a),t[o]=sortVerticesCounterClockwise({vertices_coords:e},t[o].concat(a),o)})(e,o.edges.new),(({edges_vertices:e,vertices_edges:t,vertices_vertices:r},s)=>{if(!t||!r)return;const a=e[s];a.map((e=>r[e])).map(((e,t)=>e.indexOf(a[(t+1)%a.length]))).forEach(((e,r)=>t[a[r]].splice(e,0,s)))})(e,o.edges.new);const c=build_faces(e,t,o.vertices);((e,t,r)=>{const s={};r.forEach((t=>e.faces_vertices[t].forEach((e=>{s[e]||(s[e]=[]),s[e].push(t)})))),e.faces_vertices[t].forEach((r=>{const a=e.vertices_faces[r].indexOf(t),o=s[r];if(-1===a||!o)throw new Error(l);e.vertices_faces[r].splice(a,1,...o)}))})(e,t,c),((e,t,r,s)=>{const a={};s.forEach((t=>e.faces_edges[t].forEach((e=>{a[e]||(a[e]=[]),a[e].push(t)})))),[...e.faces_edges[t],r].forEach((r=>{const s=a[r],o=[];for(let s=0;s<e.edges_faces[r].length;s+=1)e.edges_faces[r][s]===t&&o.push(s);if(0===o.length||!s)throw new Error(l);o.reverse().forEach((t=>e.edges_faces[r].splice(t,1)));const c=o[o.length-1];e.edges_faces[r].splice(c,0,...s)}))})(e,t,o.edges.new,c),(({faces_vertices:e,faces_faces:t},r,s)=>{const a=t[r],o=s.map((t=>e[t])),c=a.map((t=>{if(null==t)return;const r=e[t],a=[0,0];for(let e=0;e<o.length;e+=1){let t=0;for(let s=0;s<r.length;s+=1)-1!==o[e].indexOf(r[s])&&(t+=1);a[e]=t}return a[0]>=2?s[0]:a[1]>=2?s[1]:void 0}));s.forEach(((e,r,a)=>{t[e]=[a[(r+1)%s.length]]})),a.forEach(((e,s)=>{if(null!=e)for(let a=0;a<t[e].length;a+=1)t[e][a]===r&&(t[e][a]=c[s],t[c[s]].push(e))}))})(e,t,c);const n=remove(e,"faces",[t]);c.forEach(((e,t)=>{c[t]=n[c[t]]})),n.splice(-2);const i=n.slice();return i[t]=c,o.faces={map:i,new:c,remove:t},o},buildFacesIfNeeded=(e,t)=>{const r={faces_vertices:!1,faces_edges:!1};return e.faces_vertices&&e.faces_vertices.length||e.faces_edges&&e.faces_edges.length||!t||!e.vertices_coords?(e.faces_vertices||e.faces_edges?e.faces_vertices&&!e.faces_edges?(e.faces_edges=makeFacesEdgesFromVertices(e),r.faces_edges=!0):e.faces_edges&&!e.faces_vertices&&(e.faces_vertices=makeFacesVerticesFromEdges(e),r.faces_vertices=!0):(e.faces_vertices=[],e.faces_edges=[]),r):((e=>{const{faces_vertices:t,faces_edges:r}=makePlanarFaces(e);e.faces_vertices=t,e.faces_edges=r})(e),r.faces_vertices=!0,r.faces_edges=!0,r)},populate=(e,t={})=>{if("object"!=typeof e)return e;if(!e.edges_vertices)return e;const r={vertices_vertices:!1,faces_vertices:!1,faces_edges:!1};e.vertices_vertices&&!e.vertices_edges?e.vertices_edges=makeVerticesEdges(e):e.vertices_edges&&e.vertices_vertices||(e.vertices_edges=makeVerticesEdgesUnsorted(e),e.vertices_vertices=makeVerticesVertices(e),e.vertices_edges=makeVerticesEdges(e),r.vertices_vertices=!0),(e=>{if(e.edges_vertices){if(e.edges_assignment||(e.edges_assignment=[]),e.edges_foldAngle||(e.edges_foldAngle=[]),e.edges_assignment.length>e.edges_foldAngle.length)for(let t=e.edges_foldAngle.length;t<e.edges_assignment.length;t+=1)e.edges_foldAngle[t]=edgeAssignmentToFoldAngle(e.edges_assignment[t]);if(e.edges_foldAngle.length>e.edges_assignment.length)for(let t=e.edges_assignment.length;t<e.edges_foldAngle.length;t+=1)e.edges_assignment[t]=edgeFoldAngleToAssignment(e.edges_foldAngle[t]);for(let t=e.edges_assignment.length;t<e.edges_vertices.length;t+=1)e.edges_assignment[t]="U",e.edges_foldAngle[t]=0}})(e);const s="object"==typeof t&&t.faces;return Object.assign(r,buildFacesIfNeeded(e,s)),(!e.vertices_faces||r.vertices_vertices||r.faces_vertices)&&(e.vertices_faces=makeVerticesFaces(e)),e.edges_faces&&!r.faces_edges||(e.edges_faces=makeEdgesFacesUnsorted(e)),e.faces_faces&&!r.faces_vertices||(e.faces_faces=makeFacesFaces(e)),e};var rs=Object.freeze({__proto__:null,populate:populate});const make_face_side=(e,t,r,s)=>{const a=subtract2(r,t),o=cross2(e,a);return s?o>0:o<0},make_face_center=(e,t)=>e.faces_vertices[t]?e.faces_vertices[t].map((t=>e.vertices_coords[t])).reduce(((e,t)=>[e[0]+t[0],e[1]+t[1]]),[0,0]).map((r=>r/e.faces_vertices[t].length)):[0,0],ss={F:!0,f:!0,U:!0,u:!0},as={M:"V",m:"V",V:"M",v:"M"},face_snapshot=(e,t)=>({center:e.faces_center[t],matrix:e.faces_matrix2[t],winding:e.faces_winding[t],crease:e.faces_crease[t],side:e.faces_side[t],layer:e.faces_layer[t]}),getVerticesCollinearToLine=({vertices_coords:e},{vector:t,origin:r},s=p)=>{const a=normalize2(t);return e.map((e=>{const t=subtract2(e,r),o=magnitude2(t);if(Math.abs(o)<s)return!0;const c=scale2$1(t,1/o),n=Math.abs(dot2(c,a));return Math.abs(1-n)<s})).map(((e,t)=>({a:e,i:t}))).filter((e=>e.a)).map((e=>e.i))},getEdgesCollinearToLine=({vertices_coords:e,edges_vertices:t,vertices_edges:r},{vector:s,origin:a},o=p)=>{r||(r=makeVerticesEdgesUnsorted({edges_vertices:t}));const c=getVerticesCollinearToLine({vertices_coords:e},{vector:s,origin:a},o),n=t.map((()=>0));return c.forEach((e=>r[e].forEach((e=>{n[e]+=1})))),n.map(((e,t)=>({count:e,i:t}))).filter((e=>2===e.count)).map((e=>e.i))};var os=Object.freeze({__proto__:null,flatFold:(e,{vector:t,origin:r},s="V",a=p)=>{const o=as[c=s]||c;var c;populate(e),e.faces_layer||(e.faces_layer=Array(e.faces_vertices.length).fill(0)),e.faces_center=e.faces_vertices.map(((t,r)=>make_face_center(e,r))),e.faces_matrix2||(e.faces_matrix2=makeFacesMatrix2(e,[faceContainingPoint(e,r,t)])),e.faces_winding=makeFacesWindingFromMatrix2(e.faces_matrix2),e.faces_crease=e.faces_matrix2.map(invertMatrix2).map((e=>multiplyMatrix2Line2(e,{vector:t,origin:r}))),e.faces_side=e.faces_vertices.map(((t,r)=>make_face_side(e.faces_crease[r].vector,e.faces_crease[r].origin,e.faces_center[r],e.faces_winding[r])));const n=makeVerticesCoordsFoldedFromMatrix2(e,e.faces_matrix2),i=getEdgesCollinearToLine({vertices_coords:n,edges_vertices:e.edges_vertices},{vector:t,origin:r},a).filter((t=>ss[e.edges_assignment[t]]));i.map((t=>e.edges_faces[t].find((e=>null!=e)))).map((t=>e.faces_winding[t])).map((e=>e?s:o)).forEach(((t,r)=>{e.edges_assignment[i[r]]=t,e.edges_foldAngle[i[r]]=edgeAssignmentToFoldAngle(t)}));const l=face_snapshot(e,0),d=e.faces_vertices.map(((e,t)=>t)).reverse().map((t=>{const r=face_snapshot(e,t),c=splitFaceWithLine(e,t,r.crease,a);if(void 0===c)return;e.edges_assignment[c.edges.new]=r.winding?s:o,e.edges_foldAngle[c.edges.new]=edgeAssignmentToFoldAngle(e.edges_assignment[c.edges.new]);return c.faces.map[c.faces.remove].forEach((t=>{e.faces_center[t]=make_face_center(e,t),e.faces_side[t]=make_face_side(r.crease.vector,r.crease.origin,e.faces_center[t],r.winding),e.faces_layer[t]=r.layer})),c})).filter((e=>void 0!==e)),_=mergeNextmaps(...d.map((e=>e.faces.map))),m=mergeNextmaps(...d.map((e=>e.edges.map)).filter((e=>void 0!==e))),g=d.map((e=>e.faces.remove)).reverse();e.faces_layer=((e,t)=>{const r=[],s=e.map(((e,t)=>t)),a=s.filter((e=>t[e])),o=s.filter((e=>!t[e]));return o.sort(((t,r)=>e[t]-e[r])).forEach(((e,t)=>{r[e]=t})),a.sort(((t,r)=>e[r]-e[t])).forEach(((e,t)=>{r[e]=o.length+t})),r})(e.faces_layer,e.faces_side);const v=_&&_[0]&&2===_[0].length,u=v?_[0].filter((t=>e.faces_side[t])).shift():0;let h=l.matrix;return s!==o&&(h=v||e.faces_side[0]?multiplyMatrices2(l.matrix,makeMatrix2Reflect(l.crease.vector,l.crease.origin)):l.matrix),e.faces_matrix2=makeFacesMatrix2(e,[u]).map((e=>multiplyMatrices2(h,e))),delete e.faces_center,delete e.faces_winding,delete e.faces_crease,delete e.faces_side,{faces:{map:_,remove:g},edges:{map:m}}},getEdgesCollinearToLine:getEdgesCollinearToLine,getVerticesCollinearToLine:getVerticesCollinearToLine});const intersectLineVertices=({vertices_coords:e},{vector:t,origin:r},s=includeL,a=p)=>{const o=magSquared(t),c=Math.sqrt(o);return c<a?Array(e.length).fill(void 0):e.map((e=>subtract2(e,r))).map((e=>{const r=dot2(e,t)/o;return Math.abs(cross2(e,t))<a&&s(r,a/c)?r:void 0}))},intersectLineVerticesEdges=({vertices_coords:e,edges_vertices:t},{vector:r,origin:s},a=includeL,o=p)=>{if(!e)return{vertices:[],edges:[]};const c=intersectLineVertices({vertices_coords:e},{vector:r,origin:s},a,o);if(!t)return{vertices:c,edges:[]};const n=t.map((e=>e.map((e=>void 0!==c[e]?e:void 0)).filter((e=>void 0!==e)))),i=t.map((t=>t.map((t=>e[t])))).map((([e,t],o)=>0===n[o].length?intersectLineLine({vector:r,origin:s},pointsToLine2(e,t),a,includeS):void 0)).map((e=>void 0!==e&&e.point?e:void 0));return{vertices:c,edges:i}},intersectLine=({vertices_coords:e,edges_vertices:t,faces_vertices:r,faces_edges:s},{vector:a,origin:o},c=includeL,n=p)=>{const{vertices:i,edges:l}=intersectLineVerticesEdges({vertices_coords:e,edges_vertices:t},{vector:a,origin:o},c,n);if(!r)return{vertices:i,edges:l,faces:[]};s||(s=makeFacesEdgesFromVertices({edges_vertices:t,faces_vertices:r}));const d=s.map((e=>e.map((e=>l[e]?{...l[e],edge:e}:void 0)).filter((e=>void 0!==e)))),_=r.map((e=>e.map((e=>void 0!==i[e]?{a:i[e],vertex:e}:void 0)).filter((e=>void 0!==e)))),m=r.map(((e,t)=>[..._[t],...d[t]])),epsilonEqual=(e,t)=>Math.abs(e.a-t.a)<2*n,g=m.map((e=>e.sort(((e,t)=>e.a-t.a)))).map((e=>clusterSortedGeneric(e,epsilonEqual).map((t=>t.map((t=>e[t])))))).map((e=>e.map((e=>e[0]))));return{vertices:i,edges:l,faces:g}},intersectLineAndPoints=({vertices_coords:e,edges_vertices:t,faces_vertices:r,faces_edges:s},{vector:a,origin:o},c=includeL,n=[],i=p)=>{const{vertices:l,edges:d,faces:_}=intersectLine({vertices_coords:e,edges_vertices:t,faces_vertices:r,faces_edges:s},{vector:a,origin:o},c,i);if(!e||!r)return{vertices:l,edges:d,faces:[]};const m=e.map(resize2),g=n.length?_.map(((e,t)=>{const s=r[t].map((e=>m[e]));return n.map((e=>({...overlapConvexPolygonPoint(s,e,exclude,i),point:e}))).filter((e=>e.overlap))})):_.map((()=>[]));return{vertices:l,edges:d,faces:_.map(((e,t)=>({edges:e.map((e=>"edge"in e&&"a"in e&&"b"in e&&"point"in e?e:void 0)).filter((e=>void 0!==e)),vertices:e.map((e=>"vertex"in e&&"a"in e?e:void 0)).filter((e=>void 0!==e)),points:g[t]})))}},filterCollinearFacesData=({edges_vertices:e},{vertices:t,faces:r})=>{const s=[];e.map((e=>void 0!==t[e[0]]&&void 0!==t[e[1]])).map(((e,t)=>e?t:void 0)).filter((e=>void 0!==e)).map((t=>e[t])).forEach((e=>s.push(e)));const a=r.map((e=>e.vertices.map((({vertex:e})=>e)))),o=[];a.forEach(((e,t)=>{o[t]={}})),a.forEach(((e,t)=>e.forEach((e=>{o[t][e]=!0})))),r.forEach(((e,t)=>{const a={};s.filter((e=>o[t][e[0]]&&o[t][e[1]])).forEach((e=>{a[e[0]]=!0,a[e[1]]=!0})),r[t].vertices=e.vertices.filter((e=>!a[e.vertex]))}))};var cs=Object.freeze({__proto__:null,filterCollinearFacesData:filterCollinearFacesData,intersectLine:intersectLine,intersectLineAndPoints:intersectLineAndPoints,intersectLineVertices:intersectLineVertices,intersectLineVerticesEdges:intersectLineVerticesEdges});const updateVerticesVertices=({vertices_vertices:e,faces_vertices:t},r,s)=>{if(!e)return;s.map((s=>((e,t,r)=>{const s=e.indexOf(r);if(-1===s)return-1;const a=e[(s+e.length-1)%e.length],o=e[(s+1)%e.length],c=t.indexOf(a);return-1===c||t[(c+t.length-1)%t.length]!==o?-1:c})(t[r],e[s],s))).forEach(((t,r)=>{const a=s[(r+1)%s.length];-1!==t?e[s[r]].splice(t,0,a):e[s[r]].push(a)}))},updateVerticesEdges=({vertices_edges:e,vertices_vertices:t},r,s)=>{if(!e)return;if(!t)return void r.forEach((t=>e[t].push(s)));const a=r.map(((e,r,s)=>t[e].indexOf(s[(r+1)%s.length])));if(a.some((e=>-1===e)))throw new Error(`splitFace() vertices_edges ${r.join(", ")}`);a.forEach(((t,a)=>{e[r[a]].splice(t,0,s)}))},updateFacesEdges=({edges_vertices:e,faces_vertices:t,faces_edges:r},s,a,o)=>{if(!r)return;const c=[...r[s],o],n=makeVerticesToEdge({edges_vertices:e},c),i=a.map((e=>t[e].map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>e.join(" "))).map((e=>n[e]))));if(i.flat().some((e=>void 0===e)))throw new Error(`splitFace() faces_edges ${s}`);a.forEach(((e,t)=>{r[e]=i[t]}))},splitFaceWithLeafEdge=(e,t,r,s,a="U",o=0)=>{const c=[r,s],n=addEdge(e,c,[t,t],a,o);return e.vertices_faces&&(e.vertices_faces[s]=Array.from(new Set([...e.vertices_faces[s],t]))),(({faces_vertices:e},t,r,s)=>{e&&(e[t]=((e,t,r)=>{const s=[...e],a=e[t];return s.splice(t,0,a,r),s})(e[t],e[t].indexOf(r),s))})(e,t,r,s),updateFacesEdges(e,t,[t],n),updateVerticesVertices(e,t,c),updateVerticesEdges(e,c,n),{edge:n,faces:{}}},splitFaceWithEdge=(e,t,r,s="U",a=0)=>{if(!e.vertices_coords||!e.edges_vertices||!e.faces_vertices)return{};if(2!==r.length)return{};if(o=e.faces_vertices[t],Array.from(new Set(o)).length!==o.length)return{};var o;if((({faces_vertices:e},t,r)=>e[t].map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((([e,t])=>e===r[0]&&t===r[1]||e===r[1]&&t===r[0])).reduce(((e,t)=>e||t),!1))(e,t,r))return{};const c=addEdge(e,r,[t,t],s,a),n=[0,1].map((t=>e.faces_vertices.length+t));(({faces_vertices:e},t,r)=>{const[s,a]=r.map((r=>e[t].indexOf(r)));splitCircularArray$1(e[t],[s,a]).map((t=>e.push(t)))})(e,t,r),updateFacesEdges(e,t,n,c),updateVerticesVertices(e,t,r),updateVerticesEdges(e,r,c),(({vertices_vertices:e,vertices_edges:t,vertices_faces:r,edges_vertices:s,faces_vertices:a},o,c)=>{if(!r||!a)return;const n=uniqueElements(c.flatMap((e=>a[e]))),i=uniqueElements([...c,...n.flatMap((e=>r[e]))]).filter((e=>e!==o)).filter((e=>null!=e)),l=makeVerticesToFace({faces_vertices:a},i);n.map((r=>makeVerticesFacesForVertex({vertices_vertices:e,vertices_edges:t,edges_vertices:s},r,l))).forEach(((e,t)=>{r[n[t]]=e||[]}))})(e,t,n),(({edges_vertices:e,faces_vertices:t,edges_faces:r,faces_edges:s},a,o,c)=>{if(!r)return;if(!s)return r.forEach(((e,t)=>delete r[t])),void Object.assign(r,makeEdgesFacesUnsorted({edges_vertices:e,faces_vertices:t,faces_edges:s}));const n={};[...o,a].forEach((e=>{n[e]=!0}));const i=Array.from(new Set(o.flatMap((e=>s[e])))),l=[];i.forEach((e=>{l[e]=r[e].filter((e=>!n[e]))}));const d=[];i.forEach((e=>{d[e]=[]})),o.forEach((e=>s[e].forEach((t=>d[t].push(e))))),i.forEach((e=>{r[e]=Array.from(new Set([...d[e],...l[e]]))})),r[c]=[...o]})(e,t,n,c),(({edges_vertices:e,edges_faces:t,faces_vertices:r,faces_edges:s,faces_faces:a},o,c)=>{if(!a)return;const n=uniqueElements([...a[o],...c]).filter((e=>null!=e));if(t&&s)n.forEach((e=>{a[e]=s[e].map((r=>t[r].find((t=>t!==e))))}));else if(e&&r){const e=makeVerticesToFace({faces_vertices:r},n);n.forEach((t=>{a[t]=r[t].map(((e,t,r)=>[r[(t+1)%r.length],e])).map((e=>e.join(" "))).map((t=>e[t]))}))}})(e,t,n),(({faceOrders:e},t,r)=>{if(!e)return;const s=r[0],a=r.slice(1),o=[];e.forEach((([r,c,n],i)=>{if(r===t){e[i]=[s,c,n];const t=a.map((e=>[e,c,n]));o.push(...t)}if(c===t){e[i]=[r,s,n];const t=a.map((e=>[r,e,n]));o.push(...t)}})),e.push(...o)})(e,t,n);const i=remove(e,"faces",[t]);n.forEach(((e,t)=>{n[t]=i[n[t]]}));const l=i.slice();return l.splice(-2),l[t]=n,{edge:c,faces:{map:l,new:n,remove:t}}},splitFace=(e,t,r,s="U",a=0)=>{if(!e.vertices_coords||!e.edges_vertices||!e.faces_vertices)return{};if(2!==r.length)return{};const o=r.map((r=>({vertex:r,index:e.faces_vertices[t].indexOf(r)})));switch(o.filter((({index:e})=>-1!==e)).length){case 2:return splitFaceWithEdge(e,t,r,s,a);case 1:return splitFaceWithLeafEdge(e,t,o.filter((({index:e})=>-1!==e)).shift().vertex,o.filter((({index:e})=>-1===e)).shift().vertex,s,a);default:return{edge:addIsolatedEdge(e,r,s,a),faces:{}}}};var ns=Object.freeze({__proto__:null,splitFace:splitFace,splitFaceWithEdge:splitFaceWithEdge,splitFaceWithLeafEdge:splitFaceWithLeafEdge});const splitGraphWithLineAndPoints=(e,{vector:t,origin:r},s=includeL,a=[],o=p)=>{if(!e.vertices_coords||!e.edges_vertices)return{};let c=e.edges_vertices.map(((e,t)=>[t])),n=e.faces_vertices.map(((e,t)=>[t]));const i=[],l=[],d=intersectLineAndPoints(e,{vector:t,origin:r},s,a,o);filterCollinearFacesData(e,d);const _={};d.edges.map(((e,t)=>e?{...e,edge:t}:void 0)).filter((e=>void 0!==e)).forEach((({a:t,b:r,point:s,edge:a})=>{const o=c[a][0],[n,l]=e.edges_vertices[o],d=[n,l],{vertex:m,edges:{map:g}}=splitEdge(e,o,s);i[m]={a:t,b:r,vertices:d,edge:a,point:s},c=mergeNextmaps(c,g),_[a]=m}));const m={};return d.faces.map((({vertices:e,edges:t,points:r},s)=>({vertices:e,edges:t,points:r,face:s}))).filter((({vertices:e,edges:t,points:r})=>2===((...e)=>e.map((e=>e.length)).reduce(((e,t)=>e+t),0))(e,t,r))).forEach((({vertices:t,edges:r,points:s,face:a})=>{const o=n[a][0],c=r.map((({edge:e})=>_[e])),d=addVertices(e,s.map((({point:e})=>e))),g=t.map((({vertex:e})=>e)).concat(c).concat(d),v=[g[0],g[1]],{edge:p,faces:{map:u}}=splitFace(e,o,v);l[p]={face:a,faces:void 0},d.forEach(((e,t)=>{i[e]={...s[t],face:a,faces:void 0}})),n=void 0===u?n:mergeNextmaps(n,u),m[a]=p})),i.forEach((({face:e},t)=>{void 0!==e&&(i[t].faces=n[e])})),l.forEach((({face:e},t)=>{void 0!==e&&(l[t].faces=n[e])})),{vertices:{intersect:d.vertices,source:i},edges:{intersect:d.edges,new:Object.values(m),map:c,source:l},faces:{intersect:d.faces,map:n}}};var is=Object.freeze({__proto__:null,splitGraphWithLine:(e,t,r=p)=>splitGraphWithLineAndPoints(e,t,includeL,[],r),splitGraphWithLineAndPoints:splitGraphWithLineAndPoints,splitGraphWithRay:(e,t,r=p)=>splitGraphWithLineAndPoints(e,t,A,[t.origin],r),splitGraphWithSegment:(e,t,r=p)=>splitGraphWithLineAndPoints(e,pointsToLine2(t[0],t[1]),includeS,t,r)});const trilateration2=(e,t)=>{if(void 0===e[0]||void 0===e[1]||void 0===e[2])return;const r=scale2$1(subtract2(e[1],e[0]),1/distance2(e[1],e[0])),s=dot2(r,subtract2(e[2],e[0])),a=scale2$1(r,s),o=subtract2(subtract2(e[2],e[0]),a),c=scale2$1(o,1/magnitude2(o)),n=distance2(e[1],e[0]),i=dot2(c,subtract2(e[2],e[0])),l=(t[0]**2-t[1]**2+n**2)/(2*n),d=(t[0]**2-t[2]**2+s**2+i**2)/(2*i)-s*l/i;return add2(add2(e[0],scale2$1(r,l)),scale2$1(c,d))};var ls=Object.freeze({__proto__:null,circumcircle:(e,t,r)=>{const s=t[0]-e[0],a=t[1]-e[1],o=r[0]-e[0],c=r[1]-e[1],n=s*(e[0]+t[0])+a*(e[1]+t[1]),i=o*(e[0]+r[0])+c*(e[1]+r[1]),l=2*(s*(r[1]-t[1])-a*(r[0]-t[0]));if(Math.abs(l)<p){const s=Math.min(e[0],t[0],r[0]),a=Math.min(e[1],t[1],r[1]),o=.5*(Math.max(e[0],t[0],r[0])-s),c=.5*(Math.max(e[1],t[1],r[1])-a);return{origin:[s+o,a+c],radius:Math.sqrt(o*o+c*c)}}const d=[(c*n-a*i)/l,(s*i-o*n)/l],_=d[0]-e[0],m=d[1]-e[1];return{origin:d,radius:Math.sqrt(_*_+m*m)}},trilateration2:trilateration2,trilateration3:(e,t)=>{if(void 0===e[0]||void 0===e[1]||void 0===e[2])return;const r=scale3$1(subtract3(e[1],e[0]),1/distance3(e[1],e[0])),s=dot3(r,subtract3(e[2],e[0])),a=scale3$1(r,s),o=subtract3(subtract3(e[2],e[0]),a),c=scale3$1(o,1/magnitude3(o)),n=distance3(e[1],e[0]),i=dot3(c,subtract3(e[2],e[0])),l=(t[0]**2-t[1]**2+n**2)/(2*n),d=(t[0]**2-t[2]**2+s**2+i**2)/(2*i)-s*l/i;return add3(add3(e[0],scale3$1(r,l)),scale3$1(c,d))}});const transferPointInFaceBetweenGraphs=(e,t,r,s)=>{const a=t.faces_vertices[r].filter((r=>e.vertices_coords[r]&&t.vertices_coords[r])),o=a.map(((e,t,r)=>[r[(t+r.length-1)%r.length],e,r[(t+1)%r.length]])).map((r=>{const[s,a,o]=r.map((t=>e.vertices_coords[t])),[c,n,i]=r.map((e=>t.vertices_coords[e]));return[s,a,o,c,n,i]})).map((([e,t,r,s,a,o])=>collinearPoints(e,t,r)||collinearPoints(s,a,o))),c=a.filter(((e,t)=>!o[t]));if(c.length<3)return;const[n,i,l]=c,d=[resize2(t.vertices_coords[n]),resize2(t.vertices_coords[i]),resize2(t.vertices_coords[l])],_=[distance2(e.vertices_coords[n],s),distance2(e.vertices_coords[i],s),distance2(e.vertices_coords[l],s)];return trilateration2(d,_)};var fs=Object.freeze({__proto__:null,transferPointInFaceBetweenGraphs:transferPointInFaceBetweenGraphs});const makeNewFlatFoldFaceOrders=({edges_faces:e,edges_assignment:t,edges_foldAngle:r},s)=>{const a=s.filter((t=>2===e[t].length)),o=a.map((t=>e[t]));if(t){const e=a.map((e=>t[e]));return o.map((([t,r],s)=>((e,t,r)=>{switch(r){case"V":case"v":return[e,t,1];case"M":case"m":return[e,t,-1];default:return}})(t,r,e[s]))).filter((e=>void 0!==e))}if(r){const e=a.map((e=>r[e]));return o.map((([t,r],s)=>((e,t,r)=>epsilonEqual(r,180)?[e,t,1]:epsilonEqual(r,-180)?[e,t,-1]:void 0)(t,r,e[s]))).filter((e=>void 0!==e))}return[]},updateFaceOrders=(e,t,r,s,a,o,c)=>{const n=edgeFoldAngleIsFlatFolded(s);if(!e.faceOrders&&n&&(e.faceOrders=[]),n){const t=makeNewFlatFoldFaceOrders(e,o);e.faceOrders=e.faceOrders.concat(t)}if(e.faceOrders){const o=(({vertices_coords:e,faces_vertices:t,faceOrders:r},s,a)=>{if(!r)return[];const o=invertFlatMap(a),c=t.map((t=>t.map((t=>e[t])))).map((e=>e.map(resize2))).map((e=>average2(...e))).map((e=>cross2(subtract2(e,s.origin),s.vector))).map(Math.sign);return r.map((([e,t],r)=>void 0===o[e]&&void 0===o[t]||!(1===c[e]&&-1===c[t]||-1===c[e]&&1===c[t])?void 0:r)).filter((e=>void 0!==e))})(t,r,c);if(n)(({faceOrders:e},t,r,s)=>{const a={true:1,false:-1},o={true:-1,false:1};t.forEach((t=>{const[c,n]=e[t],i=r>0?a[s[n]]:o[s[n]];e[t]=[c,n,i]}))})(e,o,s,a);else{const t={};o.forEach((e=>{t[e]=!0})),e.faceOrders=e.faceOrders.filter(((e,r)=>!t[r]))}}},foldGraph=(e,{vector:t,origin:r},s=includeL,a=[],o="V",c=void 0,n=void 0,i=p)=>{if(void 0!==c&&!e.edges_foldAngle&&e.edges_assignment&&(e.edges_foldAngle=makeEdgesFoldAngle(e)),e.edges_faces||(e.edges_faces=makeEdgesFacesUnsorted(e)),void 0===c&&(c=Y[o]||0),void 0===n){const s=faceContainingPoint(e,r,t);n=makeVerticesCoordsFolded(e,[s])}const l=invertAssignment(o),d=0===c?0:-c,_=br(e.vertices_coords);Object.assign(e,{vertices_coords:br(n)});const m=splitGraphWithLineAndPoints(e,{vector:t,origin:r},s,a,i),g=Array.from(new Set(m.edges.new.flatMap((t=>e.edges_faces[t])))),v=makeFacesWinding(e),u=br(e.vertices_coords);Object.assign(e,{vertices_coords:_});const h={...e,vertices_coords:u},b=m.vertices.source.map(((e,t)=>({...e,vertex:t})));b.map((e=>"point"in e&&"face"in e&&"faces"in e&&"vertex"in e?e:void 0)).filter((e=>void 0!==e)).forEach((({point:t,faces:r,vertex:s})=>{e.vertices_coords[s]=transferPointInFaceBetweenGraphs(h,e,r[0],t)})),b.map((e=>"vertices"in e&&"vertex"in e&&"b"in e?e:void 0)).filter((e=>void 0!==e)).forEach((({b:t,vertices:r,vertex:s})=>{e.vertices_coords[s]=((e,t)=>{const r=pointsToLine2(e[0],e[1]);return add2(r.origin,scale2$1(r.vector,t))})(r.map((t=>e.vertices_coords[t])).map(resize2),t)}));const y=m.edges.source.map((({faces:e})=>({assign:v[e[0]]?o:l,angle:v[e[0]]?c:d})));e.edges_assignment&&y.forEach((({assign:t},r)=>{e.edges_assignment[r]=t})),e.edges_foldAngle&&y.forEach((({angle:t},r)=>{e.edges_foldAngle[r]=t}));const E=(({edges_vertices:e,edges_faces:t,edges_assignment:r,edges_foldAngle:s},{assignment:a,foldAngle:o,oppositeAssignment:c,oppositeFoldAngle:n},i,l)=>{const d=l.vertices.intersect.map((e=>void 0!==e)),_=e.map((e=>d[e[0]]&&d[e[1]])).map(((e,t)=>e?t:void 0)).filter((e=>void 0!==e)).map((e=>({edge:e,faces:t[e].filter((e=>void 0!==e))}))).filter((({faces:e})=>2===e.length)).filter((({faces:[e,t]})=>i[e]===i[t]));return _.forEach((({edge:e,faces:t})=>{const l=t.map((e=>i[e])).shift();r[e]=l?a:c,s[e]=l?o:n})),_.map((({edge:e})=>e))})(e,{assignment:o,foldAngle:c,oppositeAssignment:l,oppositeFoldAngle:d},v,m);return updateFaceOrders(e,{...e,vertices_coords:u},{vector:t,origin:r},c,v,[...m.edges.new,...E],g),{edges:{map:m.edges.map,new:m.edges.new,reassigned:E},faces:{map:m.faces.map,new:g}}};var ds=Object.freeze({__proto__:null,foldGraph:foldGraph,foldLine:(e,t,r="V",s=void 0,a=void 0,o=p)=>foldGraph(e,t,includeL,[],r,s,a,o),foldRay:(e,t,r="V",s=void 0,a=void 0,o=p)=>foldGraph(e,t,A,[t.origin],r,s,a,o),foldSegment:(e,t,r="V",s=void 0,a=void 0,o=p)=>foldGraph(e,pointsToLine2(t[0],t[1]),includeS,t,r,s,a,o)});var _s=Object.freeze({__proto__:null,foldGraphIntoSegments:({vertices_coords:e,edges_vertices:t,edges_foldAngle:r,edges_assignment:s,faces_vertices:a,faces_edges:o,faces_faces:c},{vector:n,origin:i},l="V",d=p)=>{o||(o=makeFacesEdgesFromVertices({edges_vertices:t,faces_vertices:a}));const _=faceContainingPoint({vertices_coords:e,faces_vertices:a},i,n),m=invertAssignment(l),g=makeVerticesCoordsFlatFolded({vertices_coords:e,edges_vertices:t,edges_foldAngle:r,edges_assignment:s,faces_vertices:a,faces_faces:c},[_]),v=edgesToLines2({vertices_coords:e,edges_vertices:t}),u=makeFacesWinding({vertices_coords:g,faces_vertices:a});u[_]||u.forEach(((e,t)=>{u[t]=!e}));const{faces:h}=intersectLine({vertices_coords:g,edges_vertices:t,faces_vertices:a,faces_edges:o},{vector:n,origin:i},includeL,d);h.forEach(((e,t)=>{2!==e.length&&delete h[t]}));const remapPoint=({vertex:t,edge:r,b:s})=>void 0!==t?resize2(e[t]):add2(scale2$1(v[r].vector,s),v[r].origin);return h.map(((e,t)=>({intersections:e,assignment:u[t]?l:m,points:e.map(remapPoint)})))}});const splitLineToSegments=({vertices_coords:e,edges_vertices:t,faces_vertices:r,faces_edges:s},{vector:a,origin:o},c=includeL,n=[],i=p)=>{const{vertices:l,edges:d,faces:_}=intersectLineAndPoints({vertices_coords:e,edges_vertices:t,faces_vertices:r,faces_edges:s},{vector:a,origin:o},c,n,i);_.map((e=>["vertices","edges","points"].map((t=>e[t].length)).reduce(((e,t)=>e+t),0))).map(((e,t)=>2!==e?t:void 0)).filter((e=>void 0!==e)).forEach((e=>delete _[e]));const m={vertices:[],edges_face:_.map(((e,t)=>t)).filter((e=>void 0!==e))},g={},v={};return m.edges_vertices=_.map(((t,r)=>{const s=t.vertices.map((({a:t,vertex:r})=>{const s=m.vertices.length;return void 0!==g[r]?g[r]:(m.vertices.push({a:t,vertex:r,point:[...e[r]]}),g[r]=s,s)})),a=t.edges.map((({a:e,b:t,point:r,edge:s})=>{const a=m.vertices.length;return void 0!==v[s]?v[s]:(m.vertices.push({a:e,b:t,point:r,edge:s}),v[s]=a,a)})),o=t.points.map((({point:e,t:t})=>{const s=m.vertices.length;return m.vertices.push({point:e,t:t,face:r}),s}));return s.concat(a).concat(o)})).filter((e=>void 0!==e)),{vertices:l,edges:d,faces:_,segments:m}},splitLineIntoEdges=({vertices_coords:e,edges_vertices:t,faces_vertices:r,faces_edges:s},a,o=includeL,c=[],n=p)=>{if(!e||!t||!r)return;const{vertices:i,segments:l}=splitLineToSegments({vertices_coords:e,edges_vertices:t,faces_vertices:r,faces_edges:s},a,o,c,n),d={...l,vertices_info:l.vertices};delete d.vertices;let _=0;const m=d.vertices_info.map((t=>void 0===t.vertex?e.length+_++:t.vertex)),g=d.edges_vertices.map(((e,r)=>t.length+r));remapKey(d,"vertices",m),remapKey(d,"edges",g),d.vertices=d.vertices_info,delete d.vertices_info,d.vertices.map(((e,t)=>t)).filter((t=>void 0!==e[t])).forEach((e=>delete d.vertices[e]));const v=i.map((e=>void 0!==e)),u=t.map((e=>v[e[0]]&&v[e[1]]));return{...d,edges_collinear:u}};var ms=Object.freeze({__proto__:null,splitLineIntoEdges:splitLineIntoEdges,splitLineToSegments:splitLineToSegments});const transferPoint=(e,t,{vertex:r,edge:s,face:a,point:o,b:c})=>{if(void 0!==r)return t.vertices_coords[r];if(void 0!==s)return((e,t,r)=>{const s=e.edges_vertices[t].map((t=>e.vertices_coords[t])),a=pointsToLine2(s[0],s[1]);return add2(a.origin,scale2$1(a.vector,r))})(t,s,c);if(void 0!==a)return transferPointInFaceBetweenGraphs(e,t,a,o);throw new Error("transferPoint() failed")};var gs=Object.freeze({__proto__:null,foldGraphIntoSubgraph:(e,t,r,s=includeL,a=[],o="V",c=void 0,n=p)=>{void 0===c&&(c=Y[o]||0);const i=invertAssignment(o),l=0===c?0:-c,d=makeFacesWinding(t),{vertices:_,edges_vertices:m,edges_collinear:g,edges_face:v}=splitLineIntoEdges(t,r,s,a,n),u=_.map((r=>transferPoint(t,e,r))),h=v.map((e=>d[e]?o:i)),b=v.map((e=>d[e]?c:l)),y=e.edges_faces?e.edges_faces:makeEdgesFacesUnsorted(e),E={F:!0,f:!0,U:!0,u:!0};return g.map(((e,t)=>e?t:void 0)).filter((e=>void 0!==e)).forEach((e=>{if(!E[h[e]])return;const t=y[e].filter((e=>void 0!==e)).shift(),r=d[t];h[e]=r?o:i,b[e]=r?c:l})),{vertices_coords:u,edges_vertices:m,edges_assignment:h,edges_foldAngle:b}},transferPoint:transferPoint});const noNulls=e=>e.map(((e,t)=>null==e?t:void 0)).filter((e=>void 0!==e)),arraysHaveSameIndices=(e=[])=>{if(e.length<2)return[];const t={};return e[0].forEach(((e,r)=>{t[r]=!0})),Array.from(Array(e.length-1)).map(((t,r)=>e[r+1])).flatMap(((e,r)=>e.map(((e,s)=>t[s]?void 0:[0,r+1,s])).filter((e=>void 0!==e))))},validateReferences=e=>{const t=getAllPrefixes(e).filter((e=>"file"!==e&&"frame"!==e)),r=getAllSuffixes(e),s=t.map((t=>filterKeysWithPrefix(e,t))),a=s.map((t=>t.map((t=>e[t])).filter((e=>e.constructor===Array)))).map(arraysHaveSameIndices).flatMap(((e,t)=>e.map((e=>[s[t][e[0]],s[t][e[1]],e[2]])))).map((([e,t,r])=>`array indices differ ${e}, ${t} at index ${r}`));let o=[];try{o=((e,t)=>{const r={};return e.forEach((e=>{r[e]=1})),t.forEach((e=>{r[e]=1===r[e]?2:1})),Object.keys(r).filter((e=>2===r[e]))})(t,r).flatMap((r=>{const a=s[t.indexOf(r)],o=e[a[0]];return filterKeysWithSuffix(e,r).flatMap((t=>e[t].flatMap(((e,s)=>e.map(((e,c)=>null==e||void 0!==o[e]?void 0:`${t}[${s}][${c}] references ${r} ${e}, missing in ${a[0]}`)).filter((e=>void 0!==e))))))}))}catch(e){o.push("reference validation failed due to bad index access")}return a.concat(o)},pairwiseReferenceTest=(e,t,r,s)=>{try{const a={};e.forEach(((e,t)=>{a[t]={}})),e.forEach(((e,t)=>e.filter((e=>null!=e)).forEach((e=>{a[t][e]=!0}))));const o={};t.forEach(((e,t)=>{o[t]={}})),t.forEach(((e,t)=>e.filter((e=>null!=e)).forEach((e=>{o[t][e]=!0}))));const c=e.flatMap(((e,t)=>e.filter((e=>null!=e)).map((e=>o[e]&&o[e][t]?void 0:`${s}_${r}[${e}] missing ${t} referenced in ${r}_${s}`)).filter((e=>void 0!==e)))),n=t.flatMap(((e,t)=>e.filter((e=>null!=e)).map((e=>a[e]&&a[e][t]?void 0:`${r}_${s}[${e}] missing ${t} referenced in ${s}_${r}`)).filter((e=>void 0!==e))));return c.concat(n)}catch(e){return["pairwise reference validation failed due to bad index access"]}},reflexiveTest=(e,t)=>pairwiseReferenceTest(e,e,t,t),validateWinding=e=>{const t=(({vertices_vertices:e,vertices_edges:t,vertices_faces:r,edges_vertices:s,faces_vertices:a,faces_edges:o})=>{const c=[],n=s?makeVerticesToEdge({edges_vertices:s}):void 0,i=a?makeVerticesToFace({faces_vertices:a}):void 0,l=o?makeEdgesToFace({faces_edges:o}):void 0;try{if(e&&t&&n){const r=e.flatMap(((e,r)=>e.map((e=>[r,e])).map((e=>e.join(" "))).map((e=>n[e])).map(((e,s)=>t[r][s]!==e?[r,s,e,t[r][s]]:void 0)))).filter((e=>void 0!==e)).map((([e,t,r,s])=>`windings of vertices_vertices and vertices_edges at [${e}][${t}] do not match (${r} ${s})`));c.push(...r)}if(e&&r&&i){const t=e.flatMap(((e,t)=>e.map((e=>[t,e])).map((e=>e.join(" "))).map((e=>i[e])).map(((e,s)=>r[t][s]!=e?[t,s,e,r[t][s]]:void 0)))).filter((e=>void 0!==e)).map((([e,t,r,s])=>`windings of vertices_vertices and vertices_faces at [${e}][${t}] do not match (${r} ${s})`));c.push(...t)}if(t&&r&&l){const e=t.flatMap(((e,t)=>e.map(((e,t,r)=>[r[(t+1)%r.length],e])).map((e=>e.join(" "))).map((e=>l[e])).map(((e,s)=>r[t][s]!=e?[t,s,e,r[t][s]]:void 0)))).filter((e=>void 0!==e)).map((([e,t,r,s])=>`windings of vertices_edges and vertices_faces at [${e}][${t}] do not match (${r} ${s})`));c.push(...e)}}catch(e){c.push("vertices winding validation failed due to bad index access")}return c})(e),r=(({edges_vertices:e,edges_faces:t,faces_vertices:r,faces_edges:s,faces_faces:a})=>{const o=[],c=e?makeVerticesToEdge({edges_vertices:e}):void 0,n=r?makeVerticesToFace({faces_vertices:r}):void 0;try{if(r&&s&&c){const e=r.flatMap(((e,t)=>e.map(((e,t,r)=>[0,1].map((e=>r[(t+e)%r.length])))).map((e=>e.join(" "))).map((e=>c[e])).map(((e,r)=>s[t][r]!==e?[t,r,e,s[t][r]]:void 0)))).filter((e=>void 0!==e)).map((([e,t,r,s])=>`windings of faces_vertices and faces_edges at [${e}][${t}] do not match (${r} ${s})`));o.push(...e)}if(r&&a&&n){const e=r.flatMap(((e,t)=>e.map(((e,t,r)=>[1,0].map((e=>r[(t+e)%r.length])))).map((e=>e.join(" "))).map((e=>n[e])).map(((e,r)=>a[t][r]!=e?[t,r,e,a[t][r]]:void 0)))).filter((e=>void 0!==e)).map((([e,t,r,s])=>`windings of faces_vertices and faces_faces at [${e}][${t}] do not match (${r} ${s})`));o.push(...e)}if(s&&a&&t){const e=s.flatMap(((e,r)=>e.map((e=>t[e].filter((e=>e!==r)).shift())).map(((e,t)=>a[r][t]!=e?[r,t,e,a[r][t]]:void 0)))).filter((e=>void 0!==e)).map((([e,t,r,s])=>`windings of faces_edges and faces_faces at [${e}][${t}] do not match (${r} ${s})`));o.push(...e)}}catch(e){o.push("faces winding validation failed due to bad index access")}return o})(e);return t.concat(r)},validateAssignments=e=>{const t=[];return e.edges_assignment&&e.edges_foldAngle&&t.push(...(({edges_assignment:e,edges_foldAngle:t})=>{const r=t.map(Math.sign);return e.map((e=>Y[e])).map(Math.sign).map(((s,a)=>s===r[a]?void 0:`assignment does not match fold angle at ${a}: ${e[a]}, ${t[a]}`)).filter((e=>void 0!==e))})(e)),t},ordersTest=(e,t="orders")=>{const r=e.map((([e,t],r)=>e===t?[e,t,r]:void 0)).filter((e=>void 0!==e)).map((([e,r,s])=>`${t} between the same face ${e}, ${r} at index ${s}`)),s={},a=e.filter((([e,t])=>{const r=e<t?`${e} ${t}`:`${t} ${e}`,a=!0===s[r];return s[r]=!0,a})).map((([e,r])=>`${t} duplicate orders found at indices ${e}, ${r}`));return r.concat(a)};var vs=Object.freeze({__proto__:null,validate:e=>(e=>{const t=[];try{G.graph.filter((t=>e[t])).forEach((r=>t.push(...noNulls(e[r]).map((e=>`${r}[${e}] is undefined or null`)))))}catch(e){t.push("validation error: undefined or null array index")}try{["vertices_coords","vertices_vertices","vertices_edges","edges_vertices","faces_vertices","faces_edges"].filter((t=>e[t])).flatMap((t=>e[t].map(noNulls).flatMap(((e,r)=>e.map((e=>`${t}[${r}][${e}] is undefined or null`)))))).forEach((e=>t.push(e)))}catch(e){t.push("validation error: undefined or null array index")}if(e.vertices_coords)try{t.push(...e.vertices_coords.map(((e,t)=>2!==e.length&&3!==e.length?t:void 0)).filter((e=>void 0!==e)).map((e=>`vertices_coords[${e}] is not length 2 or 3`)))}catch(e){t.push("validation error: coordinate value undefined or null")}if(e.edges_vertices)try{t.push(...e.edges_vertices.map(((e,t)=>2!==e.length?t:void 0)).filter((e=>void 0!==e)).map((e=>`edges_vertices[${e}] is not length 2`)));const r=circularEdges(e);0!==r.length&&t.push(`circular edges_vertices: ${r.join(", ")}`);const s=duplicateEdges(e);if(0!==s.length){const e=s.map(((e,t)=>`${t}(${e})`)).filter((e=>e)).join(", ");t.push(`duplicate edges_vertices: ${e}`)}}catch(e){t.push("validation error: edge value undefined or null")}if(e.faces_vertices)try{t.push(...e.faces_vertices.map(((e,t)=>0===e.length?t:void 0)).filter((e=>void 0!==e)).map((e=>`faces_vertices[${e}] contains no vertices`)))}catch(e){t.push("validation error: face (faces_vertices) value undefined or null")}if(e.faces_edges)try{t.push(...e.faces_edges.map(((e,t)=>0===e.length?t:void 0)).filter((e=>void 0!==e)).map((e=>`faces_edges[${e}] contains no edges`)))}catch(e){t.push("validation error: face (faces_edges) value undefined or null")}return t})(e).concat(validateReferences(e)).concat((e=>{const t=[];return e.faces_vertices&&e.vertices_faces&&t.push(...pairwiseReferenceTest(e.faces_vertices,e.vertices_faces,"faces","vertices")),e.edges_vertices&&e.vertices_edges&&t.push(...pairwiseReferenceTest(e.edges_vertices,e.vertices_edges,"edges","vertices")),e.faces_edges&&e.edges_faces&&t.push(...pairwiseReferenceTest(e.faces_edges,e.edges_faces,"faces","edges")),e.vertices_vertices&&t.push(...reflexiveTest(e.vertices_vertices,"vertices")),e.faces_faces&&t.push(...reflexiveTest(e.faces_faces,"faces")),t})(e)).concat(validateWinding(e)).concat(validateAssignments(e)).concat((e=>{const t=[];return e.faceOrders&&t.push(...ordersTest(e.faceOrders,"faceOrders")),e.edgeOrders&&t.push(...ordersTest(e.edgeOrders,"edgeOrders")),t})(e))});const clean=(e,t)=>{const r=removeDuplicateVertices(e,t),s=removeCircularEdges(e),a=removeDuplicateEdges(e),o=removeIsolatedVertices(e),c=invertFlatMap(r.map),n=o.remove.map((e=>c[e])),i=invertFlatMap(s.map),l=a.remove.map((e=>i[e]));return{vertices:{map:mergeFlatNextmaps(r.map,o.map),remove:r.remove.concat(n)},edges:{map:mergeFlatNextmaps(s.map,a.map),remove:s.remove.concat(l)}}};var ps=Object.freeze({__proto__:null,clean:clean});const join=(e,t)=>{const r=getDimensionQuick(t),s=getDimensionQuick(e),a={};H.forEach((e=>{const r=filterKeysWithPrefix(t,e).shift();a[e]=void 0!==r?t[r]:[]}));const o={};H.forEach((t=>{o[t]=count(e,t)}));const c={vertices:[],edges:[],faces:[]};H.forEach((e=>a[e].forEach(((t,r)=>{c[e][r]=o[e]++}))));const n=br(t);H.forEach((e=>remapKey(n,e,c[e]))),Object.keys(n).filter((e=>n[e].constructor===Array)).filter((t=>!(t in e))).forEach((t=>{e[t]=[]})),Object.keys(n).filter((e=>n[e].constructor===Array)).forEach((t=>n[t].forEach(((r,s)=>{e[t][s]=r}))));const i={},l={};H.forEach((t=>{const r=filterKeysWithPrefix(e,t).shift();l[t]=void 0!==r?e[r]:[]})),H.forEach((e=>{const t=l[e].map((()=>0));c[e].forEach((e=>{t[e]=1})),i[e]=invertFlatToArrayMap(t)}));return(r!==s?(e.vertices_coords||[]).map(((e,t)=>2===e.length?t:void 0)).filter((e=>void 0!==e)):[]).forEach((t=>{e.vertices_coords[t][2]=0})),i};var us=Object.freeze({__proto__:null,join:join});const makeEdgesVerticesFromFaces=({faces_vertices:e})=>{const t={},r=[];return e.map((e=>e.map(((e,t,r)=>[e,r[(t+1)%r.length]])).forEach((([e,s])=>{t[`${e} ${s}`]||t[`${s} ${e}`]||(t[`${e} ${s}`]=!0,r.push([e,s]))})))),r};var hs=Object.freeze({__proto__:null,makeEdgesVerticesFromFaces:makeEdgesVerticesFromFaces});const bs={B:1,C:2,V:3,M:4,J:5,F:6,U:7};Object.keys(bs).forEach((e=>{bs[e.toLowerCase()]=bs[e]}));const highestPriorityAssignmentIndex=e=>{if(1===e.length)return 0;let t=0;return e.forEach(((r,s)=>{bs[r]<bs[e[t]]&&(t=s)})),t},planarizeCollinearEdges=({vertices_coords:e,edges_vertices:t,edges_assignment:r,edges_foldAngle:s},a=p)=>{const{lines:o,edges_line:c}=getEdgesLine({vertices_coords:e,edges_vertices:t},a),n=makeVerticesEdgesUnsorted({edges_vertices:t}),i=invertFlatToArrayMap(c),l=i.map((e=>uniqueElements(e.flatMap((e=>t[e]))))).map(((t,r)=>t.map((t=>({v:t,p:dot2(subtract2(e[t],o[r].origin),o[r].vector)}))).sort(((e,t)=>e.p-t.p)))),d=l.map((e=>e.map((({v:e})=>e)))),_=l.map((e=>e.map((({p:e})=>e)))).map(((e,t)=>clusterSortedGeneric(e,epsilonEqual).map((e=>e.map((e=>d[t][e])))))),m=(e=>{const t=[];let r=0;e.map((e=>e.map((e=>{const s=e.map((e=>t[e])).shift(),a=void 0!==s,o=a?s:r;return e.forEach((e=>{t[e]=o})),a?s:r++}))));const s=invertFlatToArrayMap(t).filter((e=>e));return invertArrayToFlatMap(s)})(_),g=invertFlatToArrayMap(m),v=_.map(((e,t)=>{const r={};i[t].forEach((e=>{r[e]=!0}));const s=new Set;return Array.from(Array(e.length-1)).map(((t,r)=>e[r])).map((e=>{const t=uniqueElements(e.flatMap((e=>n[e])).filter((e=>r[e]))),a=t.map((e=>!s.has(e)));return t.forEach(((e,t)=>a[t]?s.add(e):s.delete(e))),Array.from(s)}))})),u=_.map((e=>e.map((e=>m[e[0]])))).flatMap(((e,t)=>Array.from(Array(e.length-1)).map(((r,s)=>v[t][s].length?[e[s],e[s+1]]:void 0)))).filter((e=>void 0!==e)).map((([e,t])=>[e,t])),h=(e=>{const t=[];let r=0;return e.map((e=>e.map((e=>(e.filter((e=>void 0===t[e])).forEach((e=>{t[e]=[]})),e.forEach((e=>t[e].push(r))),e.length?r++:r))))),t})(v),b=g.map((t=>e[t[0]])).map(resize2),y={vertices_coords:b,edges_vertices:u};if(r||s){const e=invertArrayMap(h),t=r?e.map((e=>e.map((e=>r[e])))).map(highestPriorityAssignmentIndex):e.map((()=>0));r&&(y.edges_assignment=t.map(((t,s)=>r[e[s][t]]))),s&&(y.edges_foldAngle=t.map(((t,r)=>s[e[r][t]])))}return{result:y,changes:{vertices:{map:m},edges:{map:h},edges_line:c,lines:o}}};var ys=Object.freeze({__proto__:null,planarizeCollinearEdges:planarizeCollinearEdges});const intersectAllEdges=({vertices_coords:e,vertices_edges:t,edges_vertices:r},s=p)=>{t||(t=makeVerticesEdgesUnsorted({edges_vertices:r}));const a=r.map((()=>({})));r.forEach(((e,r)=>e.flatMap((e=>t[e])).forEach((e=>{a[r][e]=!0,a[e][r]=!0}))));const o=edgesToLines2({vertices_coords:e,edges_vertices:r}),c=[];for(let e=0;e<r.length-1;e+=1)for(let t=e+1;t<r.length;t+=1){if(a[e][t])continue;const{a:r,b:n,point:i}=intersectLineLine(o[e],o[t],includeS,includeS,s);if(i){if((epsilonEqual(r,0)||epsilonEqual(r,1))&&(epsilonEqual(n,0)||epsilonEqual(n,1)))continue;c.push({i:e,j:t,a:r,b:n,point:i})}}return c};var Es=Object.freeze({__proto__:null,intersectAllEdges:intersectAllEdges});const planarizeOverlaps=({vertices_coords:e,vertices_edges:t,edges_vertices:r,edges_assignment:s,edges_foldAngle:a},o=p)=>{t||(t=makeVerticesEdgesUnsorted({edges_vertices:r}));const c=r.map((()=>[])),n=intersectAllEdges({vertices_coords:e,vertices_edges:t,edges_vertices:r},o);n.filter((({a:e})=>!epsilonEqual(e,0)&&!epsilonEqual(e,1))).forEach((({i:e,a:t})=>c[e].push(t))),n.filter((({b:e})=>!epsilonEqual(e,0)&&!epsilonEqual(e,1))).forEach((({j:e,b:t})=>c[e].push(t))),c.forEach((e=>e.sort(((e,t)=>e-t))));const i=c.map((e=>clusterSortedGeneric(e,epsilonEqual))),average=e=>e.length?e.reduce(((e,t)=>e+t),0)/e.length:0,l=i.map(((e,t)=>e.map((e=>e.map((e=>c[t][e])))).map(average)));let d=0;const _=l.map((e=>Array.from(Array(e.length+1)).map((()=>d++)))),m=invertArrayToFlatMap(_);let g=e.length;const v=l.map((e=>e.map((()=>g++)))).map(((e,t)=>[r[t][0],...e,r[t][1]])).flatMap((e=>Array.from(Array(e.length-1)).map(((t,r)=>[e[r],e[r+1]])))).map((([e,t])=>[e,t])),u=l.flatMap(((t,s)=>{if(!t.length)return[];const a=edgeToLine2({vertices_coords:e,edges_vertices:r},s);return t.map((e=>add2(a.origin,scale2$1(a.vector,e))))})),h={vertices_coords:e.concat(u).map(resize2),edges_vertices:v};s&&(h.edges_assignment=m.map((e=>s[e]))),a&&(h.edges_foldAngle=m.map((e=>a[e])));const b=e.map(((e,t)=>t)),{map:y}=removeDuplicateVertices(h,o),{map:E}=removeCircularEdges(h),M=mergeNextmaps(_,E);return{result:h,changes:{vertices:{map:mergeFlatNextmaps(b,y)},edges:{map:M}}}};var Ms=Object.freeze({__proto__:null,planarizeOverlaps:planarizeOverlaps});const planarizeCollinearVertices=(e,t=p)=>{e.vertices_edges||(e.vertices_edges=makeVerticesEdgesUnsorted(e));const r=e.vertices_edges.map(((e,t)=>2===e.length?t:void 0)).filter((e=>void 0!==e)).filter((r=>isVertexCollinear(e,r,t))).reverse(),s=r.map((t=>(({edges_vertices:e,vertices_edges:t},r)=>{const s=t[r].sort(((e,t)=>e-t)),[a,o]=s.flatMap((t=>e[t])).filter((e=>e!==r));return e[s[0]]=[a,o],e[s[1]]=void 0,[a,o].forEach((e=>{const r=t[e].indexOf(s[1]);-1!==r&&(t[e][r]=s[0])})),s[1]})(e,t)));delete e.vertices_edges;const a=remove(e,"edges",s),o=remove(e,"vertices",r),{map:c}=removeDuplicateEdges(e),n=mergeNextmaps(a,c);return{result:e,changes:{vertices:{map:o},edges:{map:n}}}};var As=Object.freeze({__proto__:null,planarizeCollinearVertices:planarizeCollinearVertices});const planarizeEdgesVerbose=(e,t=p)=>{const{result:r,changes:{vertices:{map:s},edges:{map:a}}}=planarizeCollinearEdges(e,t),{result:o,changes:{vertices:{map:c},edges:{map:n}}}=planarizeOverlaps(r,t),{result:i,changes:{vertices:{map:l},edges:{map:d}}}=planarizeCollinearVertices(o,t);return{result:i,changes:{vertices:{map:mergeNextmaps(s,c,l)},edges:{map:mergeNextmaps(a,n,d)}}}},planarizeVerbose=(e,t=p)=>{const r=(e=>e.edges_vertices?e:e.faces_vertices?{...e,edges_vertices:makeEdgesVerticesFromFaces(e)}:{})(e),{result:s,changes:{vertices:{map:a},edges:{map:o}}}=planarizeEdgesVerbose(r,t),{faces_vertices:c,faces_edges:n}=makePlanarFaces(s);s.faces_vertices=c,s.faces_edges=n;const i=((e,t,r)=>{if(!e.faces_vertices)return[];const s=t.faces_edges||makeFacesEdgesFromVertices(t),a=makeFacesFaces(t).map((e=>e.filter((e=>null!=e)))),o=makeEdgesFacesUnsorted(t),c=makeEdgesFacesUnsorted(e),n=connectedComponents(a),i=invertFlatToArrayMap(n).map((e=>e.flatMap((e=>s[e])))).map(uniqueElements),l=i.map((e=>e.find((e=>1===o[e].length)))),d=l.map((e=>o[e][0])),_={};o.forEach(((e,t)=>chooseTwoPairs(e).forEach((e=>{_[e.join(" ")]=t,_[e.reverse().join(" ")]=t}))));const m=invertArrayMap(r.edges.map),g=[];minimumSpanningTrees(a,d).forEach(((e,t)=>{const r=e.shift();if(!r||!r.length)return;const s=r[0],a=l[t],o=m[a];g[s.index]=new Set(o.flatMap((e=>c[e]))),e.forEach((e=>e.forEach((({index:e,parent:t})=>{const r=_[`${e} ${t}`],s=m[r].flatMap((e=>c[e])),a=new Set(g[t]);s.forEach((e=>a.has(e)?a.delete(e):a.add(e))),g[e]=a}))))}));const v=g.map((e=>Array.from(e)));return invertArrayMap(v)})(r,s,{vertices:{map:a},edges:{map:o}});return((e,t)=>{const r=invertArrayMap(t);e.faces_vertices.map(((e,t)=>t)).filter((e=>void 0===r[e])).forEach((t=>{delete e.faces_vertices[t],delete e.faces_edges[t]}))})(s,i),{result:s,changes:{vertices:{map:a},edges:{map:o},faces:{map:i}}}};var xs=Object.freeze({__proto__:null,planarize:(e,t=p)=>{const{result:r}=planarizeVerbose(e,t);return r},planarizeEdges:({vertices_coords:e,edges_vertices:t,edges_assignment:r,edges_foldAngle:s},a=p)=>{const{result:o}=planarizeCollinearEdges({vertices_coords:e,edges_vertices:t,edges_assignment:r,edges_foldAngle:s},a),{result:c}=planarizeOverlaps(o,a),{result:n}=planarizeCollinearVertices(c,a);return n},planarizeEdgesVerbose:planarizeEdgesVerbose,planarizeVerbose:planarizeVerbose});const makeOneSide=(e,t)=>(e.edges_faces.forEach(((r,s)=>{if(2!==r.length)return;const[a,o]=r.map((e=>t[e]));a===o&&e.edges_assignment&&(e.edges_assignment[s]="J"),a===o&&e.edges_foldAngle&&(e.edges_foldAngle[s]=0)})),e),correctFaceWinding=(e,t,r)=>e.faces_vertices.map(((e,t)=>t)).filter((e=>!t[r[e]])).forEach((t=>{e.faces_vertices[t].reverse(),e.faces_edges[t].reverse(),e.faces_edges[t].push(e.faces_edges[t].shift())})),fixCycles=e=>{const{result:t,changes:{faces:{map:r}}}=planarizeVerbose(e);t.edges_faces=makeEdgesFacesUnsorted(t);const s=invertArrayMap(r);!t.edges_assignment&&t.edges_vertices&&(t.edges_assignment=t.edges_vertices.map((()=>"U")));const a=makeFacesNormal(e),o=faceOrdersToDirectedEdges({...e,faces_normal:a}),c=makeFacesWinding(e),n=s.map((e=>{const t={};e.forEach((e=>{t[e]=!0}));const r=o.filter((([e,r])=>t[e]&&t[r])),s=topologicalSort(r);return e.filter((e=>-1===s.indexOf(e))).concat(s)})),i=n.map((e=>e[0])),l=n.map((e=>e.slice().reverse()[0])),d=makeOneSide(structuredClone(t),i),_=makeOneSide(t,l);correctFaceWinding(d,c,i),correctFaceWinding(_,c,l);const m=d.faces_vertices.map(((e,t)=>c[i[t]]?[d.faces_vertices.length+t,t,-1]:[d.faces_vertices.length+t,t,1]));return join(d,_),{...d,faceOrders:m,frame_classes:["foldedForm"]}};var Os=Object.freeze({__proto__:null,fixCycles:fixCycles});const explodeFaces=({vertices_coords:e,edges_vertices:t,edges_assignment:r,edges_foldAngle:s,faces_vertices:a,faces_edges:o})=>{if(!a)return t?br({vertices_coords:e,edges_vertices:t,edges_assignment:r,edges_foldAngle:s}):e?br({vertices_coords:e}):{};let c=0;const n=a.map((e=>e.map((()=>c++))));if(!e)return{faces_vertices:n};const i=getDimensionQuick({vertices_coords:e}),l=br(a.flatMap((t=>t.map((t=>e[t]))))),d=3===i?l.map(resize3):l.map(resize2);if(!t)return{vertices_coords:d,faces_vertices:n};o||(o=makeFacesEdgesFromVertices({edges_vertices:t,faces_vertices:a}));let _=0;const m={vertices_coords:d,faces_vertices:n,edges_vertices:o.flatMap((e=>e.map(((e,t,r)=>t===r.length-1?[_,++_-r.length]:[_,++_])))).map((([e,t])=>[e,t]))},g=o.flatMap((e=>e));return r&&(m.edges_assignment=g.map((e=>r[e]))),s&&(m.edges_foldAngle=g.map((e=>s[e]))),m};var js=Object.freeze({__proto__:null,explodeEdges:({vertices_coords:e,edges_vertices:t,edges_assignment:r,edges_foldAngle:s})=>{if(!t)return e?{vertices_coords:e}:{};let a=0;const o={edges_vertices:t.map((()=>[a++,a++]))};return r&&(o.edges_assignment=r),s&&(o.edges_foldAngle=s),e&&(o.vertices_coords=structuredClone(t.flatMap((t=>t.map((t=>e[t])))))),o},explodeFaces:explodeFaces});const nearestEdge=({vertices_coords:e,edges_vertices:t},r)=>{if(!e||!t)return;const s=2===getDimensionQuick({vertices_coords:e})?(({vertices_coords:e,edges_vertices:t},r)=>t.map((t=>t.map((t=>e[t])))).map((e=>nearestPointOnLine({vector:subtract2(e[1],e[0]),origin:e[0]},r,clampSegment))))({vertices_coords:e,edges_vertices:t},r):(({vertices_coords:e,edges_vertices:t},r)=>t.map((t=>t.map((t=>e[t])))).map((e=>nearestPointOnLine({vector:subtract3(e[1],e[0]),origin:e[0]},r,clampSegment))))({vertices_coords:e,edges_vertices:t},r);return arrayMinimumIndex(s,(e=>distance(e,r)))};var ws=Object.freeze({__proto__:null,nearestEdge:nearestEdge,nearestFace:(e,t)=>{const r=faceContainingPoint(e,t);if(void 0!==r)return r;if(e.edges_faces){const r=nearestEdge(e,t);if(void 0===r)return;const s=e.edges_faces[r];if(1===s.length)return s[0];if(s.length>1){const r=makeFacesCenterQuick({vertices_coords:e.vertices_coords,faces_vertices:s.map((t=>e.faces_vertices[t]))}).map((e=>distance(e,t)));let a=0;for(let e=0;e<r.length;e+=1)r[e]<r[a]&&(a=e);return s[a]}}},nearestVertex:({vertices_coords:e},t)=>{if(!e)return;const r=getDimensionQuick({vertices_coords:e});if(void 0===r)return;const s=resize(r,t),a=e.map(((e,t)=>({d:distance(s,e),i:t}))).sort(((e,t)=>e.d-t.d)).shift();return a?a.i:void 0}});var ks=Object.freeze({__proto__:null,normalize:e=>{const t={vertices:[],edges:[],faces:[]};let r=0,s=0,a=0;return e.vertices_coords.forEach(((e,s)=>{t.vertices[s]=r++})),e.edges_vertices.forEach(((e,r)=>{t.edges[r]=s++})),e.faces_vertices.forEach(((e,r)=>{t.faces[r]=a++})),remapKey(e,"vertices",t.vertices),remapKey(e,"edges",t.edges),remapKey(e,"faces",t.faces),e}});const getFacesFacesOverlap=({vertices_coords:e,faces_vertices:t},r=p)=>{const s=makeFacesPolygon({vertices_coords:e,faces_vertices:t}).map((e=>e.map(resize2))),a=s.map((e=>boundingBox$1(e))),o=t.map((()=>[])),c={},n=[];return sweepFaces({vertices_coords:e,faces_vertices:t},0,r).forEach((({start:e,end:t})=>{e.forEach((e=>{n[e]=!0})),n.forEach(((t,n)=>e.filter((e=>e!==n)).forEach((e=>{const t=n<e?`${n} ${e}`:`${e} ${n}`;c[t]||(c[t]=!0,overlapBoundingBoxes(a[n],a[e],r)&&overlapConvexPolygons(s[n],s[e],r)&&(o[n].push(e),o[e].push(n)))})))),t.forEach((e=>delete n[e]))})),o},getEdgesEdgesCollinearOverlap=({vertices_coords:e,edges_vertices:t},r=p)=>{const{lines:s,edges_line:a}=getEdgesLine({vertices_coords:e,edges_vertices:t},r),o=makeEdgesCoords({vertices_coords:e,edges_vertices:t}).map(((e,t)=>e.map((e=>dot(s[a[t]].vector,e))))),c=t.map((()=>[]));return invertFlatToArrayMap(a).flatMap((e=>chooseTwoPairs(e))).filter((e=>{const[t,s]=e.map((e=>o[e]));return doRangesOverlap(t,s,r)})).forEach((([e,t])=>{c[e].push(t),c[t].push(e)})),c},getOverlappingComponents=({vertices_coords:e,edges_vertices:t,faces_vertices:r},s=p)=>{const a=e.map(resize2),o=edgesToLines2({vertices_coords:e,edges_vertices:t}),c=r.map((e=>e.map((e=>a[e])))),n=getVerticesClusters({vertices_coords:e},s),i=arrayArrayToLookupArray(clustersToReflexiveArrays(n));e.forEach(((e,t)=>{i[t][t]=!0}));const l=e.map((()=>[]));e.map(((e,t)=>o.map(((e,t)=>t)).filter((t=>overlapLinePoint(o[t],e,excludeS,s))).forEach((e=>{l[t][e]=!0}))));const d=t.map((()=>[]));o.map(((e,t)=>o.map(((e,t)=>t)).filter((r=>t!==r&&void 0!==intersectLineLine(e,o[r],excludeS,excludeS,s).point)).forEach((e=>{d[t][e]=!0,d[e][t]=!0}))));const _=r.map((()=>[]));return c.map(((t,r)=>e.map(((e,t)=>t)).filter((e=>overlapConvexPolygonPoint(t,a[e],exclude,s).overlap)).forEach((e=>{_[r][e]=!0})))),{verticesVertices:i,verticesEdges:l,edgesEdges:d,facesVertices:_}},getFacesEdgesOverlap=({vertices_coords:e,edges_vertices:t,faces_vertices:r,faces_edges:s},a=p)=>{const{verticesVertices:o,verticesEdges:c,edgesEdges:n,facesVertices:i}=getOverlappingComponents({vertices_coords:e,edges_vertices:t,faces_vertices:r},a),l=r.map((()=>[]));return r.forEach(((e,a)=>t.forEach(((e,d)=>{const _=((e,s)=>{const a=r[s].filter((t=>c[t][e])),[n,i]=t[e],l=r[s].filter((e=>o[e][n]||o[e][i]));return((e,t)=>{const r={};return t.forEach((e=>{r[e]=!0})),e.map(((e,t,r)=>[e,r[(t+1)%r.length]])).filter((([e,t])=>r[e]&&r[t])).forEach((([e,t])=>{r[e]=!1,r[t]=!1})),t.filter((e=>r[e]))})(r[s],Array.from(new Set([...l,...a])))})(d,a),m=((e,r)=>{const[a,o]=t[e],i=s[r].filter((e=>c[a][e]||c[o][e])),l=s[r].filter((t=>n[e][t]));return Array.from(new Set([...i,...l]))})(d,a),g=((e,r)=>t[e].filter((e=>i[r][e])))(d,a);_.length+m.length+g.length===2&&(1===_.length&&1===m.length&&t[m[0]].includes(_[0])||l[a].push(d))})))),l},getEdgesFacesOverlap=({vertices_coords:e,edges_vertices:t,faces_vertices:r,faces_edges:s},a=p)=>{const o=t.map((()=>[]));return getFacesEdgesOverlap({vertices_coords:e,edges_vertices:t,faces_vertices:r,faces_edges:s},a).forEach(((e,t)=>e.forEach((e=>{o[e].push(t)})))),o};var Fs=Object.freeze({__proto__:null,getEdgesEdgesCollinearOverlap:getEdgesEdgesCollinearOverlap,getEdgesFacesOverlap:getEdgesFacesOverlap,getFacesEdgesOverlap:getFacesEdgesOverlap,getFacesFacesOverlap:getFacesFacesOverlap,getOverlappingComponents:getOverlappingComponents});var Ss=Object.freeze({__proto__:null,planarizeMakeFaces:(e,t,{edges:{map:r}})=>{const s=invertArrayMap(r),{faces_vertices:a,faces_edges:o}=makePlanarFaces(t),c=(({edges_vertices:e,edges_faces:t,faces_vertices:r,faces_edges:s},a,o)=>{if(!r&&!s)return[];s||(s=makeFacesEdgesFromVertices({edges_vertices:e,faces_vertices:r})),t||(t=makeEdgesFacesUnsorted({edges_vertices:e,faces_vertices:r,faces_edges:s}));const c=a.map((e=>e.filter((e=>void 0!==o[e])).map((e=>o[e])))),n=c.map((e=>e.map((e=>e.flatMap((e=>t[e])))))),i=n.map((e=>invertFlatToArrayMap(e.flat()).map((e=>e.length)))).map((e=>invertFlatToArrayMap(e))).map((e=>e.pop())).map((e=>void 0===e?[]:e));return i})(e,o,s);return{faces_vertices:a,faces_edges:o,faceMap:invertArrayMap(c)}}});const pleat=({vertices_coords:e,edges_vertices:t},r,s,a,o=p)=>{const c=edgesToLines2({vertices_coords:e,edges_vertices:t});return pleat$2(r,s,a,o).map((e=>e.map((e=>{const t=c.map((t=>intersectLineLine(e,t,includeL,includeS,o).a)).filter((e=>void 0!==e));if(t.length<2)return;const r=Math.min(...t),s=Math.max(...t);return Math.abs(s-r)<o?void 0:[add2(e.origin,scale2$1(e.vector,r)),add2(e.origin,scale2$1(e.vector,s))]})).filter((e=>void 0!==e))))};var Cs=Object.freeze({__proto__:null,pleat:pleat,pleatEdges:({vertices_coords:e,edges_vertices:t},r,s,a,o=p)=>{const c=edgeToLine2({vertices_coords:e,edges_vertices:t},r),n=edgeToLine2({vertices_coords:e,edges_vertices:t},s);return pleat({vertices_coords:e,edges_vertices:t},c,n,a,o)}});var Vs=Object.freeze({__proto__:null,raycast:(e,t)=>{}});const triangulateConvexFacesVertices=({faces_vertices:e})=>e.flatMap((e=>{return e.length<4?[e]:(t=e,Array.from(Array(t.length-2)).map(((e,r)=>[t[0],t[r+1],t[r+2]])));var t})),groupByThree=e=>3===e.length?[e]:Array.from(Array(Math.floor(e.length/3))).map(((t,r)=>[3*r+0,3*r+1,3*r+2].map((t=>e[t])))),triangulateNonConvexFacesVertices=({vertices_coords:e,faces_vertices:t},r)=>{if(!e||!e.length)throw new Error(_);const s=e.filter((()=>!0)).shift().length;if(3===s||!r)return triangulateConvexFacesVertices({faces_vertices:t});const a=makeFacesWinding({vertices_coords:e,faces_vertices:t});return t.map((t=>t.flatMap((t=>e[t])))).map((e=>r(e,null,s))).map(((e,r)=>e.map((e=>t[r][e])))).flatMap(((e,t)=>a[t]?groupByThree(e):groupByThree(e).map((e=>e.reverse()))))},rebuildTriangleEdges=({edges_vertices:e,edges_assignment:t,edges_foldAngle:r,faces_vertices:s},{faces_vertices:a})=>{const o=e?makeVerticesToEdge({edges_vertices:e}):{};let c=e?e.length:0;const n=[],i=a.map((e=>e.map(((e,t,r)=>{const s=[e,r[(t+1)%r.length]],a=s.join(" ");return a in o?o[a]:(n.push(s),o[a]=c,o[s.slice().reverse().join(" ")]=c,c++)})))),l=t?t.concat(n.map((()=>"J"))):(({edges_vertices:e,faces_vertices:t},{faces_vertices:r,faces_edges:s})=>{const a=e?e.map((()=>"U")):Array.from(Array(countImpliedEdges({faces_edges:s}))).map((()=>"U")),o=makeVerticesToFace({faces_vertices:t});return r.map(((e,t)=>e.map(((e,t,r)=>[e,r[(t+1)%r.length]])).forEach((([e,r],c)=>{const n=[`${e} ${r}`,`${r} ${e}`];if(void 0===o[n[0]]&&void 0===o[n[1]]){const e=s[t][c];a[e]="J"}})))),Array.from(Array(a.length)).map(((e,t)=>t)).filter((e=>void 0===a[e])).forEach((e=>{a[e]="U"})),a})({edges_vertices:e,faces_vertices:s},{faces_vertices:a,faces_edges:i}),d={edges_vertices:e?e.concat(n):n,faces_edges:i,edges_assignment:l};if(r){const e=n.map((()=>0));d.edges_foldAngle=r.concat(e)}return d},triangulate=({vertices_coords:e,edges_vertices:t,edges_assignment:r,edges_foldAngle:s,faces_vertices:a,faceOrders:o},c)=>{if(!a){const a={vertices_coords:e,edges_vertices:t,edges_assignment:r,edges_foldAngle:s};return Object.keys(a).filter((e=>!a[e])).forEach((e=>delete a[e])),{result:a,changes:{}}}const n=(({faces_vertices:e})=>{let t=0;return e.map((e=>Math.max(3,e.length))).map((e=>Array.from(Array(e-2)).map((()=>t++))))})({faces_vertices:a}),i=c?triangulateNonConvexFacesVertices({vertices_coords:e,faces_vertices:a},c):triangulateConvexFacesVertices({faces_vertices:a}),l=rebuildTriangleEdges({edges_vertices:t,edges_assignment:r,edges_foldAngle:s,faces_vertices:a},{faces_vertices:i}),d={...l,vertices_coords:e,faces_vertices:i},_=t?t.length:0;return{result:d,changes:{faces:{map:n},edges:{new:Array.from(Array(l.edges_vertices.length-_)).map(((e,t)=>_+t))}}}};var zs=Object.freeze({__proto__:null,triangulate:triangulate,triangulateConvexFacesVertices:triangulateConvexFacesVertices,triangulateNonConvexFacesVertices:triangulateNonConvexFacesVertices});const prepareForRenderingWithCycles=(e,{earcut:t,layerNudge:r}={})=>{const s=br(e),{planes_faces:a,planes_transform:o}=getFacesPlane(s);if(!s.faceOrders)return triangulate(s,t).result;const c=o.map(invertMatrix4),n=a.map((e=>faceOrdersSubset(s.faceOrders,e))),i={...s,vertices_coords:s.vertices_coords.map(resize3)},l=a.map((e=>subgraphWithFaces(i,e))),d=l.map(((e,t)=>({...e,vertices_coords:e.vertices_coords.map((e=>multiplyMatrix4Vector3(o[t],e)))}))).map(((e,t)=>fixCycles({...e,faceOrders:n[t]}))).map(((e,t)=>({...e,vertices_coords:e.vertices_coords.map(resize3).map((e=>multiplyMatrix4Vector3(c[t],e)))}))),_=d.map((e=>nudgeFacesWithFaceOrders(e))),m=d.map((e=>triangulate(e,t))),g=m.map((({result:e})=>e)).map(explodeFaces);return m.forEach((({changes:e},t)=>{const s=invertArrayToFlatMap(e.faces.map),a=g[t].vertices_coords.map((()=>{}));s.forEach(((e,s)=>{const o=_[t][e];o&&g[t].faces_vertices[s].forEach((e=>{a[e]=scale3$1(o.vector,o.layer*r)}))})),a.forEach(((e,r)=>{e&&(g[t].vertices_coords[r]=add3(resize3(g[t].vertices_coords[r]),e))}))})),g.length>1&&g.forEach(((e,t)=>{0!==t&&join(g[0],e)})),g[0]},prepareForRendering=(e,{earcut:t,layerNudge:r=5e-6}={})=>{const s=br(e);if(!s.edges_assignment){const e=countEdges(s)||countImpliedEdges(s);e&&(s.edges_assignment=Array(e).fill("U"))}if(!s.faceOrders)return explodeFaces(triangulate(s,t).result);const a=nudgeFacesWithFaceOrders(s);if(!a)return prepareForRenderingWithCycles(e,{earcut:t,layerNudge:r});const{changes:o,result:c}=triangulate(s,t),n=explodeFaces(c);if(o.faces){invertArrayToFlatMap(o.faces.map).forEach(((e,t)=>{const s=a[e];s&&n.faces_vertices[t].forEach((e=>{const t=scale3$1(s.vector,s.layer*r);n.vertices_coords[e]=add3(resize3(n.vertices_coords[e]),t)}))}))}return n};var Ts=Object.freeze({__proto__:null,prepareForRendering:prepareForRendering,prepareForRenderingWithCycles:prepareForRenderingWithCycles});const transform=({vertices_coords:e},t)=>e.map(resize3).map((e=>multiplyMatrix3Vector3(t,e)));var Ps=Object.freeze({__proto__:null,rotate:(e,t,r=[0,0,1],s=[0,0,0])=>{const a=makeMatrix3Rotate(t,resize3(r),resize3(s)),o=transform(e,a);return Object.assign(e,{vertices_coords:o})},rotateX:(e,t,r=[0,0,0])=>{const s=makeMatrix3RotateX(t,resize3(r)),a=transform(e,s);return Object.assign(e,{vertices_coords:a})},rotateY:(e,t,r=[0,0,0])=>{const s=makeMatrix3RotateY(t,resize3(r)),a=transform(e,s);return Object.assign(e,{vertices_coords:a})},rotateZ:(e,t,r=[0,0,0])=>{const s=2===getDimensionQuick(e)?resize2:resize3,a=makeMatrix3RotateZ(t,resize3(r)),o=transform(e,a).map((e=>s(e)));return Object.assign(e,{vertices_coords:o})},scale:(e,t=[1,1,1],r=[0,0,0])=>{const s=resize3(r),a=e.vertices_coords.map((e=>add(scaleNonUniform(subtract(e,s),t),s)));return Object.assign(e,{vertices_coords:a})},scale2:(e,t=[1,1],r=[0,0])=>{const s=e.vertices_coords.map((e=>add2(scaleNonUniform2(subtract2(e,r),t),r)));return Object.assign(e,{vertices_coords:s})},scale3:(e,t=[1,1,1],r=[0,0,0])=>{const s=[t[0]||1,t[1]||1,t[2]||1],a=resize3(r),o=e.vertices_coords.map(resize3).map((e=>add3(scaleNonUniform3(subtract3(e,a),s),a)));return Object.assign(e,{vertices_coords:o})},scaleUniform:(e,t=1,r=[0,0,0])=>{if(!e.vertices_coords)return e;const s=resize3(r),a=e.vertices_coords.map((e=>add(scale$1(subtract(e,s),t),s)));return Object.assign(e,{vertices_coords:a})},scaleUniform2:(e,t=1,r=[0,0])=>{if(!e.vertices_coords)return e;const s=e.vertices_coords.map((e=>add2(scale2$1(subtract2(e,r),t),r)));return Object.assign(e,{vertices_coords:s})},scaleUniform3:(e,t=1,r=[0,0,0])=>{if(!e.vertices_coords)return e;const s=resize3(r),a=e.vertices_coords.map(resize3).map((e=>add3(scale3$1(subtract3(e,s),t),s)));return Object.assign(e,{vertices_coords:a})},transform:transform,translate:(e,t)=>{if(!e.vertices_coords)return e;const r=e.vertices_coords.map((e=>add(e,t)));return Object.assign(e,{vertices_coords:r})},translate2:(e,t)=>{if(!e.vertices_coords)return e;const r=e.vertices_coords.map((e=>add2(e,t)));return Object.assign(e,{vertices_coords:r})},translate3:(e,t)=>{if(!e.vertices_coords)return e;const r=resize3(t),s=e.vertices_coords.map(resize3).map((e=>add3(e,r)));return Object.assign(e,{vertices_coords:s})},unitize:e=>{if(!e.vertices_coords)return e;const t=boundingBox$1(e.vertices_coords),r=Math.max(...t.span),s=0===r?1:1/r,a=t.min,o=e.vertices_coords.map((e=>subtract(e,a))).map((e=>scale$1(e,s)));return Object.assign(e,{vertices_coords:o})}});var $s={...me,...Ee,...Object.freeze({__proto__:null,makeEdgesEdges:({edges_vertices:e,vertices_edges:t})=>e.map(((e,r)=>{const s=t[e[0]].filter((e=>e!==r)),a=t[e[1]].filter((e=>e!==r));return s.concat(a)}))}),...ue,...ye,...hs,...pe,...de,...Wr,...fe,...U,...ve,...D,...oe,...le};var Bs=Object.freeze({__proto__:null,bird:()=>populate({vertices_coords:[[0,0],[.5,0],[1,0],[1,.5],[1,1],[.5,1],[0,1],[0,.5],[.5,.5],[.5,(Math.SQRT2-1)/2],[(3-Math.SQRT2)/2,.5],[.5,(3-Math.SQRT2)/2],[(Math.SQRT2-1)/2,.5],[Math.SQRT1_2/2,Math.SQRT1_2/2],[1-Math.SQRT1_2/2,1-Math.SQRT1_2/2]],edges_vertices:[[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,0],[0,9],[9,2],[2,10],[10,4],[4,11],[11,6],[6,12],[12,0],[1,9],[9,8],[3,10],[10,8],[5,11],[11,8],[7,12],[12,8],[2,8],[6,8],[0,13],[13,8],[13,9],[13,12],[4,14],[14,8],[14,10],[14,11]],edges_assignment:Array.from("BBBBBBBBVVVVVVVVMVMVMVMVMMFFFFFFFF")},{faces:!0}),blintz:()=>populate({vertices_coords:[[0,0],[.5,0],[1,0],[1,.5],[1,1],[.5,1],[0,1],[0,.5]],vertices_vertices:[[1,7],[2,3,7,0],[3,1],[4,5,1,2],[5,3],[6,7,3,4],[7,5],[0,1,5,6]],edges_vertices:[[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,0],[7,1],[1,3],[3,5],[5,7]],edges_assignment:Array.from("BBBBBBBBVVVV"),faces_vertices:[[7,1,3,5],[1,7,0],[3,1,2],[5,3,4],[7,5,6]]}),fish:()=>populate({vertices_coords:[[0,0],[Math.SQRT1_2,0],[1,0],[1,1-Math.SQRT1_2],[1,1],[1-Math.SQRT1_2,1],[0,1],[0,Math.SQRT1_2],[.5,.5],[Math.SQRT1_2,1-Math.SQRT1_2],[1-Math.SQRT1_2,Math.SQRT1_2]],edges_vertices:[[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,0],[9,0],[9,2],[9,4],[10,0],[10,6],[10,4],[9,1],[10,7],[9,3],[10,5],[8,0],[8,9],[8,4],[8,10]],edges_assignment:Array.from("BBBBBBBBVVVVVVMMFFFFFF")},{faces:!0}),frog:()=>populate({vertices_coords:[[0,1],[0,Math.SQRT1_2],[0,.5],[0,1-Math.SQRT1_2],[0,0],[.5,.5],[1,1],[(1-Math.SQRT1_2)/2,Math.SQRT1_2/2],[Math.SQRT1_2/2,(1-Math.SQRT1_2)/2],[1-Math.SQRT1_2,0],[.5,0],[Math.SQRT1_2,0],[1,0],[.5,(1-Math.SQRT1_2)/2],[1-Math.SQRT1_2/2,(1-Math.SQRT1_2)/2],[(1-Math.SQRT1_2)/2,1-Math.SQRT1_2/2],[(1-Math.SQRT1_2)/2,.5],[(1+Math.SQRT1_2)/2,1-Math.SQRT1_2/2],[1,Math.SQRT1_2],[Math.SQRT1_2,1],[1-Math.SQRT1_2/2,(1+Math.SQRT1_2)/2],[Math.SQRT1_2/2,(1+Math.SQRT1_2)/2],[.5,1],[1,.5],[(1+Math.SQRT1_2)/2,Math.SQRT1_2/2],[.5,(1+Math.SQRT1_2)/2],[(1+Math.SQRT1_2)/2,.5],[1-Math.SQRT1_2,1],[1,1-Math.SQRT1_2]],edges_vertices:[[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[4,7],[4,8],[4,9],[9,10],[10,11],[11,12],[8,13],[13,14],[15,16],[16,7],[3,7],[7,5],[5,17],[17,18],[19,20],[20,5],[5,8],[8,9],[2,15],[14,10],[21,22],[23,24],[10,8],[7,2],[12,14],[0,15],[22,25],[25,5],[5,13],[13,10],[2,16],[16,5],[5,26],[26,23],[6,17],[6,20],[11,14],[14,5],[5,21],[21,27],[28,24],[24,5],[5,15],[15,1],[12,5],[5,0],[20,25],[25,21],[24,26],[26,17],[12,24],[0,21],[12,28],[28,23],[23,18],[18,6],[6,19],[19,22],[22,27],[27,0],[22,20],[17,23]],edges_assignment:Array.from("BBBBFFVVBBBBMMMMFVVFFVVFVVVVVVVVVMMVVMMVVVFVVFFVVFMMMMMMVVBBBBBBBBVV")},{faces:!0}),kite:()=>populate({vertices_coords:[[0,0],[1,0],[1,Math.SQRT2-1],[1,1],[Math.SQRT2-1,1],[0,1]],edges_vertices:[[0,1],[1,2],[2,3],[3,4],[4,5],[5,0],[0,2],[0,4],[0,3]],edges_assignment:Array.from("BBBBBBVVF")},{faces:!0}),squareFish:()=>populate({vertices_coords:[[0,0],[2-Math.SQRT2,0],[1,0],[0,1],[0,2-Math.SQRT2],[.5,.5],[Math.SQRT1_2,Math.SQRT1_2],[1,1],[Math.SQRT1_2,1-Math.SQRT1_2],[1,Math.SQRT2-1],[1-Math.SQRT1_2,Math.SQRT1_2],[Math.SQRT2-1,1],[Math.SQRT1_2,1],[1,Math.SQRT1_2]],edges_vertices:[[0,1],[1,2],[3,4],[4,0],[0,5],[5,6],[6,7],[0,8],[8,9],[0,10],[10,11],[8,1],[10,4],[8,6],[6,12],[3,10],[10,5],[5,8],[8,2],[10,6],[6,13],[7,12],[12,11],[11,3],[11,6],[6,9],[2,9],[9,13],[13,7]],edges_assignment:Array.from("BBBBFFFVFVFMMVVVFFVVVBBBMMBBB")},{faces:!0}),waterbomb:()=>populate({vertices_coords:[[0,0],[.5,0],[1,0],[1,.5],[1,1],[.5,1],[0,1],[0,.5],[.5,.5]],vertices_vertices:[[1,8,7],[2,8,0],[3,8,1],[4,8,2],[5,8,3],[6,8,4],[7,8,5],[0,8,6],[0,1,2,3,4,5,6,7]],edges_vertices:[[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,0],[0,8],[1,8],[2,8],[3,8],[4,8],[5,8],[6,8],[7,8]],edges_assignment:Array.from("BBBBBBBBVFVMVFVM"),faces_vertices:[[0,1,8],[1,2,8],[2,3,8],[3,4,8],[4,5,8],[5,6,8],[6,7,8],[7,0,8]]}),windmill:()=>populate({vertices_coords:[[0,0],[.25,0],[.5,0],[.75,0],[1,0],[0,1],[0,.75],[0,.5],[0,.25],[.25,.25],[.5,.5],[.75,.75],[1,1],[.25,1],[.25,.75],[.25,.5],[1,.25],[.75,.25],[.5,.25],[.5,1],[1,.5],[.5,.75],[.75,.5],[.75,1],[1,.75]],edges_vertices:[[0,1],[1,2],[2,3],[3,4],[5,6],[6,7],[7,8],[8,0],[0,9],[9,10],[10,11],[11,12],[13,14],[14,15],[15,9],[9,1],[16,17],[17,18],[18,9],[9,8],[7,14],[14,19],[20,17],[17,2],[2,9],[9,7],[19,21],[21,10],[10,18],[18,2],[20,22],[22,10],[10,15],[15,7],[4,17],[17,10],[10,14],[14,5],[23,11],[11,22],[22,17],[17,3],[6,14],[14,21],[21,11],[11,24],[12,23],[23,19],[19,13],[13,5],[4,16],[16,20],[20,24],[24,12],[19,11],[11,20]],edges_assignment:Array.from("BBBBBBBBVFFVFVVFFVVFMFMFMFFFFFFFFFVFFVFVVFFVVFBBBBBBBBMF")},{faces:!0})});const makeRectCoords=(e,t)=>[[0,0],[e,0],[e,t],[0,t]],makeGraphWithBoundaryCoords=e=>({vertices_coords:e,edges_vertices:e.map(((e,t,r)=>[t,(t+1)%r.length])),edges_assignment:Array(e.length).fill("B"),faces_vertices:[e.map(((e,t)=>t))],faces_edges:[e.map(((e,t)=>t))]}),polygon=(e=3,t=1)=>populate(makeGraphWithBoundaryCoords(makePolygonCircumradius(e,t)));var Ns=Object.freeze({__proto__:null,circle:(e=1,t=128)=>polygon(t,e),polygon:polygon,rectangle:(e=1,t=1)=>populate(makeGraphWithBoundaryCoords(makeRectCoords(e,t))),square:(e=1)=>populate(makeGraphWithBoundaryCoords(makeRectCoords(e,e)))});const Rs={};Rs.prototype=Object.create(Object.prototype),Rs.prototype.constructor=Rs,Object.entries({clean:clean,populate:populate,subgraph:subgraph,boundary:boundary,boundaries:boundaries$1,planarBoundary:planarBoundary,planarBoundaries:planarBoundaries,boundingBox:boundingBox,invertAssignments:invertAssignments,svg:foldToSvg,obj:foldToObj,...ts,...js,...ws,...Ps,...vs}).forEach((([e,t])=>{Rs.prototype[e]=function(){return t.apply(null,[this,...arguments])}})),Rs.prototype.clone=function(){return Object.assign(Object.create(Object.getPrototypeOf(this)),br(this))},Rs.prototype.planarize=function(){const e=planarize$2(this);return this.clear(),Object.assign(this,e),this},Rs.prototype.clear=function(){return G.graph.forEach((e=>delete this[e])),G.orders.forEach((e=>delete this[e])),delete this.file_frames,this},Rs.prototype.folded=function(){const e=this.faces_matrix2?makeVerticesCoordsFoldedFromMatrix2(this,this.faces_matrix2):makeVerticesCoordsFolded(this,...arguments);return Object.assign(this,{vertices_coords:e,frame_classes:["foldedForm"]}),this},Rs.prototype.flatFolded=function(){const e=this.faces_matrix2?makeVerticesCoordsFoldedFromMatrix2(this,this.faces_matrix2):makeVerticesCoordsFlatFolded(this,...arguments);return Object.assign(this,{vertices_coords:e,frame_classes:["foldedForm"]}),this};var Ls=Rs.prototype;const makeGraphInstance=(...e)=>Object.assign(Object.create(Ls),{...e.reduce(((e,t)=>({...e,...t})),{}),file_spec:1.2,file_creator:I}),Graph=function(){return populate(makeGraphInstance(...arguments))};(Graph.prototype=Ls).constructor=Graph,Object.keys(Ns).forEach((e=>{Graph[e]=(...t)=>makeGraphInstance(Ns[e](...t))})),Object.keys(Bs).forEach((e=>{Graph[e]=(...t)=>makeGraphInstance(Bs[e](...t))}));const Is=Graph,Us={...tt,...Nr,...re,...Rr,...Lr,...Te,...ze,...Ve,...q,...Gr,...Kr,...Ar,...os,...ds,..._s,...gs,...we,...je,...Fe,...es,...Oe,...ie,...Be,...ps,...Ce,...ae,...Os,...xr,...$e,...js,...cs,...us,...$s,...Ae,...ws,...ks,...he,...Or,...Fs,...xs,...Es,...ys,...As,...Ss,...Ms,...Cs,...rs,...Vs,...xe,...Ts,...ke,...ts,...ns,...ms,...is,...qr,...W,...fs,...Ps,...Yr,...zs,...ge,...vs},Ds=Object.assign(Is,Us),convexHullRadialSortPoints=(e,t=p)=>{const r=((e,t=p)=>{if(!e||!e.length)return;const r=((e,t)=>{let r=[0];for(let s=1;s<e.length;s+=1)switch(t(e[r[0]],e[s])){case 0:r.push(s);break;case 1:r=[s]}return r})(e,((e,r)=>epsilonCompare(e[0],r[0],t)));let s=0;for(let t=1;t<r.length;t+=1)e[r[t]][1]<e[r[s]][1]&&(s=t);return r[s]})(e,t);if(void 0===r)return[];const s=e.map((t=>subtract2(t,e[r]))).map((e=>normalize2(e))).map((e=>dot2([0,1],e))),a=s.map(((e,t)=>({a:e,i:t}))).sort(((e,t)=>e.a-t.a)).map((e=>e.i)).filter((e=>e!==r));return[[r]].concat(clusterScalars(a.map((e=>s[e])),t).map((e=>e.map((e=>a[e])))).map((t=>1===t.length?t:t.map((t=>({i:t,len:distance2(e[t],e[r])}))).sort(((e,t)=>e.len-t.len)).map((e=>e.i)))))},convexHull=(e=[],t=!1,r=p)=>{if(e.length<2)return[];const s=convexHullRadialSortPoints(e,r).map((e=>1===e.length?e:(e=>e.concat(e.slice(0,-1).reverse()))(e))).flat();s.push(s[0]);const a=[s[0]];let o=1;const c={"-1":()=>a.pop(),1:e=>{a.push(e),o+=1},undefined:()=>{o+=1}};for(c[0]=t?c[1]:c[-1];o<s.length;){if(a.length<2){a.push(s[o]),o+=1;continue}const t=a[a.length-2],n=a[a.length-1],i=s[o],l=[t,n,i].map((t=>e[t]));c[threePointTurnDirection(l[0],l[1],l[2],r)](i)}return a.pop(),a};const recurseSkeleton=(e,t,r)=>{const s=e.map(((e,t)=>({vector:r[t],origin:e}))).map(((e,t,r)=>intersectLineLine(e,r[(t+1)%r.length],x,x).point)),a=t.map(((e,t)=>nearestPointOnLine(e,s[t]))).map((([e,t])=>[e,t]));if(3===e.length)return e.map((e=>({type:"skeleton",points:[e,s[0]]}))).concat([{type:"perpendicular",points:[a[0],s[0]]}]);const o=s.map(((e,t)=>distance(e,a[t])));let c=0;o.forEach(((e,t)=>{e<o[c]&&(c=t)}));const n=[{type:"skeleton",points:[e[c],s[c]]},{type:"skeleton",points:[e[(c+1)%e.length],s[c]]},{type:"perpendicular",points:[a[c],s[c]]}],i=clockwiseBisect2(flip2(t[(c+t.length-1)%t.length].vector),t[(c+1)%t.length].vector),l=c===e.length-1;return e.splice(c,2,s[c]),t.splice(c,1),r.splice(c,2,i),l&&(e.splice(0,1),r.splice(0,1),t.push(t.shift())),n.concat(recurseSkeleton(e,t,r))};var Qs={...y,...M,...O,...E,...P,...Zr,...Dr,...Qr,...Object.freeze({__proto__:null,convexHull:convexHull,convexHullRadialSortPoints:convexHullRadialSortPoints}),...w,...Se,...ce,..._e,...j,...F,...Object.freeze({__proto__:null,straightSkeleton:e=>{const t=e.map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>({vector:subtract2(e[1],e[0]),origin:e[0]}))),r=e.map(((e,t,r)=>[(t-1+r.length)%r.length,t,(t+1)%r.length].map((e=>r[e])))).map((e=>[subtract2(e[0],e[1]),subtract2(e[2],e[1])])).map((([e,t])=>clockwiseBisect2(e,t)));return recurseSkeleton([...e],t,r)}}),...ls,...Object.freeze({__proto__:null,enclosingBoundingBoxes:(e,t,r=p)=>{const s=Math.min(e.min.length,t.min.length);for(let a=0;a<s;a+=1)if(t.min[a]<e.min[a]-r||t.max[a]>e.max[a]+r)return!1;return!0},pointInBoundingBox:(e,t,r=p)=>{for(let s=0;s<e.length;s+=1)if(e[s]<t.min[s]-r||e[s]>t.max[s]+r)return!1;return!0}}),...$,...C,...B};var Ws=Object.freeze({__proto__:null,foldDegree4:(e,t,r=0)=>{const s=(e=>e.filter((e=>"M"===e)).length>e.filter((e=>"V"===e)).length?e.indexOf("V"):e.indexOf("M"))(t.map((e=>e.toUpperCase())));if(-1===s)return;const a=e[(s+1)%e.length],o=e[(s+2)%e.length],c=Math.max(-Math.PI,Math.min(Math.PI,r)),n=-Math.cos(a)*Math.cos(o)+Math.sin(a)*Math.sin(o)*Math.cos(Math.PI-c),i=Math.cos(Math.PI-c)-Math.sin(Math.PI-c)**2*Math.sin(a)*Math.sin(o)/(1-n),l=-Math.acos(i)+Math.PI;return s%2==0?[l,c,l,c].map(((e,t)=>s===t?-e:e)):[c,l,c,l].map(((e,t)=>s===t?-e:e))}});const alternatingSum=e=>[0,1].map((t=>e.filter(((e,r)=>r%2===t)).reduce(((e,t)=>e+t),0))),kawasakiSolutionsRadians=e=>e.map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((([e,t])=>counterClockwiseAngleRadians(e,t))).map(((e,t,r)=>r.slice(t+1,r.length).concat(r.slice(0,t)))).map((e=>alternatingSum(e).map((e=>Math.PI-e)))).map(((t,r)=>e[r]+t[0])).map(((t,r)=>isCounterClockwiseBetween(t,e[r],e[(r+1)%e.length])?t:void 0)),kawasakiSolutionsVectors=e=>kawasakiSolutionsRadians(e.map((e=>Math.atan2(e[1],e[0])))).map((e=>void 0===e?void 0:[Math.cos(e),Math.sin(e)]));var qs=Object.freeze({__proto__:null,alternatingSum:alternatingSum,alternatingSumDifference:e=>{const t=e.reduce(((e,t)=>e+t),0)/2;return alternatingSum(e).map((e=>e-t))},kawasakiSolutions:({vertices_coords:e,vertices_edges:t,edges_assignment:r,edges_vertices:s},a)=>{t||(t=makeVerticesEdgesUnsorted({edges_vertices:s}));const o=r?t[a].filter((e=>X[r[e]])):t[a];if(o.length%2==0)return[];const c=o.map((e=>s[e][0]===a?s[e]:[s[e][1],s[e][0]])).map((t=>t.map((t=>e[t])))).map((e=>subtract2(e[1],e[0]))),n=counterClockwiseOrder2(c).map((e=>c[e])),i=kawasakiSolutionsVectors(n),l=n.map(normalize2),d=i.filter((e=>void 0!==e)).filter((e=>!l.map((t=>dot2(e,t))).map((e=>Math.abs(1-e)<.001)).reduce(((e,t)=>e||t),!1)));return d},kawasakiSolutionsRadians:kawasakiSolutionsRadians,kawasakiSolutionsVectors:kawasakiSolutionsVectors});const getVerticesWithNoFolds=({vertices_edges:e,edges_assignment:t})=>e.map((e=>e.map((e=>!X[t[e]])).reduce(((e,t)=>e&&t),!0))).map(((e,t)=>e?t:void 0)).filter((e=>void 0!==e)),verticesFlatFoldabilityMaekawa=({edges_vertices:e,vertices_edges:t,edges_assignment:r})=>{t||(t=makeVerticesEdgesUnsorted({edges_vertices:e}));const s=t.map((e=>e.map((e=>Y[r[e]])).filter((e=>0!==e&&void 0!==e)).map(Math.sign).reduce(((e,t)=>e+t),0))).map((e=>Math.abs(e)-2));return boundaryVertices({edges_vertices:e,edges_assignment:r}).forEach((e=>{s[e]=0})),getVerticesWithNoFolds({vertices_edges:t,edges_assignment:r}).forEach((e=>{s[e]=0})),s},verticesFlatFoldabilityKawasaki=({vertices_coords:e,vertices_vertices:t,vertices_edges:r,edges_vertices:s,edges_assignment:a})=>{t||(t=makeVerticesVertices({vertices_coords:e,vertices_edges:r,edges_vertices:s})),r||(r=makeVerticesEdgesUnsorted({edges_vertices:s}));const o=makeVerticesVerticesVector({vertices_coords:e,vertices_vertices:t,edges_vertices:s}).map(((e,t)=>e.filter(((e,s)=>X[a[r[t][s]]])))).map((e=>e.map(resize2))).map((e=>e.length>1?counterClockwiseSectors2(e):[0,0])).map((e=>alternatingSum(e))).map((([e,t])=>e-t));return boundaryVertices({edges_vertices:s,edges_assignment:a}).forEach((e=>{o[e]=0})),getVerticesWithNoFolds({vertices_edges:r,edges_assignment:a}).forEach((e=>{o[e]=0})),o},verticesFlatFoldableMaekawa=e=>verticesFlatFoldabilityMaekawa(e).map((e=>0===e)),verticesFlatFoldableKawasaki=(e,t=p)=>verticesFlatFoldabilityKawasaki(e).map(Math.abs).map((e=>e<t)),verticesFlatFoldability=(e,t)=>{const r=verticesFlatFoldableMaekawa(e).map((e=>e?0:1)),s=verticesFlatFoldableKawasaki(e,t).map((e=>e?0:1));return r.map(((e,t)=>e|s[t]<<1))};const verticesFoldability=({vertices_coords:e,vertices_vertices:t,vertices_edges:r,vertices_faces:s,edges_vertices:a,edges_foldAngle:o,edges_vector:c,faces_vertices:n})=>{t||(t=makeVerticesVertices({vertices_coords:e,vertices_edges:r,vertices_faces:s,edges_vertices:a,faces_vertices:n})),r||(r=makeVerticesEdges({edges_vertices:a,vertices_vertices:t})),s||(s=makeVerticesFaces({vertices_coords:e,vertices_vertices:t,faces_vertices:n}));const i=makeVerticesVerticesVector({vertices_coords:e,vertices_vertices:t,vertices_edges:r,vertices_faces:s,edges_vertices:a,edges_vector:c,faces_vertices:n});return e.map(((e,t)=>{if(s[t].includes(void 0)||s[t].includes(null))return 0;const a=i[t].map((e=>Math.atan2(e[1],e[0]))),c=r[t].map((e=>o[e])).map((e=>e*h)),n=a.map((e=>makeMatrix3RotateZ(e))),l=n.map((e=>invertMatrix3(e))),d=c.map((e=>makeMatrix3RotateX(e))),_=i[t].map(((e,t)=>multiplyMatrices3(n[t],multiplyMatrices3(d[t],l[t]))));let m=[...Jr];return _.forEach((e=>{m=multiplyMatrices3(m,e)})),Array.from(Array(9)).map(((e,t)=>Math.abs(m[t]-Jr[t]))).reduce(((e,t)=>e+t),0)}))};var Gs={...Ws,...Object.freeze({__proto__:null,verticesFlatFoldability:verticesFlatFoldability,verticesFlatFoldabilityKawasaki:verticesFlatFoldabilityKawasaki,verticesFlatFoldabilityMaekawa:verticesFlatFoldabilityMaekawa,verticesFlatFoldable:(e,t)=>verticesFlatFoldability(e,t).map((e=>0===e)),verticesFlatFoldableKawasaki:verticesFlatFoldableKawasaki,verticesFlatFoldableMaekawa:verticesFlatFoldableMaekawa}),...Object.freeze({__proto__:null,verticesFoldability:verticesFoldability,verticesFoldable:(e,t=p)=>verticesFoldability(e).map((e=>Math.abs(e)<t))}),...qs,...Object.freeze({__proto__:null,maekawaSolver:e=>{const t=(r=e).map(((e,t)=>t)).filter((e=>"U"===r[e]||"u"===r[e]));var r;const s=Array.from(Array(2**t.length)).map(((e,t)=>t.toString(2))).map((e=>Array(t.length-e.length+1).join("0")+e)).map((e=>Array.from(e).map((e=>"0"===e?"V":"M")))).map((r=>{const s=e.slice();return t.forEach(((e,t)=>{s[e]=r[t]})),s}));if(e.filter((e=>K[e])).length>0)return s;const a=s.map((e=>e.filter((e=>"M"===e||"m"===e)).length)),o=s.map((e=>e.filter((e=>"V"===e||"v"===e)).length));return s.filter(((e,t)=>2===Math.abs(a[t]-o[t])))}})};const Hs={B:[.5,.5,.5],b:[.5,.5,.5],V:[.2,.4,.6],v:[.2,.4,.6],M:[.75,.25,.15],m:[.75,.25,.15],F:[.3,.3,.3],f:[.3,.3,.3],J:[.3,.2,0],j:[.3,.2,0],C:[.5,.8,.1],c:[.5,.8,.1],U:[.6,.25,.9],u:[.6,.25,.9]},Js={B:[0,0,0],b:[0,0,0],V:[.2,.5,.8],v:[.2,.5,.8],M:[.75,.25,.15],m:[.75,.25,.15],F:[.75,.75,.75],f:[.75,.75,.75],J:[1,.75,.25],j:[1,.75,.25],C:[.5,.8,.1],c:[.5,.8,.1],U:[.6,.25,.9],u:[.6,.25,.9]},parseColorToWebGLColor=e=>{if("string"==typeof e){const[t,r,s]=parseColorToRgb(e).slice(0,3).map((e=>e/255));return[t,r,s]}if(e&&e.constructor===Array){const[t,r,s]=e;return[t,r,s]}};var Zs=Object.freeze({__proto__:null,dark:Hs,light:Js,parseColorToWebGLColor:parseColorToWebGLColor});var Ys=Object.freeze({__proto__:null,deallocModel:(e,t)=>{t.vertexArrays.forEach((t=>e.disableVertexAttribArray(t.location))),t.vertexArrays.forEach((t=>e.deleteBuffer(t.buffer))),t.elementArrays.forEach((t=>e.deleteBuffer(t.buffer))),e.deleteProgram(t.program)},drawModel:(e,t,r,s={})=>{e.useProgram(r.program),r.flags.forEach((t=>e.enable(t)));const a=e.getProgramParameter(r.program,e.ACTIVE_UNIFORMS);for(let t=0;t<a;t+=1){const a=e.getActiveUniform(r.program,t).name;if(!s[a])continue;const{func:o,value:c}=s[a],n=e.getUniformLocation(r.program,a);switch(o){case"uniformMatrix2fv":case"uniformMatrix3fv":case"uniformMatrix4fv":e[o](n,!1,c);break;default:e[o](n,c)}}r.vertexArrays.forEach((t=>{e.bindBuffer(e.ARRAY_BUFFER,t.buffer),e.bufferData(e.ARRAY_BUFFER,t.data,e.STATIC_DRAW),e.vertexAttribPointer(t.location,t.length,t.type,!1,0,0),e.enableVertexAttribArray(t.location)})),r.elementArrays.forEach((r=>{e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,r.buffer),e.bufferData(e.ELEMENT_ARRAY_BUFFER,r.data,e.STATIC_DRAW),e.drawElements(r.mode,r.data.length,2===t?e.UNSIGNED_INT:e.UNSIGNED_SHORT,0)})),r.flags.forEach((t=>e.disable(t)))}});var Xs=Object.freeze({__proto__:null,makeModelMatrix:e=>{if(!e)return[...Ir];const t=boundingBox(e);if(!t)return[...Ir];const r=Math.max(...t.span);if(0===r)return[...Ir];const s=[r,0,0,0,0,r,0,0,0,0,r,0,...resize(3,midpoint(t.min,t.max)),1];return invertMatrix4(s)||[...Ir]},makeProjectionMatrix:([e,t],r="perspective",s=45)=>{const a=Math.min(e,t),o=[(e-a)/a/2,(t-a)/a/2].map((e=>e+.5));return"orthographic"===r?makeOrthographicMatrix4(o[1],o[0],-o[1],-o[0],-100,100):makePerspectiveMatrix4(s*(Math.PI/180),e/t,.1,20)},rebuildViewport:(e,t)=>{if(!e)return;const r=window.devicePixelRatio||1,s=[t.clientWidth,t.clientHeight].map((e=>e*r));t.width===s[0]&&t.height===s[1]||(t.width=s[0],t.height=s[1]),e.viewport(0,0,e.canvas.width,e.canvas.height)}});const compileShader=(e,t,r)=>{const s=e.createShader(r);if(e.shaderSource(s,t),e.compileShader(s),!e.getShaderParameter(s,e.COMPILE_STATUS))throw new Error(e.getShaderInfoLog(s));return s},createProgram=(e,t,r)=>((e,t,r)=>{const s=e.createProgram();if(e.attachShader(s,t),e.attachShader(s,r),e.linkProgram(s),!e.getProgramParameter(s,e.LINK_STATUS))throw new Error(e.getProgramInfoLog(s));return e.deleteShader(t),e.deleteShader(r),s})(e,compileShader(e,t,e.VERTEX_SHADER),compileShader(e,r,e.FRAGMENT_SHADER));var Ks={...Zs,...Ys,...Xs,...Object.freeze({__proto__:null,createProgram:createProgram,initializeWebGL:(e,t)=>{const r=RabbitEarWindow$1().devicePixelRatio||1;switch(e.width=e.clientWidth*r,e.height=e.clientHeight*r,t){case 1:return{gl:e.getContext("webgl"),version:1};case 2:return{gl:e.getContext("webgl2"),version:2}}const s=e.getContext("webgl2");if(s)return{gl:s,version:2};const a=e.getContext("webgl");if(a)return{gl:a,version:1};throw new Error(i)}})};const makeFacesVertexData=({vertices_coords:e,edges_assignment:t,faces_vertices:r,faces_edges:s,faces_normal:a},o={})=>{const c=e.map((e=>[...e].concat(Array(3-e.length).fill(0)))).map(resize3),n=makeVerticesNormal({vertices_coords:c,faces_vertices:r,faces_normal:a}),i=c.map(((e,t)=>t%3)).map((e=>[0===e?1:0,1===e?1:0,2===e?1:0])),l=(({edges_assignment:e,faces_vertices:t,faces_edges:r})=>r&&e?r.map((t=>t.map((t=>e[t])).map((e=>"J"===e||"j"===e)))):t?t.map((e=>e.map((()=>!1)))):[])({edges_assignment:t,faces_vertices:r,faces_edges:s});if(!o.showTriangulation)for(let e=0;e<l.length;e+=1)l[e][0]&&(i[3*e+0][2]=i[3*e+1][2]=100),l[e][1]&&(i[3*e+1][0]=i[3*e+2][0]=100),l[e][2]&&(i[3*e+0][1]=i[3*e+2][1]=100);return{vertices_coords:c,vertices_normal:n,vertices_barycentric:i}},makeThickEdgesVertexData=(e,t)=>{if(!e||!e.vertices_coords||!e.edges_vertices)return;const r={...t&&t.dark?Hs:Js,...t},s=e.vertices_coords.map((e=>[...e].concat(Array(3-e.length).fill(0)))),a=e.edges_vertices.flatMap((e=>e.map((e=>s[e])))).flatMap((e=>[e,e,e,e])),o=makeEdgesVector(e);return{vertices_coords:a,vertices_color:e.edges_assignment?e.edges_assignment.flatMap((e=>Array(8).fill(r[e]))):e.edges_vertices.flatMap((()=>Array(8).fill(r.U))),verticesEdgesVector:o.flatMap((e=>[e,e,e,e,e,e,e,e])),vertices_vector:e.edges_vertices.flatMap((()=>[[1,0],[0,1],[-1,0],[0,-1],[1,0],[0,1],[-1,0],[0,-1]]))}};var ea=Object.freeze({__proto__:null,makeFacesVertexData:makeFacesVertexData,makeThickEdgesVertexData:makeThickEdgesVertexData});const makeFoldedVertexArrays=(e,t,{vertices_coords:r,edges_vertices:s,edges_assignment:a,faces_vertices:o,faces_edges:c,faces_normal:n}={},i={})=>{if(!r||!o)return[];!c&&s&&o&&(c=makeFacesEdgesFromVertices({edges_vertices:s,faces_vertices:o}));const{vertices_coords:l,vertices_normal:d,vertices_barycentric:_}=makeFacesVertexData({vertices_coords:r,edges_assignment:a,faces_vertices:o,faces_edges:c,faces_normal:n},i);return[{location:e.getAttribLocation(t,"v_position"),buffer:e.createBuffer(),type:e.FLOAT,length:l.length?l[0].length:3,data:new Float32Array(l.flat())},{location:e.getAttribLocation(t,"v_normal"),buffer:e.createBuffer(),type:e.FLOAT,length:d.length?d[0].length:3,data:new Float32Array(d.flat())},{location:e.getAttribLocation(t,"v_barycentric"),buffer:e.createBuffer(),type:e.FLOAT,length:3,data:new Float32Array(_.flat())}].filter((e=>-1!==e.location))},makeFoldedElementArrays=(e,t=1,r={})=>r&&r.vertices_coords&&r.faces_vertices?[{mode:e.TRIANGLES,buffer:e.createBuffer(),data:2===t?new Uint32Array(r.faces_vertices.flat()):new Uint16Array(r.faces_vertices.flat())}]:[],makeThickEdgesVertexArrays=(e,t,r,s={})=>{if(!r||!r.vertices_coords||!r.edges_vertices)return[];const{vertices_coords:a,vertices_color:o,verticesEdgesVector:c,vertices_vector:n}=makeThickEdgesVertexData(r,s.assignment_color);return a?[{location:e.getAttribLocation(t,"v_position"),buffer:e.createBuffer(),type:e.FLOAT,length:a.length?a[0].length:3,data:new Float32Array(a.flat())},{location:e.getAttribLocation(t,"v_color"),buffer:e.createBuffer(),type:e.FLOAT,length:o.length?o[0].length:3,data:new Float32Array(o.flat())},{location:e.getAttribLocation(t,"edge_vector"),buffer:e.createBuffer(),type:e.FLOAT,length:c.length?c[0].length:3,data:new Float32Array(c.flat())},{location:e.getAttribLocation(t,"vertex_vector"),buffer:e.createBuffer(),type:e.FLOAT,length:n.length?n[0].length:3,data:new Float32Array(n.flat())}].filter((e=>-1!==e.location)):[]},makeThickEdgesElementArrays=(e,t=1,r={})=>{if(!r||!r.edges_vertices)return[];const s=r.edges_vertices.map(((e,t)=>8*t)).flatMap((e=>[e+0,e+1,e+4,e+4,e+1,e+5,e+1,e+2,e+5,e+5,e+2,e+6,e+2,e+3,e+6,e+6,e+3,e+7,e+3,e+0,e+7,e+7,e+0,e+4]));return[{mode:e.TRIANGLES,buffer:e.createBuffer(),data:2===t?new Uint32Array(s):new Uint16Array(s)}]};var ta=Object.freeze({__proto__:null,makeFoldedElementArrays:makeFoldedElementArrays,makeFoldedVertexArrays:makeFoldedVertexArrays,makeThickEdgesElementArrays:makeThickEdgesElementArrays,makeThickEdgesVertexArrays:makeThickEdgesVertexArrays});const makeUniforms$1=({projectionMatrix:e,modelViewMatrix:t,frontColor:r,backColor:s,outlineColor:a,strokeWidth:o,opacity:c})=>({u_matrix:{func:"uniformMatrix4fv",value:multiplyMatrices4(e||Ir,t||Ir)},u_projection:{func:"uniformMatrix4fv",value:e||Ir},u_modelView:{func:"uniformMatrix4fv",value:t||Ir},u_frontColor:{func:"uniform3fv",value:parseColorToWebGLColor(r||"gray")},u_backColor:{func:"uniform3fv",value:parseColorToWebGLColor(s||"white")},u_outlineColor:{func:"uniform3fv",value:parseColorToWebGLColor(a||"black")},u_strokeWidth:{func:"uniform1f",value:void 0!==o?o:.05},u_opacity:{func:"uniform1f",value:void 0!==c?c:1}});var ra=Object.freeze({__proto__:null,makeUniforms:makeUniforms$1});const sa="#version 300 es\nuniform mat4 u_modelView;\nuniform mat4 u_matrix;\nuniform vec3 u_frontColor;\nuniform vec3 u_backColor;\nin vec3 v_position;\nin vec3 v_normal;\nout vec3 front_color;\nout vec3 back_color;\nvoid main () {\n\tgl_Position = u_matrix * vec4(v_position, 1);\n\tvec3 light = abs(normalize((vec4(v_normal, 1) * u_modelView).xyz));\n\tfloat brightness = 0.5 + light.x * 0.15 + light.z * 0.35;\n\tfront_color = u_frontColor * brightness;\n\tback_color = u_backColor * brightness;\n}\n",aa="#version 300 es\nuniform mat4 u_matrix;\nuniform mat4 u_projection;\nuniform mat4 u_modelView;\nuniform float u_strokeWidth;\nin vec3 v_position;\nin vec3 v_color;\nin vec3 edge_vector;\nin vec2 vertex_vector;\nout vec3 blend_color;\nvoid main () {\n\tvec3 edge_norm = normalize(edge_vector);\n\t// axis most dissimilar to edge_vector\n\tvec3 absNorm = abs(edge_norm);\n\tvec3 xory = absNorm.x < absNorm.y ? vec3(1,0,0) : vec3(0,1,0);\n\tvec3 axis = absNorm.x > absNorm.z && absNorm.y > absNorm.z ? vec3(0,0,1) : xory;\n\t// two perpendiculars. with edge_vector these make basis vectors\n\tvec3 one = cross(axis, edge_norm);\n\tvec3 two = cross(one, edge_norm);\n\tvec3 displaceNormal = normalize(\n\t\tone * vertex_vector.x + two * vertex_vector.y\n\t);\n\tvec3 displace = displaceNormal * (u_strokeWidth * 0.5);\n\tgl_Position = u_matrix * vec4(v_position + displace, 1);\n\tblend_color = v_color;\n}\n",oa="#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\nuniform float u_opacity;\nin vec3 front_color;\nin vec3 back_color;\nin vec3 outline_color;\nin vec3 barycentric;\nout vec4 outColor;\nfloat edgeFactor(vec3 barycenter) {\n\tvec3 d = fwidth(barycenter);\n\tvec3 a3 = smoothstep(vec3(0.0), d*3.5, barycenter);\n\treturn min(min(a3.x, a3.y), a3.z);\n}\nvoid main () {\n\tgl_FragDepth = gl_FragCoord.z;\n\tvec3 color = gl_FrontFacing ? front_color : back_color;\n\t// vec4 color4 = gl_FrontFacing\n\t// \t? vec4(front_color, u_opacity)\n\t// \t: vec4(back_color, u_opacity);\n\t// vec4 outline4 = vec4(outline_color, 1);\n\t// outColor = vec4(mix(vec3(0.0), color, edgeFactor(barycentric)), u_opacity);\n\toutColor = vec4(mix(outline_color, color, edgeFactor(barycentric)), u_opacity);\n\t// outColor = mix(outline4, color4, edgeFactor(barycentric));\n}\n",ca="#version 100\nprecision mediump float;\nuniform float u_opacity;\nvarying vec3 barycentric;\nvarying vec3 front_color;\nvarying vec3 back_color;\nvarying vec3 outline_color;\nvoid main () {\n\tvec3 color = gl_FrontFacing ? front_color : back_color;\n\t// vec3 boundary = vec3(0.0, 0.0, 0.0);\n\tvec3 boundary = outline_color;\n\t// gl_FragDepth = 0.5;\n\tgl_FragColor = any(lessThan(barycentric, vec3(0.02)))\n\t\t? vec4(boundary, u_opacity)\n\t\t: vec4(color, u_opacity);\n}\n",na="#version 100\nattribute vec3 v_position;\nattribute vec3 v_normal;\nuniform mat4 u_projection;\nuniform mat4 u_modelView;\nuniform mat4 u_matrix;\nuniform vec3 u_frontColor;\nuniform vec3 u_backColor;\nvarying vec3 normal_color;\nvarying vec3 front_color;\nvarying vec3 back_color;\nvoid main () {\n\tgl_Position = u_matrix * vec4(v_position, 1);\n\tvec3 light = abs(normalize((vec4(v_normal, 1) * u_modelView).xyz));\n\tfloat brightness = 0.5 + light.x * 0.15 + light.z * 0.35;\n\tfront_color = u_frontColor * brightness;\n\tback_color = u_backColor * brightness;\n}\n",ia="#version 100\nattribute vec3 v_position;\nattribute vec3 v_color;\nattribute vec3 edge_vector;\nattribute vec2 vertex_vector;\nuniform mat4 u_matrix;\nuniform mat4 u_projection;\nuniform mat4 u_modelView;\nuniform float u_strokeWidth;\nvarying vec3 blend_color;\nvoid main () {\n\tvec3 edge_norm = normalize(edge_vector);\n\t// axis most dissimilar to edge_vector\n\tvec3 absNorm = abs(edge_norm);\n\tvec3 xory = absNorm.x < absNorm.y ? vec3(1,0,0) : vec3(0,1,0);\n\tvec3 axis = absNorm.x > absNorm.z && absNorm.y > absNorm.z ? vec3(0,0,1) : xory;\n\t// two perpendiculars. with edge_vector these make basis vectors\n\tvec3 one = cross(axis, edge_norm);\n\tvec3 two = cross(one, edge_norm);\n\tvec3 displaceNormal = normalize(\n\t\tone * vertex_vector.x + two * vertex_vector.y\n\t);\n\tvec3 displace = displaceNormal * (u_strokeWidth * 0.5);\n\tgl_Position = u_matrix * vec4(v_position + displace, 1);\n\tblend_color = v_color;\n}\n",la="#version 100\nprecision mediump float;\nuniform float u_opacity;\nvarying vec3 front_color;\nvarying vec3 back_color;\nvoid main () {\n\tvec3 color = gl_FrontFacing ? front_color : back_color;\n\tgl_FragColor = vec4(color, u_opacity);\n}\n",fa="#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\nin vec3 blend_color;\nout vec4 outColor;\n \nvoid main() {\n\toutColor = vec4(blend_color.rgb, 1);\n}\n",da="#version 100\nattribute vec3 v_position;\nattribute vec3 v_normal;\nattribute vec3 v_barycentric;\nuniform mat4 u_projection;\nuniform mat4 u_modelView;\nuniform mat4 u_matrix;\nuniform vec3 u_frontColor;\nuniform vec3 u_backColor;\nuniform vec3 u_outlineColor;\nvarying vec3 normal_color;\nvarying vec3 barycentric;\nvarying vec3 front_color;\nvarying vec3 back_color;\nvarying vec3 outline_color;\nvoid main () {\n\tgl_Position = u_matrix * vec4(v_position, 1);\n\tbarycentric = v_barycentric;\n\tvec3 light = abs(normalize((vec4(v_normal, 1) * u_modelView).xyz));\n\tfloat brightness = 0.5 + light.x * 0.15 + light.z * 0.35;\n\tfront_color = u_frontColor * brightness;\n\tback_color = u_backColor * brightness;\n\toutline_color = u_outlineColor;\n}\n",_a="#version 300 es\nuniform mat4 u_modelView;\nuniform mat4 u_matrix;\nuniform vec3 u_frontColor;\nuniform vec3 u_backColor;\nuniform vec3 u_outlineColor;\nin vec3 v_position;\nin vec3 v_normal;\nin vec3 v_barycentric;\nin float v_rawEdge;\nout vec3 front_color;\nout vec3 back_color;\nout vec3 outline_color;\nout vec3 barycentric;\n// flat out int rawEdge;\nflat out int provokedVertex;\nvoid main () {\n\tgl_Position = u_matrix * vec4(v_position, 1);\n\tprovokedVertex = gl_VertexID;\n\tbarycentric = v_barycentric;\n\t// rawEdge = int(v_rawEdge);\n\tvec3 light = abs(normalize((vec4(v_normal, 1) * u_modelView).xyz));\n\tfloat brightness = 0.5 + light.x * 0.15 + light.z * 0.35;\n\tfront_color = u_frontColor * brightness;\n\tback_color = u_backColor * brightness;\n\toutline_color = u_outlineColor;\n}\n",ma="#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\nuniform float u_opacity;\nin vec3 front_color;\nin vec3 back_color;\nout vec4 outColor;\nvoid main () {\n\tgl_FragDepth = gl_FragCoord.z;\n\tvec3 color = gl_FrontFacing ? front_color : back_color;\n\toutColor = vec4(color, u_opacity);\n}\n",ga="#version 100\nprecision mediump float;\nvarying vec3 blend_color;\nvoid main () {\n\tgl_FragColor = vec4(blend_color.rgb, 1);\n}\n";var va=Object.freeze({__proto__:null,model_100_frag:la,model_100_vert:na,model_300_frag:ma,model_300_vert:sa,outlined_model_100_frag:ca,outlined_model_100_vert:da,outlined_model_300_frag:oa,outlined_model_300_vert:_a,simple_100_frag:ga,simple_300_frag:fa,thick_edges_100_vert:ia,thick_edges_300_vert:aa});const foldedFormFaces=(e,t=1,r={},s={})=>{const a=prepareForRendering(r,s),o=1===t?createProgram(e,na,la):createProgram(e,sa,ma);return{program:o,vertexArrays:makeFoldedVertexArrays(e,o,a,s),elementArrays:makeFoldedElementArrays(e,t,a),flags:[e.DEPTH_TEST],makeUniforms:makeUniforms$1}},foldedFormFacesOutlined=(e,t=1,r={},s={})=>{const a=prepareForRendering(r,s),o=1===t?createProgram(e,da,ca):createProgram(e,_a,oa);return{program:o,vertexArrays:makeFoldedVertexArrays(e,o,a,s),elementArrays:makeFoldedElementArrays(e,t,a),flags:[e.DEPTH_TEST],makeUniforms:makeUniforms$1}},foldedFormEdges=(e,t=1,r={},s={})=>{const a=1===t?createProgram(e,ia,ga):createProgram(e,aa,fa);return{program:a,vertexArrays:makeThickEdgesVertexArrays(e,a,r,s),elementArrays:makeThickEdgesElementArrays(e,t,r),flags:[e.DEPTH_TEST],makeUniforms:makeUniforms$1}};var pa={...ta,...ea,...Object.freeze({__proto__:null,foldedForm:(e,t=1,r={},s={})=>{const a=[];return!1!==s.faces&&(!1===s.outlines?a.push(foldedFormFaces(e,t,r,s)):a.push(foldedFormFacesOutlined(e,t,r,s))),!0===s.edges&&a.push(foldedFormEdges(e,t,r,s)),a},foldedFormEdges:foldedFormEdges,foldedFormFaces:foldedFormFaces,foldedFormFacesOutlined:foldedFormFacesOutlined}),...va,...ra};const make2D=e=>e.map((e=>[0,1].map((t=>e[t]||0)))),makeCPEdgesVertexData=(e,t)=>{if(!e||!e.vertices_coords||!e.edges_vertices)return;const r={...t&&t.dark?Hs:Js,...t},s=make2D(e.edges_vertices.flatMap((t=>t.map((t=>e.vertices_coords[t])))).flatMap((e=>[e,e]))),a=make2D(makeEdgesVector(e));return{vertices_coords:s,vertices_color:e.edges_assignment?e.edges_assignment.flatMap((e=>[r[e],r[e],r[e],r[e]])):e.edges_vertices.flatMap((()=>[r.U,r.U,r.U,r.U])),verticesEdgesVector:a.flatMap((e=>[e,e,e,e])),vertices_vector:e.edges_vertices.flatMap((()=>[[1,0],[-1,0],[-1,0],[1,0]]))}};var ua=Object.freeze({__proto__:null,makeCPEdgesVertexData:makeCPEdgesVertexData});const makeCPEdgesVertexArrays=(e,t,r,s)=>{if(!r||!r.vertices_coords||!r.edges_vertices)return[];const{vertices_coords:a,vertices_color:o,verticesEdgesVector:c,vertices_vector:n}=makeCPEdgesVertexData(r,s);return a?[{location:e.getAttribLocation(t,"v_position"),buffer:e.createBuffer(),type:e.FLOAT,length:2,data:new Float32Array(a.flat())},{location:e.getAttribLocation(t,"v_color"),buffer:e.createBuffer(),type:e.FLOAT,length:o.length?o[0].length:2,data:new Float32Array(o.flat())},{location:e.getAttribLocation(t,"edge_vector"),buffer:e.createBuffer(),type:e.FLOAT,length:c.length?c[0].length:2,data:new Float32Array(c.flat())},{location:e.getAttribLocation(t,"vertex_vector"),buffer:e.createBuffer(),type:e.FLOAT,length:n.length?n[0].length:2,data:new Float32Array(n.flat())}].filter((e=>-1!==e.location)):[]},makeCPEdgesElementArrays=(e,t=1,r={})=>{if(!r||!r.edges_vertices)return[];const s=r.edges_vertices.map(((e,t)=>4*t)).flatMap((e=>[e+0,e+1,e+2,e+2,e+3,e+0]));return[{mode:e.TRIANGLES,buffer:e.createBuffer(),data:2===t?new Uint32Array(s):new Uint16Array(s)}]},makeCPFacesVertexArrays=(e,t,r)=>r&&r.vertices_coords?[{location:e.getAttribLocation(t,"v_position"),buffer:e.createBuffer(),type:e.FLOAT,length:2,data:new Float32Array(r.vertices_coords.flatMap(resize2))}].filter((e=>-1!==e.location)):[],makeCPFacesElementArrays=(e,t=1,r={})=>r&&r.vertices_coords&&r.faces_vertices?[{mode:e.TRIANGLES,buffer:e.createBuffer(),data:2===t?new Uint32Array(triangulateConvexFacesVertices(r).flat()):new Uint16Array(triangulateConvexFacesVertices(r).flat())}]:[];var ha=Object.freeze({__proto__:null,makeCPEdgesElementArrays:makeCPEdgesElementArrays,makeCPEdgesVertexArrays:makeCPEdgesVertexArrays,makeCPFacesElementArrays:makeCPFacesElementArrays,makeCPFacesVertexArrays:makeCPFacesVertexArrays});const makeUniforms=({projectionMatrix:e,modelViewMatrix:t,cpColor:r,strokeWidth:s})=>({u_matrix:{func:"uniformMatrix4fv",value:multiplyMatrices4(e||Ir,t||Ir)},u_projection:{func:"uniformMatrix4fv",value:e||Ir},u_modelView:{func:"uniformMatrix4fv",value:t||Ir},u_cpColor:{func:"uniform3fv",value:parseColorToWebGLColor(r||"white")},u_strokeWidth:{func:"uniform1f",value:s||.05}});var ba=Object.freeze({__proto__:null,makeUniforms:makeUniforms});const ya="#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\nin vec3 blend_color;\nout vec4 outColor;\nvoid main() {\n\toutColor = vec4(blend_color.rgb, 1);\n}\n",Ea="#version 100\nprecision mediump float;\nvarying vec3 blend_color;\nvoid main () {\n\tgl_FragColor = vec4(blend_color.rgb, 1);\n}\n",Ma="#version 300 es\nuniform mat4 u_matrix;\nuniform float u_strokeWidth;\nin vec2 v_position;\nin vec3 v_color;\nin vec2 edge_vector;\nin vec2 vertex_vector;\nout vec3 blend_color;\nvoid main () {\n\tfloat sign = vertex_vector[0];\n\tfloat halfWidth = u_strokeWidth * 0.5;\n\tvec2 side = normalize(vec2(edge_vector.y * sign, -edge_vector.x * sign)) * halfWidth;\n\tgl_Position = u_matrix * vec4(side + v_position, 0, 1);\n\tblend_color = v_color;\n}\n",Aa="#version 100\nuniform mat4 u_matrix;\nuniform float u_strokeWidth;\nattribute vec2 v_position;\nattribute vec3 v_color;\nattribute vec2 edge_vector;\nattribute vec2 vertex_vector;\nvarying vec3 blend_color;\nvoid main () {\n\tfloat sign = vertex_vector[0];\n\tfloat halfWidth = u_strokeWidth * 0.5;\n\tvec2 side = normalize(vec2(edge_vector.y * sign, -edge_vector.x * sign)) * halfWidth;\n\tgl_Position = u_matrix * vec4(side + v_position, 0, 1);\n\tblend_color = v_color;\n}\n",xa="#version 100\nuniform mat4 u_matrix;\nuniform vec3 u_cpColor;\nattribute vec2 v_position;\nvarying vec3 blend_color;\nvoid main () {\n\tgl_Position = u_matrix * vec4(v_position, 0, 1);\n\tblend_color = u_cpColor;\n}\n",Oa="#version 300 es\nuniform mat4 u_matrix;\nuniform vec3 u_cpColor;\nin vec2 v_position;\nout vec3 blend_color;\nvoid main () {\n\tgl_Position = u_matrix * vec4(v_position, 0, 1);\n\tblend_color = u_cpColor;\n}\n";var ja=Object.freeze({__proto__:null,cp_100_frag:Ea,cp_100_vert:xa,cp_300_frag:ya,cp_300_vert:Oa,thick_edges_100_vert:Aa,thick_edges_300_vert:Ma});const cpFacesV1=(e,t={},r=void 0)=>{const s=createProgram(e,xa,Ea);return{program:s,vertexArrays:makeCPFacesVertexArrays(e,s,t),elementArrays:makeCPFacesElementArrays(e,1,t),flags:[],makeUniforms:makeUniforms}},cpEdgesV1=(e,t={},r=void 0)=>{const s=createProgram(e,Aa,Ea);return{program:s,vertexArrays:makeCPEdgesVertexArrays(e,s,t,r),elementArrays:makeCPEdgesElementArrays(e,1,t),flags:[],makeUniforms:makeUniforms}},cpFacesV2=(e,t={},r=void 0)=>{const s=createProgram(e,Oa,ya);return{program:s,vertexArrays:makeCPFacesVertexArrays(e,s,t),elementArrays:makeCPFacesElementArrays(e,2,t),flags:[],makeUniforms:makeUniforms}},cpEdgesV2=(e,t={},r=void 0)=>{const s=createProgram(e,Ma,ya);return{program:s,vertexArrays:makeCPEdgesVertexArrays(e,s,t,r),elementArrays:makeCPEdgesElementArrays(e,2,t),flags:[],makeUniforms:makeUniforms}};var wa={...Ks,...pa,...{...ha,...ua,...Object.freeze({__proto__:null,cpEdgesV1:cpEdgesV1,cpEdgesV2:cpEdgesV2,cpFacesV1:cpFacesV1,cpFacesV2:cpFacesV2,creasePattern:(e,t=1,r={},s=void 0)=>1===t?[cpFacesV1(e,r,s),cpEdgesV1(e,r,s)]:[cpFacesV2(e,r,s),cpEdgesV2(e,r,s)]}),...ja,...ba}};const constraints3DFaceClusters=({vertices_coords:e,edges_vertices:t,edges_faces:r,edges_assignment:s,edges_foldAngle:a,faces_vertices:o,faces_edges:c,faces_faces:n},i=p)=>{const{planes_transform:l,faces_winding:d,faces_plane:_,faces_cluster:m,clusters_plane:g,clusters_faces:v}=getCoplanarAdjacentOverlappingFaces({vertices_coords:e,faces_vertices:o,faces_faces:n},i),u=g.map((e=>l[e])),h=v.map((i=>subgraphWithFaces({vertices_coords:e,edges_vertices:t,edges_faces:r,edges_assignment:s,edges_foldAngle:a,faces_vertices:o,faces_edges:c,faces_faces:n},i))),b=e.map(resize3);h.forEach((({vertices_coords:e},t)=>{h[t].vertices_coords=e.map(((e,r)=>multiplyMatrix4Vector3(u[t],b[r]))).map((([e,t])=>[e,t]))}));const y=mergeArraysWithHoles(...h.map((e=>makeFacesPolygon(e,i)))),E=y.map((e=>average2(...e)));h.forEach((({faces_vertices:e},t)=>{h[t].faces_center=e.map(((e,t)=>E[t]))})),d.map(((e,t)=>e?void 0:t)).filter((e=>void 0!==e)).forEach((e=>y[e].reverse()));const M=mergeArraysWithHoles(...h.map((e=>getFacesFacesOverlap(e,i)))),A=connectedComponentsPairs(M).map((e=>e.join(" ")));return{planes_transform:l,faces_plane:_,faces_cluster:m,faces_winding:d,faces_polygon:y,faces_center:E,clusters_faces:v,clusters_graph:h,clusters_transform:u,facesFacesOverlap:M,facePairs:A}};var ka=Object.freeze({__proto__:null,constraints3DFaceClusters:constraints3DFaceClusters});const Fa=["taco_taco","taco_tortilla","tortilla_tortilla","transitivity"],emptyCategoryObject=()=>({taco_taco:void 0,taco_tortilla:void 0,tortilla_tortilla:void 0,transitivity:void 0}),Sa={taco_taco:e=>[[e[0],e[2]],[e[1],e[3]],[e[1],e[2]],[e[0],e[3]],[e[0],e[1]],[e[2],e[3]]],taco_tortilla:e=>[[e[0],e[2]],[e[0],e[1]],[e[1],e[2]]],tortilla_tortilla:e=>[[e[0],e[2]],[e[1],e[3]]],transitivity:e=>[[e[0],e[1]],[e[1],e[2]],[e[2],e[0]]]},sortedPairString=e=>e[0]<e[1]?`${e[0]} ${e[1]}`:`${e[1]} ${e[0]}`,Ca={taco_taco:e=>[sortedPairString([e[0],e[2]]),sortedPairString([e[1],e[3]]),sortedPairString([e[1],e[2]]),sortedPairString([e[0],e[3]]),sortedPairString([e[0],e[1]]),sortedPairString([e[2],e[3]])],taco_tortilla:e=>[sortedPairString([e[0],e[2]]),sortedPairString([e[0],e[1]]),sortedPairString([e[1],e[2]])],tortilla_tortilla:e=>[sortedPairString([e[0],e[2]]),sortedPairString([e[1],e[3]])],transitivity:e=>[sortedPairString([e[0],e[1]]),sortedPairString([e[1],e[2]]),sortedPairString([e[2],e[0]])]},Va={0:0,1:1,2:-1},solverSolutionToFaceOrders=(e,t)=>{const r=Object.keys(e),s=r.map((e=>e.split(" ").map((e=>parseInt(e,10))))),a=s.map(((s,a)=>{const o=Va[e[r[a]]];return t[s[1]]?o:-o}));return s.map((([e,t],r)=>[e,t,a[r]]))},mergeWithoutOverwrite=e=>{const t={};return e.forEach((e=>Object.keys(e).forEach((r=>{if(void 0!==t[r]&&t[r]!==e[r])throw new Error(`two competing results: ${t[r]}, ${e[r]}, for "${r}"`);t[r]=e[r]})))),t};var za=Object.freeze({__proto__:null,constraintToFacePairs:Sa,constraintToFacePairsStrings:Ca,emptyCategoryObject:emptyCategoryObject,mergeWithoutOverwrite:mergeWithoutOverwrite,solverSolutionToFaceOrders:solverSolutionToFaceOrders,tacoTypeNames:Fa});const getOverlapFacesWith3DEdge=({edges_faces:e},{clusters_graph:t,faces_plane:r},s=p)=>{const a=e.map((e=>2===e.length&&r[e[0]]!==r[e[1]])),o=t.map((e=>({vertices_coords:e.vertices_coords,edges_vertices:e.edges_vertices,faces_vertices:e.faces_vertices,faces_edges:e.faces_edges}))).map((e=>getFacesEdgesOverlap(e,s))).map((e=>e.map((e=>e.filter((e=>a[e])))))),c=o.flatMap((t=>t.flatMap(((t,s)=>t.map((t=>({edge:t,faces:e[t],facesPlanes:e[t].map((e=>r[e])),tortilla:s,tortillaPlane:r[s]})))))));return c.map((({edge:e,faces:t,facesPlanes:r,tortilla:s,tortillaPlane:a})=>({edge:e,tortilla:s,coplanar:t.filter(((e,t)=>r[t]===a)).shift(),angled:t.filter(((e,t)=>r[t]!==a)).shift()})))},solveOverlapFacesWith3DEdge=({edges_foldAngle:e},t,r)=>{const s=t.map((({tortilla:e,coplanar:t})=>[e,t])),a=s.map((([e,t])=>e<t));s.map(((e,t)=>t)).filter((e=>!a[e])).forEach((e=>s[e].reverse()));const o=s.map((e=>e.join(" "))),c=t.map((({edge:t})=>e[t])).map(Math.sign).map((e=>1===e)),n=t.map((({coplanar:e})=>r[e])),i=c.map(((e,t)=>!(e!==n[t]))).map((e=>e?1:0)).map(((e,t)=>a[t]?e:1-e)).map((e=>e+1));return mergeWithoutOverwrite(o.map(((e,t)=>({[e]:i[t]}))))},solveFacePair3D=({edges_foldAngle:e,faces_winding:t},r,s)=>{const a=s.map((e=>t[e])),o=r.map((t=>e[t])).map(((e,t)=>a[t]?e:-e)),c=o[0]>o[1],n=s[0]<s[1],i=c!==n?2:1,l=n?s.join(" "):[s[1],s[0]].join(" ");return{[l]:i}},getSolvable3DEdgePairs=({edges_faces:e,faces_plane:t,edgePairs:r,facesFacesLookup:s})=>{const a=(({edges_faces:e,faces_plane:t,facesFacesLookup:r})=>{const s=[],a=e.map(((e,t)=>t)).filter((t=>2===e[t].length));return a.filter((r=>t[e[r][0]]===t[e[r][1]])).forEach((t=>{const[a,o]=e[t];s[t]=r[a][o]?2:1})),a.filter((r=>t[e[r][0]]!==t[e[r][1]])).forEach((e=>{s[e]=0})),s})({edges_faces:e,faces_plane:t,facesFacesLookup:s}),o=r.map((r=>({faces:r.flatMap((t=>e[t])),planes:r.flatMap((r=>e[r].map((e=>t[e])))),angleClasses:r.map((e=>a[e]))}))).map((({faces:e,planes:t,angleClasses:r})=>({faces:[e[0],e[1],e[2],e[3]],planes:[t[0],t[1],t[2],t[3]],angleClasses:[r[0],r[1]]}))),c=o.map((e=>(({faces:e,planes:t,angleClasses:r},s)=>{const[a,o]=r,[c,n,i,l]=e,[d,_,m,g]=t;return a&&o?0:s[c][i]||s[c][l]||s[n][i]||s[n][l]?1===a||1===o?3:2===a||2===o?5:d===m&&_!==g&&s[c][i]||d===g&&_!==m&&s[c][l]||_===m&&d!==g&&s[n][i]||_===g&&d!==m&&s[n][l]?2:d===m&&_===g&&s[c][i]&&!s[n][l]||d===g&&_===m&&s[c][l]&&!s[n][i]||_===m&&d===g&&s[n][i]&&!s[c][l]||_===g&&d===m&&s[n][l]&&!s[c][i]?1:d===m&&_===g&&s[c][i]&&s[n][l]||d===g&&_===m&&s[c][l]&&s[n][i]||_===m&&d===g&&s[n][i]&&s[c][l]||_===g&&d===m&&s[n][l]&&s[c][i]?4:6:0})(e,s))),[,n,i,l,d,_,m]=invertFlatToArrayMap(c);return m&&m.length&&console.warn("getSolvable3DEdgePairs uncaught edge pairs"),{tJunctions:n||[],yJunctions:i||[],bentFlatTortillas:l||[],bentTortillas:d||[],bentTortillasFlatTaco:_||[]}},constraints3DEdges=({vertices_coords:e,edges_vertices:t,edges_faces:r,edges_foldAngle:s},{faces_plane:a,faces_winding:o,facesFacesOverlap:c},n=p)=>{const i=t.slice();r.map(((e,t)=>t)).filter((e=>2!==r[e].length)).forEach((e=>delete i[e]));const l=getEdgesEdgesCollinearOverlap({vertices_coords:e,edges_vertices:i},n),d=connectedComponentsPairs(l),_=arrayArrayToLookupArray(c),{tJunctions:m,yJunctions:g,bentFlatTortillas:v,bentTortillas:u,bentTortillasFlatTaco:h}=getSolvable3DEdgePairs({edges_faces:r,faces_plane:a,edgePairs:d,facesFacesLookup:_}),b=u.map((e=>d[e])).map((e=>{const t=e.flatMap((e=>r[e])),s=[t[0],t[1],t[2],t[3]];return a[s[0]]!==a[s[2]]&&([s[2],s[3]]=[s[3],s[2]]),o[s[0]]!==o[s[1]]&&([s[1],s[3]]=[s[3],s[1]]),s})),y=h.map((e=>d[e])).map((e=>{const[t,s,a,o]=e.flatMap((e=>r[e])),c=[[t,a,s],[a,s,o],[a,t,o],[t,o,s]].filter((([e,t,r])=>_[e][t]&&_[e][r])).shift();return c?[c[0],c[1],c[2]]:void 0})).filter((e=>void 0!==e)),E=[...m,...g,...v].map((e=>d[e])).map((e=>{const[t,a,c,n]=e.flatMap((e=>r[e])),i=[[t,c],[t,n],[a,c],[a,n]].filter((([e,t])=>_[e][t])).shift();if(i)return solveFacePair3D({edges_foldAngle:s,faces_winding:o},e,i)}));return{orders:mergeWithoutOverwrite(E),tortilla_tortilla:b,taco_tortilla:y}};var Ta=Object.freeze({__proto__:null,constraints3DEdges:constraints3DEdges,getOverlapFacesWith3DEdge:getOverlapFacesWith3DEdge,getSolvable3DEdgePairs:getSolvable3DEdgePairs,solveFacePair3D:solveFacePair3D,solveOverlapFacesWith3DEdge:solveOverlapFacesWith3DEdge});const makeEdgesFacesSide=({vertices_coords:e,edges_vertices:t,edges_faces:r,faces_center:s})=>{const a=t.map((t=>t.map((t=>e[t])))).map((([e,t])=>pointsToLine(e,t)));return r.map(((e,t)=>e.map((e=>cross2(subtract2(s[e],a[t].origin),a[t].vector))).map((e=>Math.sign(e)))))},makeEdgePairsFacesSide=({vertices_coords:e,edges_vertices:t,edges_faces:r,faces_center:s},a)=>{const o=a.map((([r])=>edgeToLine2({vertices_coords:e,edges_vertices:t},r)));return a.map((e=>e.map((e=>r[e])))).map(((e,t)=>e.map((e=>e.map((e=>s[e])).map((e=>cross2(subtract2(e,o[t].origin),o[t].vector))).map(Math.sign))))).map((e=>[[e[0][0],e[0][1]],[e[1][0],e[1][1]]]))};var Pa=Object.freeze({__proto__:null,makeEdgePairsFacesSide:makeEdgePairsFacesSide,makeEdgesFacesSide:makeEdgesFacesSide,makeEdgesFacesSide2D:({vertices_coords:e,edges_faces:t,faces_vertices:r,faces_center:s},{lines:a,edges_line:o})=>(s||(s=makeFacesCenter2DQuick({vertices_coords:e,faces_vertices:r})),t.map(((e,t)=>e.map((e=>{const{vector:r,origin:c}=a[o[t]];return cross2(subtract2(s[e],c),r)})).map(Math.sign)))),makeEdgesFacesSide3D:({vertices_coords:e,edges_faces:t,faces_vertices:r,faces_center:s},{lines:a,edges_line:o,planes_transform:c,faces_plane:n})=>{s||(s=makeFacesCenter3DQuick({vertices_coords:e,faces_vertices:r}).map(((e,t)=>multiplyMatrix4Vector3(c[n[t]],e))));const i=invertFlatToArrayMap(o).map((e=>e.flatMap((e=>t[e].map((e=>n[e])))))).map((e=>uniqueElements(e))),l=a.map((({vector:e,origin:t})=>({vector:resize3(e),origin:resize3(t)}))),d=a.map((()=>[]));return i.forEach(((e,t)=>e.forEach((e=>{const{vector:r,origin:s}=l[t];d[t][e]=multiplyMatrix4Line3(c[e],r,s)})))),t.map(((e,t)=>e.map((e=>{const{vector:r,origin:a}=d[o[t]][n[e]];return cross2(subtract2(s[e],a),r)})).map(Math.sign)))}});const classifyEdgePair=e=>{const t=e.map((([e,t])=>e===t));if(t[0]&&t[1])return e[0][0]!==e[1][0]?0:1;if(!t[0]&&!t[1])return e[0][0]===e[1][0]?2:3;const r=(t[0]?e[0][0]:e[1][0])===(t[0]?e[1]:e[0])[0]?0:1;return 4+(t[0]?0:2)+r},makeTortillaTortillaFacesCrossing=(e,t,r)=>{const s=t.map((e=>2===e.length&&e[0]!==e[1])).map(((e,t)=>e?t:void 0)).filter((e=>void 0!==e)),a=[];return s.forEach((e=>{a[e]=r[e]})),a.flatMap(((t,r)=>t.map((t=>[...e[r],t,t])))).filter((e=>4===e.length)).map((e=>[e[0],e[1],e[2],e[3]]))},makeTacosAndTortillas=({vertices_coords:e,edges_vertices:t,edges_faces:r,faces_vertices:s,faces_edges:a,faces_center:o},c=p)=>{o||(o=makeFacesCenterQuick({vertices_coords:e,faces_vertices:s}));const n=getEdgesFacesOverlap({vertices_coords:e,edges_vertices:t,faces_vertices:s,faces_edges:a},c),i=makeEdgesFacesSide({vertices_coords:e,edges_vertices:t,edges_faces:r,faces_center:o}),l=connectedComponentsPairs(getEdgesEdgesCollinearOverlap({vertices_coords:e,edges_vertices:t},c)).filter((e=>e.every((e=>r[e].length>1)))),d=makeEdgePairsFacesSide({vertices_coords:e,edges_vertices:t,edges_faces:r,faces_center:o},l).map(classifyEdgePair),_=makeTortillaTortillaFacesCrossing(r,i,n),m=l.map((e=>[[r[e[0]][0],r[e[0]][1]],[r[e[1]][0],r[e[1]][1]]])),g=n.map(((e,t)=>i[t].length>1&&i[t][0]===i[t][1]?e:[])).map(((e,t)=>({taco:r[t],tortillas:e}))).filter((({tortillas:e})=>e.length)).flatMap((({taco:[e,t],tortillas:r})=>r.map((r=>[e,r,t])))).map((e=>[e[0],e[1],e[2]]));return{taco_taco:d.map(((e,t)=>1===e?t:void 0)).filter((e=>void 0!==e)).map((e=>l[e].map((e=>r[e])))).map((e=>[e[0][0],e[1][0],e[0][1],e[1][1]])),taco_tortilla:d.map(((e,t)=>e>3?t:void 0)).filter((e=>void 0!==e)).map((e=>(([e,t],r)=>{switch(r){case 4:return[e[0],t[0],e[1]];case 5:return[e[0],t[1],e[1]];case 6:return[t[0],e[0],t[1]];case 7:return[t[0],e[1],t[1]];default:return}})(m[e],d[e]))).concat(g),tortilla_tortilla:d.map(((e,t)=>2===e||3===e?t:void 0)).filter((e=>void 0!==e)).map((e=>(([e,t],r)=>{switch(r){case 2:return[...e,...t];case 3:return[...e,t[1],t[0]];default:return}})(m[e],d[e]))).concat(_)}};var $a=Object.freeze({__proto__:null,makeTacosAndTortillas:makeTacosAndTortillas,makeTortillaTortillaFacesCrossing:makeTortillaTortillaFacesCrossing});const makeTransitivity=({faces_polygon:e},t,r=p)=>{const s=t.map((()=>({})));t.forEach(((e,t)=>e.forEach((e=>{s[t][e]=!0,s[e][t]=!0}))));const a=[];t.forEach(((t,s)=>t.forEach((t=>{const o=clipPolygonPolygon(e[s],e[t],r);o&&(a[s]||(a[s]=[]),a[t]||(a[t]=[]),a[s][t]=o,a[t][s]=o)}))));const o=[];for(let t=0;t<a.length-1;t+=1)if(a[t])for(let c=t+1;c<a.length;c+=1)if(a[t][c])for(let n=c+1;n<a.length;n+=1){if(t===n||c===n)continue;if(!s[t][n]||!s[c][n])continue;if(clipPolygonPolygon(a[t][c],e[n],r)){const[e,r,s]=[t,c,n].sort(((e,t)=>e-t));o.push([e,r,s])}}return o},getTransitivityTriosFromTacos=({taco_taco:e,taco_tortilla:t})=>{const r=e.map((e=>e.slice().sort(((e,t)=>e-t)))).flatMap((([e,t,r,s])=>[[e,t,r],[e,t,s],[e,r,s],[t,r,s]])),s=t.map((e=>e.slice().sort(((e,t)=>e-t)))),a={};return r.concat(s).map((e=>e.join(" "))).forEach((e=>{a[e]=!0})),a};var Ba=Object.freeze({__proto__:null,getTransitivityTriosFromTacos:getTransitivityTriosFromTacos,makeTransitivity:makeTransitivity});const solveFlatAdjacentEdges=({edges_faces:e,edges_assignment:t},r)=>{const s={0:0,1:2,2:1},a={M:1,m:1,V:2,v:2},o={};return e.forEach(((e,c)=>{const n=t[c],i=a[n];if(2!==e.length||void 0===i)return;const l=r[e[0]]?i:s[i],d=e[0]<e[1],_=d?e.join(" "):e.slice().reverse().join(" "),m=d?l:s[l];o[_]=m})),o};var Na=Object.freeze({__proto__:null,solveFlatAdjacentEdges:solveFlatAdjacentEdges});const makeConstraintsLookup=e=>{const t={taco_taco:void 0,taco_tortilla:void 0,tortilla_tortilla:void 0,transitivity:void 0};return Fa.forEach((e=>{t[e]={}})),Fa.forEach((r=>e[r].forEach((e=>Ca[r](e).forEach((e=>{t[r][e]=[]})))))),Fa.forEach((r=>e[r].forEach(((e,s)=>Ca[r](e).forEach((e=>t[r][e].push(s))))))),t},makeSolverConstraintsFlat=({vertices_coords:e,edges_vertices:t,edges_faces:r,edges_assignment:s,faces_vertices:a,faces_edges:o,faces_center:c},n=p)=>{const i=makeFacesWinding({vertices_coords:e,faces_vertices:a}),l=makeFacesPolygon({vertices_coords:e,faces_vertices:a},n);i.map(((e,t)=>e?void 0:t)).filter((e=>void 0!==e)).forEach((e=>l[e].reverse()));const d=getFacesFacesOverlap({vertices_coords:e,faces_vertices:a},n),{taco_taco:_,taco_tortilla:m,tortilla_tortilla:g}=makeTacosAndTortillas({vertices_coords:e,edges_vertices:t,edges_faces:r,faces_vertices:a,faces_edges:o,faces_center:c},n),v=getTransitivityTriosFromTacos({taco_taco:_,taco_tortilla:m}),u=makeTransitivity({faces_polygon:l},d,n).filter((e=>void 0===v[e.join(" ")])),h=connectedComponentsPairs(d).map((e=>e.join(" ")));return{constraints:{taco_taco:_,taco_tortilla:m,tortilla_tortilla:g,transitivity:u},lookup:makeConstraintsLookup({taco_taco:_,taco_tortilla:m,tortilla_tortilla:g,transitivity:u}),facePairs:h,faces_winding:i,orders:solveFlatAdjacentEdges({edges_faces:r,edges_assignment:s},i)}};var Ra=Object.freeze({__proto__:null,makeConstraintsLookup:makeConstraintsLookup,makeSolverConstraintsFlat:makeSolverConstraintsFlat});const makeSolverConstraints3D=({vertices_coords:e,edges_vertices:t,edges_faces:r,edges_assignment:s,edges_foldAngle:a,faces_vertices:o,faces_edges:c,faces_faces:n},i=p)=>{const{faces_plane:l,faces_winding:d,faces_polygon:_,clusters_graph:m,facesFacesOverlap:v,facePairs:u}=constraints3DFaceClusters({vertices_coords:e,edges_vertices:t,edges_faces:r,edges_assignment:s,edges_foldAngle:a,faces_vertices:o,faces_edges:c,faces_faces:n},i);let h;try{h=constraints3DEdges({vertices_coords:e,edges_vertices:t,edges_faces:r,edges_foldAngle:a},{faces_plane:l,faces_winding:d,facesFacesOverlap:v},i)}catch(e){throw new Error(g,{cause:e})}const{orders:b,tortilla_tortilla:y,taco_tortilla:E}=h,M=a.map(edgeFoldAngleIsFlat).map(((e,t)=>e?void 0:t)).filter((e=>void 0!==e));["edges_vertices","edges_faces","edges_assignment","edges_foldAngle"].forEach((e=>m.forEach(((t,r)=>M.forEach((t=>delete m[r][e][t]))))));const A=m.map((e=>makeTacosAndTortillas(e,i))),x=A.flatMap((e=>e.taco_taco)),O=A.flatMap((e=>e.taco_tortilla)),j=A.flatMap((e=>e.tortilla_tortilla)),w=getTransitivityTriosFromTacos({taco_taco:x,taco_tortilla:O}),F=makeTransitivity({faces_polygon:_},v,i).filter((e=>void 0===w[e.join(" ")]));O.push(...E),j.push(...y);const S=makeConstraintsLookup({taco_taco:x,taco_tortilla:O,tortilla_tortilla:j,transitivity:F}),C=m.map((e=>solveFlatAdjacentEdges(e,d))).reduce(((e,t)=>Object.assign(e,t)),{}),V=getOverlapFacesWith3DEdge({edges_faces:r},{clusters_graph:m,faces_plane:l},i);let z,T;try{z=solveOverlapFacesWith3DEdge({edges_foldAngle:a},V,d)}catch(e){throw new Error(g,{cause:e})}try{T=mergeWithoutOverwrite([b,C,z])}catch(e){throw new Error(g,{cause:e})}return{constraints:{taco_taco:x,taco_tortilla:O,tortilla_tortilla:j,transitivity:F},lookup:S,facePairs:u,faces_winding:d,orders:T}};var La=Object.freeze({__proto__:null,makeSolverConstraints3D:makeSolverConstraints3D});const getBranchCount=({branches:e})=>e?e.map((e=>({choices:e.length,branches:e.flatMap(getBranchCount)}))):"leaf",getBranchStructure=({branches:e})=>void 0===e?[]:e.map((e=>e.map(getBranchStructure))),getBranchLeafStructure=({branches:e})=>void 0===e?"leaf":e.map((e=>e.map(getBranchLeafStructure))),gather=({orders:e,branches:t},r=[])=>[e,...(t||[]).flatMap((e=>gather(e[r.shift()||0],r)))],compile=({orders:e,branches:t},r)=>gather({orders:e,branches:t},r).flat(),gatherAll=({orders:e,branches:t})=>{if(!t)return[[e]];const r=t.map((e=>e.flatMap(gatherAll)));return((...e)=>{const t=e.reduce(((e,t)=>e*t),1),r=e.slice();for(let e=r.length-2;e>=0;e-=1)r[e]*=r[e+1];return r.push(1),r.shift(),Array.from(Array(t)).map(((t,s)=>e.map(((e,t)=>Math.floor(s/r[t])%e))))})(...r.map((e=>e.length))).map((e=>e.flatMap(((e,t)=>r[t][e])))).map((t=>[e,...t]))},compileAll=({orders:e,branches:t})=>gatherAll({orders:e,branches:t}).map((e=>e.flat())),Ia={count:function(){return getBranchCount(this)},structure:function(){return getBranchStructure(this)},leaves:function(){return getBranchLeafStructure(this)},gather:function(...e){return gather(this,e)},gatherAll:function(){return gatherAll(this)},compile:function(...e){return compile(this,e)},compileAll:function(){return compileAll(this)},faceOrders:function(...e){return compile(this,e)}};var Ua=Object.freeze({__proto__:null,LayerPrototype:Ia,compile:compile,compileAll:compileAll,gather:gather,gatherAll:gatherAll,getBranchStructure:getBranchStructure});const makeLookupEntry=e=>{const t=e[0].length,r=Array.from(Array(t+1)).map((()=>({})));Array.from(Array(2**t)).map(((e,t)=>t.toString(2))).map((e=>Array.from(e).map((e=>parseInt(e,10)+1)).join(""))).map((e=>`11111${e}`.slice(-t))).forEach((e=>{r[0][e]=!1})),e.forEach((e=>{r[0][e]=!0})),Array.from(Array(t)).map(((e,t)=>t+1)).map((e=>Array.from(Array(3**t)).map(((e,t)=>t.toString(3))).map((e=>`000000${e}`.slice(-t))).forEach((t=>((e,t,r)=>{const s=Array.from(r).map((e=>parseInt(e,10)));if(s.filter((e=>0===e)).length!==t)return;e[t][r]=!1;const a=[];for(let o=0;o<s.length;o+=1){const c=[];if(0===s[o]){for(let r=1;r<=2;r+=1)s[o]=r,!1!==e[t-1][s.join("")]&&c.push([o,r]);s[o]=0,c.length&&(e[t][r]=!0),1===c.length&&a.push(c[0])}}a.length&&(e[t][r]=[a[0][0],a[0][1]])})(r,e,t)))));const s=r.reduce(((e,t)=>({...e,...t})));return Object.keys(s).filter((e=>"object"==typeof s[e])).forEach((e=>{s[e]=Object.freeze(s[e])})),Object.freeze(s)},Da={taco_taco:makeLookupEntry(["111112","111121","111222","112111","121112","121222","122111","122212","211121","211222","212111","212221","221222","222111","222212","222221"]),taco_tortilla:makeLookupEntry(["112","121","212","221"]),tortilla_tortilla:makeLookupEntry(["11","22"]),transitivity:makeLookupEntry(["112","121","122","211","212","221"])};var Qa=Object.freeze({__proto__:null,table:Da});const buildRuleAndLookup=(e,t,...r)=>{const s={0:0,1:2,2:1},a=Sa[e](t),o=a.map((e=>e[1]<e[0])),c=a.map(((e,t)=>o[t]?`${e[1]} ${e[0]}`:`${e[0]} ${e[1]}`)),n=c.map((e=>r.find((t=>t[e])))).map(((e,t)=>void 0===e?0:e[c[t]])).map(((e,t)=>o[t]?s[e]:e)).join("");if(!0===Da[e][n]||!1===Da[e][n])return Da[e][n];const[i,l]=Da[e][n];return[c[i],o[i]?s[l]:l]},getConstraintIndicesFromFacePairs=(e,t,r)=>{const s={taco_taco:void 0,taco_tortilla:void 0,tortilla_tortilla:void 0,transitivity:void 0};return Fa.forEach((a=>{const o=r.flatMap((e=>t[a][e]));s[a]=uniqueElements(o).filter((t=>e[a][t]))})),s},propagate=(e,t,r,...s)=>{let a=r;const o={};do{const r=getConstraintIndicesFromFacePairs(e,t,a),c={};for(let t=0;t<Fa.length;t+=1){const a=Fa[t],n=r[a];for(let t=0;t<n.length;t+=1){const r=buildRuleAndLookup(a,e[a][n[t]],...s,o);if(!0!==r){if(!1===r)throw new Error(`invalid ${a} ${n[t]}:${e[a][n[t]]}`);if(o[r[0]]){if(o[r[0]]!==r[1])throw new Error(`conflict ${a} ${n[t]}:${e[a][n[t]]}`)}else{const[e,t]=r;c[e]=!0,o[r[0]]=t}}}}a=Object.keys(c)}while(a.length);return o},getBranches=(e,t,r)=>{const s={};e.forEach((e=>{s[e]=!0}));let a=0;const o=[];for(;a<e.length;){if(!s[e[a]]){a+=1;continue}const c=[],n=[e[a]],i={[e[a]]:!0};do{const e=n.pop();delete s[e],c.push(e);const a={};Fa.forEach((s=>{const o=r[s][e];o&&o.map((e=>t[s][e])).map((e=>Ca[s](e).forEach((e=>{a[e]=!0}))))}));const o=Object.keys(a).filter((e=>s[e])).filter((e=>!i[e]));n.push(...o),o.forEach((e=>{i[e]=!0}))}while(n.length);a+=1,o.push(c)}return o},solveBranch$1=(e,t,r,...s)=>{const a=r[0];return[1,2].map((r=>{const o={[a]:r};try{const r=propagate(e,t,[a],...s,o);return Object.assign(r,o)}catch(e){return}})).filter((e=>void 0!==e)).map((a=>Object.keys(a).length===r.length?{orders:a}:{orders:a,branches:getBranches(r.filter((e=>!(e in a))),e,t).map((r=>solveBranch$1(e,t,r,...s,a)))}))},solver$1=({constraints:e,lookup:t,facePairs:r,orders:s})=>{let a;try{a=propagate(e,t,Object.keys(s),s)}catch(e){throw new Error(g,{cause:e})}const o={...s,...a},c=r.filter((e=>!(e in o)));try{return 0===c.length?{orders:o}:{orders:o,branches:getBranches(c,e,t).map((r=>solveBranch$1(e,t,r,s,a)))}}catch(e){throw new Error(g,{cause:e})}};var Wa=Object.freeze({__proto__:null,solver:solver$1});const solveBranch=(e,t,r,...s)=>{if(!r.length)return[];const a=r[0],o=[1,2].map((r=>{const o={[a]:r};try{const r=propagate(e,t,[a],...s,o);return Object.assign(r,o)}catch(e){return}})).filter((e=>void 0!==e)),c=o.map((e=>Object.keys(e).length)),n=o.filter(((e,t)=>c[t]===r.length)),i=o.filter(((e,t)=>c[t]!==r.length)).map((a=>solveBranch(e,t,r.filter((e=>!(e in a))),...s,a)));return n.map((e=>[...s,e])).concat(...i)},solver=({constraints:e,lookup:t,facePairs:r,orders:s})=>{let a;try{a=propagate(e,t,Object.keys(s),s)}catch(e){throw new Error(g,{cause:e})}const o=r.filter((e=>!(e in s))).filter((e=>!(e in a)));let c;try{c=getBranches(o,e,t).map((r=>solveBranch(e,t,r,s,a)))}catch(e){throw new Error(g,{cause:e})}const n={...s,...a};c.forEach((e=>e.forEach((e=>e.splice(0,2)))));return{root:n,branches:c.map((e=>e.map((e=>Object.assign({},...e)))))}},layerSolutionToFaceOrdersTree=({orders:e,branches:t},r)=>void 0===t?{orders:solverSolutionToFaceOrders(e,r)}:{orders:solverSolutionToFaceOrders(e,r),branches:t.map((e=>e.map((e=>layerSolutionToFaceOrdersTree(e,r)))))},solveLayerOrders=({vertices_coords:e,edges_vertices:t,edges_faces:r,edges_assignment:s,edges_foldAngle:a,faces_vertices:o,faces_edges:c,faces_faces:n,edges_vector:i},l)=>{if(!e||!t||!o)return{orders:{},faces_winding:[]};c||(c=makeFacesEdgesFromVertices({edges_vertices:t,faces_vertices:o})),r||(r=makeEdgesFacesUnsorted({edges_vertices:t,faces_vertices:o,faces_edges:c})),n||(n=makeFacesFaces({faces_vertices:o})),!a&&s&&(a=makeEdgesFoldAngle({edges_assignment:s})),s||(s=makeEdgesAssignmentSimple({edges_foldAngle:a})),void 0===l&&(l=makeEpsilon({vertices_coords:e,edges_vertices:t}));const{constraints:d,lookup:_,facePairs:m,faces_winding:g,orders:v}=makeSolverConstraintsFlat({vertices_coords:e,edges_vertices:t,edges_faces:r,edges_assignment:s,edges_foldAngle:a,faces_vertices:o,faces_edges:c,faces_faces:n,edges_vector:i},l);return{...solver$1({constraints:d,lookup:_,facePairs:m,orders:v}),faces_winding:g}},solveLayerOrders3D=({vertices_coords:e,edges_vertices:t,edges_faces:r,edges_assignment:s,edges_foldAngle:a,faces_vertices:o,faces_edges:c,faces_faces:n},i)=>{if(!e||!t||!o)return{orders:{},faces_winding:[]};c||(c=makeFacesEdgesFromVertices({edges_vertices:t,faces_vertices:o})),r||(r=makeEdgesFacesUnsorted({edges_vertices:t,faces_vertices:o,faces_edges:c})),n||(n=makeFacesFaces({faces_vertices:o})),!a&&s&&(a=makeEdgesFoldAngle({edges_assignment:s})),s||(s=makeEdgesAssignmentSimple({edges_foldAngle:a})),void 0===i&&(i=makeEpsilon({vertices_coords:e,edges_vertices:t}));const{constraints:l,lookup:d,facePairs:_,faces_winding:m,orders:g}=makeSolverConstraints3D({vertices_coords:e,edges_vertices:t,edges_faces:r,edges_assignment:s,edges_foldAngle:a,faces_vertices:o,faces_edges:c,faces_faces:n},i);return{...solver$1({constraints:l,lookup:d,facePairs:_,orders:g}),faces_winding:m}},solveFaceOrders=(e,t)=>{const{faces_winding:r,...s}=solveLayerOrders(e,t);return layerSolutionToFaceOrdersTree(s,r)},solveFaceOrders3D=(e,t)=>{const{faces_winding:r,...s}=solveLayerOrders3D(e,t);return layerSolutionToFaceOrdersTree(s,r)};var qa=Object.freeze({__proto__:null,solveFaceOrders:solveFaceOrders,solveFaceOrders3D:solveFaceOrders3D,solveLayerOrders:solveLayerOrders,solveLayerOrders3D:solveLayerOrders3D,solveLayerOrdersSingleBranches:({vertices_coords:e,edges_vertices:t,edges_faces:r,edges_assignment:s,faces_vertices:a,faces_edges:o,edges_vector:c},n)=>{if(!e||!t||!a)return{orders:{},faces_winding:[]};o||(o=makeFacesEdgesFromVertices({edges_vertices:t,faces_vertices:a})),r||(r=makeEdgesFacesUnsorted({edges_vertices:t,faces_vertices:a,faces_edges:o})),void 0===n&&(n=makeEpsilon({vertices_coords:e,edges_vertices:t}));const{constraints:i,lookup:l,facePairs:d,faces_winding:_,orders:m}=makeSolverConstraintsFlat({vertices_coords:e,edges_vertices:t,edges_faces:r,edges_assignment:s,faces_vertices:a,faces_edges:o,edges_vector:c},n);return{...solver({constraints:i,lookup:l,facePairs:d,orders:m}),faces_winding:_}}});const Ga={...La,...ka,...Ta,...Ra,...Pa,...za,...Na,...Ua,...qa,...Wa,...Qa,...$a,...Ba,layer3D:(e,t)=>Object.assign(Object.create(Ia),solveFaceOrders3D(e,t))},Ha=Object.assign(((e,t)=>Object.assign(Object.create(Ia),solveFaceOrders(e,t))),Ga),perpendicularBalancedSegment=(e,t,r)=>{const s=void 0===r?((e,t)=>{const r=clipLineConvexPolygon(e,t);return void 0===r?void 0:midpoint2(r[0],r[1])})(e,t):r,a=rotate90(t.vector),o=clipLineConvexPolygon(e,{vector:a,origin:s});if(!o)return;const c=o.map((e=>distance2(s,e))).sort(((e,t)=>e-t)).shift(),n=scale2$1(normalize2(a),c);return[add2(s,flip2(n)),add2(s,n)]},betweenTwoSegments=(e,t,r)=>{const s=r.map((e=>midpoint2(e[0],e[1]))),a=midpoint2(s[0],s[1]),o={vector:rotate90(e.vector),origin:a};return t.map((e=>intersectLineLine(e,o).point))},arrowFromSegment=(e,t={})=>{if(void 0===e)return;const r=subtract2(e[1],e[0]),s=magnitude2(r),a=t.padding?t.padding:.05*s,o=dot2(r,[1,0]),c=t&&t.vmin?t.vmin:s;return{segment:[e[0],e[1]],head:{width:.0666*c,height:.1*c},bend:o>0?.3:-.3,padding:a}},arrowFromSegmentInPolygon=(e,t,r={})=>{const s=r.vmin?r.vmin:Math.min(...(boundingBox$1(e)?.span||[1,1]).slice(0,2));return arrowFromSegment(t,{...r,vmin:s})},foldLineArrow=({vertices_coords:e},t,r)=>{const s=e.map(resize2),a=convexHull(s).map((e=>s[e])),o=perpendicularBalancedSegment(a,t);if(void 0!==o)return arrowFromSegmentInPolygon(a,o,r)};var Ja=Object.freeze({__proto__:null,arrowFromLine:(e,t,r)=>{const s=clipLineConvexPolygon(e,t);return void 0===s?void 0:arrowFromSegmentInPolygon(e,s,r)},arrowFromSegment:arrowFromSegment,arrowFromSegmentInPolygon:arrowFromSegmentInPolygon,foldLineArrow:foldLineArrow});const diagramReflectPoint=({vector:e,origin:t},r)=>multiplyMatrix2Vector2(makeMatrix2Reflect(e,t),r);var Za=Object.freeze({__proto__:null,axiom1Arrows:({vertices_coords:e},t,r,s)=>{const a=e.map(resize2),o=convexHull(a).map((e=>a[e]));return axiom1(t,r).map((e=>perpendicularBalancedSegment(o,e))).map((e=>arrowFromSegmentInPolygon(o,e,s)))},axiom2Arrows:({vertices_coords:e},t,r,s)=>{const a=e.map(resize2),o=convexHull(a).map((e=>a[e]));return[arrowFromSegmentInPolygon(o,[t,r],s)]},axiom3Arrows:({vertices_coords:e},t,r,s)=>{const a=e.map(resize2),o=convexHull(a).map((e=>a[e])),c=axiom3(t,r),n=[t,r].map((e=>clipLineConvexPolygon(o,e))).filter((e=>void 0!==e));if(2!==n.length)return c.map((t=>foldLineArrow({vertices_coords:e},t,s)));const[i,l]=n.map((([e,t])=>pointsToLine2(e,t))),d=intersectLineLine(i,l,includeS,includeS).point,_=d?c.map((e=>((e,t,r,s)=>{const a=e.map((e=>e.vector)),o=a.map(flip2),c=a.concat(o).map((e=>({vector:e,origin:t}))),n=c.map((e=>dot2(e.vector,r.vector))),i=c.map((e=>cross2(e.vector,r.vector))),l=c.filter(((e,t)=>n[t]>0&&i[t]>0)).shift(),d=c.filter(((e,t)=>n[t]>0&&i[t]<0)).shift(),_=c.filter(((e,t)=>n[t]<0&&i[t]>0)).shift(),m=c.filter(((e,t)=>n[t]<0&&i[t]<0)).shift(),g=[l,d,_,m].map((e=>clipLineConvexPolygon(s,e,includeS,A)));if(g.includes(void 0))return;const v=g.map((e=>e.shift())),p=v.map((e=>distance2(e,t)));return[[p[0]<p[1]?v[0]:v[1],p[0]<p[1]?add2(d.origin,scale2$1(normalize2(d.vector),p[0])):add2(l.origin,scale2$1(normalize2(l.vector),p[1]))],[p[2]<p[3]?v[2]:v[3],p[2]<p[3]?add2(m.origin,scale2$1(normalize2(m.vector),p[2])):add2(_.origin,scale2$1(normalize2(_.vector),p[3]))]]})([t,r],d,e,o))):[betweenTwoSegments(c.filter((e=>void 0!==e)).shift(),[t,r],n)];return _.map((e=>arrowFromSegmentInPolygon(o,e,s)))},axiom4Arrows:({vertices_coords:e},t,r,s)=>{const a=e.map(resize2),o=convexHull(a).map((e=>a[e])),c=axiom4(t,r).shift(),n=intersectLineLine(c,t).point,i=perpendicularBalancedSegment(o,c,n);return[arrowFromSegmentInPolygon(o,i,s)]},axiom5Arrows:({vertices_coords:e},t,r,s,a)=>{const o=e.map(resize2),c=convexHull(o).map((e=>o[e]));return axiom5(t,r,s).map((e=>[s,diagramReflectPoint(e,s)])).map((e=>arrowFromSegmentInPolygon(c,e,a)))},axiom6Arrows:({vertices_coords:e},t,r,s,a,o)=>{const c=e.map(resize2),n=convexHull(c).map((e=>c[e]));return axiom6(t,r,s,a).flatMap((e=>[s,a].map((t=>[t,diagramReflectPoint(e,t)])))).map((e=>arrowFromSegmentInPolygon(n,e,o)))},axiom7Arrows:({vertices_coords:e},t,r,s,a)=>{const o=e.map(resize2),c=convexHull(o).map((e=>o[e]));return axiom7(t,r,s).flatMap((e=>[[s,diagramReflectPoint(e,s)],perpendicularBalancedSegment(c,e,intersectLineLine(e,r).point)])).filter((e=>void 0!==e)).map((e=>arrowFromSegmentInPolygon(c,e,a)))},diagramReflectPoint:diagramReflectPoint});const Ya={axiom:L,convert:$r,diagram:{...Ja,...Za},general:Br,graph:Ds,layer:Ha,math:Qs,singleVertex:Gs,svg:vr,webgl:wa,...Object.freeze({__proto__:null,__types__:()=>{}})};lr.ear=Ya;const Xa=Ya;return Object.defineProperty(Xa,"window",{enumerable:!1,set:e=>{var t;vr.window=((t=e).document||(t.document=(e=>(new e.DOMParser).parseFromString("<!DOCTYPE html><title>.</title>","text/html"))(t)),v.window=t,v.window)}}),Ya}));
